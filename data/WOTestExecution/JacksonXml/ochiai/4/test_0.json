{
    "bug_id": 4,
    "test_id": 0,
    "test_name": "com.fasterxml.jackson.dataformat.xml.misc.RootNameTest.testDynamicRootName",
    "test_body": "public void testDynamicRootName() throws IOException\n{\nString xml;\nObjectWriter w = _xmlMapper.writer().withRootName(\"rudy\");\nxml = w.writeValueAsString(new StringBean(\"foo\"));\nassertEquals(\"<rudy><text>foo</text></rudy>\", xml);\nxml = w.writeValueAsString(new StringBean(null));\nassertEquals(\"<rudy><text/></rudy>\", xml);\n// and even with null will respect configured root name\nxml = w.writeValueAsString(null);\nassertEquals(\"<rudy/>\", xml);\n}\n",
    "stack_trace": "junit.framework.ComparisonFailure: expected:<<[rudy]/>> but was:<<[null]/>>\nat junit.framework.Assert.assertEquals(Assert.java:100)\nat junit.framework.Assert.assertEquals(Assert.java:107)\nat junit.framework.TestCase.assertEquals(TestCase.java:269)\nat com.fasterxml.jackson.dataformat.xml.misc.RootNameTest.testDynamicRootName(RootNameTest.java:81)",
    "covered_methods": [
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>()V",
            "method_body": "public XmlMapper() {\nthis(new XmlFactory());\n}",
            "method_id": 0
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;)V",
            "method_body": "public XmlMapper(XmlFactory xmlFactory) {\nthis(xmlFactory, DEFAULT_XML_MODULE);\n}",
            "method_id": 1
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.TypeUtil:isIndexedType(Ljava/lang/Class;)Z",
            "method_body": "public static boolean isIndexedType(Class<?> cls)\n{\nreturn (cls.isArray() && cls != byte[].class && cls != char[].class)\n|| Collection.class.isAssignableFrom(cls);\n}",
            "method_id": 2
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<init>(Lcom/fasterxml/jackson/dataformat/xml/XmlFactory;Lcom/fasterxml/jackson/dataformat/xml/JacksonXmlModule;)V",
            "method_body": "public XmlMapper(XmlFactory xmlFactory, JacksonXmlModule module)\n{\n/* Need to override serializer provider (due to root name handling);\n* deserializer provider fine as is\n*/\nsuper(xmlFactory, new XmlSerializerProvider(new XmlRootNameLookup()), null);\n_xmlModule = module;\n// but all the rest is done via Module interface!\nif (module != null) {\nregisterModule(module);\n}\n// 19-May-2015, tatu: Must ensure we use XML-specific indenter\n_serializationConfig = _serializationConfig.withDefaultPrettyPrinter(DEFAULT_XML_PRETTY_PRINTER);\n}",
            "method_id": 3
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlMapper:<clinit>()V",
            "method_body": "private static final long serialVersionUID = 1L;\n\nprotected final static JacksonXmlModule DEFAULT_XML_MODULE = new JacksonXmlModule();\n\nprotected final static DefaultXmlPrettyPrinter DEFAULT_XML_PRETTY_PRINTER = new DefaultXmlPrettyPrinter();\n\n// need to hold on to module instance just in case copy() is used\nprotected final JacksonXmlModule _xmlModule;\n\n/*\n/**********************************************************\n/* Life-cycle: construction, configuration\n/**********************************************************\n*/\n\npublic XmlMapper() {\nthis(new XmlFactory());\n}",
            "method_id": 4
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:<init>()V",
            "method_body": "public JacksonXmlModule()\n{\nsuper(\"JacksonXmlModule\", PackageVersion.VERSION);\n}",
            "method_id": 5
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:setupModule(Lcom/fasterxml/jackson/databind/Module$SetupContext;)V",
            "method_body": "public void setupModule(SetupContext context)\n{\n// Need to modify BeanDeserializer, BeanSerializer that are used\ncontext.addBeanSerializerModifier(new XmlBeanSerializerModifier());\ncontext.addBeanDeserializerModifier(new XmlBeanDeserializerModifier(_cfgNameForTextElement));\n\n// as well as AnnotationIntrospector\ncontext.insertAnnotationIntrospector(_constructIntrospector());\n\n// and finally inform XmlFactory about overrides, if need be:\nif (_cfgNameForTextElement != FromXmlParser.DEFAULT_UNNAMED_TEXT_PROPERTY) {\nXmlMapper m = (XmlMapper) context.getOwner();\nm.setXMLTextElementName(_cfgNameForTextElement);\n}\n\n/* Usually this would be the first call; but here anything added will\n* be stuff user may has added, so do it afterwards instead.\n*/\nsuper.setupModule(context);\n}",
            "method_id": 6
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlModule:_constructIntrospector()Lcom/fasterxml/jackson/databind/AnnotationIntrospector;",
            "method_body": "protected AnnotationIntrospector _constructIntrospector() {\nreturn new JacksonXmlAnnotationIntrospector(_cfgDefaultUseWrapper);\n}",
            "method_id": 7
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.PackageVersion:<clinit>()V",
            "method_body": "public final static Version VERSION = VersionUtil.parseVersion(\n\"2.8.5-SNAPSHOT\", \"com.fasterxml.jackson.dataformat\", \"jackson-dataformat-xml\");\n\n@Override\npublic Version version() {\nreturn VERSION;\n}",
            "method_id": 8
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter:<init>()V",
            "method_body": "public void writeIndentation(JsonGenerator g, int level) throws IOException;\n\npublic void writeIndentation(XMLStreamWriter2 sw, int level) throws XMLStreamException;\n\n/**\n* @return True if indenter is considered inline (does not add linefeeds),\n*   false otherwise\n*/\npublic boolean isInline();\n}\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* By default, let's use only spaces to separate array values.\n*/\nprotected Indenter _arrayIndenter = new FixedSpaceIndenter();\n\n/**\n* By default, let's use linefeed-adding indenter for separate\n* object entries. We'll further configure indenter to use\n* system-specific linefeeds, and 2 spaces per level (as opposed to,\n* say, single tabs)\n*/\nprotected Indenter _objectIndenter = new Lf2SpacesIndenter();\n\n// // // Config, other white space configuration\n\n/**\n* By default we will add spaces around colons used to\n* separate object fields and values.\n* If disabled, will not use spaces around colon.\n*/\nprotected boolean _spacesInObjectEntries = true;\n\n/*\n/**********************************************************\n/* State\n/**********************************************************\n*/\n\n/**\n* Number of open levels of nesting. Used to determine amount of\n* indentation to use.\n*/\nprotected transient int _nesting = 0;\n\n/**\n* Marker flag set on start element, and cleared if an end element\n* is encountered. Used for suppressing indentation to allow empty\n* elements.\n*\n* @since 2.3.0\n*/\nprotected transient boolean _justHadStartElement;\n\n/*\n/**********************************************************\n/* Life-cycle (construct, configure)\n/**********************************************************\n*/\n\npublic DefaultXmlPrettyPrinter() { }",
            "method_id": 9
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$FixedSpaceIndenter:<init>()V",
            "method_body": "public FixedSpaceIndenter() { }\npublic FixedSpaceIndenter() { }",
            "method_id": 10
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<init>()V",
            "method_body": "public Lf2SpacesIndenter() { }\npublic Lf2SpacesIndenter() { }",
            "method_id": 11
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.DefaultXmlPrettyPrinter$Lf2SpacesIndenter:<clinit>()V",
            "method_body": "final static int SPACE_COUNT = 64;\nfinal static char[] SPACES = new char[SPACE_COUNT];\nstatic {\nArrays.fill(SPACES, ' ');\n}",
            "method_id": 12
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<init>(Lcom/fasterxml/jackson/dataformat/xml/util/XmlRootNameLookup;)V",
            "method_body": "public XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}",
            "method_id": 13
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<clinit>()V",
            "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* If all we get to serialize is a null, there's no way to figure out\n* expected root name; so let's just default to something like \"&lt;null>\"...\n*/\nprotected final static QName ROOT_NAME_FOR_NULL = new QName(\"null\");\n\nprotected final XmlRootNameLookup _rootNameLookup;\n\npublic XmlSerializerProvider(XmlRootNameLookup rootNames)\n{\nsuper();\n_rootNameLookup = rootNames;\n}",
            "method_id": 14
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlRootNameLookup:<init>()V",
            "method_body": "private static final long serialVersionUID = 1L;\n\n/**\n* For efficient operation, let's try to minimize number of times we\n* need to introspect root element name to use.\n*<p>\n* Note: changed to <code>transient</code> for 2.3; no point in serializing such\n* state\n*/\nprotected final transient LRUMap<ClassKey,QName> _rootNames = new LRUMap<ClassKey,QName>(40, 200);\n\npublic XmlRootNameLookup() { }",
            "method_id": 15
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:<init>()V",
            "method_body": "public XmlBeanSerializerModifier() { }\npublic XmlBeanSerializerModifier() { }",
            "method_id": 16
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlBeanDeserializerModifier:<init>(Ljava/lang/String;)V",
            "method_body": "public XmlBeanDeserializerModifier(String nameForTextValue)\n{\n_cfgNameForTextValue = nameForTextValue;\n}",
            "method_id": 17
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:<init>(Z)V",
            "method_body": "public JacksonXmlAnnotationIntrospector(boolean defaultUseWrapper) {\n_cfgDefaultUseWrapper = defaultUseWrapper;\n}",
            "method_id": 18
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledIn(I)Z",
            "method_body": "@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }",
            "method_id": 19
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:_initWithRootName(Lcom/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator;Ljavax/xml/namespace/QName;)V",
            "method_body": "protected void _initWithRootName(ToXmlGenerator xgen, QName rootName) throws IOException\n{\n/* 28-Nov-2012, tatu: We should only initialize the root\n*  name if no name has been set, as per [dataformat-xml#42],\n*  to allow for custom serializers to work.\n*/\nif (!xgen.setNextNameIfMissing(rootName)) {\n// however, if we are root, we... insist\nif (xgen.inRoot()) {\nxgen.setNextName(rootName);\n}\n}\nxgen.initGenerator();\nString ns = rootName.getNamespaceURI();\n/* [dataformat-xml#26] If we just try writing root element with namespace,\n* we will get an explicit prefix. But we'd rather use the default\n* namespace, so let's try to force that.\n*/\nif (ns != null && ns.length() > 0) {\ntry {\nxgen.getStaxWriter().setDefaultNamespace(ns);\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}\n}",
            "method_id": 20
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:_rootNameFromConfig()Ljavax/xml/namespace/QName;",
            "method_body": "protected QName _rootNameFromConfig()\n{\nPropertyName name = _config.getFullRootName();\nif (name == null) {\nreturn null;\n}\nString ns = name.getNamespace();\nif (ns == null || ns.isEmpty()) {\nreturn new QName(name.getSimpleName());\n}\nreturn new QName(ns, name.getSimpleName());\n}",
            "method_id": 21
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:initGenerator()V",
            "method_body": "public void initGenerator()  throws IOException\n{\nif (_initialized) {\nreturn;\n}\n_initialized = true;\ntry {\nif (Feature.WRITE_XML_1_1.enabledIn(_formatFeatures)) {\n_xmlWriter.writeStartDocument(\"UTF-8\", \"1.1\");\n} else if (Feature.WRITE_XML_DECLARATION.enabledIn(_formatFeatures)) {\n_xmlWriter.writeStartDocument(\"UTF-8\", \"1.0\");\n} else {\nreturn;\n}\n// as per [dataformat-xml#172], try adding indentation\nif (_xmlPrettyPrinter != null) {\n// ... but only if it is likely to succeed:\nif (!_stax2Emulation) {\n_xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n}\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}",
            "method_id": 22
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:setNextNameIfMissing(Ljavax/xml/namespace/QName;)Z",
            "method_body": "public final boolean setNextNameIfMissing(QName name)\n{\nif (_nextName == null) {\n_nextName = name;\nreturn true;\n}\nreturn false;\n}",
            "method_id": 23
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:getMask()I",
            "method_body": "@Override public int getMask() { return _mask; }\n@Override public int getMask() { return _mask; }",
            "method_id": 24
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:createGenerator(Ljava/io/Writer;)Lcom/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator;",
            "method_body": "public ToXmlGenerator createGenerator(Writer out) throws IOException\n{\nreturn new ToXmlGenerator(_createContext(out, false),\n_generatorFeatures, _xmlGeneratorFeatures,\n_objectCodec, _createXmlWriter(out));\n}",
            "method_id": 25
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_createXmlWriter(Ljava/io/Writer;)Ljavax/xml/stream/XMLStreamWriter;",
            "method_body": "protected XMLStreamWriter _createXmlWriter(Writer w) throws IOException\n{\ntry {\nreturn _initializeXmlWriter(_xmlOutputFactory.createXMLStreamWriter(w));\n} catch (XMLStreamException e) {\nreturn StaxUtil.throwXmlAsIOException(e);\n}\n}",
            "method_id": 26
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:serializeValue(Lcom/fasterxml/jackson/core/JsonGenerator;Ljava/lang/Object;)V",
            "method_body": "public void serializeValue(JsonGenerator gen, Object value) throws IOException\n{\nif (value == null) {\n_serializeXmlNull(gen);\nreturn;\n}\nfinal Class<?> cls = value.getClass();\nfinal boolean asArray;\nfinal ToXmlGenerator xgen = _asXmlGenerator(gen);\nif (xgen == null) { // called by convertValue()\nasArray = false;\n} else {\nQName rootName = _rootNameFromConfig();\nif (rootName == null) {\nrootName = _rootNameLookup.findRootName(cls, _config);\n}\n_initWithRootName(xgen, rootName);\nasArray = TypeUtil.isIndexedType(cls);\nif (asArray) {\n_startRootArray(xgen, rootName);\n}\n}\n\n// From super-class implementation\nfinal JsonSerializer<Object> ser = findTypedValueSerializer(cls, true, null);\ntry {\nser.serialize(value, gen, this);\n} catch (IOException ioe) { // As per [JACKSON-99], pass IOException and subtypes as-is\nthrow ioe;\n} catch (Exception e) { // but wrap RuntimeExceptions, to get path information\nString msg = e.getMessage();\nif (msg == null) {\nmsg = \"[no message for \"+e.getClass().getName()+\"]\";\n}\nthrow JsonMappingException.from(gen, msg, e);\n}\n// end of super-class implementation\n\nif (asArray) {\ngen.writeEndObject();\n}\n}",
            "method_id": 27
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:close()V",
            "method_body": "public void close() throws IOException\n{\n//        boolean wasClosed = _closed;\nsuper.close();\n\n// First: let's see that we still have buffers...\nif (isEnabled(JsonGenerator.Feature.AUTO_CLOSE_JSON_CONTENT)) {\ntry {\nwhile (true) {\n/* 28-May-2016, tatu: To work around incompatibility introduced by\n*     `jackson-core` 2.8 where return type of `getOutputContext()`\n*     changed, let's do direct access here.\n*/\n//                    JsonStreamContext ctxt = getOutputContext();\nJsonStreamContext ctxt = _writeContext;\nif (ctxt.inArray()) {\nwriteEndArray();\n} else if (ctxt.inObject()) {\nwriteEndObject();\n} else {\nbreak;\n}\n}\n} catch (ArrayIndexOutOfBoundsException e) {\n/* 29-Nov-2010, tatu: Stupid, stupid SJSXP doesn't do array checks, so we get\n*   hit by this as a collateral problem in some cases. Yuck.\n*/\nthrow new JsonGenerationException(e, this);\n}\n}\ntry {\nif (_ioContext.isResourceManaged() || isEnabled(JsonGenerator.Feature.AUTO_CLOSE_TARGET)) {\n_xmlWriter.closeCompletely();\n} else {\n_xmlWriter.close();\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}",
            "method_id": 28
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initializeXmlWriter(Ljavax/xml/stream/XMLStreamWriter;)Ljavax/xml/stream/XMLStreamWriter;",
            "method_body": "protected final XMLStreamWriter _initializeXmlWriter(XMLStreamWriter sw) throws IOException, XMLStreamException\n{\n// And just for Sun Stax parser (JDK default), seems that we better define default namespace\n// (Woodstox doesn't care) -- otherwise it'll add unnecessary odd declaration\nsw.setDefaultNamespace(\"\");\nreturn sw;\n}",
            "method_id": 29
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:<init>(Lcom/fasterxml/jackson/core/io/IOContext;IILcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLStreamWriter;)V",
            "method_body": "public ToXmlGenerator(IOContext ctxt, int stdFeatures, int xmlFeatures,\nObjectCodec codec, XMLStreamWriter sw)\n{\nsuper(stdFeatures, codec);\n_formatFeatures = xmlFeatures;\n_ioContext = ctxt;\n_originalXmlWriter = sw;\n_xmlWriter = Stax2WriterAdapter.wrapIfNecessary(sw);\n_stax2Emulation = (_xmlWriter != sw);\n_xmlPrettyPrinter = (_cfgPrettyPrinter instanceof XmlPrettyPrinter) ?\n(XmlPrettyPrinter) _cfgPrettyPrinter : null;\n}",
            "method_id": 30
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>()V",
            "method_body": "public XmlFactory() { this(null, null, null); }\npublic XmlFactory() { this(null, null, null); }",
            "method_id": 31
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
            "method_body": "public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\nthis(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\nxmlIn, xmlOut, null);\n}",
            "method_id": 32
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;IILjavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;Ljava/lang/String;)V",
            "method_body": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\nXMLInputFactory xmlIn, XMLOutputFactory xmlOut,\nString nameForTextElem)\n{\nsuper(oc);\n_xmlParserFeatures = xpFeatures;\n_xmlGeneratorFeatures = xgFeatures;\n_cfgNameForTextElement = nameForTextElem;\nif (xmlIn == null) {\nxmlIn = XMLInputFactory.newInstance();\n// as per [dataformat-xml#190], disable external entity expansion by default\nxmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n// and ditto wrt [dataformat-xml#211], SUPPORT_DTD\nxmlIn.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);\n}\nif (xmlOut == null) {\nxmlOut = XMLOutputFactory.newInstance();\n}\n_initFactories(xmlIn, xmlOut);\n_xmlInputFactory = xmlIn;\n_xmlOutputFactory = xmlOut;\n}",
            "method_id": 33
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<clinit>()V",
            "method_body": "public final static String FORMAT_NAME_XML = \"XML\";\n\n/**\n* Bitfield (set of flags) of all parser features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all generator features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\nprotected int _xmlParserFeatures;\n\nprotected int _xmlGeneratorFeatures;\n\n// non-final for setters (why are they needed again?)\nprotected transient XMLInputFactory _xmlInputFactory;\n\nprotected transient XMLOutputFactory _xmlOutputFactory;\n\nprotected String _cfgNameForTextElement;\n\n/*\n/**********************************************************\n/* Factory construction, configuration\n/**********************************************************\n*/\n\n/**\n* Default constructor used to create factory instances.\n* Creation of a factory instance is a light-weight operation,\n* but it is still a good idea to reuse limited number of\n* factory instances (and quite often just a single instance):\n* factories are used as context for storing some reused\n* processing objects (such as symbol tables parsers use)\n* and this reuse only works within context of a single\n* factory instance.\n*/\npublic XmlFactory() { this(null, null, null); }",
            "method_id": 34
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initFactories(Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
            "method_body": "protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\n// Better ensure namespaces get built properly, so:\nxmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n// and for parser, force coalescing as well (much simpler to use)\nxmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n}",
            "method_id": 35
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:<clinit>()V",
            "method_body": "public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n/**\n* Enumeration that defines all togglable features for XML parsers.\n* None defined so far (2.6), so just a placeholder.\n*/\npublic enum Feature implements FormatFeature\n{\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}",
            "method_id": 36
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}",
            "method_id": 37
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
            "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}",
            "method_id": 38
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<clinit>()V",
            "method_body": "protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n\n/**\n* Enumeration that defines all togglable extra XML-specific features\n*/\npublic enum Feature implements FormatFeature\n{\n/**\n* Feature that controls whether XML declaration should be written before\n* when generator is initialized (true) or not (false)\n*/\nWRITE_XML_DECLARATION(false),\n\n/**\n* Feature that controls whether output should be done as XML 1.1; if so,\n* certain aspects may differ from default (1.0) processing: for example,\n* XML declaration will be automatically added (regardless of setting\n* <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n* know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n* control characters (Ascii codes 0 through 31) as well as additional linefeeds\n* and name characters.\n*/\nWRITE_XML_1_1(false)\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}",
            "method_id": 39
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}",
            "method_id": 40
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledByDefault()Z",
            "method_body": "@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public boolean enabledByDefault() { return _defaultState; }",
            "method_id": 41
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:<init>(Lcom/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider;Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/ser/SerializerFactory;)V",
            "method_body": "public XmlSerializerProvider(XmlSerializerProvider src,\nSerializationConfig config, SerializerFactory f)\n{\nsuper(src, config, f);\n_rootNameLookup  = src._rootNameLookup;\n}",
            "method_id": 42
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:createInstance(Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/ser/SerializerFactory;)Lcom/fasterxml/jackson/databind/ser/DefaultSerializerProvider;",
            "method_body": "public DefaultSerializerProvider createInstance(SerializationConfig config,\nSerializerFactory jsf) {\nreturn new XmlSerializerProvider(this, config, jsf);\n}",
            "method_id": 43
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:_asXmlGenerator(Lcom/fasterxml/jackson/core/JsonGenerator;)Lcom/fasterxml/jackson/dataformat/xml/ser/ToXmlGenerator;",
            "method_body": "protected ToXmlGenerator _asXmlGenerator(JsonGenerator gen)\nthrows JsonMappingException\n{\n// [Issue#71]: When converting, we actually get TokenBuffer, which is fine\nif (!(gen instanceof ToXmlGenerator)) {\n// but verify\nif (!(gen instanceof TokenBuffer)) {\nthrow JsonMappingException.from(gen,\n\"XmlMapper does not with generators of type other than ToXmlGenerator; got: \"+gen.getClass().getName());\n}\nreturn null;\n}\nreturn (ToXmlGenerator) gen;\n}",
            "method_id": 44
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.TypeUtil:isIndexedType(Lcom/fasterxml/jackson/databind/JavaType;)Z",
            "method_body": "public static boolean isIndexedType(JavaType type)\n{\nif (type.isContainerType()) {\nClass<?> cls = type.getRawClass();\n// One special case; byte[] will be serialized as base64-encoded String, not real array, so:\n// (actually, ditto for char[]; thought to be a String)\nif (cls == byte[].class || cls == char[].class) {\nreturn false;\n}\n// issue#5: also, should not add wrapping for Maps\nif (Map.class.isAssignableFrom(cls)) {\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}",
            "method_id": 45
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsTextAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
            "method_body": "public static Boolean findIsTextAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsText(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}",
            "method_id": 46
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:modifySerializer(Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Lcom/fasterxml/jackson/databind/JsonSerializer;)Lcom/fasterxml/jackson/databind/JsonSerializer;",
            "method_body": "public JsonSerializer<?> modifySerializer(SerializationConfig config,\nBeanDescription beanDesc, JsonSerializer<?> serializer)\n{\n/* First things first: we can only handle real BeanSerializers; question\n* is, what to do if it's not one: throw exception or bail out?\n* For now let's do latter.\n*/\nif (!(serializer instanceof BeanSerializerBase)) {\nreturn serializer;\n}\nreturn new XmlBeanSerializer((BeanSerializerBase) serializer);\n}",
            "method_id": 47
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:_verifyValueWrite(Ljava/lang/String;)V",
            "method_body": "protected final void _verifyValueWrite(String typeMsg) throws IOException\n{\nint status = _writeContext.writeValue();\nif (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n_reportError(\"Can not \"+typeMsg+\", expecting field name\");\n}\n}",
            "method_id": 48
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsAttributeAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
            "method_body": "public static Boolean findIsAttributeAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nBoolean b = ((JaxbAnnotationIntrospector) intr).isOutputAsAttribute(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}",
            "method_id": 49
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findNamespaceAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/String;",
            "method_body": "public static String findNamespaceAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nString ns = ((XmlAnnotationIntrospector) intr).findNamespace(prop);\nif (ns != null) {\nreturn ns;\n}\n} else  if (intr instanceof JaxbAnnotationIntrospector) {\nString ns = ((JaxbAnnotationIntrospector) intr).findNamespace(prop);\nif (ns != null) {\nreturn ns;\n}\n}\n}\nreturn null;\n}",
            "method_id": 50
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.AnnotationUtil:findIsCDataAnnotation(Lcom/fasterxml/jackson/databind/AnnotationIntrospector;Lcom/fasterxml/jackson/databind/introspect/AnnotatedMember;)Ljava/lang/Boolean;",
            "method_body": "public static Boolean findIsCDataAnnotation(AnnotationIntrospector ai,\nAnnotatedMember prop)\n{\nfor (AnnotationIntrospector intr : ai.allIntrospectors()) {\nif (intr instanceof XmlAnnotationIntrospector) {\nBoolean b = ((XmlAnnotationIntrospector) intr).isOutputAsCData(prop);\nif (b != null) {\nreturn b;\n}\n}\n}\nreturn null;\n}",
            "method_id": 51
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:_isAttribute(Lcom/fasterxml/jackson/databind/ser/BeanPropertyWriter;)Z",
            "method_body": "protected static boolean _isAttribute(BeanPropertyWriter bpw)\n{\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nreturn (info != null) && info.isAttribute();\n}",
            "method_id": 52
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:_isCData(Lcom/fasterxml/jackson/databind/ser/BeanPropertyWriter;)Z",
            "method_body": "protected static boolean _isCData(BeanPropertyWriter bpw)\n{\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nreturn (info != null) && info.isCData();\n}",
            "method_id": 53
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:<init>(Ljava/lang/Boolean;Ljava/lang/String;Ljava/lang/Boolean;Ljava/lang/Boolean;)V",
            "method_body": "public XmlInfo(Boolean isAttribute, String ns, Boolean isText, Boolean isCData)\n{\n_isAttribute = (isAttribute == null) ? false : isAttribute.booleanValue();\n_namespace = (ns == null) ? \"\" : ns;\n_isText = (isText == null) ? false : isText.booleanValue();\n_isCData = (isCData == null) ? false : isCData.booleanValue();\n}",
            "method_id": 54
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:getNamespace()Ljava/lang/String;",
            "method_body": "public String getNamespace() { return _namespace; }\npublic String getNamespace() { return _namespace; }",
            "method_id": 55
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:isAttribute()Z",
            "method_body": "public boolean isAttribute() { return _isAttribute; }\npublic boolean isAttribute() { return _isAttribute; }",
            "method_id": 56
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:isText()Z",
            "method_body": "public boolean isText() { return _isText; }\npublic boolean isText() { return _isText; }",
            "method_id": 57
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.util.XmlInfo:isCData()Z",
            "method_body": "public boolean isCData() { return _isCData; }\npublic boolean isCData() { return _isCData; }",
            "method_id": 58
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerModifier:changeProperties(Lcom/fasterxml/jackson/databind/SerializationConfig;Lcom/fasterxml/jackson/databind/BeanDescription;Ljava/util/List;)Ljava/util/List;",
            "method_body": "public List<BeanPropertyWriter> changeProperties(SerializationConfig config,\nBeanDescription beanDesc, List<BeanPropertyWriter> beanProperties)\n{\nfinal AnnotationIntrospector intr = config.getAnnotationIntrospector();\nfor (int i = 0, len = beanProperties.size(); i < len; ++i) {\nBeanPropertyWriter bpw = beanProperties.get(i);\nfinal AnnotatedMember member = bpw.getMember();\nString ns = AnnotationUtil.findNamespaceAnnotation(intr, member);\nBoolean isAttribute = AnnotationUtil.findIsAttributeAnnotation(intr, member);\nBoolean isText = AnnotationUtil.findIsTextAnnotation(intr, member);\nBoolean isCData = AnnotationUtil.findIsCDataAnnotation(intr, member);\nbpw.setInternalSetting(XmlBeanSerializerBase.KEY_XML_INFO,\nnew XmlInfo(isAttribute, ns, isText, isCData));\n\n// Actually: if we have a Collection type, easiest place to add wrapping would be here...\n//  or: let's also allow wrapping of \"untyped\" (Object): assuming it is a dynamically\n//   typed Collection...\nif (!TypeUtil.isIndexedType(bpw.getType())) {\ncontinue;\n}\nPropertyName wrappedName = PropertyName.construct(bpw.getName(), ns);\nPropertyName wrapperName = bpw.getWrapperName();\n\n// first things first: no wrapping?\nif (wrapperName == null || wrapperName == PropertyName.NO_NAME) {\ncontinue;\n}\n// no local name? Just double the wrapped name for wrapper\nString localName = wrapperName.getSimpleName();\nif (localName == null || localName.length() == 0) {\nwrapperName = wrappedName;\n}\nbeanProperties.set(i, new XmlBeanPropertyWriter(bpw, wrapperName, wrappedName));\n}\nreturn beanProperties;\n}",
            "method_id": 59
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:<init>(Lcom/fasterxml/jackson/databind/ser/std/BeanSerializerBase;)V",
            "method_body": "public XmlBeanSerializerBase(BeanSerializerBase src)\n{\nsuper(src);\n\n/* Then make sure attributes are sorted before elements, keep track\n* of how many there are altogether\n*/\nint attrCount = 0;\nfor (BeanPropertyWriter bpw : _props) {\nif (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\nattrCount = _orderAttributesFirst(_props, _filteredProps);\nbreak;\n}\n}\n_attributeCount = attrCount;\n\n// also: pre-compute need, if any, for CDATA handling:\nBitSet cdata = null;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nif (_isCData(bpw)) {\nif (cdata == null) {\ncdata = new BitSet(len);\n}\ncdata.set(i);\n}\n}\n_cdata = cdata;\n\n// And then collect namespace information\n_xmlNames = new QName[_props.length];\nint textIndex = -1;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nString ns = null;\nif (info != null) {\nns = info.getNamespace();\nif (textIndex < 0 && info.isText()) {\ntextIndex = i;\n}\n}\n_xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n}\n_textPropertyIndex = textIndex;\n}",
            "method_id": 60
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:<clinit>()V",
            "method_body": "public final static String KEY_XML_INFO = new String(\"xmlInfo\");\n\n/**\n* Number of attributes to write; these will have been ordered to be the first\n* properties to write.\n*/\nprotected final int _attributeCount;\n\n/**\n* Index of \"text value\" property we have, if any; can have at most\n* one such property.\n*/\nprotected final int _textPropertyIndex;\n\n/**\n* Array that contains namespace URIs associated with properties, if any;\n* null if no namespace definitions have been assigned\n*/\nprotected final QName[] _xmlNames;\n\n/**\n* Optional set of indexes of properties that should be serialized as CDATA,\n* instead of regular XML text segment. Left as null in cases where none of\n* element values are to be written in such a way.\n*/\nprotected final BitSet _cdata;\n\npublic XmlBeanSerializerBase(BeanSerializerBase src)\n{\nsuper(src);\n\n/* Then make sure attributes are sorted before elements, keep track\n* of how many there are altogether\n*/\nint attrCount = 0;\nfor (BeanPropertyWriter bpw : _props) {\nif (_isAttribute(bpw)) { // Yup: let's build re-ordered list then\nattrCount = _orderAttributesFirst(_props, _filteredProps);\nbreak;\n}\n}\n_attributeCount = attrCount;\n\n// also: pre-compute need, if any, for CDATA handling:\nBitSet cdata = null;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nif (_isCData(bpw)) {\nif (cdata == null) {\ncdata = new BitSet(len);\n}\ncdata.set(i);\n}\n}\n_cdata = cdata;\n\n// And then collect namespace information\n_xmlNames = new QName[_props.length];\nint textIndex = -1;\nfor (int i = 0, len = _props.length; i < len; ++i) {\nBeanPropertyWriter bpw = _props[i];\nXmlInfo info = (XmlInfo) bpw.getInternalSetting(KEY_XML_INFO);\nString ns = null;\nif (info != null) {\nns = info.getNamespace();\nif (textIndex < 0 && info.isText()) {\ntextIndex = i;\n}\n}\n_xmlNames[i] = new QName((ns == null) ? \"\" : ns, bpw.getName());\n}\n_textPropertyIndex = textIndex;\n}",
            "method_id": 61
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializer:<init>(Lcom/fasterxml/jackson/databind/ser/std/BeanSerializerBase;)V",
            "method_body": "public XmlBeanSerializer(BeanSerializerBase src) {\nsuper(src);\n}",
            "method_id": 62
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:_findXmlName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
            "method_body": "protected PropertyName _findXmlName(Annotated a)\n{\nJacksonXmlProperty pann = a.getAnnotation(JacksonXmlProperty.class);\nif (pann != null) {\nreturn PropertyName.construct(pann.localName(), pann.namespace());\n}\nreturn null;\n}",
            "method_id": 63
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeStartObject()V",
            "method_body": "public final void writeStartObject() throws IOException\n{\n_verifyValueWrite(\"start an object\");\n_writeContext = _writeContext.createChildObjectContext();\nif (_cfgPrettyPrinter != null) {\n_cfgPrettyPrinter.writeStartObject(this);\n} else {\n_handleStartObject();\n}\n}",
            "method_id": 64
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:_handleStartObject()V",
            "method_body": "public final void _handleStartObject() throws IOException\n{\nif (_nextName == null) {\nhandleMissingName();\n}\n// Need to keep track of names to make Lists work correctly\n_elementNameStack.addLast(_nextName);\ntry {\n_xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}",
            "method_id": 65
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeFieldName(Lcom/fasterxml/jackson/core/SerializableString;)V",
            "method_body": "public void writeFieldName(SerializableString name) throws IOException\n{\nwriteFieldName(name.getValue());\n}",
            "method_id": 66
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializer:serialize(Ljava/lang/Object;Lcom/fasterxml/jackson/core/JsonGenerator;Lcom/fasterxml/jackson/databind/SerializerProvider;)V",
            "method_body": "public void serialize(Object bean, JsonGenerator jgen, SerializerProvider provider) throws IOException\n{\nif (_objectIdWriter != null) {\n_serializeWithObjectId(bean, jgen, provider, true);\nreturn;\n}\njgen.writeStartObject();\nif (_propertyFilterId != null) {\nserializeFieldsFiltered(bean, jgen, provider);\n} else {\nserializeFields(bean, jgen, provider);\n}\njgen.writeEndObject();\n}",
            "method_id": 67
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlBeanSerializerBase:serializeFields(Ljava/lang/Object;Lcom/fasterxml/jackson/core/JsonGenerator;Lcom/fasterxml/jackson/databind/SerializerProvider;)V",
            "method_body": "protected void serializeFields(Object bean, JsonGenerator gen0, SerializerProvider provider)\nthrows IOException\n{\n// 19-Aug-2013, tatu: During 'convertValue()', need to skip\nif (!(gen0 instanceof ToXmlGenerator)) {\nsuper.serializeFields(bean, gen0, provider);\nreturn;\n}\n\nfinal ToXmlGenerator xgen = (ToXmlGenerator) gen0;\nfinal BeanPropertyWriter[] props;\nif (_filteredProps != null && provider.getActiveView() != null) {\nprops = _filteredProps;\n} else {\nprops = _props;\n}\n\nfinal int attrCount = _attributeCount;\nfinal boolean isAttribute = xgen._nextIsAttribute;\nif (attrCount > 0) {\nxgen.setNextIsAttribute(true);\n}\nfinal int textIndex = _textPropertyIndex;\nfinal QName[] xmlNames = _xmlNames;\nint i = 0;\nfinal BitSet cdata = _cdata;\n\ntry {\nfor (final int len = props.length; i < len; ++i) {\n// 28-jan-2014, pascal: we don't want to reset the attribute flag if we are an unwrapping serializer\n// that started with nextIsAttribute to true because all properties should be unwrapped as attributes too.\nif (i == attrCount && !(isAttribute && isUnwrappingSerializer())) {\nxgen.setNextIsAttribute(false);\n}\n// also: if this is property to write as text (\"unwrap\"), need to:\nif (i == textIndex) {\nxgen.setNextIsUnwrapped(true);\n}\nxgen.setNextName(xmlNames[i]);\nBeanPropertyWriter prop = props[i];\nif (prop != null) { // can have nulls in filtered list\nif ((cdata != null) && cdata.get(i)) {\nxgen.setNextIsCData(true);\nprop.serializeAsField(bean, xgen, provider);\nxgen.setNextIsCData(false);\n} else {\nprop.serializeAsField(bean, xgen, provider);\n}\n}\n// Reset to avoid next value being written as unwrapped,\n// for example when property is suppressed\nif (i == textIndex) {\nxgen.setNextIsUnwrapped(false);\n}\n}\nif (_anyGetterWriter != null) {\n// For [#117]: not a clean fix, but with @JsonTypeInfo, we'll end up\n// with accidental attributes otherwise\nxgen.setNextIsAttribute(false);\n_anyGetterWriter.getAndSerialize(bean, xgen, provider);\n}\n} catch (Exception e) {\nString name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\nwrapAndThrow(provider, e, bean, name);\n} catch (StackOverflowError e) { // Bit tricky, can't do more calls as stack is full; so:\nJsonMappingException mapE = JsonMappingException.from(gen0,\n\"Infinite recursion (StackOverflowError)\");\nString name = (i == props.length) ? \"[anySetter]\" : props[i].getName();\nmapE.prependPath(new JsonMappingException.Reference(bean, name));\nthrow mapE;\n}\n}",
            "method_id": 68
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNameForSerialization(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
            "method_body": "public PropertyName findNameForSerialization(Annotated a)\n{\nPropertyName name = _findXmlName(a);\nif (name == null) {\nname = super.findNameForSerialization(a);\nif (name == null) {\nif (a.hasAnnotation(JacksonXmlText.class)) {\nreturn PropertyName.USE_DEFAULT;\n}\n}\n}\nreturn name;\n}",
            "method_id": 69
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:setNextIsAttribute(Z)V",
            "method_body": "public void setNextIsAttribute(boolean isAttribute)\n{\n_nextIsAttribute = isAttribute;\n}",
            "method_id": 70
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeFieldName(Ljava/lang/String;)V",
            "method_body": "public final void writeFieldName(String name) throws IOException\n{\nif (_writeContext.writeFieldName(name) == JsonWriteContext.STATUS_EXPECT_VALUE) {\n_reportError(\"Can not write a field name, expecting a value\");\n}\n// Should this ever get called?\nString ns = (_nextName == null) ? \"\" : _nextName.getNamespaceURI();\nsetNextName(new QName(ns, name));\n}",
            "method_id": 71
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:setNextName(Ljavax/xml/namespace/QName;)V",
            "method_body": "public final void setNextName(QName name)\n{\n_nextName = name;\n}",
            "method_id": 72
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findWrapperName(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
            "method_body": "public PropertyName findWrapperName(Annotated ann)\n{\nJacksonXmlElementWrapper w = ann.getAnnotation(JacksonXmlElementWrapper.class);\nif (w != null) {\n// Special case: wrapping explicitly blocked?\nif (!w.useWrapping()) {\nreturn PropertyName.NO_NAME;\n}\n// also: need to ensure we use marker:\nString localName = w.localName();\nif (localName == null || localName.length() == 0) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn PropertyName.construct(w.localName(), w.namespace());\n}\n/* 09-Sep-2012, tatu: In absence of configurating we need to use our\n*   default settings...\n*/\nif (_cfgDefaultUseWrapper) {\nreturn PropertyName.USE_DEFAULT;\n}\nreturn null;\n}",
            "method_id": 73
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsText(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
            "method_body": "public Boolean isOutputAsText(Annotated ann)\n{\nJacksonXmlText prop = ann.getAnnotation(JacksonXmlText.class);\nif (prop != null) {\nreturn prop.value() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}",
            "method_id": 74
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNamespace(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/String;",
            "method_body": "public String findNamespace(Annotated ann)\n{\nJacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\nif (prop != null) {\nreturn prop.namespace();\n}\nreturn null;\n}",
            "method_id": 75
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:findNameForDeserialization(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Lcom/fasterxml/jackson/databind/PropertyName;",
            "method_body": "public PropertyName findNameForDeserialization(Annotated a)\n{\nPropertyName name = _findXmlName(a);\nif (name == null) {\nname = super.findNameForDeserialization(a);\nif (name == null) {\nif (a.hasAnnotation(JacksonXmlText.class)) {\nreturn PropertyName.USE_DEFAULT;\n}\n}\n}\nreturn name;\n}",
            "method_id": 76
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsAttribute(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
            "method_body": "public Boolean isOutputAsAttribute(Annotated ann)\n{\nJacksonXmlProperty prop = ann.getAnnotation(JacksonXmlProperty.class);\nif (prop != null) {\nreturn prop.isAttribute() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}",
            "method_id": 77
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.JacksonXmlAnnotationIntrospector:isOutputAsCData(Lcom/fasterxml/jackson/databind/introspect/Annotated;)Ljava/lang/Boolean;",
            "method_body": "public Boolean isOutputAsCData(Annotated ann) {\nJacksonXmlCData prop = ann.getAnnotation(JacksonXmlCData.class);\nif (prop != null) {\nreturn prop.value() ? Boolean.TRUE : Boolean.FALSE;\n}\nreturn null;\n}",
            "method_id": 78
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeString(Ljava/lang/String;)V",
            "method_body": "public void writeString(String text) throws IOException\n{\n_verifyValueWrite(\"write String value\");\nif (_nextName == null) {\nhandleMissingName();\n}\ntry {\nif (_nextIsAttribute) { // must write attribute name and value with one call\n_xmlWriter.writeAttribute(_nextName.getNamespaceURI(), _nextName.getLocalPart(), text);\n} else if (checkNextIsUnwrapped()) {\n// [Issue#56] Should figure out how to prevent indentation for end element\n//   but for now, let's just make sure structure is correct\n//if (_xmlPrettyPrinter != null) { ... }\nif(_nextIsCData) {\n_xmlWriter.writeCData(text);\n} else {\n_xmlWriter.writeCharacters(text);\n}\n} else if (_xmlPrettyPrinter != null) {\n_xmlPrettyPrinter.writeLeafElement(_xmlWriter,\n_nextName.getNamespaceURI(), _nextName.getLocalPart(),\ntext, _nextIsCData);\n} else {\n_xmlWriter.writeStartElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\nif(_nextIsCData) {\n_xmlWriter.writeCData(text);\n} else {\n_xmlWriter.writeCharacters(text);\n}\n_xmlWriter.writeEndElement();\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}",
            "method_id": 79
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:checkNextIsUnwrapped()Z",
            "method_body": "protected boolean checkNextIsUnwrapped()\n{\nif (_nextIsUnwrapped) {\n_nextIsUnwrapped = false;\nreturn true;\n}\nreturn false;\n}",
            "method_id": 80
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.XmlSerializerProvider:_serializeXmlNull(Lcom/fasterxml/jackson/core/JsonGenerator;)V",
            "method_body": "protected void _serializeXmlNull(JsonGenerator jgen) throws IOException\n{\n// 14-Nov-2016, tatu: As per [dataformat-xml#213], we may have explicitly\n//    configured root name...\nif (jgen instanceof ToXmlGenerator) {\n_initWithRootName((ToXmlGenerator) jgen, ROOT_NAME_FOR_NULL);\n}\nsuper.serializeValue(jgen, null);\n}",
            "method_id": 81
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeEndObject()V",
            "method_body": "public final void writeEndObject() throws IOException\n{\nif (!_writeContext.inObject()) {\n_reportError(\"Current context not Object but \"+_writeContext.typeDesc());\n}\n_writeContext = _writeContext.getParent();\nif (_cfgPrettyPrinter != null) {\n// as per [Issue#45], need to suppress indentation if only attributes written:\nint count = _nextIsAttribute ? 0 : _writeContext.getEntryCount();\n_cfgPrettyPrinter.writeEndObject(this, count);\n} else {\n_handleEndObject();\n}\n}",
            "method_id": 82
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:_handleEndObject()V",
            "method_body": "public final void _handleEndObject() throws IOException\n{\n// We may want to repeat same element, so:\nif (_elementNameStack.isEmpty()) {\nthrow new JsonGenerationException(\"Can not write END_ELEMENT without open START_ELEMENT\", this);\n}\n_nextName = _elementNameStack.removeLast();\ntry {\n// note: since attributes don't nest, can only have one attribute active, so:\n_nextIsAttribute = false;\n_xmlWriter.writeEndElement();\n// [databind-xml#172]: possibly also need indentation\nif (_elementNameStack.isEmpty() && (_xmlPrettyPrinter != null)) {\n// ... but only if it is likely to succeed:\nif (!_stax2Emulation) {\n_xmlPrettyPrinter.writePrologLinefeed(_xmlWriter);\n}\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}",
            "method_id": 83
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator:writeNull()V",
            "method_body": "public void writeNull() throws IOException\n{\n_verifyValueWrite(\"write null value\");\nif (_nextName == null) {\nhandleMissingName();\n}\n// !!! TODO: proper use of 'xsd:isNil' ?\ntry {\nif (_nextIsAttribute) {\n/* With attributes, best just leave it out, right? (since there's no way\n* to use 'xsi:nil')\n*/\n} else if (checkNextIsUnwrapped()) {\n// as with above, best left unwritten?\n} else {\nif (_xmlPrettyPrinter != null) {\n_xmlPrettyPrinter.writeLeafNullElement(_xmlWriter,\n_nextName.getNamespaceURI(), _nextName.getLocalPart());\n} else {\n_xmlWriter.writeEmptyElement(_nextName.getNamespaceURI(), _nextName.getLocalPart());\n}\n}\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\n}\n}",
            "method_id": 84
        }
    ]
}