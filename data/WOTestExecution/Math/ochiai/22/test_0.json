{
    "bug_id": 22,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.distribution.FDistributionTest.testIsSupportLowerBoundInclusive",
    "test_body": null,
    "stack_trace": "junit.framework.AssertionFailedError: expected:<false> but was:<true>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:118)\nat org.junit.Assert.assertEquals(Assert.java:144)\nat org.apache.commons.math3.distribution.RealDistributionAbstractTest.testIsSupportLowerBoundInclusive(RealDistributionAbstractTest.java:351)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:isSupportLowerBoundInclusive()Z",
            "method_body": "public boolean isSupportLowerBoundInclusive() {\nreturn true;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:density(D)D",
            "method_body": "public double density(double x) {\nfinal double nhalf = numeratorDegreesOfFreedom / 2;\nfinal double mhalf = denominatorDegreesOfFreedom / 2;\nfinal double logx = FastMath.log(x);\nfinal double logn = FastMath.log(numeratorDegreesOfFreedom);\nfinal double logm = FastMath.log(denominatorDegreesOfFreedom);\nfinal double lognxm = FastMath.log(numeratorDegreesOfFreedom * x +\ndenominatorDegreesOfFreedom);\nreturn FastMath.exp(nhalf * logn + nhalf * logx - logx +\nmhalf * logm - nhalf * lognxm - mhalf * lognxm -\nBeta.logBeta(nhalf, mhalf));\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.special.Beta:logBeta(DD)D",
            "method_body": "public static double logBeta(double a, double b) {\nreturn logBeta(a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:getSupportLowerBound()D",
            "method_body": "public double getSupportLowerBound() {\nreturn 0;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:<init>(DD)V",
            "method_body": "public FDistribution(double numeratorDegreesOfFreedom,\ndouble denominatorDegreesOfFreedom)\nthrows NotStrictlyPositiveException {\nthis(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom,\nDEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:<init>(DDD)V",
            "method_body": "public FDistribution(double numeratorDegreesOfFreedom,\ndouble denominatorDegreesOfFreedom,\ndouble inverseCumAccuracy)\nthrows NotStrictlyPositiveException {\nthis(new Well19937c(), numeratorDegreesOfFreedom,\ndenominatorDegreesOfFreedom, inverseCumAccuracy);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:<init>(Lorg/apache/commons/math3/random/RandomGenerator;DDD)V",
            "method_body": "public FDistribution(RandomGenerator rng,\ndouble numeratorDegreesOfFreedom,\ndouble denominatorDegreesOfFreedom,\ndouble inverseCumAccuracy)\nthrows NotStrictlyPositiveException {\nsuper(rng);\n\nif (numeratorDegreesOfFreedom <= 0) {\nthrow new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\nnumeratorDegreesOfFreedom);\n}\nif (denominatorDegreesOfFreedom <= 0) {\nthrow new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\ndenominatorDegreesOfFreedom);\n}\nthis.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;\nthis.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;\nsolverAbsoluteAccuracy = inverseCumAccuracy;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.special.Beta:logBeta(DDDI)D",
            "method_body": "public static double logBeta(double a, double b,\ndouble epsilon,\nint maxIterations) {\ndouble ret;\n\nif (Double.isNaN(a) ||\nDouble.isNaN(b) ||\na <= 0.0 ||\nb <= 0.0) {\nret = Double.NaN;\n} else {\nret = Gamma.logGamma(a) + Gamma.logGamma(b) -\nGamma.logGamma(a + b);\n}\n\nreturn ret;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractRealDistribution:<init>(Lorg/apache/commons/math3/random/RandomGenerator;)V",
            "method_body": "protected AbstractRealDistribution(RandomGenerator rng) {\nrandom = rng;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.random.AbstractWell:<init>(IIII)V",
            "method_body": "protected AbstractWell(final int k, final int m1, final int m2, final int m3) {\nthis(k, m1, m2, m3, null);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.random.Well19937c:<init>()V",
            "method_body": "public Well19937c() {\nsuper(K, M1, M2, M3);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.random.AbstractWell:setSeed(J)V",
            "method_body": "public void setSeed(final long seed) {\nsetSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.random.AbstractWell:<init>(IIII[I)V",
            "method_body": "protected AbstractWell(final int k, final int m1, final int m2, final int m3, final int[] seed) {\n\n// the bits pool contains k bits, k = r w - p where r is the number\n// of w bits blocks, w is the block size (always 32 in the original paper)\n// and p is the number of unused bits in the last block\nfinal int w = 32;\nfinal int r = (k + w - 1) / w;\nthis.v      = new int[r];\nthis.index  = 0;\n\n// precompute indirection index tables. These tables are used for optimizing access\n// they allow saving computations like \"(j + r - 2) % r\" with costly modulo operations\niRm1 = new int[r];\niRm2 = new int[r];\ni1   = new int[r];\ni2   = new int[r];\ni3   = new int[r];\nfor (int j = 0; j < r; ++j) {\niRm1[j] = (j + r - 1) % r;\niRm2[j] = (j + r - 2) % r;\ni1[j]   = (j + m1)    % r;\ni2[j]   = (j + m2)    % r;\ni3[j]   = (j + m3)    % r;\n}\n\n// initialize the pool content\nsetSeed(seed);\n\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.random.AbstractWell:setSeed([I)V",
            "method_body": "public void setSeed(final int[] seed) {\nif (seed == null) {\nsetSeed(System.currentTimeMillis() + System.identityHashCode(this));\nreturn;\n}\n\nSystem.arraycopy(seed, 0, v, 0, Math.min(seed.length, v.length));\n\nif (seed.length < v.length) {\nfor (int i = seed.length; i < v.length; ++i) {\nfinal long l = v[i - seed.length];\nv[i] = (int) ((1812433253l * (l ^ (l >> 30)) + i) & 0xffffffffL);\n}\n}\n\nindex = 0;\nclear();  // Clear normal deviate cache\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.random.RandomDataImpl:<init>()V",
            "method_body": "public RandomDataImpl() {\ndelegate = new RandomDataGenerator();\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:<init>()V",
            "method_body": "public BitsStreamGenerator() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:clear()V",
            "method_body": "public void clear() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.special.Gamma:logGamma1p(D)D",
            "method_body": "public static double logGamma1p(final double x)\nthrows NumberIsTooSmallException, NumberIsTooLargeException {\n\nif (x < -0.5) {\nthrow new NumberIsTooSmallException(x, -0.5, true);\n}\nif (x > 1.5) {\nthrow new NumberIsTooLargeException(x, 1.5, true);\n}\n\nreturn -FastMath.log1p(invGamma1pm1(x));\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.special.Gamma:invGamma1pm1(D)D",
            "method_body": "public static double invGamma1pm1(final double x) {\n\nif (x < -0.5) {\nthrow new NumberIsTooSmallException(x, -0.5, true);\n}\nif (x > 1.5) {\nthrow new NumberIsTooLargeException(x, 1.5, true);\n}\n\nfinal double ret;\nfinal double t = x <= 0.5 ? x : (x - 0.5) - 0.5;\nif (t < 0.0) {\nfinal double a = INV_GAMMA1P_M1_A0 + t * INV_GAMMA1P_M1_A1;\ndouble b = INV_GAMMA1P_M1_B8;\nb = INV_GAMMA1P_M1_B7 + t * b;\nb = INV_GAMMA1P_M1_B6 + t * b;\nb = INV_GAMMA1P_M1_B5 + t * b;\nb = INV_GAMMA1P_M1_B4 + t * b;\nb = INV_GAMMA1P_M1_B3 + t * b;\nb = INV_GAMMA1P_M1_B2 + t * b;\nb = INV_GAMMA1P_M1_B1 + t * b;\nb = 1.0 + t * b;\n\ndouble c = INV_GAMMA1P_M1_C13 + t * (a / b);\nc = INV_GAMMA1P_M1_C12 + t * c;\nc = INV_GAMMA1P_M1_C11 + t * c;\nc = INV_GAMMA1P_M1_C10 + t * c;\nc = INV_GAMMA1P_M1_C9 + t * c;\nc = INV_GAMMA1P_M1_C8 + t * c;\nc = INV_GAMMA1P_M1_C7 + t * c;\nc = INV_GAMMA1P_M1_C6 + t * c;\nc = INV_GAMMA1P_M1_C5 + t * c;\nc = INV_GAMMA1P_M1_C4 + t * c;\nc = INV_GAMMA1P_M1_C3 + t * c;\nc = INV_GAMMA1P_M1_C2 + t * c;\nc = INV_GAMMA1P_M1_C1 + t * c;\nc = INV_GAMMA1P_M1_C + t * c;\nif (x > 0.5) {\nret = t * c / x;\n} else {\nret = x * ((c + 0.5) + 0.5);\n}\n} else {\ndouble p = INV_GAMMA1P_M1_P6;\np = INV_GAMMA1P_M1_P5 + t * p;\np = INV_GAMMA1P_M1_P4 + t * p;\np = INV_GAMMA1P_M1_P3 + t * p;\np = INV_GAMMA1P_M1_P2 + t * p;\np = INV_GAMMA1P_M1_P1 + t * p;\np = INV_GAMMA1P_M1_P0 + t * p;\n\ndouble q = INV_GAMMA1P_M1_Q4;\nq = INV_GAMMA1P_M1_Q3 + t * q;\nq = INV_GAMMA1P_M1_Q2 + t * q;\nq = INV_GAMMA1P_M1_Q1 + t * q;\nq = 1.0 + t * q;\n\ndouble c = INV_GAMMA1P_M1_C13 + (p / q) * t;\nc = INV_GAMMA1P_M1_C12 + t * c;\nc = INV_GAMMA1P_M1_C11 + t * c;\nc = INV_GAMMA1P_M1_C10 + t * c;\nc = INV_GAMMA1P_M1_C9 + t * c;\nc = INV_GAMMA1P_M1_C8 + t * c;\nc = INV_GAMMA1P_M1_C7 + t * c;\nc = INV_GAMMA1P_M1_C6 + t * c;\nc = INV_GAMMA1P_M1_C5 + t * c;\nc = INV_GAMMA1P_M1_C4 + t * c;\nc = INV_GAMMA1P_M1_C3 + t * c;\nc = INV_GAMMA1P_M1_C2 + t * c;\nc = INV_GAMMA1P_M1_C1 + t * c;\nc = INV_GAMMA1P_M1_C0 + t * c;\n\nif (x > 0.5) {\nret = (t / x) * ((c - 0.5) - 0.5);\n} else {\nret = x * c;\n}\n}\n\nreturn ret;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log1p(D)D",
            "method_body": "public static double log1p(final double x) {\nif (x == -1) {\nreturn Double.NEGATIVE_INFINITY;\n}\n\nif (x == Double.POSITIVE_INFINITY) {\nreturn Double.POSITIVE_INFINITY;\n}\n\nif (x > 1e-6 ||\nx < -1e-6) {\nfinal double xpa = 1 + x;\nfinal double xpb = -(xpa - 1 - x);\n\nfinal double[] hiPrec = new double[2];\nfinal double lores = log(xpa, hiPrec);\nif (Double.isInfinite(lores)) { // Don't allow this to be converted to NaN\nreturn lores;\n}\n\n// Do a taylor series expansion around xpa:\n//   f(x+y) = f(x) + f'(x) y + f''(x)/2 y^2\nfinal double fx1 = xpb / xpa;\nfinal double epsilon = 0.5 * fx1 + 1;\nreturn epsilon * fx1 + hiPrec[1] + hiPrec[0];\n} else {\n// Value is small |x| < 1e6, do a Taylor series centered on 1.\nfinal double y = (x * F_1_3 - F_1_2) * x + 1;\nreturn y * x;\n}\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.special.Gamma:logGamma(D)D",
            "method_body": "public static double logGamma(double x) {\ndouble ret;\n\nif (Double.isNaN(x) || (x <= 0.0)) {\nret = Double.NaN;\n} else if (x < 0.5) {\nreturn logGamma1p(x) - FastMath.log(x);\n} else if (x <= 2.5) {\nreturn logGamma1p((x - 0.5) - 0.5);\n} else if (x <= 8.0) {\nfinal int n = (int) FastMath.floor(x - 1.5);\ndouble prod = 1.0;\nfor (int i = 1; i <= n; i++) {\nprod *= x - i;\n}\nreturn logGamma1p(x - (n + 1)) + FastMath.log(prod);\n} else {\ndouble sum = lanczos(x);\ndouble tmp = x + LANCZOS_G + .5;\nret = ((x + .5) * FastMath.log(tmp)) - tmp +\nHALF_LOG_2_PI + FastMath.log(sum / x);\n}\n\nreturn ret;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:exp(D)D",
            "method_body": "public static double exp(double x) {\nreturn exp(x, 0.0, null);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D)D",
            "method_body": "public static double log(final double x) {\nreturn log(x, null);\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:floor(D)D",
            "method_body": "public static double floor(double x) {\nlong y;\n\nif (x != x) { // NaN\nreturn x;\n}\n\nif (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\nreturn x;\n}\n\ny = (long) x;\nif (x < 0 && y != x) {\ny--;\n}\n\nif (y == 0) {\nreturn x*y;\n}\n\nreturn y;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:exp(DD[D)D",
            "method_body": "private static double exp(double x, double extra, double[] hiPrec) {\ndouble intPartA;\ndouble intPartB;\nint intVal;\n\n/* Lookup exp(floor(x)).\n* intPartA will have the upper 22 bits, intPartB will have the lower\n* 52 bits.\n*/\nif (x < 0.0) {\nintVal = (int) -x;\n\nif (intVal > 746) {\nif (hiPrec != null) {\nhiPrec[0] = 0.0;\nhiPrec[1] = 0.0;\n}\nreturn 0.0;\n}\n\nif (intVal > 709) {\n/* This will produce a subnormal output */\nfinal double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\nif (hiPrec != null) {\nhiPrec[0] /= 285040095144011776.0;\nhiPrec[1] /= 285040095144011776.0;\n}\nreturn result;\n}\n\nif (intVal == 709) {\n/* exp(1.494140625) is nearly a machine number... */\nfinal double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\nif (hiPrec != null) {\nhiPrec[0] /= 4.455505956692756620;\nhiPrec[1] /= 4.455505956692756620;\n}\nreturn result;\n}\n\nintVal++;\n\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\nintVal = -intVal;\n} else {\nintVal = (int) x;\n\nif (intVal > 709) {\nif (hiPrec != null) {\nhiPrec[0] = Double.POSITIVE_INFINITY;\nhiPrec[1] = 0.0;\n}\nreturn Double.POSITIVE_INFINITY;\n}\n\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n}\n\n/* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n* x and look up the exp function of it.\n* fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n*/\nfinal int intFrac = (int) ((x - intVal) * 1024.0);\nfinal double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\nfinal double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n/* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n* has a value in the range 0 <= epsilon < 2^-10.\n* Do the subtraction from x as the last step to avoid possible loss of percison.\n*/\nfinal double epsilon = x - (intVal + intFrac / 1024.0);\n\n/* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\nfull double precision (52 bits).  Since z < 2^-10, we will have\n62 bits of precision when combined with the contant 1.  This will be\nused in the last addition below to get proper rounding. */\n\n/* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\nis less than 0.5 ULP */\ndouble z = 0.04168701738764507;\nz = z * epsilon + 0.1666666505023083;\nz = z * epsilon + 0.5000000000042687;\nz = z * epsilon + 1.0;\nz = z * epsilon + -3.940510424527919E-20;\n\n/* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\nexpansion.\ntempA is exact since intPartA and intPartB only have 22 bits each.\ntempB will have 52 bits of precision.\n*/\ndouble tempA = intPartA * fracPartA;\ndouble tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n/* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\nimportant.  For accuracy add by increasing size.  tempA is exact and\nmuch larger than the others.  If there are extra bits specified from the\npow() function, use them. */\nfinal double tempC = tempB + tempA;\nfinal double result;\nif (extra != 0.0) {\nresult = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n} else {\nresult = tempC*z + tempB + tempA;\n}\n\nif (hiPrec != null) {\n// If requesting high precision\nhiPrec[0] = tempA;\nhiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n}\n\nreturn result;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D[D)D",
            "method_body": "private static double log(final double x, final double[] hiPrec) {\nif (x==0) { // Handle special case of +0/-0\nreturn Double.NEGATIVE_INFINITY;\n}\nlong bits = Double.doubleToLongBits(x);\n\n/* Handle special cases of negative input, and NaN */\nif ((bits & 0x8000000000000000L) != 0 || x != x) {\nif (x != 0.0) {\nif (hiPrec != null) {\nhiPrec[0] = Double.NaN;\n}\n\nreturn Double.NaN;\n}\n}\n\n/* Handle special cases of Positive infinity. */\nif (x == Double.POSITIVE_INFINITY) {\nif (hiPrec != null) {\nhiPrec[0] = Double.POSITIVE_INFINITY;\n}\n\nreturn Double.POSITIVE_INFINITY;\n}\n\n/* Extract the exponent */\nint exp = (int)(bits >> 52)-1023;\n\nif ((bits & 0x7ff0000000000000L) == 0) {\n// Subnormal!\nif (x == 0) {\n// Zero\nif (hiPrec != null) {\nhiPrec[0] = Double.NEGATIVE_INFINITY;\n}\n\nreturn Double.NEGATIVE_INFINITY;\n}\n\n/* Normalize the subnormal number. */\nbits <<= 1;\nwhile ( (bits & 0x0010000000000000L) == 0) {\n--exp;\nbits <<= 1;\n}\n}\n\n\nif (exp == -1 || exp == 0) {\nif (x < 1.01 && x > 0.99 && hiPrec == null) {\n/* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\npolynomial expansion in higer precision. */\n\n/* Compute x - 1.0 and split it */\ndouble xa = x - 1.0;\ndouble xb = xa - x + 1.0;\ndouble tmp = xa * HEX_40000000;\ndouble aa = xa + tmp - tmp;\ndouble ab = xa - aa;\nxa = aa;\nxb = ab;\n\nfinal double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\ndouble ya = lnCoef_last[0];\ndouble yb = lnCoef_last[1];\n\nfor (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\n/* Add  a = y + lnQuickCoef */\nfinal double[] lnCoef_i = LN_QUICK_COEF[i];\naa = ya + lnCoef_i[0];\nab = yb + lnCoef_i[1];\n/* Split y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n}\n\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\nreturn ya + yb;\n}\n}\n\n// lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\nfinal double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n/*\ndouble epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\nepsilon -= 1.0;\n*/\n\n// y is the most significant 10 bits of the mantissa\n//double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n//double epsilon = (x - y) / y;\nfinal double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\ndouble lnza = 0.0;\ndouble lnzb = 0.0;\n\nif (hiPrec != null) {\n/* split epsilon -> x */\ndouble tmp = epsilon * HEX_40000000;\ndouble aa = epsilon + tmp - tmp;\ndouble ab = epsilon - aa;\ndouble xa = aa;\ndouble xb = ab;\n\n/* Need a more accurate epsilon, so adjust the division. */\nfinal double numer = bits & 0x3ffffffffffL;\nfinal double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\naa = numer - xa*denom - xb * denom;\nxb += aa / denom;\n\n/* Remez polynomial evaluation */\nfinal double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\ndouble ya = lnCoef_last[0];\ndouble yb = lnCoef_last[1];\n\nfor (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\n/* Add  a = y + lnHiPrecCoef */\nfinal double[] lnCoef_i = LN_HI_PREC_COEF[i];\naa = ya + lnCoef_i[0];\nab = yb + lnCoef_i[1];\n/* Split y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n}\n\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n\n/* split, so now lnz = a */\n/*\ntmp = aa * 1073741824.0;\nlnza = aa + tmp - tmp;\nlnzb = aa - lnza + ab;\n*/\nlnza = aa + ab;\nlnzb = -(lnza - aa - ab);\n} else {\n/* High precision not required.  Eval Remez polynomial\nusing standard double precision */\nlnza = -0.16624882440418567;\nlnza = lnza * epsilon + 0.19999954120254515;\nlnza = lnza * epsilon + -0.2499999997677497;\nlnza = lnza * epsilon + 0.3333333333332802;\nlnza = lnza * epsilon + -0.5;\nlnza = lnza * epsilon + 1.0;\nlnza = lnza * epsilon;\n}\n\n/* Relative sizes:\n* lnzb     [0, 2.33E-10]\n* lnm[1]   [0, 1.17E-7]\n* ln2B*exp [0, 1.12E-4]\n* lnza      [0, 9.7E-4]\n* lnm[0]   [0, 0.692]\n* ln2A*exp [0, 709]\n*/\n\n/* Compute the following sum:\n* lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n*/\n\n//return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\ndouble a = LN_2_A*exp;\ndouble b = 0.0;\ndouble c = a+lnm[0];\ndouble d = -(c-a-lnm[0]);\na = c;\nb = b + d;\n\nc = a + lnza;\nd = -(c - a - lnza);\na = c;\nb = b + d;\n\nc = a + LN_2_B*exp;\nd = -(c - a - LN_2_B*exp);\na = c;\nb = b + d;\n\nc = a + lnm[1];\nd = -(c - a - lnm[1]);\na = c;\nb = b + d;\n\nc = a + lnzb;\nd = -(c - a - lnzb);\na = c;\nb = b + d;\n\nif (hiPrec != null) {\nhiPrec[0] = a;\nhiPrec[1] = b;\n}\n\nreturn a + b;\n}",
            "method_id": 25
        }
    ]
}