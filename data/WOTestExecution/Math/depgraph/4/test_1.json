{
    "bug_id": 4,
    "test_id": 1,
    "test_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLineTest.testIntersectionNotIntersecting",
    "test_body": "public void testIntersectionNotIntersecting() throws MathIllegalArgumentException {\nSubLine sub1 = new SubLine(new Vector3D(1, 1, 1), new Vector3D(1.5, 1, 1));\nSubLine sub2 = new SubLine(new Vector3D(2, 3, 0), new Vector3D(2, 3, 0.5));\nAssert.assertNull(sub1.intersection(sub2, true));\nAssert.assertNull(sub1.intersection(sub2, false));\n}\n",
    "stack_trace": "java.lang.NullPointerException\nat org.apache.commons.math3.geometry.euclidean.threed.Line.getAbscissa(Line.java:114)\nat org.apache.commons.math3.geometry.euclidean.threed.Line.toSubSpace(Line.java:129)\nat org.apache.commons.math3.geometry.euclidean.threed.SubLine.intersection(SubLine.java:116)\nat org.apache.commons.math3.geometry.euclidean.threed.SubLineTest.testIntersectionNotIntersecting(SubLineTest.java:160)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:closestPoint(Lorg/apache/commons/math3/geometry/euclidean/threed/Line;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D closestPoint(final Line line) {\n\nfinal double cos = direction.dotProduct(line.direction);\nfinal double n = 1 - cos * cos;\nif (n < Precision.EPSILON) {\n// the lines are parallel\nreturn zero;\n}\n\nfinal Vector3D delta0 = line.zero.subtract(zero);\nfinal double a        = delta0.dotProduct(direction);\nfinal double b        = delta0.dotProduct(line.direction);\n\nreturn new Vector3D(1, zero, (a - b * cos) / n, direction);\n\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine:intersection(Lorg/apache/commons/math3/geometry/euclidean/threed/SubLine;Z)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n// compute the intersection on infinite line\nVector3D v1D = line.intersection(subLine.line);\n\n// check location of point with respect to first sub-line\nLocation loc1 = remainingRegion.checkPoint(line.toSubSpace(v1D));\n\n// check location of point with respect to second sub-line\nLocation loc2 = subLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n\nif (includeEndPoints) {\nreturn ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v1D : null;\n} else {\nreturn ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v1D : null;\n}\n\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:intersection(Lorg/apache/commons/math3/geometry/euclidean/threed/Line;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D intersection(final Line line) {\nfinal Vector3D closest = closestPoint(line);\nreturn line.contains(closest) ? closest : null;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine:buildIntervalSet(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lorg/apache/commons/math3/geometry/euclidean/oned/IntervalsSet;",
            "method_body": "private static IntervalsSet buildIntervalSet(final Vector3D start, final Vector3D end)\nthrows MathIllegalArgumentException {\nfinal Line line = new Line(start, end);\nreturn new IntervalsSet(line.toSubSpace(start).getX(),\nline.toSubSpace(end).getX());\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:linearCombination(DDDDDD)D",
            "method_body": "public static double linearCombination(final double a1, final double b1,\nfinal double a2, final double b2,\nfinal double a3, final double b3) {\n\n// the code below is split in many additions/subtractions that may\n// appear redundant. However, they should NOT be simplified, as they\n// do use IEEE754 floating point arithmetic rounding properties.\n// as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n// The variables naming conventions are that xyzHigh contains the most significant\n// bits of xyz and xyzLow contains its least significant bits. So theoretically\n// xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n// be represented in only one double precision number so we preserve two numbers\n// to hold it as long as we can, combining the high and low order bits together\n// only at the end, after cancellation may have occurred on high order bits\n\n// split a1 and b1 as two 26 bits numbers\nfinal double ca1        = SPLIT_FACTOR * a1;\nfinal double a1High     = ca1 - (ca1 - a1);\nfinal double a1Low      = a1 - a1High;\nfinal double cb1        = SPLIT_FACTOR * b1;\nfinal double b1High     = cb1 - (cb1 - b1);\nfinal double b1Low      = b1 - b1High;\n\n// accurate multiplication a1 * b1\nfinal double prod1High  = a1 * b1;\nfinal double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n// split a2 and b2 as two 26 bits numbers\nfinal double ca2        = SPLIT_FACTOR * a2;\nfinal double a2High     = ca2 - (ca2 - a2);\nfinal double a2Low      = a2 - a2High;\nfinal double cb2        = SPLIT_FACTOR * b2;\nfinal double b2High     = cb2 - (cb2 - b2);\nfinal double b2Low      = b2 - b2High;\n\n// accurate multiplication a2 * b2\nfinal double prod2High  = a2 * b2;\nfinal double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n// split a3 and b3 as two 26 bits numbers\nfinal double ca3        = SPLIT_FACTOR * a3;\nfinal double a3High     = ca3 - (ca3 - a3);\nfinal double a3Low      = a3 - a3High;\nfinal double cb3        = SPLIT_FACTOR * b3;\nfinal double b3High     = cb3 - (cb3 - b3);\nfinal double b3Low      = b3 - b3High;\n\n// accurate multiplication a3 * b3\nfinal double prod3High  = a3 * b3;\nfinal double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n// accurate addition a1 * b1 + a2 * b2\nfinal double s12High    = prod1High + prod2High;\nfinal double s12Prime   = s12High - prod2High;\nfinal double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n// accurate addition a1 * b1 + a2 * b2 + a3 * b3\nfinal double s123High   = s12High + prod3High;\nfinal double s123Prime  = s123High - prod3High;\nfinal double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n// final rounding, s123 may have suffered many cancellations, we try\n// to recover some bits from the extra words we have saved up to now\ndouble result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\nif (Double.isNaN(result)) {\n// either we have split infinite numbers or some coefficients were NaNs,\n// just rely on the naive implementation and let IEEE754 handle this\nresult = a1 * b1 + a2 * b2 + a3 * b3;\n}\n\nreturn result;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:distance(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D",
            "method_body": "public double distance(final Vector3D p) {\nfinal Vector3D d = p.subtract(zero);\nfinal Vector3D n = new Vector3D(1.0, d, -d.dotProduct(direction), direction);\nreturn n.getNorm();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:linearCombination(DDDD)D",
            "method_body": "public static double linearCombination(final double a1, final double b1,\nfinal double a2, final double b2) {\n\n// the code below is split in many additions/subtractions that may\n// appear redundant. However, they should NOT be simplified, as they\n// use IEEE754 floating point arithmetic rounding properties.\n// as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n// The variable naming conventions are that xyzHigh contains the most significant\n// bits of xyz and xyzLow contains its least significant bits. So theoretically\n// xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n// be represented in only one double precision number so we preserve two numbers\n// to hold it as long as we can, combining the high and low order bits together\n// only at the end, after cancellation may have occurred on high order bits\n\n// split a1 and b1 as two 26 bits numbers\nfinal double ca1        = SPLIT_FACTOR * a1;\nfinal double a1High     = ca1 - (ca1 - a1);\nfinal double a1Low      = a1 - a1High;\nfinal double cb1        = SPLIT_FACTOR * b1;\nfinal double b1High     = cb1 - (cb1 - b1);\nfinal double b1Low      = b1 - b1High;\n\n// accurate multiplication a1 * b1\nfinal double prod1High  = a1 * b1;\nfinal double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n// split a2 and b2 as two 26 bits numbers\nfinal double ca2        = SPLIT_FACTOR * a2;\nfinal double a2High     = ca2 - (ca2 - a2);\nfinal double a2Low      = a2 - a2High;\nfinal double cb2        = SPLIT_FACTOR * b2;\nfinal double b2High     = cb2 - (cb2 - b2);\nfinal double b2Low      = b2 - b2High;\n\n// accurate multiplication a2 * b2\nfinal double prod2High  = a2 * b2;\nfinal double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n// accurate addition a1 * b1 + a2 * b2\nfinal double s12High    = prod1High + prod2High;\nfinal double s12Prime   = s12High - prod2High;\nfinal double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n// final rounding, s12 may have suffered many cancellations, we try\n// to recover some bits from the extra words we have saved up to now\ndouble result = s12High + (prod1Low + prod2Low + s12Low);\n\nif (Double.isNaN(result)) {\n// either we have split infinite numbers or some coefficients were NaNs,\n// just rely on the naive implementation and let IEEE754 handle this\nresult = a1 * b1 + a2 * b2;\n}\n\nreturn result;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:toSubSpace(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/euclidean/oned/Vector1D;",
            "method_body": "public Vector1D toSubSpace(final Vector<Euclidean3D> point) {\nreturn new Vector1D(getAbscissa((Vector3D) point));\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:getAbscissa(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)D",
            "method_body": "public double getAbscissa(final Vector3D point) {\nreturn point.subtract(zero).dotProduct(direction);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:contains(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Z",
            "method_body": "public boolean contains(final Vector3D p) {\nreturn distance(p) < 1.0e-10;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:subtract(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D subtract(final Vector<Euclidean3D> v) {\nfinal Vector3D v3 = (Vector3D) v;\nreturn new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:dotProduct(Lorg/apache/commons/math3/geometry/Vector;)D",
            "method_body": "public double dotProduct(final Vector<Euclidean3D> v) {\nfinal Vector3D v3 = (Vector3D) v;\nreturn MathArrays.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:getNorm()D",
            "method_body": "public double getNorm() {\n// there are no cancellation problems here, so we use the straightforward formula\nreturn FastMath.sqrt (x * x + y * y + z * z);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:<init>(DDD)V",
            "method_body": "public Vector3D(double x, double y, double z) {\nthis.x = x;\nthis.y = y;\nthis.z = z;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:<init>(DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Vector3D(double a, Vector3D u) {\nthis.x = a * u.x;\nthis.y = a * u.y;\nthis.z = a * u.z;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:<init>(DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\nthis.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x);\nthis.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y);\nthis.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D:<init>(D)V",
            "method_body": "public Vector1D(double x) {\nthis.x = x;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine:<init>(Lorg/apache/commons/math3/geometry/euclidean/threed/Line;Lorg/apache/commons/math3/geometry/euclidean/oned/IntervalsSet;)V",
            "method_body": "public SubLine(final Line line, final IntervalsSet remainingRegion) {\nthis.line            = line;\nthis.remainingRegion = remainingRegion;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine:<init>(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public SubLine(final Vector3D start, final Vector3D end)\nthrows MathIllegalArgumentException {\nthis(new Line(start, end), buildIntervalSet(start, end));\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:<init>(DD)V",
            "method_body": "public IntervalsSet(final double lower, final double upper) {\nsuper(buildTree(lower, upper));\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:buildTree(DD)Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\nif (Double.isInfinite(lower) && (lower < 0)) {\nif (Double.isInfinite(upper) && (upper > 0)) {\n// the tree must cover the whole real line\nreturn new BSPTree<Euclidean1D>(Boolean.TRUE);\n}\n// the tree must be open on the negative infinity side\nfinal SubHyperplane<Euclidean1D> upperCut =\nnew OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\nreturn new BSPTree<Euclidean1D>(upperCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(Boolean.TRUE),\nnull);\n}\nfinal SubHyperplane<Euclidean1D> lowerCut =\nnew OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\nif (Double.isInfinite(upper) && (upper > 0)) {\n// the tree must be open on the positive infinity side\nreturn new BSPTree<Euclidean1D>(lowerCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(Boolean.TRUE),\nnull);\n}\n\n// the tree must be bounded on the two sides\nfinal SubHyperplane<Euclidean1D> upperCut =\nnew OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\nreturn new BSPTree<Euclidean1D>(lowerCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(upperCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(Boolean.TRUE),\nnull),\nnull);\n\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint:<init>(Lorg/apache/commons/math3/geometry/euclidean/oned/Vector1D;Z)V",
            "method_body": "public OrientedPoint(final Vector1D location, final boolean direct) {\nthis.location = location;\nthis.direct   = direct;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint:wholeHyperplane()Lorg/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint;",
            "method_body": "public SubOrientedPoint wholeHyperplane() {\nreturn new SubOrientedPoint(this, null);\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint:<init>(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;Lorg/apache/commons/math3/geometry/partitioning/Region;)V",
            "method_body": "public SubOrientedPoint(final Hyperplane<Euclidean1D> hyperplane,\nfinal Region<Euclidean1D> remainingRegion) {\nsuper(hyperplane, remainingRegion);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:<init>(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Ljava/lang/Object;)V",
            "method_body": "public BSPTree(final SubHyperplane<S> cut, final BSPTree<S> plus, final BSPTree<S> minus,\nfinal Object attribute) {\nthis.cut       = cut;\nthis.plus      = plus;\nthis.minus     = minus;\nthis.parent    = null;\nthis.attribute = attribute;\nplus.parent    = this;\nminus.parent   = this;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:<init>(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)V",
            "method_body": "protected AbstractRegion(final BSPTree<S> tree) {\nthis.tree = tree;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:<init>(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;Lorg/apache/commons/math3/geometry/partitioning/Region;)V",
            "method_body": "protected AbstractSubHyperplane(final Hyperplane<S> hyperplane,\nfinal Region<T> remainingRegion) {\nthis.hyperplane      = hyperplane;\nthis.remainingRegion = remainingRegion;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:<init>(Ljava/lang/Object;)V",
            "method_body": "public BSPTree(final Object attribute) {\ncut    = null;\nplus   = null;\nminus  = null;\nparent = null;\nthis.attribute = attribute;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D:getX()D",
            "method_body": "public double getX() {\nreturn x;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:<init>(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Line(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\nreset(p1, p2);\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:reset(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public void reset(final Vector3D p1, final Vector3D p2) throws MathIllegalArgumentException {\nfinal Vector3D delta = p2.subtract(p1);\nfinal double norm2 = delta.getNormSq();\nif (norm2 == 0.0) {\nthrow new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n}\nthis.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\nzero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:getNormSq()D",
            "method_body": "public double getNormSq() {\n// there are no cancellation problems here, so we use the straightforward formula\nreturn x * x + y * y + z * z;\n}",
            "method_id": 32
        }
    ]
}