{
    "bug_id": 24,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.optimization.univariate.BrentOptimizerTest.testMath855",
    "test_body": "public void testMath855() {\nfinal double minSin = 3 * Math.PI / 2;\nfinal double offset = 1e-8;\nfinal double delta = 1e-7;\nfinal UnivariateFunction f1 = new Sin();\nfinal UnivariateFunction f2 = new StepFunction(new double[] { minSin, minSin + offset, minSin + 5 * offset },\nnew double[] { 0, -1, 0 });\nfinal UnivariateFunction f = FunctionUtils.add(f1, f2);\nfinal UnivariateOptimizer optimizer = new BrentOptimizer(1e-8, 1e-100);\nfinal UnivariatePointValuePair result\n= optimizer.optimize(200, f, GoalType.MINIMIZE, minSin - 6.789 * delta, minSin + 9.876 * delta);\nfinal int numEval = optimizer.getEvaluations();\nfinal double sol = result.getPoint();\nfinal double expected = 4.712389027602411;\n// System.out.println(\"min=\" + (minSin + offset) + \" f=\" + f.value(minSin + offset));\n// System.out.println(\"sol=\" + sol + \" f=\" + f.value(sol));\n// System.out.println(\"exp=\" + expected + \" f=\" + f.value(expected));\nAssert.assertTrue(\"Best point not reported\", f.value(sol) <= f.value(expected));\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: Best point not reported\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.apache.commons.math3.optimization.univariate.BrentOptimizerTest.testMath855(BrentOptimizerTest.java:213)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.analysis.function.StepFunction:<init>([D[D)V",
            "method_body": "public StepFunction(double[] x,\ndouble[] y)\nthrows NullArgumentException,\nNoDataException,\nDimensionMismatchException {\nif (x == null ||\ny == null) {\nthrow new NullArgumentException();\n}\nif (x.length == 0 ||\ny.length == 0) {\nthrow new NoDataException();\n}\nif (y.length != x.length) {\nthrow new DimensionMismatchException(y.length, x.length);\n}\nMathArrays.checkOrder(x);\n\nabscissa = MathArrays.copyOf(x);\nordinate = MathArrays.copyOf(y);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:optimize(ILorg/apache/commons/math3/analysis/UnivariateFunction;Lorg/apache/commons/math3/optimization/GoalType;DDD)Lorg/apache/commons/math3/optimization/univariate/UnivariatePointValuePair;",
            "method_body": "public UnivariatePointValuePair optimize(int maxEval, UnivariateFunction f,\nGoalType goalType,\ndouble min, double max,\ndouble startValue) {\n// Checks.\nif (f == null) {\nthrow new NullArgumentException();\n}\nif (goalType == null) {\nthrow new NullArgumentException();\n}\n\n// Reset.\nsearchMin = min;\nsearchMax = max;\nsearchStart = startValue;\ngoal = goalType;\nfunction = f;\nevaluations.setMaximalCount(maxEval);\nevaluations.resetCount();\n\n// Perform computation.\nreturn doOptimize();\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xa;\ndouble xb = 0.0;\n\n/* Take absolute value of the input */\nxa = x;\nif (x < 0) {\nnegative = true;\nxa = -xa;\n}\n\n/* Check for zero and negative zero */\nif (xa == 0.0) {\nlong bits = Double.doubleToLongBits(x);\nif (bits < 0) {\nreturn -0.0;\n}\nreturn 0.0;\n}\n\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nreturn Double.NaN;\n}\n\n/* Perform any argument reduction */\nif (xa > 3294198.0) {\n// PI * (2**20)\n// Argument too big for CodyWaite reduction.  Must use\n// PayneHanek.\ndouble reduceResults[] = new double[3];\nreducePayneHanek(xa, reduceResults);\nquadrant = ((int) reduceResults[0]) & 3;\nxa = reduceResults[1];\nxb = reduceResults[2];\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa, xb);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\n}\n\nif (negative) {\nquadrant ^= 2;  // Flip bit 1\n}\n\nswitch (quadrant) {\ncase 0:\nreturn sinQ(xa, xb);\ncase 1:\nreturn cosQ(xa, xb);\ncase 2:\nreturn -sinQ(xa, xb);\ncase 3:\nreturn -cosQ(xa, xb);\ndefault:\nreturn Double.NaN;\n}\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\n\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\n\nreturn p;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.FunctionUtils$4:<init>([Lorg/apache/commons/math3/analysis/UnivariateFunction;)V",
            "method_body": "public static UnivariateFunction add(final UnivariateFunction ... f) {\nreturn new UnivariateFunction() {\ndouble r = f[0].value(x);\nfor (int i = 1; i < f.length; i++) {\nr += f[i].value(x);\nreturn r;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optimization/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<UnivariatePointValuePair> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:getMax()D",
            "method_body": "public double getMax() {\nreturn searchMax;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:getRemB()D",
            "method_body": "double getRemB() {\nreturn finalRemB;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max,\nMaxCountExceededCallback cb) {\nif (cb == null){\nthrow new NullArgumentException();\n}\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.function.Sin:value(D)D",
            "method_body": "public double value(double x) {\nreturn FastMath.sin(x);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polySine(D)D",
            "method_body": "private static double polySine(final double x)\n{\ndouble x2 = x*x;\n\ndouble p = 2.7553817452272217E-6;\np = p * x2 + -1.9841269659586505E-4;\np = p * x2 + 0.008333333333329196;\np = p * x2 + -0.16666666666666666;\n//p *= x2;\n//p *= x;\np = p * x2 * x;\n\nreturn p;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sinQ(DD)D",
            "method_body": "private static double sinQ(double xa, double xb) {\nint idx = (int) ((xa * 8.0) + 0.5);\nfinal double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n// Table lookups\nfinal double sintA = SINE_TABLE_A[idx];\nfinal double sintB = SINE_TABLE_B[idx];\nfinal double costA = COSINE_TABLE_A[idx];\nfinal double costB = COSINE_TABLE_B[idx];\n\n// Polynomial eval of sin(epsilon), cos(epsilon)\ndouble sinEpsA = epsilon;\ndouble sinEpsB = polySine(epsilon);\nfinal double cosEpsA = 1.0;\nfinal double cosEpsB = polyCosine(epsilon);\n\n// Split epsilon   xa + xb = x\nfinal double temp = sinEpsA * HEX_40000000;\ndouble temp2 = (sinEpsA + temp) - temp;\nsinEpsB +=  sinEpsA - temp2;\nsinEpsA = temp2;\n\n/* Compute sin(x) by angle addition formula */\ndouble result;\n\n/* Compute the following sum:\n*\n* result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n*          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n*\n* Ranges of elements\n*\n* xxxtA   0            PI/2\n* xxxtB   -1.5e-9      1.5e-9\n* sinEpsA -0.0625      0.0625\n* sinEpsB -6e-11       6e-11\n* cosEpsA  1.0\n* cosEpsB  0           -0.0625\n*\n*/\n\n//result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n//          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n//result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n//result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\ndouble a = 0;\ndouble b = 0;\n\ndouble t = sintA;\ndouble c = a + t;\ndouble d = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA * sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nb = b + sintA * cosEpsB + costA * sinEpsB;\n/*\nt = sintA*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nb = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n/*\nt = sintB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = sintB*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nif (xb != 0.0) {\nt = ((costA + costB) * (cosEpsA + cosEpsB) -\n(sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n}\n\nresult = a + b;\n\nreturn result;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:getEvaluations()I",
            "method_body": "public int getEvaluations() {\nreturn evaluations.getCount();\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() {\nif (++count > maximalCount) {\nmaxCountCallback.trigger(maximalCount);\n}\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:checkOrder([DLorg/apache/commons/math3/util/MathArrays$OrderDirection;ZZ)Z",
            "method_body": "public static boolean checkOrder(double[] val, OrderDirection dir,\nboolean strict, boolean abort) {\ndouble previous = val[0];\nfinal int max = val.length;\n\nint index;\nITEM:\nfor (index = 1; index < max; index++) {\nswitch (dir) {\ncase INCREASING:\nif (strict) {\nif (val[index] <= previous) {\nbreak ITEM;\n}\n} else {\nif (val[index] < previous) {\nbreak ITEM;\n}\n}\nbreak;\ncase DECREASING:\nif (strict) {\nif (val[index] >= previous) {\nbreak ITEM;\n}\n} else {\nif (val[index] > previous) {\nbreak ITEM;\n}\n}\nbreak;\ndefault:\n// Should never happen.\nthrow new MathInternalError();\n}\n\nprevious = val[index];\n}\n\nif (index == max) {\n// Loop completed.\nreturn true;\n}\n\n// Loop early exit means wrong ordering.\nif (abort) {\nthrow new NonMonotonicSequenceException(val[index], previous, index, dir, strict);\n} else {\nreturn false;\n}\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:getRemA()D",
            "method_body": "double getRemA() {\nreturn finalRemA;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.function.StepFunction:value(D)D",
            "method_body": "public double value(double x) {\nint index = Arrays.binarySearch(abscissa, x);\ndouble fx = 0;\n\nif (index < -1) {\n// \"x\" is between \"abscissa[-index-2]\" and \"abscissa[-index-1]\".\nfx = ordinate[-index-2];\n} else if (index >= 0) {\n// \"x\" is exactly \"abscissa[index]\".\nfx = ordinate[index];\n} else {\n// Otherwise, \"x\" is smaller than the first value in \"abscissa\"\n// (hence the returned value should be \"ordinate[0]\").\nfx = ordinate[0];\n}\n\nreturn fx;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.FunctionUtils:add([Lorg/apache/commons/math3/analysis/UnivariateFunction;)Lorg/apache/commons/math3/analysis/UnivariateFunction;",
            "method_body": "public static UnivariateFunction add(final UnivariateFunction ... f) {\nreturn new UnivariateFunction() {\n/** {@inheritDoc} */\npublic double value(double x) {\ndouble r = f[0].value(x);\nfor (int i = 1; i < f.length; i++) {\nr += f[i].value(x);\n}\nreturn r;\n}\n};\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:computeObjectiveValue(D)D",
            "method_body": "protected double computeObjectiveValue(double point) {\ntry {\nevaluations.incrementCount();\n} catch (MaxCountExceededException e) {\nthrow new TooManyEvaluationsException(e.getMax());\n}\nreturn function.value(point);\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(J)J",
            "method_body": "public static long abs(final long x) {\nreturn (x < 0l) ? -x : x;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:checkOrder([DLorg/apache/commons/math3/util/MathArrays$OrderDirection;Z)V",
            "method_body": "public static void checkOrder(double[] val, OrderDirection dir,\nboolean strict) {\ncheckOrder(val, dir, strict, true);\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair:<init>(DD)V",
            "method_body": "public UnivariatePointValuePair(final double point,\nfinal double value) {\nthis.point = point;\nthis.value = value;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DDI)Z",
            "method_body": "public static boolean equals(double x, double y, int maxUlps) {\nlong xInt = Double.doubleToLongBits(x);\nlong yInt = Double.doubleToLongBits(y);\n\n// Make lexicographically ordered as a two's-complement integer.\nif (xInt < 0) {\nxInt = SGN_MASK - xInt;\n}\nif (yInt < 0) {\nyInt = SGN_MASK - yInt;\n}\n\nfinal boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\nreturn isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:<init>(DD)V",
            "method_body": "CodyWaite(double xa,\ndouble xb) {\n// Estimate k.\n//k = (int)(xa / 1.5707963267948966);\nint k = (int)(xa * 0.6366197723675814);\n\n// Compute remainder.\ndouble remA;\ndouble remB;\nwhile (true) {\ndouble a = -k * 1.570796251296997;\nremA = xa + a;\nremB = -(remA - xa - a);\n\na = -k * 7.549789948768648E-8;\ndouble b = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\na = -k * 6.123233995736766E-17;\nb = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\nif (remA > 0) {\nbreak;\n}\n\n// Remainder is negative, so decrement k and try again.\n// This should only happen if the input is very close\n// to an even multiple of pi/2.\n--k;\n}\n\nthis.finalK = k;\nthis.finalRemA = remA;\nthis.finalRemB = remB;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:getGoalType()Lorg/apache/commons/math3/optimization/GoalType;",
            "method_body": "public GoalType getGoalType() {\nreturn goal;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:min(II)I",
            "method_body": "public static int min(final int a, final int b) {\nreturn (a <= b) ? a : b;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:getStartValue()D",
            "method_body": "public double getStartValue() {\nreturn searchStart;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:getMin()D",
            "method_body": "public double getMin() {\nreturn searchMin;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BrentOptimizer:<init>(DDLorg/apache/commons/math3/optimization/ConvergenceChecker;)V",
            "method_body": "public BrentOptimizer(double rel,\ndouble abs,\nConvergenceChecker<UnivariatePointValuePair> checker) {\nsuper(checker);\n\nif (rel < MIN_RELATIVE_TOLERANCE) {\nthrow new NumberIsTooSmallException(rel, MIN_RELATIVE_TOLERANCE, true);\n}\nif (abs <= 0) {\nthrow new NotStrictlyPositiveException(abs);\n}\n\nrelativeThreshold = rel;\nabsoluteThreshold = abs;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cosQ(DD)D",
            "method_body": "private static double cosQ(double xa, double xb) {\nfinal double pi2a = 1.5707963267948966;\nfinal double pi2b = 6.123233995736766E-17;\n\nfinal double a = pi2a - xa;\ndouble b = -(a - pi2a + xa);\nb += pi2b - xb;\n\nreturn sinQ(a, b);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:optimize(ILorg/apache/commons/math3/analysis/UnivariateFunction;Lorg/apache/commons/math3/optimization/GoalType;DD)Lorg/apache/commons/math3/optimization/univariate/UnivariatePointValuePair;",
            "method_body": "public UnivariatePointValuePair optimize(int maxEval,\nUnivariateFunction f,\nGoalType goalType,\ndouble min, double max){\nreturn optimize(maxEval, f, goalType, min, max, min + 0.5 * (max - min));\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath$CodyWaite:getK()I",
            "method_body": "int getK() {\nreturn finalK;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:copyOf([DI)[D",
            "method_body": "public static double[] copyOf(double[] source, int len) {\nfinal double[] output = new double[len];\nSystem.arraycopy(source, 0, output, 0, FastMath.min(len, source.length));\nreturn output;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DD)Z",
            "method_body": "public static boolean equals(double x, double y) {\nreturn equals(x, y, 1);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.UnivariatePointValuePair:getPoint()D",
            "method_body": "public double getPoint() {\nreturn point;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BaseAbstractUnivariateOptimizer:<init>(Lorg/apache/commons/math3/optimization/ConvergenceChecker;)V",
            "method_body": "protected BaseAbstractUnivariateOptimizer(ConvergenceChecker<UnivariatePointValuePair> checker) {\nthis.checker = checker;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:getCount()I",
            "method_body": "public int getCount() {\nreturn count;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.FunctionUtils$4:value(D)D",
            "method_body": "public static UnivariateFunction add(final UnivariateFunction ... f) {\nreturn new UnivariateFunction() {\n/** {@inheritDoc} */\npublic double value(double x) {\ndouble r = f[0].value(x);\nfor (int i = 1; i < f.length; i++) {\nr += f[i].value(x);\n}\nreturn r;\n}\n};\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(I)V",
            "method_body": "public Incrementor(int max) {\nthis(max,\nnew MaxCountExceededCallback() {\n/** {@inheritDoc} */\npublic void trigger(int max) {\nthrow new MaxCountExceededException(max);\n}\n});\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>()V",
            "method_body": "public Incrementor() {\nthis(0);\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BrentOptimizer:<init>(DD)V",
            "method_body": "public BrentOptimizer(double rel,\ndouble abs) {\nthis(rel, abs, null);\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:copyOf([D)[D",
            "method_body": "public static double[] copyOf(double[] source) {\nreturn copyOf(source, source.length);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:checkOrder([D)V",
            "method_body": "public static void checkOrder(double[] val) {\ncheckOrder(val, OrderDirection.INCREASING, true);\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.univariate.BrentOptimizer:doOptimize()Lorg/apache/commons/math3/optimization/univariate/UnivariatePointValuePair;",
            "method_body": "protected UnivariatePointValuePair doOptimize() {\nfinal boolean isMinim = getGoalType() == GoalType.MINIMIZE;\nfinal double lo = getMin();\nfinal double mid = getStartValue();\nfinal double hi = getMax();\n\n// Optional additional convergence criteria.\nfinal ConvergenceChecker<UnivariatePointValuePair> checker\n= getConvergenceChecker();\n\ndouble a;\ndouble b;\nif (lo < hi) {\na = lo;\nb = hi;\n} else {\na = hi;\nb = lo;\n}\n\ndouble x = mid;\ndouble v = x;\ndouble w = x;\ndouble d = 0;\ndouble e = 0;\ndouble fx = computeObjectiveValue(x);\nif (!isMinim) {\nfx = -fx;\n}\ndouble fv = fx;\ndouble fw = fx;\n\nUnivariatePointValuePair previous = null;\nUnivariatePointValuePair current\n= new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\nint iter = 0;\nwhile (true) {\nfinal double m = 0.5 * (a + b);\nfinal double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\nfinal double tol2 = 2 * tol1;\n\n// Default stopping criterion.\nfinal boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\nif (!stop) {\ndouble p = 0;\ndouble q = 0;\ndouble r = 0;\ndouble u = 0;\n\nif (FastMath.abs(e) > tol1) { // Fit parabola.\nr = (x - w) * (fx - fv);\nq = (x - v) * (fx - fw);\np = (x - v) * q - (x - w) * r;\nq = 2 * (q - r);\n\nif (q > 0) {\np = -p;\n} else {\nq = -q;\n}\n\nr = e;\ne = d;\n\nif (p > q * (a - x) &&\np < q * (b - x) &&\nFastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n// Parabolic interpolation step.\nd = p / q;\nu = x + d;\n\n// f must not be evaluated too close to a or b.\nif (u - a < tol2 || b - u < tol2) {\nif (x <= m) {\nd = tol1;\n} else {\nd = -tol1;\n}\n}\n} else {\n// Golden section step.\nif (x < m) {\ne = b - x;\n} else {\ne = a - x;\n}\nd = GOLDEN_SECTION * e;\n}\n} else {\n// Golden section step.\nif (x < m) {\ne = b - x;\n} else {\ne = a - x;\n}\nd = GOLDEN_SECTION * e;\n}\n\n// Update by at least \"tol1\".\nif (FastMath.abs(d) < tol1) {\nif (d >= 0) {\nu = x + tol1;\n} else {\nu = x - tol1;\n}\n} else {\nu = x + d;\n}\n\ndouble fu = computeObjectiveValue(u);\nif (!isMinim) {\nfu = -fu;\n}\n\n// User-defined convergence checker.\nprevious = current;\ncurrent = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\nif (checker != null) {\nif (checker.converged(iter, previous, current)) {\nreturn current;\n}\n}\n\n// Update a, b, v, w and x.\nif (fu <= fx) {\nif (u < x) {\nb = x;\n} else {\na = x;\n}\nv = w;\nfv = fw;\nw = x;\nfw = fx;\nx = u;\nfx = fu;\n} else {\nif (u < x) {\na = u;\n} else {\nb = u;\n}\nif (fu <= fw ||\nPrecision.equals(w, x)) {\nv = w;\nfv = fw;\nw = u;\nfw = fu;\n} else if (fu <= fv ||\nPrecision.equals(v, x) ||\nPrecision.equals(v, w)) {\nv = u;\nfv = fu;\n}\n}\n} else { // Default termination (Brent's criterion).\nreturn current;\n}\n++iter;\n}\n}",
            "method_id": 46
        }
    ]
}