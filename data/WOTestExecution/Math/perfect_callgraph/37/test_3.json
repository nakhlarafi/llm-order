{
    "bug_id": 37,
    "test_id": 3,
    "test_name": "org.apache.commons.math.complex.ComplexTest.testTan",
    "test_body": "public void testTan() {\nComplex z = new Complex(3, 4);\nComplex expected = new Complex(-0.000187346, 0.999356);\nTestUtils.assertEquals(expected, z.tan(), 1.0e-5);\n/* Check that no overflow occurs (MATH-722) */\nComplex actual = new Complex(3.0, 1E10).tan();\nexpected = new Complex(0, 1);\nTestUtils.assertEquals(expected, actual, 1.0e-5);\nactual = new Complex(3.0, -1E10).tan();\nexpected = new Complex(0, -1);\nTestUtils.assertEquals(expected, actual, 1.0e-5);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<1.0> but was:<NaN>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math.TestUtils.assertEquals(TestUtils.java:95)\nat org.apache.commons.math.complex.ComplexTest.testTan(ComplexTest.java:1002)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.complex.Complex:tan()Lorg/apache/commons/math/complex/Complex;",
            "method_body": "public Complex tan() {\nif (isNaN) {\nreturn NaN;\n}\n\ndouble real2 = 2.0 * real;\ndouble imaginary2 = 2.0 * imaginary;\ndouble d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n\nreturn createComplex(FastMath.sin(real2) / d,\nFastMath.sinh(imaginary2) / d);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:<init>(DD)V",
            "method_body": "public Complex(double real, double imaginary) {\nthis.real = real;\nthis.imaginary = imaginary;\n\nisNaN = Double.isNaN(real) || Double.isNaN(imaginary);\nisInfinite = !isNaN &&\n(Double.isInfinite(real) || Double.isInfinite(imaginary));\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:cos(D)D",
            "method_body": "public static double cos(double x) {\nint quadrant = 0;\n\n/* Take absolute value of the input */\ndouble xa = x;\nif (x < 0) {\nxa = -xa;\n}\n\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nreturn Double.NaN;\n}\n\n/* Perform any argument reduction */\ndouble xb = 0;\nif (xa > 3294198.0) {\n// PI * (2**20)\n// Argument too big for CodyWaite reduction.  Must use\n// PayneHanek.\ndouble reduceResults[] = new double[3];\nreducePayneHanek(xa, reduceResults);\nquadrant = ((int) reduceResults[0]) & 3;\nxa = reduceResults[1];\nxb = reduceResults[2];\n} else if (xa > 1.5707963267948966) {\n/* Inline the Cody/Waite reduction for performance */\n\n// Estimate k\n//k = (int)(xa / 1.5707963267948966);\nint k = (int)(xa * 0.6366197723675814);\n\n// Compute remainder\ndouble remA;\ndouble remB;\nwhile (true) {\ndouble a = -k * 1.570796251296997;\nremA = xa + a;\nremB = -(remA - xa - a);\n\na = -k * 7.549789948768648E-8;\ndouble b = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\na = -k * 6.123233995736766E-17;\nb = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\nif (remA > 0.0) {\nbreak;\n}\n\n// Remainder is negative, so decrement k and try again.\n// This should only happen if the input is very close\n// to an even multiple of pi/2\nk--;\n}\nquadrant = k & 3;\nxa = remA;\nxb = remB;\n}\n\n//if (negative)\n//  quadrant = (quadrant + 2) % 4;\n\nswitch (quadrant) {\ncase 0:\nreturn cosQ(xa, xb);\ncase 1:\nreturn -sinQ(xa, xb);\ncase 2:\nreturn -cosQ(xa, xb);\ncase 3:\nreturn sinQ(xa, xb);\ndefault:\nreturn Double.NaN;\n}\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:cosQ(DD)D",
            "method_body": "private static double cosQ(double xa, double xb) {\nfinal double pi2a = 1.5707963267948966;\nfinal double pi2b = 6.123233995736766E-17;\n\nfinal double a = pi2a - xa;\ndouble b = -(a - pi2a + xa);\nb += pi2b - xb;\n\nreturn sinQ(a, b);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:sinQ(DD)D",
            "method_body": "private static double sinQ(double xa, double xb) {\nint idx = (int) ((xa * 8.0) + 0.5);\nfinal double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n// Table lookups\nfinal double sintA = SINE_TABLE_A[idx];\nfinal double sintB = SINE_TABLE_B[idx];\nfinal double costA = COSINE_TABLE_A[idx];\nfinal double costB = COSINE_TABLE_B[idx];\n\n// Polynomial eval of sin(epsilon), cos(epsilon)\ndouble sinEpsA = epsilon;\ndouble sinEpsB = polySine(epsilon);\nfinal double cosEpsA = 1.0;\nfinal double cosEpsB = polyCosine(epsilon);\n\n// Split epsilon   xa + xb = x\nfinal double temp = sinEpsA * HEX_40000000;\ndouble temp2 = (sinEpsA + temp) - temp;\nsinEpsB +=  sinEpsA - temp2;\nsinEpsA = temp2;\n\n/* Compute sin(x) by angle addition formula */\ndouble result;\n\n/* Compute the following sum:\n*\n* result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n*          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n*\n* Ranges of elements\n*\n* xxxtA   0            PI/2\n* xxxtB   -1.5e-9      1.5e-9\n* sinEpsA -0.0625      0.0625\n* sinEpsB -6e-11       6e-11\n* cosEpsA  1.0\n* cosEpsB  0           -0.0625\n*\n*/\n\n//result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n//          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n//result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n//result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\ndouble a = 0;\ndouble b = 0;\n\ndouble t = sintA;\ndouble c = a + t;\ndouble d = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA * sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nb = b + sintA * cosEpsB + costA * sinEpsB;\n/*\nt = sintA*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nb = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n/*\nt = sintB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = sintB*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nif (xb != 0.0) {\nt = ((costA + costB) * (cosEpsA + cosEpsB) -\n(sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n}\n\nresult = a + b;\n\nreturn result;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:cosh(D)D",
            "method_body": "public static double cosh(double x) {\nif (x != x) {\nreturn x;\n}\n\n// cosh[z] = (exp(z) + exp(-z))/2\n\n// for numbers with magnitude 20 or so,\n// exp(-z) can be ignored in comparison with exp(z)\n\nif (x > 20.0) {\nreturn exp(x)/2.0;\n}\n\nif (x < -20) {\nreturn exp(-x)/2.0;\n}\n\ndouble hiPrec[] = new double[2];\nif (x < 0.0) {\nx = -x;\n}\nexp(x, 0.0, hiPrec);\n\ndouble ya = hiPrec[0] + hiPrec[1];\ndouble yb = -(ya - hiPrec[0] - hiPrec[1]);\n\ndouble temp = ya * HEX_40000000;\ndouble yaa = ya + temp - temp;\ndouble yab = ya - yaa;\n\n// recip = 1/y\ndouble recip = 1.0/ya;\ntemp = recip * HEX_40000000;\ndouble recipa = recip + temp - temp;\ndouble recipb = recip - recipa;\n\n// Correct for rounding in division\nrecipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n// Account for yb\nrecipb += -yb * recip * recip;\n\n// y = y + 1/y\ntemp = ya + recipa;\nyb += -(temp - ya - recipa);\nya = temp;\ntemp = ya + recipb;\nyb += -(temp - ya - recipb);\nya = temp;\n\ndouble result = ya + yb;\nresult *= 0.5;\nreturn result;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:exp(D)D",
            "method_body": "public static double exp(double x) {\nreturn exp(x, 0.0, null);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:exp(DD[D)D",
            "method_body": "private static double exp(double x, double extra, double[] hiPrec) {\ndouble intPartA;\ndouble intPartB;\nint intVal;\n\n/* Lookup exp(floor(x)).\n* intPartA will have the upper 22 bits, intPartB will have the lower\n* 52 bits.\n*/\nif (x < 0.0) {\nintVal = (int) -x;\n\nif (intVal > 746) {\nif (hiPrec != null) {\nhiPrec[0] = 0.0;\nhiPrec[1] = 0.0;\n}\nreturn 0.0;\n}\n\nif (intVal > 709) {\n/* This will produce a subnormal output */\nfinal double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\nif (hiPrec != null) {\nhiPrec[0] /= 285040095144011776.0;\nhiPrec[1] /= 285040095144011776.0;\n}\nreturn result;\n}\n\nif (intVal == 709) {\n/* exp(1.494140625) is nearly a machine number... */\nfinal double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\nif (hiPrec != null) {\nhiPrec[0] /= 4.455505956692756620;\nhiPrec[1] /= 4.455505956692756620;\n}\nreturn result;\n}\n\nintVal++;\n\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\nintVal = -intVal;\n} else {\nintVal = (int) x;\n\nif (intVal > 709) {\nif (hiPrec != null) {\nhiPrec[0] = Double.POSITIVE_INFINITY;\nhiPrec[1] = 0.0;\n}\nreturn Double.POSITIVE_INFINITY;\n}\n\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n}\n\n/* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n* x and look up the exp function of it.\n* fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n*/\nfinal int intFrac = (int) ((x - intVal) * 1024.0);\nfinal double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\nfinal double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n/* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n* has a value in the range 0 <= epsilon < 2^-10.\n* Do the subtraction from x as the last step to avoid possible loss of percison.\n*/\nfinal double epsilon = x - (intVal + intFrac / 1024.0);\n\n/* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\nfull double precision (52 bits).  Since z < 2^-10, we will have\n62 bits of precision when combined with the contant 1.  This will be\nused in the last addition below to get proper rounding. */\n\n/* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\nis less than 0.5 ULP */\ndouble z = 0.04168701738764507;\nz = z * epsilon + 0.1666666505023083;\nz = z * epsilon + 0.5000000000042687;\nz = z * epsilon + 1.0;\nz = z * epsilon + -3.940510424527919E-20;\n\n/* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\nexpansion.\ntempA is exact since intPartA and intPartB only have 22 bits each.\ntempB will have 52 bits of precision.\n*/\ndouble tempA = intPartA * fracPartA;\ndouble tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n/* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\nimportant.  For accuracy add by increasing size.  tempA is exact and\nmuch larger than the others.  If there are extra bits specified from the\npow() function, use them. */\nfinal double tempC = tempB + tempA;\nfinal double result;\nif (extra != 0.0) {\nresult = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n} else {\nresult = tempC*z + tempB + tempA;\n}\n\nif (hiPrec != null) {\n// If requesting high precision\nhiPrec[0] = tempA;\nhiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n}\n\nreturn result;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xa;\ndouble xb = 0.0;\n\n/* Take absolute value of the input */\nxa = x;\nif (x < 0) {\nnegative = true;\nxa = -xa;\n}\n\n/* Check for zero and negative zero */\nif (xa == 0.0) {\nlong bits = Double.doubleToLongBits(x);\nif (bits < 0) {\nreturn -0.0;\n}\nreturn 0.0;\n}\n\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nreturn Double.NaN;\n}\n\n/* Perform any argument reduction */\nif (xa > 3294198.0) {\n// PI * (2**20)\n// Argument too big for CodyWaite reduction.  Must use\n// PayneHanek.\ndouble reduceResults[] = new double[3];\nreducePayneHanek(xa, reduceResults);\nquadrant = ((int) reduceResults[0]) & 3;\nxa = reduceResults[1];\nxb = reduceResults[2];\n} else if (xa > 1.5707963267948966) {\n/* Inline the Cody/Waite reduction for performance */\n\n// Estimate k\n//k = (int)(xa / 1.5707963267948966);\nint k = (int)(xa * 0.6366197723675814);\n\n// Compute remainder\ndouble remA;\ndouble remB;\nwhile (true) {\ndouble a = -k * 1.570796251296997;\nremA = xa + a;\nremB = -(remA - xa - a);\n\na = -k * 7.549789948768648E-8;\ndouble b = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\na = -k * 6.123233995736766E-17;\nb = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\nif (remA > 0.0) {\nbreak;\n}\n\n// Remainder is negative, so decrement k and try again.\n// This should only happen if the input is very close\n// to an even multiple of pi/2\nk--;\n}\nquadrant = k & 3;\nxa = remA;\nxb = remB;\n}\n\nif (negative) {\nquadrant ^= 2;  // Flip bit 1\n}\n\nswitch (quadrant) {\ncase 0:\nreturn sinQ(xa, xb);\ncase 1:\nreturn cosQ(xa, xb);\ncase 2:\nreturn -sinQ(xa, xb);\ncase 3:\nreturn -cosQ(xa, xb);\ndefault:\nreturn Double.NaN;\n}\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:sinh(D)D",
            "method_body": "public static double sinh(double x) {\nboolean negate = false;\nif (x != x) {\nreturn x;\n}\n\n// sinh[z] = (exp(z) - exp(-z) / 2\n\n// for values of z larger than about 20,\n// exp(-z) can be ignored in comparison with exp(z)\n\nif (x > 20.0) {\nreturn exp(x)/2.0;\n}\n\nif (x < -20) {\nreturn -exp(-x)/2.0;\n}\n\nif (x == 0) {\nreturn x;\n}\n\nif (x < 0.0) {\nx = -x;\nnegate = true;\n}\n\ndouble result;\n\nif (x > 0.25) {\ndouble hiPrec[] = new double[2];\nexp(x, 0.0, hiPrec);\n\ndouble ya = hiPrec[0] + hiPrec[1];\ndouble yb = -(ya - hiPrec[0] - hiPrec[1]);\n\ndouble temp = ya * HEX_40000000;\ndouble yaa = ya + temp - temp;\ndouble yab = ya - yaa;\n\n// recip = 1/y\ndouble recip = 1.0/ya;\ntemp = recip * HEX_40000000;\ndouble recipa = recip + temp - temp;\ndouble recipb = recip - recipa;\n\n// Correct for rounding in division\nrecipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n// Account for yb\nrecipb += -yb * recip * recip;\n\nrecipa = -recipa;\nrecipb = -recipb;\n\n// y = y + 1/y\ntemp = ya + recipa;\nyb += -(temp - ya - recipa);\nya = temp;\ntemp = ya + recipb;\nyb += -(temp - ya - recipb);\nya = temp;\n\nresult = ya + yb;\nresult *= 0.5;\n}\nelse {\ndouble hiPrec[] = new double[2];\nexpm1(x, hiPrec);\n\ndouble ya = hiPrec[0] + hiPrec[1];\ndouble yb = -(ya - hiPrec[0] - hiPrec[1]);\n\n/* Compute expm1(-x) = -expm1(x) / (expm1(x) + 1) */\ndouble denom = 1.0 + ya;\ndouble denomr = 1.0 / denom;\ndouble denomb = -(denom - 1.0 - ya) + yb;\ndouble ratio = ya * denomr;\ndouble temp = ratio * HEX_40000000;\ndouble ra = ratio + temp - temp;\ndouble rb = ratio - ra;\n\ntemp = denom * HEX_40000000;\ndouble za = denom + temp - temp;\ndouble zb = denom - za;\n\nrb += (ya - za*ra - za*rb - zb*ra - zb*rb) * denomr;\n\n// Adjust for yb\nrb += yb*denomr;                        // numerator\nrb += -ya * denomb * denomr * denomr;   // denominator\n\n// y = y - 1/y\ntemp = ya + ra;\nyb += -(temp - ya - ra);\nya = temp;\ntemp = ya + rb;\nyb += -(temp - ya - rb);\nya = temp;\n\nresult = ya + yb;\nresult *= 0.5;\n}\n\nif (negate) {\nresult = -result;\n}\n\nreturn result;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:createComplex(DD)Lorg/apache/commons/math/complex/Complex;",
            "method_body": "protected Complex createComplex(double realPart,\ndouble imaginaryPart) {\nreturn new Complex(realPart, imaginaryPart);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\n\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\n\nreturn p;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:getReal()D",
            "method_body": "public double getReal() {\nreturn real;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:polySine(D)D",
            "method_body": "private static double polySine(final double x)\n{\ndouble x2 = x*x;\n\ndouble p = 2.7553817452272217E-6;\np = p * x2 + -1.9841269659586505E-4;\np = p * x2 + 0.008333333333329196;\np = p * x2 + -0.16666666666666666;\n//p *= x2;\n//p *= x;\np = p * x2 * x;\n\nreturn p;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:getImaginary()D",
            "method_body": "public double getImaginary() {\nreturn imaginary;\n}",
            "method_id": 14
        }
    ]
}