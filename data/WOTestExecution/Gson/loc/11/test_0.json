{
    "bug_id": 11,
    "test_id": 0,
    "test_name": "com.google.gson.functional.PrimitiveTest.testNumberAsStringDeserialization",
    "test_body": "public void testNumberAsStringDeserialization() {\nNumber value = gson.fromJson(\"\\\"18\\\"\", Number.class);\nassertEquals(18, value.intValue());\n}\n",
    "stack_trace": "com.google.gson.JsonSyntaxException: Expecting number, got: STRING\nat com.google.gson.internal.bind.TypeAdapters$15.read(TypeAdapters.java:373)\nat com.google.gson.internal.bind.TypeAdapters$15.read(TypeAdapters.java:362)\nat com.google.gson.Gson.fromJson(Gson.java:887)\nat com.google.gson.Gson.fromJson(Gson.java:852)\nat com.google.gson.Gson.fromJson(Gson.java:801)\nat com.google.gson.Gson.fromJson(Gson.java:773)\nat com.google.gson.functional.PrimitiveTest.testNumberAsStringDeserialization(PrimitiveTest.java:162)",
    "covered_methods": [
        {
            "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
            "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\" + locationString());\n} else {\nreturn -1;\n}\n}",
            "method_id": 0,
            "loc": 88
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:<clinit>()V",
            "method_body": "private static final char[] NON_EXECUTE_PREFIX = \")]}'\\n\".toCharArray();\nprivate static final long MIN_INCOMPLETE_INTEGER = Long.MIN_VALUE / 10;\n\nprivate static final int PEEKED_NONE = 0;\nprivate static final int PEEKED_BEGIN_OBJECT = 1;\nprivate static final int PEEKED_END_OBJECT = 2;\nprivate static final int PEEKED_BEGIN_ARRAY = 3;\nprivate static final int PEEKED_END_ARRAY = 4;\nprivate static final int PEEKED_TRUE = 5;\nprivate static final int PEEKED_FALSE = 6;\nprivate static final int PEEKED_NULL = 7;\nprivate static final int PEEKED_SINGLE_QUOTED = 8;\nprivate static final int PEEKED_DOUBLE_QUOTED = 9;\nprivate static final int PEEKED_UNQUOTED = 10;\n/** When this is returned, the string value is stored in peekedString. */\nprivate static final int PEEKED_BUFFERED = 11;\nprivate static final int PEEKED_SINGLE_QUOTED_NAME = 12;\nprivate static final int PEEKED_DOUBLE_QUOTED_NAME = 13;\nprivate static final int PEEKED_UNQUOTED_NAME = 14;\n/** When this is returned, the integer value is stored in peekedLong. */\nprivate static final int PEEKED_LONG = 15;\nprivate static final int PEEKED_NUMBER = 16;\nprivate static final int PEEKED_EOF = 17;\n\n/* State machine when parsing numbers */\nprivate static final int NUMBER_CHAR_NONE = 0;\nprivate static final int NUMBER_CHAR_SIGN = 1;\nprivate static final int NUMBER_CHAR_DIGIT = 2;\nprivate static final int NUMBER_CHAR_DECIMAL = 3;\nprivate static final int NUMBER_CHAR_FRACTION_DIGIT = 4;\nprivate static final int NUMBER_CHAR_EXP_E = 5;\nprivate static final int NUMBER_CHAR_EXP_SIGN = 6;\nprivate static final int NUMBER_CHAR_EXP_DIGIT = 7;\n\n/** The input JSON. */\nprivate final Reader in;\n\n/** True to accept non-spec compliant JSON */\nprivate boolean lenient = false;\n\n/**\n* Use a manual buffer to easily read and unread upcoming characters, and\n* also so we can create strings without an intermediate StringBuilder.\n* We decode literals directly out of this buffer, so it must be at least as\n* long as the longest token that can be reported as a number.\n*/\nprivate final char[] buffer = new char[1024];\nprivate int pos = 0;\nprivate int limit = 0;\n\nprivate int lineNumber = 0;\nprivate int lineStart = 0;\n\nint peeked = PEEKED_NONE;\n\n/**\n* A peeked value that was composed entirely of digits with an optional\n* leading dash. Positive values may not have a leading 0.\n*/\nprivate long peekedLong;\n\n/**\n* The number of characters in a peeked number literal. Increment 'pos' by\n* this after reading a number.\n*/\nprivate int peekedNumberLength;\n\n/**\n* A peeked string that should be parsed on the next double, long or string.\n* This is populated before a numeric value is parsed and used if that parsing\n* fails.\n*/\nprivate String peekedString;\n\n/*\n* The nesting stack. Using a manual array rather than an ArrayList saves 20%.\n*/\nprivate int[] stack = new int[32];\nprivate int stackSize = 0;\n{\nstack[stackSize++] = JsonScope.EMPTY_DOCUMENT;\n}",
            "method_id": 1,
            "loc": 82
        },
        {
            "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/util/List;)V",
            "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy,\nList<TypeAdapterFactory> typeAdapterFactories) {\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.serializeNulls = serializeNulls;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// user's type adapters\nfactories.addAll(typeAdapterFactories);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n\nthis.factories = Collections.unmodifiableList(factories);\n}",
            "method_id": 2,
            "loc": 76
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
            "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}",
            "method_id": 3,
            "loc": 55
        },
        {
            "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}",
            "method_id": 4,
            "loc": 41
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$36:<clinit>()V",
            "method_body": "@Override public BitSet read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nBitSet bitset = new BitSet();\nin.beginArray();\nint i = 0;\nJsonToken tokenType = in.peek();\nwhile (tokenType != JsonToken.END_ARRAY) {\nboolean set;\nswitch (tokenType) {\ncase NUMBER:\nset = in.nextInt() != 0;\nbreak;\ncase BOOLEAN:\nset = in.nextBoolean();\nbreak;\ncase STRING:\nString stringValue = in.nextString();\ntry {\nset = Integer.parseInt(stringValue) != 0;\n} catch (NumberFormatException e) {\nthrow new JsonSyntaxException(\n\"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n}\nbreak;\ndefault:\nthrow new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n}\nif (set) {\nbitset.set(i);\n}\n++i;\ntokenType = in.peek();\n}\nin.endArray();\nreturn bitset;\n}",
            "method_id": 5,
            "loc": 40
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
            "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}",
            "method_id": 6,
            "loc": 38
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}",
            "method_id": 7,
            "loc": 37
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
            "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}",
            "method_id": 8,
            "loc": 33
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
            "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 9,
            "loc": 29
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 10,
            "loc": 29
        },
        {
            "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
            "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\ntry {\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\n} catch (EOFException e) {\n/*\n* For compatibility with JSON 1.5 and earlier, we return null for empty\n* documents instead of throwing.\n*/\nif (isEmpty) {\nreturn null;\n}\nthrow new JsonSyntaxException(e);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\n// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\nthrow new JsonSyntaxException(e);\n} finally {\nreader.setLenient(oldLenient);\n}\n}",
            "method_id": 11,
            "loc": 29
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
            "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 12,
            "loc": 28
        },
        {
            "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
            "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}",
            "method_id": 13,
            "loc": 26
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
            "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}",
            "method_id": 14,
            "loc": 23
        },
        {
            "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
            "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}",
            "method_id": 15,
            "loc": 23
        },
        {
            "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
            "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}",
            "method_id": 16,
            "loc": 23
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
            "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}",
            "method_id": 17,
            "loc": 23
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
            "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n} else {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}\n};",
            "method_id": 18,
            "loc": 21
        },
        {
            "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
            "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}",
            "method_id": 19,
            "loc": 21
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
            "method_body": "private void consumeNonExecutePrefix() throws IOException {\n// fast forward through the leading whitespace\nnextNonWhitespace(true);\npos--;\n\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}\n\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}\n}\n\n// we consumed a security token!\npos += NON_EXECUTE_PREFIX.length;\n}",
            "method_id": 20,
            "loc": 18
        },
        {
            "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
            "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}",
            "method_id": 21,
            "loc": 18
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
            "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}",
            "method_id": 22,
            "loc": 17
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
            "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 23,
            "loc": 14
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
            "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 24,
            "loc": 14
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 25,
            "loc": 14
        },
        {
            "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};",
            "method_id": 26,
            "loc": 14
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$15:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Number;",
            "method_body": "public Number read(JsonReader in) throws IOException {\nJsonToken jsonToken = in.peek();\nswitch (jsonToken) {\ncase NULL:\nin.nextNull();\nreturn null;\ncase NUMBER:\nreturn new LazilyParsedNumber(in.nextString());\ndefault:\nthrow new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n}\n}",
            "method_id": 27,
            "loc": 12
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
            "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 28,
            "loc": 12
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 29,
            "loc": 12
        },
        {
            "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
            "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}",
            "method_id": 30,
            "loc": 11
        },
        {
            "method_signature": "com.google.gson.Gson:<clinit>()V",
            "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = new TypeToken<Object>() {};",
            "method_id": 31,
            "loc": 9
        },
        {
            "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};",
            "method_id": 32,
            "loc": 9
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:getSuperclassTypeParameter(Ljava/lang/Class;)Ljava/lang/reflect/Type;",
            "method_body": "static Type getSuperclassTypeParameter(Class<?> subclass) {\nType superclass = subclass.getGenericSuperclass();\nif (superclass instanceof Class) {\nthrow new RuntimeException(\"Missing type parameter.\");\n}\nParameterizedType parameterized = (ParameterizedType) superclass;\nreturn $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}",
            "method_id": 33,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
            "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nreturn null;\n}\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}",
            "method_id": 34,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:<init>()V",
            "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}",
            "method_id": 35,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
            "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}",
            "method_id": 36,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.Gson:<init>()V",
            "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, Collections.<TypeAdapterFactory>emptyList());\n}",
            "method_id": 37,
            "loc": 7
        },
        {
            "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};",
            "method_id": 38,
            "loc": 7
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
            "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}",
            "method_id": 39,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
            "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}",
            "method_id": 40,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
            "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}",
            "method_id": 41,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}",
            "method_id": 42,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};",
            "method_id": 43,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};",
            "method_id": 44,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
            "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}",
            "method_id": 45,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:<init>()V",
            "method_body": "protected TypeToken() {\nthis.type = getSuperclassTypeParameter(getClass());\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(type);\nthis.hashCode = type.hashCode();\n}",
            "method_id": 46,
            "loc": 5
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
            "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}",
            "method_id": 47,
            "loc": 5
        },
        {
            "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
            "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}",
            "method_id": 48,
            "loc": 5
        },
        {
            "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
            "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}",
            "method_id": 49,
            "loc": 5
        },
        {
            "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
            "method_body": "public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\nObject object = fromJson(json, (Type) classOfT);\nreturn Primitives.wrap(classOfT).cast(object);\n}",
            "method_id": 50,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
            "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}",
            "method_id": 51,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
            "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}",
            "method_id": 52,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
            "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}",
            "method_id": 53,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
            "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}",
            "method_id": 54,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
            "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}",
            "method_id": 55,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
            "method_body": "public final boolean isLenient() {\nreturn lenient;\n}",
            "method_id": 56,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
            "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}",
            "method_id": 57,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
            "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}",
            "method_id": 58,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
            "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}",
            "method_id": 59,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/String;)V",
            "method_body": "public JsonParseException(String msg) {\nsuper(msg);\n}",
            "method_id": 60,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.JsonSyntaxException:<init>(Ljava/lang/String;)V",
            "method_body": "public JsonSyntaxException(String msg) {\nsuper(msg);\n}",
            "method_id": 61,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
            "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};",
            "method_id": 62,
            "loc": 2
        }
    ]
}