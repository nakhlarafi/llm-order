{
    "bug_id": 22,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.compressors.bzip2.PythonTruncatedBzip2Test.testPartialReadTruncatedData",
    "test_body": "public void testPartialReadTruncatedData() throws IOException {\n//with BZ2File(self.filename) as f:\n//    self.assertEqual(f.read(len(self.TEXT)), self.TEXT)\n//    self.assertRaises(EOFError, f.read, 1)\nfinal int length = TEXT.length();\nByteBuffer buffer = ByteBuffer.allocate(length);\nbz2Channel.read(buffer);\nassertArrayEquals(Arrays.copyOfRange(TEXT.getBytes(), 0, length),\nbuffer.array());\n// subsequent read should throw\nbuffer = ByteBuffer.allocate(1);\ntry {\nbz2Channel.read(buffer);\nAssert.fail(\"The read should have thrown.\");\n} catch (IOException e) {\n// pass\n}\n}\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode()V",
            "method_body": "private void getAndMoveToFrontDecode() throws IOException {\nthis.origPtr = bsR(24);\nrecvDecodingTables();\n\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal byte[] ll8 = dataShadow.ll8;\nfinal int[] unzftab = dataShadow.unzftab;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] seqToUnseq = dataShadow.seqToUnseq;\nfinal char[] yy = dataShadow.getAndMoveToFrontDecode_yy;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\nfinal int limitLast = this.blockSize100k * 100000;\n\n/*\n* Setting up the unzftab entries here is not strictly necessary, but it\n* does save having to do it later in a separate pass, and so saves a\n* block's worth of cache misses.\n*/\nfor (int i = 256; --i >= 0;) {\nyy[i] = (char) i;\nunzftab[i] = 0;\n}\n\nint groupNo = 0;\nint groupPos = G_SIZE - 1;\nfinal int eob = this.nInUse + 1;\nint nextSym = getAndMoveToFrontDecode0(0);\nint bsBuffShadow = this.bsBuff;\nint bsLiveShadow = this.bsLive;\nint lastShadow = -1;\nint zt = selector[groupNo] & 0xff;\nint[] base_zt = base[zt];\nint[] limit_zt = limit[zt];\nint[] perm_zt = perm[zt];\nint minLens_zt = minLens[zt];\n\nwhile (nextSym != eob) {\nif ((nextSym == RUNA) || (nextSym == RUNB)) {\nint s = -1;\n\nfor (int n = 1; true; n <<= 1) {\nif (nextSym == RUNA) {\ns += n;\n} else if (nextSym == RUNB) {\ns += n << 1;\n} else {\nbreak;\n}\n\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\n} else {\ngroupPos--;\n}\n\nint zn = minLens_zt;\n\n// Inlined:\n// int zvec = bsR(zn);\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n& ((1 << zn) - 1);\nbsLiveShadow -= zn;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\n\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1)\n| ((bsBuffShadow >> bsLiveShadow) & 1);\n}\nnextSym = perm_zt[zvec - base_zt[zn]];\n}\n\nfinal byte ch = seqToUnseq[yy[0]];\nunzftab[ch & 0xff] += s + 1;\n\nwhile (s-- >= 0) {\nll8[++lastShadow] = ch;\n}\n\nif (lastShadow >= limitLast) {\nthrow new IOException(\"block overrun\");\n}\n} else {\nif (++lastShadow >= limitLast) {\nthrow new IOException(\"block overrun\");\n}\n\nfinal char tmp = yy[nextSym - 1];\nunzftab[seqToUnseq[tmp] & 0xff]++;\nll8[lastShadow] = seqToUnseq[tmp];\n\n/*\n* This loop is hammered during decompression, hence avoid\n* native method call overhead of System.arraycopy for very\n* small ranges to copy.\n*/\nif (nextSym <= 16) {\nfor (int j = nextSym - 1; j > 0;) {\nyy[j] = yy[--j];\n}\n} else {\nSystem.arraycopy(yy, 0, yy, 1, nextSym - 1);\n}\n\nyy[0] = tmp;\n\nif (groupPos == 0) {\ngroupPos = G_SIZE - 1;\nzt = selector[++groupNo] & 0xff;\nbase_zt = base[zt];\nlimit_zt = limit[zt];\nperm_zt = perm[zt];\nminLens_zt = minLens[zt];\n} else {\ngroupPos--;\n}\n\nint zn = minLens_zt;\n\n// Inlined:\n// int zvec = bsR(zn);\nwhile (bsLiveShadow < zn) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nint zvec = (bsBuffShadow >> (bsLiveShadow - zn))\n& ((1 << zn) - 1);\nbsLiveShadow -= zn;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n}\nnextSym = perm_zt[zvec - base_zt[zn]];\n}\n}\n\nthis.last = lastShadow;\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\n}",
            "method_id": 0,
            "loc": 188
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbMakeCodeLengths([B[ILorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;II)V",
            "method_body": "private static void hbMakeCodeLengths(final byte[] len, final int[] freq,\nfinal Data dat, final int alphaSize,\nfinal int maxLen) {\n/*\n* Nodes and heap entries run from 1. Entry 0 for both the heap and\n* nodes is a sentinel.\n*/\nfinal int[] heap = dat.heap;\nfinal int[] weight = dat.weight;\nfinal int[] parent = dat.parent;\n\nfor (int i = alphaSize; --i >= 0;) {\nweight[i + 1] = (freq[i] == 0 ? 1 : freq[i]) << 8;\n}\n\nfor (boolean tooLong = true; tooLong;) {\ntooLong = false;\n\nint nNodes = alphaSize;\nint nHeap = 0;\nheap[0] = 0;\nweight[0] = 0;\nparent[0] = -2;\n\nfor (int i = 1; i <= alphaSize; i++) {\nparent[i] = -1;\nnHeap++;\nheap[nHeap] = i;\n\nint zz = nHeap;\nint tmp = heap[zz];\nwhile (weight[tmp] < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\n}\nheap[zz] = tmp;\n}\n\nwhile (nHeap > 1) {\nint n1 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\n\nint yy = 0;\nint zz = 1;\nint tmp = heap[1];\n\nwhile (true) {\nyy = zz << 1;\n\nif (yy > nHeap) {\nbreak;\n}\n\nif ((yy < nHeap)\n&& (weight[heap[yy + 1]] < weight[heap[yy]])) {\nyy++;\n}\n\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\n}\n\nheap[zz] = heap[yy];\nzz = yy;\n}\n\nheap[zz] = tmp;\n\nint n2 = heap[1];\nheap[1] = heap[nHeap];\nnHeap--;\n\nyy = 0;\nzz = 1;\ntmp = heap[1];\n\nwhile (true) {\nyy = zz << 1;\n\nif (yy > nHeap) {\nbreak;\n}\n\nif ((yy < nHeap)\n&& (weight[heap[yy + 1]] < weight[heap[yy]])) {\nyy++;\n}\n\nif (weight[tmp] < weight[heap[yy]]) {\nbreak;\n}\n\nheap[zz] = heap[yy];\nzz = yy;\n}\n\nheap[zz] = tmp;\nnNodes++;\nparent[n1] = parent[n2] = nNodes;\n\nfinal int weight_n1 = weight[n1];\nfinal int weight_n2 = weight[n2];\nweight[nNodes] = ((weight_n1 & 0xffffff00)\n+ (weight_n2 & 0xffffff00))\n| (1 + (((weight_n1 & 0x000000ff)\n> (weight_n2 & 0x000000ff))\n? (weight_n1 & 0x000000ff)\n: (weight_n2 & 0x000000ff)));\n\nparent[nNodes] = -1;\nnHeap++;\nheap[nHeap] = nNodes;\n\ntmp = 0;\nzz = nHeap;\ntmp = heap[zz];\nfinal int weight_tmp = weight[tmp];\nwhile (weight_tmp < weight[heap[zz >> 1]]) {\nheap[zz] = heap[zz >> 1];\nzz >>= 1;\n}\nheap[zz] = tmp;\n\n}\n\nfor (int i = 1; i <= alphaSize; i++) {\nint j = 0;\nint k = i;\n\nfor (int parent_k; (parent_k = parent[k]) >= 0;) {\nk = parent_k;\nj++;\n}\n\nlen[i - 1] = (byte) j;\nif (j > maxLen) {\ntooLong = true;\n}\n}\n\nif (tooLong) {\nfor (int i = 1; i < alphaSize; i++) {\nint j = weight[i] >> 8;\nj = 1 + (j >> 1);\nweight[i] = j << 8;\n}\n}\n}\n}",
            "method_id": 1,
            "loc": 150
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues1(II)I",
            "method_body": "private int sendMTFValues1(final int nGroups, final int alphaSize) {\nfinal Data dataShadow = this.data;\nfinal int[][] rfreq = dataShadow.sendMTFValues_rfreq;\nfinal int[] fave = dataShadow.sendMTFValues_fave;\nfinal short[] cost = dataShadow.sendMTFValues_cost;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[][] len = dataShadow.sendMTFValues_len;\nfinal byte[] len_0 = len[0];\nfinal byte[] len_1 = len[1];\nfinal byte[] len_2 = len[2];\nfinal byte[] len_3 = len[3];\nfinal byte[] len_4 = len[4];\nfinal byte[] len_5 = len[5];\nfinal int nMTFShadow = this.nMTF;\n\nint nSelectors = 0;\n\nfor (int iter = 0; iter < N_ITERS; iter++) {\nfor (int t = nGroups; --t >= 0;) {\nfave[t] = 0;\nint[] rfreqt = rfreq[t];\nfor (int i = alphaSize; --i >= 0;) {\nrfreqt[i] = 0;\n}\n}\n\nnSelectors = 0;\n\nfor (int gs = 0; gs < this.nMTF;) {\n/* Set group start & end marks. */\n\n/*\n* Calculate the cost of this group as coded by each of the\n* coding tables.\n*/\n\nfinal int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\n\nif (nGroups == N_GROUPS) {\n// unrolled version of the else-block\n\nshort cost0 = 0;\nshort cost1 = 0;\nshort cost2 = 0;\nshort cost3 = 0;\nshort cost4 = 0;\nshort cost5 = 0;\n\nfor (int i = gs; i <= ge; i++) {\nfinal int icv = sfmap[i];\ncost0 += len_0[icv] & 0xff;\ncost1 += len_1[icv] & 0xff;\ncost2 += len_2[icv] & 0xff;\ncost3 += len_3[icv] & 0xff;\ncost4 += len_4[icv] & 0xff;\ncost5 += len_5[icv] & 0xff;\n}\n\ncost[0] = cost0;\ncost[1] = cost1;\ncost[2] = cost2;\ncost[3] = cost3;\ncost[4] = cost4;\ncost[5] = cost5;\n\n} else {\nfor (int t = nGroups; --t >= 0;) {\ncost[t] = 0;\n}\n\nfor (int i = gs; i <= ge; i++) {\nfinal int icv = sfmap[i];\nfor (int t = nGroups; --t >= 0;) {\ncost[t] += len[t][icv] & 0xff;\n}\n}\n}\n\n/*\n* Find the coding table which is best for this group, and\n* record its identity in the selector table.\n*/\nint bt = -1;\nfor (int t = nGroups, bc = 999999999; --t >= 0;) {\nfinal int cost_t = cost[t];\nif (cost_t < bc) {\nbc = cost_t;\nbt = t;\n}\n}\n\nfave[bt]++;\nselector[nSelectors] = (byte) bt;\nnSelectors++;\n\n/*\n* Increment the symbol frequencies for the selected table.\n*/\nfinal int[] rfreq_bt = rfreq[bt];\nfor (int i = gs; i <= ge; i++) {\nrfreq_bt[sfmap[i]]++;\n}\n\ngs = ge + 1;\n}\n\n/*\n* Recompute the tables based on the accumulated frequencies.\n*/\nfor (int t = 0; t < nGroups; t++) {\nhbMakeCodeLengths(len[t], rfreq[t], this.data, alphaSize, 20);\n}\n}\n\nreturn nSelectors;\n}",
            "method_id": 2,
            "loc": 117
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:generateMTFValues()V",
            "method_body": "private void generateMTFValues() {\nfinal int lastShadow = this.last;\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] block = dataShadow.block;\nfinal int[] fmap = dataShadow.fmap;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal int[] mtfFreq = dataShadow.mtfFreq;\nfinal byte[] unseqToSeq = dataShadow.unseqToSeq;\nfinal byte[] yy = dataShadow.generateMTFValues_yy;\n\n// make maps\nint nInUseShadow = 0;\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nunseqToSeq[i] = (byte) nInUseShadow;\nnInUseShadow++;\n}\n}\nthis.nInUse = nInUseShadow;\n\nfinal int eob = nInUseShadow + 1;\n\nfor (int i = eob; i >= 0; i--) {\nmtfFreq[i] = 0;\n}\n\nfor (int i = nInUseShadow; --i >= 0;) {\nyy[i] = (byte) i;\n}\n\nint wr = 0;\nint zPend = 0;\n\nfor (int i = 0; i <= lastShadow; i++) {\nfinal byte ll_i = unseqToSeq[block[fmap[i]] & 0xff];\nbyte tmp = yy[0];\nint j = 0;\n\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = yy[j];\nyy[j] = tmp2;\n}\nyy[0] = tmp;\n\nif (j == 0) {\nzPend++;\n} else {\nif (zPend > 0) {\nzPend--;\nwhile (true) {\nif ((zPend & 1) == 0) {\nsfmap[wr] = RUNA;\nwr++;\nmtfFreq[RUNA]++;\n} else {\nsfmap[wr] = RUNB;\nwr++;\nmtfFreq[RUNB]++;\n}\n\nif (zPend >= 2) {\nzPend = (zPend - 2) >> 1;\n} else {\nbreak;\n}\n}\nzPend = 0;\n}\nsfmap[wr] = (char) (j + 1);\nwr++;\nmtfFreq[j + 1]++;\n}\n}\n\nif (zPend > 0) {\nzPend--;\nwhile (true) {\nif ((zPend & 1) == 0) {\nsfmap[wr] = RUNA;\nwr++;\nmtfFreq[RUNA]++;\n} else {\nsfmap[wr] = RUNB;\nwr++;\nmtfFreq[RUNB]++;\n}\n\nif (zPend >= 2) {\nzPend = (zPend - 2) >> 1;\n} else {\nbreak;\n}\n}\n}\n\nsfmap[wr] = (char) eob;\nmtfFreq[eob]++;\nthis.nMTF = wr + 1;\n}",
            "method_id": 3,
            "loc": 102
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackSort([I[BI)V",
            "method_body": "final void fallbackSort(int[] fmap, byte[] block, int nblock) {\nfinal int[] ftab = new int[257];\nint H, i, j, k, l, r, cc, cc1;\nint nNotDone;\nint nBhtab;\nfinal int[] eclass = getEclass();\n\nfor (i = 0; i < nblock; i++) {\neclass[i] = 0;\n}\n/*--\nLBZ2: Initial 1-char radix sort to generate\ninitial fmap and initial BH bits.\n--*/\nfor (i = 0; i < nblock; i++) {\nftab[block[i] & 0xff]++;\n}\nfor (i = 1; i < 257;    i++) {\nftab[i] += ftab[i - 1];\n}\n\nfor (i = 0; i < nblock; i++) {\nj = block[i] & 0xff;\nk = ftab[j] - 1;\nftab[j] = k;\nfmap[k] = i;\n}\n\nnBhtab = 64 + nblock;\nBitSet bhtab = new BitSet(nBhtab);\nfor (i = 0; i < 256; i++) {\nbhtab.set(ftab[i]);\n}\n\n/*--\nLBZ2: Inductively refine the buckets.  Kind-of an\n\"exponential radix sort\" (!), inspired by the\nManber-Myers suffix array construction algorithm.\n--*/\n\n/*-- LBZ2: set sentinel bits for block-end detection --*/\nfor (i = 0; i < 32; i++) {\nbhtab.set(nblock + 2 * i);\nbhtab.clear(nblock + 2 * i + 1);\n}\n\n/*-- LBZ2: the log(N) loop --*/\nH = 1;\nwhile (true) {\n\nj = 0;\nfor (i = 0; i < nblock; i++) {\nif (bhtab.get(i)) {\nj = i;\n}\nk = fmap[i] - H;\nif (k < 0) {\nk += nblock;\n}\neclass[k] = j;\n}\n\nnNotDone = 0;\nr = -1;\nwhile (true) {\n\n/*-- LBZ2: find the next non-singleton bucket --*/\nk = r + 1;\nk = bhtab.nextClearBit(k);\nl = k - 1;\nif (l >= nblock) {\nbreak;\n}\nk = bhtab.nextSetBit(k + 1);\nr = k - 1;\nif (r >= nblock) {\nbreak;\n}\n\n/*-- LBZ2: now [l, r] bracket current bucket --*/\nif (r > l) {\nnNotDone += (r - l + 1);\nfallbackQSort3(fmap, eclass, l, r);\n\n/*-- LBZ2: scan bucket and generate header bits-- */\ncc = -1;\nfor (i = l; i <= r; i++) {\ncc1 = eclass[fmap[i]];\nif (cc != cc1) {\nbhtab.set(i);\ncc = cc1;\n}\n}\n}\n}\n\nH *= 2;\nif (H > nblock || nNotDone == 0) {\nbreak;\n}\n}\n}",
            "method_id": 4,
            "loc": 102
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackQSort3([I[III)V",
            "method_body": "private void fallbackQSort3(int[] fmap,\nint[] eclass,\nint loSt,\nint hiSt) {\nint lo, unLo, ltLo, hi, unHi, gtHi, n;\n\nlong r = 0;\nint sp = 0;\nfpush(sp++, loSt, hiSt);\n\nwhile (sp > 0) {\nint[] s = fpop(--sp);\nlo = s[0]; hi = s[1];\n\nif (hi - lo < FALLBACK_QSORT_SMALL_THRESH) {\nfallbackSimpleSort(fmap, eclass, lo, hi);\ncontinue;\n}\n\n/* LBZ2: Random partitioning.  Median of 3 sometimes fails to\navoid bad cases.  Median of 9 seems to help but\nlooks rather expensive.  This too seems to work but\nis cheaper.  Guidance for the magic constants\n7621 and 32768 is taken from Sedgewick's algorithms\nbook, chapter 35.\n*/\nr = ((r * 7621) + 1) % 32768;\nlong r3 = r % 3, med;\nif (r3 == 0) {\nmed = eclass[fmap[lo]];\n} else if (r3 == 1) {\nmed = eclass[fmap[(lo + hi) >>> 1]];\n} else {\nmed = eclass[fmap[hi]];\n}\n\nunLo = ltLo = lo;\nunHi = gtHi = hi;\n\n// looks like the ternary partition attributed to Wegner\n// in the cited Sedgewick paper\nwhile (true) {\nwhile (true) {\nif (unLo > unHi) {\nbreak;\n}\nn = eclass[fmap[unLo]] - (int) med;\nif (n == 0) {\nfswap(fmap, unLo, ltLo);\nltLo++; unLo++;\ncontinue;\n}\nif (n > 0) {\nbreak;\n}\nunLo++;\n}\nwhile (true) {\nif (unLo > unHi) {\nbreak;\n}\nn = eclass[fmap[unHi]] - (int) med;\nif (n == 0) {\nfswap(fmap, unHi, gtHi);\ngtHi--; unHi--;\ncontinue;\n}\nif (n < 0) {\nbreak;\n}\nunHi--;\n}\nif (unLo > unHi) {\nbreak;\n}\nfswap(fmap, unLo, unHi); unLo++; unHi--;\n}\n\nif (gtHi < ltLo) {\ncontinue;\n}\n\nn = fmin(ltLo - lo, unLo - ltLo);\nfvswap(fmap, lo, unLo - n, n);\nint m = fmin(hi - gtHi, gtHi - unHi);\nfvswap(fmap, unHi + 1, hi - m + 1, m);\n\nn = lo + unLo - ltLo - 1;\nm = hi - (gtHi - unHi) + 1;\n\nif (n - lo > hi - m) {\nfpush(sp++, lo, n);\nfpush(sp++, m, hi);\n} else {\nfpush(sp++, m, hi);\nfpush(sp++, lo, n);\n}\n}\n}",
            "method_id": 5,
            "loc": 99
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:recvDecodingTables()V",
            "method_body": "private void recvDecodingTables() throws IOException {\nfinal Data dataShadow = this.data;\nfinal boolean[] inUse = dataShadow.inUse;\nfinal byte[] pos = dataShadow.recvDecodingTables_pos;\nfinal byte[] selector = dataShadow.selector;\nfinal byte[] selectorMtf = dataShadow.selectorMtf;\n\nint inUse16 = 0;\n\n/* Receive the mapping table */\nfor (int i = 0; i < 16; i++) {\nif (bsGetBit()) {\ninUse16 |= 1 << i;\n}\n}\n\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\n}\n\nfor (int i = 0; i < 16; i++) {\nif ((inUse16 & (1 << i)) != 0) {\nfinal int i16 = i << 4;\nfor (int j = 0; j < 16; j++) {\nif (bsGetBit()) {\ninUse[i16 + j] = true;\n}\n}\n}\n}\n\nmakeMaps();\nfinal int alphaSize = this.nInUse + 2;\n\n/* Now the selectors */\nfinal int nGroups = bsR(3);\nfinal int nSelectors = bsR(15);\n\nfor (int i = 0; i < nSelectors; i++) {\nint j = 0;\nwhile (bsGetBit()) {\nj++;\n}\nselectorMtf[i] = (byte) j;\n}\n\n/* Undo the MTF values for the selectors. */\nfor (int v = nGroups; --v >= 0;) {\npos[v] = (byte) v;\n}\n\nfor (int i = 0; i < nSelectors; i++) {\nint v = selectorMtf[i] & 0xff;\nfinal byte tmp = pos[v];\nwhile (v > 0) {\n// nearly all times v is zero, 4 in most other cases\npos[v] = pos[v - 1];\nv--;\n}\npos[0] = tmp;\nselector[i] = tmp;\n}\n\nfinal char[][] len = dataShadow.temp_charArray2d;\n\n/* Now the coding tables */\nfor (int t = 0; t < nGroups; t++) {\nint curr = bsR(5);\nfinal char[] len_t = len[t];\nfor (int i = 0; i < alphaSize; i++) {\nwhile (bsGetBit()) {\ncurr += bsGetBit() ? -1 : 1;\n}\nlen_t[i] = (char) curr;\n}\n}\n\n// finally create the Huffman tables\ncreateHuffmanDecodingTables(alphaSize, nGroups);\n}",
            "method_id": 6,
            "loc": 80
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<clinit>()V",
            "method_body": "private static final int crc32Table[] = {\n0x00000000, 0x04c11db7, 0x09823b6e, 0x0d4326d9,\n0x130476dc, 0x17c56b6b, 0x1a864db2, 0x1e475005,\n0x2608edb8, 0x22c9f00f, 0x2f8ad6d6, 0x2b4bcb61,\n0x350c9b64, 0x31cd86d3, 0x3c8ea00a, 0x384fbdbd,\n0x4c11db70, 0x48d0c6c7, 0x4593e01e, 0x4152fda9,\n0x5f15adac, 0x5bd4b01b, 0x569796c2, 0x52568b75,\n0x6a1936c8, 0x6ed82b7f, 0x639b0da6, 0x675a1011,\n0x791d4014, 0x7ddc5da3, 0x709f7b7a, 0x745e66cd,\n0x9823b6e0, 0x9ce2ab57, 0x91a18d8e, 0x95609039,\n0x8b27c03c, 0x8fe6dd8b, 0x82a5fb52, 0x8664e6e5,\n0xbe2b5b58, 0xbaea46ef, 0xb7a96036, 0xb3687d81,\n0xad2f2d84, 0xa9ee3033, 0xa4ad16ea, 0xa06c0b5d,\n0xd4326d90, 0xd0f37027, 0xddb056fe, 0xd9714b49,\n0xc7361b4c, 0xc3f706fb, 0xceb42022, 0xca753d95,\n0xf23a8028, 0xf6fb9d9f, 0xfbb8bb46, 0xff79a6f1,\n0xe13ef6f4, 0xe5ffeb43, 0xe8bccd9a, 0xec7dd02d,\n0x34867077, 0x30476dc0, 0x3d044b19, 0x39c556ae,\n0x278206ab, 0x23431b1c, 0x2e003dc5, 0x2ac12072,\n0x128e9dcf, 0x164f8078, 0x1b0ca6a1, 0x1fcdbb16,\n0x018aeb13, 0x054bf6a4, 0x0808d07d, 0x0cc9cdca,\n0x7897ab07, 0x7c56b6b0, 0x71159069, 0x75d48dde,\n0x6b93dddb, 0x6f52c06c, 0x6211e6b5, 0x66d0fb02,\n0x5e9f46bf, 0x5a5e5b08, 0x571d7dd1, 0x53dc6066,\n0x4d9b3063, 0x495a2dd4, 0x44190b0d, 0x40d816ba,\n0xaca5c697, 0xa864db20, 0xa527fdf9, 0xa1e6e04e,\n0xbfa1b04b, 0xbb60adfc, 0xb6238b25, 0xb2e29692,\n0x8aad2b2f, 0x8e6c3698, 0x832f1041, 0x87ee0df6,\n0x99a95df3, 0x9d684044, 0x902b669d, 0x94ea7b2a,\n0xe0b41de7, 0xe4750050, 0xe9362689, 0xedf73b3e,\n0xf3b06b3b, 0xf771768c, 0xfa325055, 0xfef34de2,\n0xc6bcf05f, 0xc27dede8, 0xcf3ecb31, 0xcbffd686,\n0xd5b88683, 0xd1799b34, 0xdc3abded, 0xd8fba05a,\n0x690ce0ee, 0x6dcdfd59, 0x608edb80, 0x644fc637,\n0x7a089632, 0x7ec98b85, 0x738aad5c, 0x774bb0eb,\n0x4f040d56, 0x4bc510e1, 0x46863638, 0x42472b8f,\n0x5c007b8a, 0x58c1663d, 0x558240e4, 0x51435d53,\n0x251d3b9e, 0x21dc2629, 0x2c9f00f0, 0x285e1d47,\n0x36194d42, 0x32d850f5, 0x3f9b762c, 0x3b5a6b9b,\n0x0315d626, 0x07d4cb91, 0x0a97ed48, 0x0e56f0ff,\n0x1011a0fa, 0x14d0bd4d, 0x19939b94, 0x1d528623,\n0xf12f560e, 0xf5ee4bb9, 0xf8ad6d60, 0xfc6c70d7,\n0xe22b20d2, 0xe6ea3d65, 0xeba91bbc, 0xef68060b,\n0xd727bbb6, 0xd3e6a601, 0xdea580d8, 0xda649d6f,\n0xc423cd6a, 0xc0e2d0dd, 0xcda1f604, 0xc960ebb3,\n0xbd3e8d7e, 0xb9ff90c9, 0xb4bcb610, 0xb07daba7,\n0xae3afba2, 0xaafbe615, 0xa7b8c0cc, 0xa379dd7b,\n0x9b3660c6, 0x9ff77d71, 0x92b45ba8, 0x9675461f,\n0x8832161a, 0x8cf30bad, 0x81b02d74, 0x857130c3,\n0x5d8a9099, 0x594b8d2e, 0x5408abf7, 0x50c9b640,\n0x4e8ee645, 0x4a4ffbf2, 0x470cdd2b, 0x43cdc09c,\n0x7b827d21, 0x7f436096, 0x7200464f, 0x76c15bf8,\n0x68860bfd, 0x6c47164a, 0x61043093, 0x65c52d24,\n0x119b4be9, 0x155a565e, 0x18197087, 0x1cd86d30,\n0x029f3d35, 0x065e2082, 0x0b1d065b, 0x0fdc1bec,\n0x3793a651, 0x3352bbe6, 0x3e119d3f, 0x3ad08088,\n0x2497d08d, 0x2056cd3a, 0x2d15ebe3, 0x29d4f654,\n0xc5a92679, 0xc1683bce, 0xcc2b1d17, 0xc8ea00a0,\n0xd6ad50a5, 0xd26c4d12, 0xdf2f6bcb, 0xdbee767c,\n0xe3a1cbc1, 0xe760d676, 0xea23f0af, 0xeee2ed18,\n0xf0a5bd1d, 0xf464a0aa, 0xf9278673, 0xfde69bc4,\n0x89b8fd09, 0x8d79e0be, 0x803ac667, 0x84fbdbd0,\n0x9abc8bd5, 0x9e7d9662, 0x933eb0bb, 0x97ffad0c,\n0xafb010b1, 0xab710d06, 0xa6322bdf, 0xa2f33668,\n0xbcb4666d, 0xb8757bda, 0xb5365d03, 0xb1f740b4\n};",
            "method_id": 7,
            "loc": 66
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues6(II)V",
            "method_body": "private void sendMTFValues6(final int nGroups, final int alphaSize)\nthrows IOException {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal OutputStream outShadow = this.out;\n\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int t = 0; t < nGroups; t++) {\nbyte[] len_t = len[t];\nint curr = len_t[0] & 0xff;\n\n// inlined: bsW(5, curr);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= curr << (32 - bsLiveShadow - 5);\nbsLiveShadow += 5;\n\nfor (int i = 0; i < alphaSize; i++) {\nint lti = len_t[i] & 0xff;\nwhile (curr < lti) {\n// inlined: bsW(2, 2);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= 2 << (32 - bsLiveShadow - 2);\nbsLiveShadow += 2;\n\ncurr++; /* 10 */\n}\n\nwhile (curr > lti) {\n// inlined: bsW(2, 3);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= 3 << (32 - bsLiveShadow - 2);\nbsLiveShadow += 2;\n\ncurr--; /* 11 */\n}\n\n// inlined: bsW(1, 0);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\n// bsBuffShadow |= 0 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\n}\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}",
            "method_id": 8,
            "loc": 63
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:initBlock()V",
            "method_body": "private void initBlock() throws IOException {\nchar magic0;\nchar magic1;\nchar magic2;\nchar magic3;\nchar magic4;\nchar magic5;\n\nwhile (true) {\n// Get the block magic bytes.\nmagic0 = bsGetUByte();\nmagic1 = bsGetUByte();\nmagic2 = bsGetUByte();\nmagic3 = bsGetUByte();\nmagic4 = bsGetUByte();\nmagic5 = bsGetUByte();\n\n// If isn't end of stream magic, break out of the loop.\nif (magic0 != 0x17 || magic1 != 0x72 || magic2 != 0x45\n|| magic3 != 0x38 || magic4 != 0x50 || magic5 != 0x90) {\nbreak;\n}\n\n// End of stream was reached. Check the combined CRC and\n// advance to the next .bz2 stream if decoding concatenated\n// streams.\nif (complete()) {\nreturn;\n}\n}\n\nif (magic0 != 0x31 || // '1'\nmagic1 != 0x41 || // ')'\nmagic2 != 0x59 || // 'Y'\nmagic3 != 0x26 || // '&'\nmagic4 != 0x53 || // 'S'\nmagic5 != 0x59 // 'Y'\n) {\nthis.currentState = EOF;\nthrow new IOException(\"bad block header\");\n} else {\nthis.storedBlockCRC = bsGetInt();\nthis.blockRandomised = bsR(1) == 1;\n\n/**\n* Allocate data here instead in constructor, so we do not allocate\n* it if the input file is empty.\n*/\nif (this.data == null) {\nthis.data = new Data(this.blockSize100k);\n}\n\n// currBlockNo++;\ngetAndMoveToFrontDecode();\n\nthis.crc.initialiseCRC();\nthis.currentState = START_BLOCK_STATE;\n}\n}",
            "method_id": 9,
            "loc": 59
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:writeRun()V",
            "method_body": "private void writeRun() throws IOException {\nfinal int lastShadow = this.last;\n\nif (lastShadow < this.allowableBlockSize) {\nfinal int currentCharShadow = this.currentChar;\nfinal Data dataShadow = this.data;\ndataShadow.inUse[currentCharShadow] = true;\nfinal byte ch = (byte) currentCharShadow;\n\nint runLengthShadow = this.runLength;\nthis.crc.updateCRC(currentCharShadow, runLengthShadow);\n\nswitch (runLengthShadow) {\ncase 1:\ndataShadow.block[lastShadow + 2] = ch;\nthis.last = lastShadow + 1;\nbreak;\n\ncase 2:\ndataShadow.block[lastShadow + 2] = ch;\ndataShadow.block[lastShadow + 3] = ch;\nthis.last = lastShadow + 2;\nbreak;\n\ncase 3: {\nfinal byte[] block = dataShadow.block;\nblock[lastShadow + 2] = ch;\nblock[lastShadow + 3] = ch;\nblock[lastShadow + 4] = ch;\nthis.last = lastShadow + 3;\n}\nbreak;\n\ndefault: {\nrunLengthShadow -= 4;\ndataShadow.inUse[runLengthShadow] = true;\nfinal byte[] block = dataShadow.block;\nblock[lastShadow + 2] = ch;\nblock[lastShadow + 3] = ch;\nblock[lastShadow + 4] = ch;\nblock[lastShadow + 5] = ch;\nblock[lastShadow + 6] = (byte) runLengthShadow;\nthis.last = lastShadow + 5;\n}\nbreak;\n\n}\n} else {\nendBlock();\ninitBlock();\nwriteRun();\n}\n}",
            "method_id": 10,
            "loc": 53
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues7()V",
            "method_body": "private void sendMTFValues7() throws IOException {\nfinal Data dataShadow = this.data;\nfinal byte[][] len = dataShadow.sendMTFValues_len;\nfinal int[][] code = dataShadow.sendMTFValues_code;\nfinal OutputStream outShadow = this.out;\nfinal byte[] selector = dataShadow.selector;\nfinal char[] sfmap = dataShadow.sfmap;\nfinal int nMTFShadow = this.nMTF;\n\nint selCtr = 0;\n\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int gs = 0; gs < nMTFShadow;) {\nfinal int ge = Math.min(gs + G_SIZE - 1, nMTFShadow - 1);\nfinal int selector_selCtr = selector[selCtr] & 0xff;\nfinal int[] code_selCtr = code[selector_selCtr];\nfinal byte[] len_selCtr = len[selector_selCtr];\n\nwhile (gs <= ge) {\nfinal int sfmap_i = sfmap[gs];\n\n//\n// inlined: bsW(len_selCtr[sfmap_i] & 0xff,\n// code_selCtr[sfmap_i]);\n//\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nfinal int n = len_selCtr[sfmap_i] & 0xFF;\nbsBuffShadow |= code_selCtr[sfmap_i] << (32 - bsLiveShadow - n);\nbsLiveShadow += n;\n\ngs++;\n}\n\ngs = ge + 1;\nselCtr++;\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}",
            "method_id": 11,
            "loc": 46
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues4()V",
            "method_body": "private void sendMTFValues4() throws IOException {\nfinal boolean[] inUse = this.data.inUse;\nfinal boolean[] inUse16 = this.data.sentMTFValues4_inUse16;\n\nfor (int i = 16; --i >= 0;) {\ninUse16[i] = false;\nfinal int i16 = i * 16;\nfor (int j = 16; --j >= 0;) {\nif (inUse[i16 + j]) {\ninUse16[i] = true;\n}\n}\n}\n\nfor (int i = 0; i < 16; i++) {\nbsW(1, inUse16[i] ? 1 : 0);\n}\n\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int i = 0; i < 16; i++) {\nif (inUse16[i]) {\nfinal int i16 = i * 16;\nfor (int j = 0; j < 16; j++) {\n// inlined: bsW(1, inUse[i16 + j] ? 1 : 0);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nif (inUse[i16 + j]) {\nbsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\n}\nbsLiveShadow++;\n}\n}\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}",
            "method_id": 12,
            "loc": 43
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues()V",
            "method_body": "private void sendMTFValues() throws IOException {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal int alphaSize = this.nInUse + 2;\n\nfor (int t = N_GROUPS; --t >= 0;) {\nbyte[] len_t = len[t];\nfor (int v = alphaSize; --v >= 0;) {\nlen_t[v] = GREATER_ICOST;\n}\n}\n\n/* Decide how many coding tables to use */\n// assert (this.nMTF > 0) : this.nMTF;\nfinal int nGroups = (this.nMTF < 200) ? 2 : (this.nMTF < 600) ? 3\n: (this.nMTF < 1200) ? 4 : (this.nMTF < 2400) ? 5 : 6;\n\n/* Generate an initial set of coding tables */\nsendMTFValues0(nGroups, alphaSize);\n\n/*\n* Iterate up to N_ITERS times to improve the tables.\n*/\nfinal int nSelectors = sendMTFValues1(nGroups, alphaSize);\n\n/* Compute MTF values for the selectors. */\nsendMTFValues2(nGroups, nSelectors);\n\n/* Assign actual codes for the tables. */\nsendMTFValues3(nGroups, alphaSize);\n\n/* Transmit the mapping table. */\nsendMTFValues4();\n\n/* Now the selectors. */\nsendMTFValues5(nGroups, nSelectors);\n\n/* Now the coding tables. */\nsendMTFValues6(nGroups, alphaSize);\n\n/* And finally, the block data proper */\nsendMTFValues7();\n}",
            "method_id": 13,
            "loc": 42
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:endBlock()V",
            "method_body": "private void endBlock() throws IOException {\nthis.blockCRC = this.crc.getFinalCRC();\nthis.combinedCRC = (this.combinedCRC << 1) | (this.combinedCRC >>> 31);\nthis.combinedCRC ^= this.blockCRC;\n\n// empty block at end of file\nif (this.last == -1) {\nreturn;\n}\n\n/* sort the block and establish posn of original string */\nblockSort();\n\n/*\n* A 6-byte block header, the value chosen arbitrarily as 0x314159265359\n* :-). A 32 bit value does not really give a strong enough guarantee\n* that the value will not appear by chance in the compressed\n* datastream. Worst-case probability of this event, for a 900k block,\n* is about 2.0e-3 for 32 bits, 1.0e-5 for 40 bits and 4.0e-8 for 48\n* bits. For a compressed file of size 100Gb -- about 100000 blocks --\n* only a 48-bit marker will do. NB: normal compression/ decompression\n* donot rely on these statistical properties. They are only important\n* when trying to recover blocks from damaged files.\n*/\nbsPutUByte(0x31);\nbsPutUByte(0x41);\nbsPutUByte(0x59);\nbsPutUByte(0x26);\nbsPutUByte(0x53);\nbsPutUByte(0x59);\n\n/* Now the block's CRC, so it is in a known place. */\nbsPutInt(this.blockCRC);\n\n/* Now a single bit indicating no randomisation. */\nbsW(1, 0);\n\n/* Finally, block's contents proper. */\nmoveToFrontCodeAndSend();\n}",
            "method_id": 14,
            "loc": 40
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:hbCreateDecodeTables([I[I[I[CIII)V",
            "method_body": "private static void hbCreateDecodeTables(final int[] limit,\nfinal int[] base, final int[] perm, final char[] length,\nfinal int minLen, final int maxLen, final int alphaSize) {\nfor (int i = minLen, pp = 0; i <= maxLen; i++) {\nfor (int j = 0; j < alphaSize; j++) {\nif (length[j] == i) {\nperm[pp++] = j;\n}\n}\n}\n\nfor (int i = MAX_CODE_LEN; --i > 0;) {\nbase[i] = 0;\nlimit[i] = 0;\n}\n\nfor (int i = 0; i < alphaSize; i++) {\nbase[length[i] + 1]++;\n}\n\nfor (int i = 1, b = base[0]; i < MAX_CODE_LEN; i++) {\nb += base[i];\nbase[i] = b;\n}\n\nfor (int i = minLen, vec = 0, b = base[i]; i <= maxLen; i++) {\nfinal int nb = base[i + 1];\nvec += nb - b;\nb = nb;\nlimit[i] = vec - 1;\nvec <<= 1;\n}\n\nfor (int i = minLen + 1; i <= maxLen; i++) {\nbase[i] = ((limit[i - 1] + 1) << 1) - base[i];\n}\n}",
            "method_id": 15,
            "loc": 37
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:read0()I",
            "method_body": "private int read0() throws IOException {\nfinal int retChar = this.currentChar;\nswitch (currentState) {\ncase EOF:\nreturn -1;\n\ncase START_BLOCK_STATE:\nthrow new IllegalStateException();\n\ncase RAND_PART_A_STATE:\nthrow new IllegalStateException();\n\ncase RAND_PART_B_STATE:\nsetupRandPartB();\nbreak;\n\ncase RAND_PART_C_STATE:\nsetupRandPartC();\nbreak;\n\ncase NO_RAND_PART_A_STATE:\nthrow new IllegalStateException();\n\ncase NO_RAND_PART_B_STATE:\nsetupNoRandPartB();\nbreak;\n\ncase NO_RAND_PART_C_STATE:\nsetupNoRandPartC();\nbreak;\n\ndefault:\nthrow new IllegalStateException();\n}\nreturn retChar;\n}",
            "method_id": 16,
            "loc": 36
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues5(II)V",
            "method_body": "private void sendMTFValues5(final int nGroups, final int nSelectors)\nthrows IOException {\nbsW(3, nGroups);\nbsW(15, nSelectors);\n\nfinal OutputStream outShadow = this.out;\nfinal byte[] selectorMtf = this.data.selectorMtf;\n\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nfor (int i = 0; i < nSelectors; i++) {\nfor (int j = 0, hj = selectorMtf[i] & 0xff; j < hj; j++) {\n// inlined: bsW(1, 1);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\nbsBuffShadow |= 1 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\n}\n\n// inlined: bsW(1, 0);\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24);\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\n// bsBuffShadow |= 0 << (32 - bsLiveShadow - 1);\nbsLiveShadow++;\n}\n\nthis.bsBuff = bsBuffShadow;\nthis.bsLive = bsLiveShadow;\n}",
            "method_id": 17,
            "loc": 36
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupBlock()I",
            "method_body": "private int setupBlock() throws IOException {\nif (currentState == EOF || this.data == null) {\nreturn -1;\n}\n\nfinal int[] cftab = this.data.cftab;\nfinal int[] tt = this.data.initTT(this.last + 1);\nfinal byte[] ll8 = this.data.ll8;\ncftab[0] = 0;\nSystem.arraycopy(this.data.unzftab, 0, cftab, 1, 256);\n\nfor (int i = 1, c = cftab[0]; i <= 256; i++) {\nc += cftab[i];\ncftab[i] = c;\n}\n\nfor (int i = 0, lastShadow = this.last; i <= lastShadow; i++) {\ntt[cftab[ll8[i] & 0xff]++] = i;\n}\n\nif ((this.origPtr < 0) || (this.origPtr >= tt.length)) {\nthrow new IOException(\"stream corrupted\");\n}\n\nthis.su_tPos = tt[this.origPtr];\nthis.su_count = 0;\nthis.su_i2 = 0;\nthis.su_ch2 = 256; /* not a char and not EOF */\n\nif (this.blockRandomised) {\nthis.su_rNToGo = 0;\nthis.su_rTPos = 0;\nreturn setupRandPartA();\n}\nreturn setupNoRandPartA();\n}",
            "method_id": 18,
            "loc": 36
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues0(II)V",
            "method_body": "private void sendMTFValues0(final int nGroups, final int alphaSize) {\nfinal byte[][] len = this.data.sendMTFValues_len;\nfinal int[] mtfFreq = this.data.mtfFreq;\n\nint remF = this.nMTF;\nint gs = 0;\n\nfor (int nPart = nGroups; nPart > 0; nPart--) {\nfinal int tFreq = remF / nPart;\nint ge = gs - 1;\nint aFreq = 0;\n\nfor (final int a = alphaSize - 1; (aFreq < tFreq) && (ge < a);) {\naFreq += mtfFreq[++ge];\n}\n\nif ((ge > gs) && (nPart != nGroups) && (nPart != 1)\n&& (((nGroups - nPart) & 1) != 0)) {\naFreq -= mtfFreq[ge--];\n}\n\nfinal byte[] len_np = len[nPart - 1];\nfor (int v = alphaSize; --v >= 0;) {\nif ((v >= gs) && (v <= ge)) {\nlen_np[v] = LESSER_ICOST;\n} else {\nlen_np[v] = GREATER_ICOST;\n}\n}\n\ngs = ge + 1;\nremF -= aFreq;\n}\n}",
            "method_id": 19,
            "loc": 34
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:getAndMoveToFrontDecode0(I)I",
            "method_body": "private int getAndMoveToFrontDecode0(final int groupNo) throws IOException {\nfinal InputStream inShadow = this.in;\nfinal Data dataShadow = this.data;\nfinal int zt = dataShadow.selector[groupNo] & 0xff;\nfinal int[] limit_zt = dataShadow.limit[zt];\nint zn = dataShadow.minLens[zt];\nint zvec = bsR(zn);\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nwhile (zvec > limit_zt[zn]) {\nzn++;\nwhile (bsLiveShadow < 1) {\nfinal int thech = inShadow.read();\n\nif (thech >= 0) {\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\ncontinue;\n} else {\nthrow new IOException(\"unexpected end of stream\");\n}\n}\nbsLiveShadow--;\nzvec = (zvec << 1) | ((bsBuffShadow >> bsLiveShadow) & 1);\n}\n\nthis.bsLive = bsLiveShadow;\nthis.bsBuff = bsBuffShadow;\n\nreturn dataShadow.perm[zt][zvec - dataShadow.base[zt][zn]];\n}",
            "method_id": 20,
            "loc": 32
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackSimpleSort([I[III)V",
            "method_body": "private void fallbackSimpleSort(int[] fmap,\nint[] eclass,\nint lo,\nint hi) {\nif (lo == hi) {\nreturn;\n}\n\nint j;\nif (hi - lo > 3) {\nfor (int i = hi - 4; i >= lo; i--) {\nint tmp = fmap[i];\nint ec_tmp = eclass[tmp];\nfor (j = i + 4; j <= hi && ec_tmp > eclass[fmap[j]];\nj += 4) {\nfmap[j - 4] = fmap[j];\n}\nfmap[j - 4] = tmp;\n}\n}\n\nfor (int i = hi - 1; i >= lo; i--) {\nint tmp = fmap[i];\nint ec_tmp = eclass[tmp];\nfor (j = i + 1; j <= hi && ec_tmp > eclass[fmap[j]]; j++) {\nfmap[j - 1] = fmap[j];\n}\nfmap[j-1] = tmp;\n}\n}",
            "method_id": 21,
            "loc": 30
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:init(Z)Z",
            "method_body": "private boolean init(boolean isFirstStream) throws IOException {\nif (null == in) {\nthrow new IOException(\"No InputStream\");\n}\n\nint magic0 = this.in.read();\nif (magic0 == -1 && !isFirstStream) {\nreturn false;\n}\nint magic1 = this.in.read();\nint magic2 = this.in.read();\n\nif (magic0 != 'B' || magic1 != 'Z' || magic2 != 'h') {\nthrow new IOException(isFirstStream\n? \"Stream is not in the BZip2 format\"\n: \"Garbage after a valid BZip2 stream\");\n}\n\nint blockSize = this.in.read();\nif ((blockSize < '1') || (blockSize > '9')) {\nthrow new IOException(\"BZip2 block size is invalid\");\n}\n\nthis.blockSize100k = blockSize - '0';\n\nthis.bsLive = 0;\nthis.computedCombinedCRC = 0;\n\nreturn true;\n}",
            "method_id": 22,
            "loc": 30
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:read([BII)I",
            "method_body": "public int read(final byte[] dest, final int offs, final int len)\nthrows IOException {\nif (offs < 0) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n}\nif (len < 0) {\nthrow new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n}\nif (offs + len > dest.length) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n+ len + \") > dest.length(\" + dest.length + \").\");\n}\nif (this.in == null) {\nthrow new IOException(\"stream closed\");\n}\n\nfinal int hi = offs + len;\nint destOffs = offs;\nint b;\nwhile (destOffs < hi && ((b = read0()) >= 0)) {\ndest[destOffs++] = (byte) b;\ncount(1);\n}\n\nint c = (destOffs == offs) ? -1 : (destOffs - offs);\nreturn c;\n}",
            "method_id": 23,
            "loc": 27
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:createHuffmanDecodingTables(II)V",
            "method_body": "private void createHuffmanDecodingTables(final int alphaSize,\nfinal int nGroups) {\nfinal Data dataShadow = this.data;\nfinal char[][] len = dataShadow.temp_charArray2d;\nfinal int[] minLens = dataShadow.minLens;\nfinal int[][] limit = dataShadow.limit;\nfinal int[][] base = dataShadow.base;\nfinal int[][] perm = dataShadow.perm;\n\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal char[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal char lent = len_t[i];\nif (lent > maxLen) {\nmaxLen = lent;\n}\nif (lent < minLen) {\nminLen = lent;\n}\n}\nhbCreateDecodeTables(limit[t], base[t], perm[t], len[t], minLen,\nmaxLen, alphaSize);\nminLens[t] = minLen;\n}\n}",
            "method_id": 24,
            "loc": 27
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues2(II)V",
            "method_body": "private void sendMTFValues2(final int nGroups, final int nSelectors) {\n// assert (nGroups < 8) : nGroups;\n\nfinal Data dataShadow = this.data;\nbyte[] pos = dataShadow.sendMTFValues2_pos;\n\nfor (int i = nGroups; --i >= 0;) {\npos[i] = (byte) i;\n}\n\nfor (int i = 0; i < nSelectors; i++) {\nfinal byte ll_i = dataShadow.selector[i];\nbyte tmp = pos[0];\nint j = 0;\n\nwhile (ll_i != tmp) {\nj++;\nbyte tmp2 = tmp;\ntmp = pos[j];\npos[j] = tmp2;\n}\n\npos[0] = tmp;\ndataShadow.selectorMtf[i] = (byte) j;\n}\n}",
            "method_id": 25,
            "loc": 26
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:blockSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;I)V",
            "method_body": "void blockSort(final BZip2CompressorOutputStream.Data data, final int last) {\nthis.workLimit = WORK_FACTOR * last;\nthis.workDone = 0;\nthis.firstAttempt = true;\n\nif (last + 1 < 10000) {\nfallbackSort(data, last);\n} else {\nmainSort(data, last);\n\nif (this.firstAttempt && (this.workDone > this.workLimit)) {\nfallbackSort(data, last);\n}\n}\n\nfinal int[] fmap = data.fmap;\ndata.origPtr = -1;\nfor (int i = 0; i <= last; i++) {\nif (fmap[i] == 0) {\ndata.origPtr = i;\nbreak;\n}\n}\n\n// assert (data.origPtr != -1) : data.origPtr;\n}",
            "method_id": 26,
            "loc": 26
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:sendMTFValues3(II)V",
            "method_body": "private void sendMTFValues3(final int nGroups, final int alphaSize) {\nint[][] code = this.data.sendMTFValues_code;\nbyte[][] len = this.data.sendMTFValues_len;\n\nfor (int t = 0; t < nGroups; t++) {\nint minLen = 32;\nint maxLen = 0;\nfinal byte[] len_t = len[t];\nfor (int i = alphaSize; --i >= 0;) {\nfinal int l = len_t[i] & 0xff;\nif (l > maxLen) {\nmaxLen = l;\n}\nif (l < minLen) {\nminLen = l;\n}\n}\n\n// assert (maxLen <= 20) : maxLen;\n// assert (minLen >= 1) : minLen;\n\nhbAssignCodes(code[t], len[t], minLen, maxLen, alphaSize);\n}\n}",
            "method_id": 27,
            "loc": 24
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsR(I)I",
            "method_body": "private int bsR(final int n) throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nif (bsLiveShadow < n) {\nfinal InputStream inShadow = this.in;\ndo {\nint thech = inShadow.read();\n\nif (thech < 0) {\nthrow new IOException(\"unexpected end of stream\");\n}\n\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\n} while (bsLiveShadow < n);\n\nthis.bsBuff = bsBuffShadow;\n}\n\nthis.bsLive = bsLiveShadow - n;\nreturn (bsBuffShadow >> (bsLiveShadow - n)) & ((1 << n) - 1);\n}",
            "method_id": 28,
            "loc": 23
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write([BII)V",
            "method_body": "public void write(final byte[] buf, int offs, final int len)\nthrows IOException {\nif (offs < 0) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") < 0.\");\n}\nif (len < 0) {\nthrow new IndexOutOfBoundsException(\"len(\" + len + \") < 0.\");\n}\nif (offs + len > buf.length) {\nthrow new IndexOutOfBoundsException(\"offs(\" + offs + \") + len(\"\n+ len + \") > buf.length(\"\n+ buf.length + \").\");\n}\nif (this.out == null) {\nthrow new IOException(\"stream closed\");\n}\n\nfor (int hi = offs + len; offs < hi;) {\nwrite0(buf[offs++]);\n}\n}",
            "method_id": 29,
            "loc": 21
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:write0(I)V",
            "method_body": "private void write0(int b) throws IOException {\nif (this.currentChar != -1) {\nb &= 0xff;\nif (this.currentChar == b) {\nif (++this.runLength > 254) {\nwriteRun();\nthis.currentChar = -1;\nthis.runLength = 0;\n}\n// else nothing to do\n} else {\nwriteRun();\nthis.runLength = 1;\nthis.currentChar = b;\n}\n} else {\nthis.currentChar = b & 0xff;\nthis.runLength++;\n}\n}",
            "method_id": 30,
            "loc": 20
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetBit()Z",
            "method_body": "private boolean bsGetBit() throws IOException {\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nif (bsLiveShadow < 1) {\nint thech = this.in.read();\n\nif (thech < 0) {\nthrow new IOException(\"unexpected end of stream\");\n}\n\nbsBuffShadow = (bsBuffShadow << 8) | thech;\nbsLiveShadow += 8;\nthis.bsBuff = bsBuffShadow;\n}\n\nthis.bsLive = bsLiveShadow - 1;\nreturn ((bsBuffShadow >> (bsLiveShadow - 1)) & 1) != 0;\n}",
            "method_id": 31,
            "loc": 19
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupNoRandPartA()I",
            "method_body": "private int setupNoRandPartA() throws IOException {\nif (this.su_i2 <= this.last) {\nthis.su_chPrev = this.su_ch2;\nint su_ch2Shadow = this.data.ll8[this.su_tPos] & 0xff;\nthis.su_ch2 = su_ch2Shadow;\nthis.su_tPos = this.data.tt[this.su_tPos];\nthis.su_i2++;\nthis.currentChar = su_ch2Shadow;\nthis.currentState = NO_RAND_PART_B_STATE;\nthis.crc.updateCRC(su_ch2Shadow);\nreturn su_ch2Shadow;\n} else {\nthis.currentState = NO_RAND_PART_A_STATE;\nendBlock();\ninitBlock();\nreturn setupBlock();\n}\n}",
            "method_id": 32,
            "loc": 18
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:endBlock()V",
            "method_body": "private void endBlock() throws IOException {\nthis.computedBlockCRC = this.crc.getFinalCRC();\n\n// A bad CRC is considered a fatal error.\nif (this.storedBlockCRC != this.computedBlockCRC) {\n// make next blocks readable without error\n// (repair feature, not yet documented, not tested)\nthis.computedCombinedCRC = (this.storedCombinedCRC << 1)\n| (this.storedCombinedCRC >>> 31);\nthis.computedCombinedCRC ^= this.storedBlockCRC;\n\nthrow new IOException(\"BZip2 CRC error\");\n}\n\nthis.computedCombinedCRC = (this.computedCombinedCRC << 1)\n| (this.computedCombinedCRC >>> 31);\nthis.computedCombinedCRC ^= this.computedBlockCRC;\n}",
            "method_id": 33,
            "loc": 18
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:endCompression()V",
            "method_body": "private void endCompression() throws IOException {\n/*\n* Now another magic 48-bit number, 0x177245385090, to indicate the end\n* of the last block. (sqrt(pi), if you want to know. I did want to use\n* e, but it contains too much repetition -- 27 18 28 18 28 46 -- for me\n* to feel statistically comfortable. Call me paranoid.)\n*/\nbsPutUByte(0x17);\nbsPutUByte(0x72);\nbsPutUByte(0x45);\nbsPutUByte(0x38);\nbsPutUByte(0x50);\nbsPutUByte(0x90);\n\nbsPutInt(this.combinedCRC);\nbsFinishedWithStream();\n}",
            "method_id": 34,
            "loc": 17
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:finish()V",
            "method_body": "public void finish() throws IOException {\nif (out != null) {\ntry {\nif (this.runLength > 0) {\nwriteRun();\n}\nthis.currentChar = -1;\nendBlock();\nendCompression();\n} finally {\nthis.out = null;\nthis.data = null;\nthis.blockSorter = null;\n}\n}\n}",
            "method_id": 35,
            "loc": 16
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;I)V",
            "method_body": "public BZip2CompressorOutputStream(final OutputStream out, final int blockSize) throws IOException {\nif (blockSize < 1) {\nthrow new IllegalArgumentException(\"blockSize(\" + blockSize + \") < 1\");\n}\nif (blockSize > 9) {\nthrow new IllegalArgumentException(\"blockSize(\" + blockSize + \") > 9\");\n}\n\nthis.blockSize100k = blockSize;\nthis.out = out;\n\n/* 20 is just a paranoia constant */\nthis.allowableBlockSize = (this.blockSize100k * BZip2Constants.BASEBLOCKSIZE) - 20;\ninit();\n}",
            "method_id": 36,
            "loc": 15
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:init()V",
            "method_body": "private void init() throws IOException {\nbsPutUByte('B');\nbsPutUByte('Z');\n\nthis.data = new Data(this.blockSize100k);\nthis.blockSorter = new BlockSort(this.data);\n\n// huffmanised magic bytes\nbsPutUByte('h');\nbsPutUByte('0' + this.blockSize100k);\n\nthis.combinedCRC = 0;\ninitBlock();\n}",
            "method_id": 37,
            "loc": 14
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:hbAssignCodes([I[BIII)V",
            "method_body": "private static void hbAssignCodes(final int[] code, final byte[] length,\nfinal int minLen, final int maxLen,\nfinal int alphaSize) {\nint vec = 0;\nfor (int n = minLen; n <= maxLen; n++) {\nfor (int i = 0; i < alphaSize; i++) {\nif ((length[i] & 0xff) == n) {\ncode[i] = vec;\nvec++;\n}\n}\nvec <<= 1;\n}\n}",
            "method_id": 38,
            "loc": 14
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsW(II)V",
            "method_body": "private void bsW(final int n, final int v) throws IOException {\nfinal OutputStream outShadow = this.out;\nint bsLiveShadow = this.bsLive;\nint bsBuffShadow = this.bsBuff;\n\nwhile (bsLiveShadow >= 8) {\noutShadow.write(bsBuffShadow >> 24); // write 8-bit\nbsBuffShadow <<= 8;\nbsLiveShadow -= 8;\n}\n\nthis.bsBuff = bsBuffShadow | (v << (32 - bsLiveShadow - n));\nthis.bsLive = bsLiveShadow + n;\n}",
            "method_id": 39,
            "loc": 14
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fallbackSort(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;I)V",
            "method_body": "final void fallbackSort(final BZip2CompressorOutputStream.Data data,\nfinal int last) {\ndata.block[0] = data.block[last + 1];\nfallbackSort(data.fmap, data.block, last + 1);\nfor (int i = 0; i < last + 1; i++) {\n--data.fmap[i];\n}\nfor (int i = 0; i < last + 1; i++) {\nif (data.fmap[i] == -1) {\ndata.fmap[i] = last;\nbreak;\n}\n}\n}",
            "method_id": 40,
            "loc": 14
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:makeMaps()V",
            "method_body": "private void makeMaps() {\nfinal boolean[] inUse = this.data.inUse;\nfinal byte[] seqToUnseq = this.data.seqToUnseq;\n\nint nInUseShadow = 0;\n\nfor (int i = 0; i < 256; i++) {\nif (inUse[i]) {\nseqToUnseq[nInUseShadow++] = (byte) i;\n}\n}\n\nthis.nInUse = nInUseShadow;\n}",
            "method_id": 41,
            "loc": 14
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:close()V",
            "method_body": "public void close() throws IOException {\nInputStream inShadow = this.in;\nif (inShadow != null) {\ntry {\nif (inShadow != System.in) {\ninShadow.close();\n}\n} finally {\nthis.data = null;\nthis.in = null;\n}\n}\n}",
            "method_id": 42,
            "loc": 13
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:setupNoRandPartB()I",
            "method_body": "private int setupNoRandPartB() throws IOException {\nif (this.su_ch2 != this.su_chPrev) {\nthis.su_count = 1;\nreturn setupNoRandPartA();\n} else if (++this.su_count >= 4) {\nthis.su_z = (char) (this.data.ll8[this.su_tPos] & 0xff);\nthis.su_tPos = this.data.tt[this.su_tPos];\nthis.su_j2 = 0;\nreturn setupNoRandPartC();\n} else {\nreturn setupNoRandPartA();\n}\n}",
            "method_id": 43,
            "loc": 13
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:initTT(I)[I",
            "method_body": "int[] initTT(int length) {\nint[] ttShadow = this.tt;\n\n// tt.length should always be >= length, but theoretically\n// it can happen, if the compressor mixed small and large\n// blocks. Normally only the last block will be smaller\n// than others.\nif ((ttShadow == null) || (ttShadow.length < length)) {\nthis.tt = ttShadow = new int[length];\n}\n\nreturn ttShadow;\n}",
            "method_id": 44,
            "loc": 13
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:initBlock()V",
            "method_body": "private void initBlock() {\n// blockNo++;\nthis.crc.initialiseCRC();\nthis.last = -1;\n// ch = 0;\n\nboolean[] inUse = this.data.inUse;\nfor (int i = 256; --i >= 0;) {\ninUse[i] = false;\n}\n\n}",
            "method_id": 45,
            "loc": 12
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:updateCRC(II)V",
            "method_body": "void updateCRC(int inCh, int repeat) {\nint globalCrcShadow = this.globalCrc;\nwhile (repeat-- > 0) {\nint temp = (globalCrcShadow >> 24) ^ inCh;\nglobalCrcShadow = (globalCrcShadow << 8) ^ crc32Table[(temp >= 0)\n? temp\n: (temp + 256)];\n}\nthis.globalCrc = globalCrcShadow;\n}",
            "method_id": 46,
            "loc": 10
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:<init>(Ljava/io/InputStream;Z)V",
            "method_body": "public BZip2CompressorInputStream(final InputStream in, final boolean decompressConcatenated) throws IOException {\nthis.in = in;\nthis.decompressConcatenated = decompressConcatenated;\n\ninit(true);\ninitBlock();\nsetupBlock();\n}",
            "method_id": 47,
            "loc": 8
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsFinishedWithStream()V",
            "method_body": "private void bsFinishedWithStream() throws IOException {\nwhile (this.bsLive > 0) {\nint ch = this.bsBuff >> 24;\nthis.out.write(ch); // write 8-bit\nthis.bsBuff <<= 8;\nthis.bsLive -= 8;\n}\n}",
            "method_id": 48,
            "loc": 8
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:close()V",
            "method_body": "public void close() throws IOException {\nif (out != null) {\nOutputStream outShadow = this.out;\nfinish();\noutShadow.close();\n}\n}",
            "method_id": 49,
            "loc": 7
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:updateCRC(I)V",
            "method_body": "void updateCRC(int inCh) {\nint temp = (globalCrc >> 24) ^ inCh;\nif (temp < 0) {\ntemp = 256 + temp;\n}\nglobalCrc = (globalCrc << 8) ^ CRC.crc32Table[temp];\n}",
            "method_id": 50,
            "loc": 7
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsPutInt(I)V",
            "method_body": "private void bsPutInt(final int u) throws IOException {\nbsW(8, (u >> 24) & 0xff);\nbsW(8, (u >> 16) & 0xff);\nbsW(8, (u >> 8) & 0xff);\nbsW(8, u & 0xff);\n}",
            "method_id": 51,
            "loc": 6
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream$Data:<init>(I)V",
            "method_body": "Data(int blockSize100k) {\nfinal int n = blockSize100k * BZip2Constants.BASEBLOCKSIZE;\nthis.block = new byte[(n + 1 + NUM_OVERSHOOT_BYTES)];\nthis.fmap = new int[n];\nthis.sfmap = new char[2 * n];\n}",
            "method_id": 52,
            "loc": 6
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fvswap([IIII)V",
            "method_body": "private void fvswap(int[] fmap, int yyp1, int yyp2, int yyn) {\nwhile (yyn > 0) {\nfswap(fmap, yyp1, yyp2);\nyyp1++; yyp2++; yyn--;\n}\n}",
            "method_id": 53,
            "loc": 6
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.CompressorInputStream:count(J)V",
            "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}",
            "method_id": 54,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:moveToFrontCodeAndSend()V",
            "method_body": "private void moveToFrontCodeAndSend() throws IOException {\nbsW(24, this.data.origPtr);\ngenerateMTFValues();\nsendMTFValues();\n}",
            "method_id": 55,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fswap([III)V",
            "method_body": "private void fswap(int[] fmap, int zz1, int zz2) {\nint zztmp = fmap[zz1];\nfmap[zz1] = fmap[zz2];\nfmap[zz2] = zztmp;\n}",
            "method_id": 56,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:<init>(Ljava/io/OutputStream;)V",
            "method_body": "public BZip2CompressorOutputStream(final OutputStream out)\nthrows IOException {\nthis(out, MAX_BLOCKSIZE);\n}",
            "method_id": 57,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fpush(III)V",
            "method_body": "private void fpush(int sp, int lz, int hz) {\nstack_ll[sp] = lz;\nstack_hh[sp] = hz;\n}",
            "method_id": 58,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:getEclass()[I",
            "method_body": "private int[] getEclass() {\nreturn eclass == null\n? (eclass = new int[quadrant.length / 2]) : eclass;\n}",
            "method_id": 59,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.CompressorInputStream:count(I)V",
            "method_body": "protected void count(int read) {\ncount((long) read);\n}",
            "method_id": 60,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:bsPutUByte(I)V",
            "method_body": "private void bsPutUByte(final int c) throws IOException {\nbsW(8, c);\n}",
            "method_id": 61,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorOutputStream:blockSort()V",
            "method_body": "private void blockSort() {\nblockSorter.blockSort(data, last);\n}",
            "method_id": 62,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:<init>()V",
            "method_body": "CRC() {\ninitialiseCRC();\n}",
            "method_id": 63,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:initialiseCRC()V",
            "method_body": "void initialiseCRC() {\nglobalCrc = 0xffffffff;\n}",
            "method_id": 64,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.CRC:getFinalCRC()I",
            "method_body": "int getFinalCRC() {\nreturn ~globalCrc;\n}",
            "method_id": 65,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:<init>(Lorg/apache/commons/compress/compressors/bzip2/BZip2CompressorOutputStream$Data;)V",
            "method_body": "BlockSort(final BZip2CompressorOutputStream.Data data) {\nthis.quadrant = data.sfmap;\n}",
            "method_id": 66,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:<clinit>()V",
            "method_body": "private static final int[] INCS = { 1, 4, 13, 40, 121, 364, 1093, 3280,\n9841, 29524, 88573, 265720, 797161,\n2391484 };",
            "method_id": 67,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fmin(II)I",
            "method_body": "private int fmin(int a, int b) {\nreturn a < b ? a : b;\n}",
            "method_id": 68,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BlockSort:fpop(I)[I",
            "method_body": "private int[] fpop(int sp) {\nreturn new int[] { stack_ll[sp], stack_hh[sp] };\n}",
            "method_id": 69,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetUByte()C",
            "method_body": "private char bsGetUByte() throws IOException {\nreturn (char) bsR(8);\n}",
            "method_id": 70,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream:bsGetInt()I",
            "method_body": "private int bsGetInt() throws IOException {\nreturn (((((bsR(8) << 8) | bsR(8)) << 8) | bsR(8)) << 8) | bsR(8);\n}",
            "method_id": 71,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.compress.compressors.bzip2.BZip2CompressorInputStream$Data:<init>(I)V",
            "method_body": "Data(int blockSize100k) {\nthis.ll8 = new byte[blockSize100k * BZip2Constants.BASEBLOCKSIZE];\n}",
            "method_id": 72,
            "loc": 3
        }
    ]
}