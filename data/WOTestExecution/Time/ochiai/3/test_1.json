{
    "bug_id": 3,
    "test_id": 1,
    "test_name": "org.joda.time.TestMutableDateTime_Adds.testAddDays_int_dstOverlapWinter_addZero",
    "test_body": "public void testAddDays_int_dstOverlapWinter_addZero() {\nMutableDateTime test = new MutableDateTime(2011, 10, 30, 2, 30, 0, 0, DateTimeZone.forID(\"Europe/Berlin\"));\ntest.addHours(1);\nassertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\ntest.addDays(0);\nassertEquals(\"2011-10-30T02:30:00.000+01:00\", test.toString());\n}\n",
    "stack_trace": "junit.framework.ComparisonFailure: expected:<...10-30T02:30:00.000+0[1]:00> but was:<...10-30T02:30:00.000+0[2]:00>\nat junit.framework.Assert.assertEquals(Assert.java:100)\nat junit.framework.Assert.assertEquals(Assert.java:107)\nat junit.framework.TestCase.assertEquals(TestCase.java:269)\nat org.joda.time.TestMutableDateTime_Adds.testAddDays_int_dstOverlapWinter_addZero(TestMutableDateTime_Adds.java:271)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.MutableDateTime:addHours(I)V",
            "method_body": "public void addHours(final int hours) {\nsetMillis(getChronology().hours().add(getMillis(), hours));\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.joda.time.MutableDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
            "method_body": "public MutableDateTime(\nint year,\nint monthOfYear,\nint dayOfMonth,\nint hourOfDay,\nint minuteOfHour,\nint secondOfMinute,\nint millisOfSecond,\nDateTimeZone zone) {\nsuper(year, monthOfYear, dayOfMonth,\nhourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, zone);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.joda.time.MutableDateTime:addDays(I)V",
            "method_body": "public void addDays(final int days) {\nsetMillis(getChronology().days().add(getMillis(), days));\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.joda.time.MutableDateTime:toString()Ljava/lang/String;",
            "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:getOffsetFromLocalToSubtract(J)I",
            "method_body": "private int getOffsetFromLocalToSubtract(long instant) {\nint offset = this.iZone.getOffsetFromLocal(instant);\nlong diff = instant - offset;\n// If there is a sign change, but the two values have different signs...\nif ((instant ^ diff) < 0 && (instant ^ offset) < 0) {\nthrow new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n}\nreturn offset;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:setMillis(J)V",
            "method_body": "protected void setMillis(long instant) {\niMillis = checkInstant(instant, iChronology);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.joda.time.MutableDateTime:setMillis(J)V",
            "method_body": "public void setMillis(long instant) {\nswitch (iRoundingMode) {\ncase ROUND_NONE:\nbreak;\ncase ROUND_FLOOR:\ninstant = iRoundingField.roundFloor(instant);\nbreak;\ncase ROUND_CEILING:\ninstant = iRoundingField.roundCeiling(instant);\nbreak;\ncase ROUND_HALF_FLOOR:\ninstant = iRoundingField.roundHalfFloor(instant);\nbreak;\ncase ROUND_HALF_CEILING:\ninstant = iRoundingField.roundHalfCeiling(instant);\nbreak;\ncase ROUND_HALF_EVEN:\ninstant = iRoundingField.roundHalfEven(instant);\nbreak;\n}\nsuper.setMillis(instant);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:add(JI)J",
            "method_body": "public long add(long instant, int value) {\nint offset = getOffsetToAdd(instant);\ninstant = iField.add(instant + offset, value);\nreturn instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:getOffsetToAdd(J)I",
            "method_body": "private int getOffsetToAdd(long instant) {\nint offset = this.iZone.getOffset(instant);\nlong sum = instant + offset;\n// If there is a sign change, but the two values have the same sign...\nif ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\nthrow new ArithmeticException(\"Adding time zone offset caused overflow\");\n}\nreturn offset;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:<init>(IIIIIIILorg/joda/time/DateTimeZone;)V",
            "method_body": "public BaseDateTime(\nint year,\nint monthOfYear,\nint dayOfMonth,\nint hourOfDay,\nint minuteOfHour,\nint secondOfMinute,\nint millisOfSecond,\nDateTimeZone zone) {\nthis(year, monthOfYear, dayOfMonth, hourOfDay,\nminuteOfHour, secondOfMinute, millisOfSecond, ISOChronology.getInstance(zone));\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.joda.time.format.ISODateTimeFormat:dateTime()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter dateTime() {\nreturn Constants.dt;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nStringBuffer buf, long instant, Chronology chrono,\nint displayOffset, DateTimeZone displayZone, Locale locale) {\ntry {\nprintTo(buf, null, instant, chrono);\n} catch (IOException e) {\n// Not gonna happen.\n}\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nStringBuffer buf, long instant, Chronology chrono,\nint displayOffset, DateTimeZone displayZone, Locale locale) {\nif (displayZone == null) {\nreturn;  // no zone\n}\nif (displayOffset == 0 && iZeroOffsetPrintText != null) {\nbuf.append(iZeroOffsetPrintText);\nreturn;\n}\nif (displayOffset >= 0) {\nbuf.append('+');\n} else {\nbuf.append('-');\ndisplayOffset = -displayOffset;\n}\n\nint hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\nif (iMaxFields == 1) {\nreturn;\n}\ndisplayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\nif (displayOffset == 0 && iMinFields <= 1) {\nreturn;\n}\n\nint minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\nif (iShowSeparators) {\nbuf.append(':');\n}\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\nif (iMaxFields == 2) {\nreturn;\n}\ndisplayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (displayOffset == 0 && iMinFields <= 2) {\nreturn;\n}\n\nint seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\nif (iShowSeparators) {\nbuf.append(':');\n}\nFormatUtils.appendPaddedInteger(buf, seconds, 2);\nif (iMaxFields == 3) {\nreturn;\n}\ndisplayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\nif (displayOffset == 0 && iMinFields <= 3) {\nreturn;\n}\n\nif (iShowSeparators) {\nbuf.append('.');\n}\nFormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:printTo(Ljava/lang/StringBuffer;Ljava/io/Writer;JLorg/joda/time/Chronology;)V",
            "method_body": "protected void printTo(StringBuffer buf, Writer out, long instant, Chronology chrono)\nthrows IOException\n{\nDateTimeField field = iFieldType.getField(chrono);\nint minDigits = iMinDigits;\n\nlong fraction;\ntry {\nfraction = field.remainder(instant);\n} catch (RuntimeException e) {\nif (buf != null) {\nappendUnknownString(buf, minDigits);\n} else {\nprintUnknownString(out, minDigits);\n}\nreturn;\n}\n\nif (fraction == 0) {\nif (buf != null) {\nwhile (--minDigits >= 0) {\nbuf.append('0');\n}\n} else {\nwhile (--minDigits >= 0) {\nout.write('0');\n}\n}\nreturn;\n}\n\nString str;\nlong[] fractionData = getFractionData(fraction, field);\nlong scaled = fractionData[0];\nint maxDigits = (int) fractionData[1];\n\nif ((scaled & 0x7fffffff) == scaled) {\nstr = Integer.toString((int) scaled);\n} else {\nstr = Long.toString(scaled);\n}\n\nint length = str.length();\nint digits = maxDigits;\nwhile (length < digits) {\nif (buf != null) {\nbuf.append('0');\n} else {\nout.write('0');\n}\nminDigits--;\ndigits--;\n}\n\nif (minDigits < digits) {\n// Chop off as many trailing zero digits as necessary.\nwhile (minDigits < digits) {\nif (length <= 1 || str.charAt(length - 1) != '0') {\nbreak;\n}\ndigits--;\nlength--;\n}\nif (length < str.length()) {\nif (buf != null) {\nfor (int i=0; i<length; i++) {\nbuf.append(str.charAt(i));\n}\n} else {\nfor (int i=0; i<length; i++) {\nout.write(str.charAt(i));\n}\n}\nreturn;\n}\n}\n\nif (buf != null) {\nbuf.append(str);\n} else {\nout.write(str);\n}\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:remainder(J)J",
            "method_body": "public long remainder(long instant) {\nif (instant >= 0) {\nreturn instant % iUnitMillis;\n} else {\nreturn (instant + 1) % iUnitMillis + iUnitMillis - 1;\n}\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nStringBuffer buf, long instant, Chronology chrono,\nint displayOffset, DateTimeZone displayZone, Locale locale) {\nbuf.append(iValue);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nStringBuffer buf, long instant, Chronology chrono,\nint displayOffset, DateTimeZone displayZone, Locale locale) {\ntry {\nDateTimeField field = iFieldType.getField(chrono);\nFormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n} catch (RuntimeException e) {\nappendUnknownString(buf, iMinPrintedDigits);\n}\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nStringBuffer buf, long instant, Chronology chrono,\nint displayOffset, DateTimeZone displayZone, Locale locale) {\nDateTimePrinter[] elements = iPrinters;\nif (elements == null) {\nthrow new UnsupportedOperationException();\n}\n\nif (locale == null) {\n// Guard against default locale changing concurrently.\nlocale = Locale.getDefault();\n}\n\nint len = elements.length;\nfor (int i = 0; i < len; i++) {\nelements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n}\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
            "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
            "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
            "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\n// Shift instant into local time (UTC) to avoid excessive offset\n// calculations when printing multiple fields in a composite printer.\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n// Time zone offset overflow, so revert to UTC.\nzone = DateTimeZone.UTC;\noffset = 0;\nadjustedInstant = instant;\n}\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nreturn iPrintedLengthEstimate;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
            "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nthrow new UnsupportedOperationException(\"Printing not supported\");\n}\nreturn printer;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:previousTransition(J)J",
            "method_body": "public long previousTransition(long instant) {\n// Increment in order to handle the case where instant is exactly at\n// a transition.\ninstant++;\n\nint standardOffset = iStandardOffset;\nRecurrence startRecurrence = iStartRecurrence;\nRecurrence endRecurrence = iEndRecurrence;\n\nlong start, end;\n\ntry {\nstart = startRecurrence.previous\n(instant, standardOffset, endRecurrence.getSaveMillis());\nif (instant < 0 && start > 0) {\n// Overflowed.\nstart = instant;\n}\n} catch (IllegalArgumentException e) {\n// Overflowed.\nstart = instant;\n} catch (ArithmeticException e) {\n// Overflowed.\nstart = instant;\n}\n\ntry {\nend = endRecurrence.previous\n(instant, standardOffset, startRecurrence.getSaveMillis());\nif (instant < 0 && end > 0) {\n// Overflowed.\nend = instant;\n}\n} catch (IllegalArgumentException e) {\n// Overflowed.\nend = instant;\n} catch (ArithmeticException e) {\n// Overflowed.\nend = instant;\n}\n\nreturn ((start > end) ? start : end) - 1;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence:previous(JII)J",
            "method_body": "public long previous(long instant, int standardOffset, int saveMillis) {\nreturn iOfYear.previous(instant, standardOffset, saveMillis);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:previous(JII)J",
            "method_body": "public long previous(long instant, int standardOffset, int saveMillis) {\nint offset;\nif (iMode == 'w') {\noffset = standardOffset + saveMillis;\n} else if (iMode == 's') {\noffset = standardOffset;\n} else {\noffset = 0;\n}\n\n// Convert from UTC to local time.\ninstant += offset;\n\nChronology chrono = ISOChronology.getInstanceUTC();\nlong prev = chrono.monthOfYear().set(instant, iMonthOfYear);\n// Be lenient with millisOfDay.\nprev = chrono.millisOfDay().set(prev, 0);\nprev = chrono.millisOfDay().add(prev, iMillisOfDay);\nprev = setDayOfMonthPrevious(chrono, prev);\n\nif (iDayOfWeek == 0) {\nif (prev >= instant) {\nprev = chrono.year().add(prev, -1);\nprev = setDayOfMonthPrevious(chrono, prev);\n}\n} else {\nprev = setDayOfWeek(chrono, prev);\nif (prev >= instant) {\nprev = chrono.year().add(prev, -1);\nprev = chrono.monthOfYear().set(prev, iMonthOfYear);\nprev = setDayOfMonthPrevious(chrono, prev);\nprev = setDayOfWeek(chrono, prev);\n}\n}\n\n// Convert from local time to UTC.\nreturn prev - offset;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:setDayOfMonthPrevious(Lorg/joda/time/Chronology;J)J",
            "method_body": "private long setDayOfMonthPrevious(Chronology chrono, long prev) {\ntry {\nprev = setDayOfMonth(chrono, prev);\n} catch (IllegalArgumentException e) {\nif (iMonthOfYear == 2 && iDayOfMonth == 29) {\nwhile (chrono.year().isLeap(prev) == false) {\nprev = chrono.year().add(prev, -1);\n}\nprev = setDayOfMonth(chrono, prev);\n} else {\nthrow e;\n}\n}\nreturn prev;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getInstantChronology(Lorg/joda/time/ReadableInstant;)Lorg/joda/time/Chronology;",
            "method_body": "public static final Chronology getInstantChronology(ReadableInstant instant) {\nif (instant == null) {\nreturn ISOChronology.getInstance();\n}\nChronology chrono = instant.getChronology();\nif (chrono == null) {\nreturn ISOChronology.getInstance();\n}\nreturn chrono;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
            "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nbuf.append('-');\nif (value != Integer.MIN_VALUE) {\nvalue = -value;\n} else {\nfor (; size > 10; size--) {\nbuf.append('0');\n}\nbuf.append(\"\" + -(long)Integer.MIN_VALUE);\nreturn;\n}\n}\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\n}\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nbuf.append('0');\n}\n// Calculate value div/mod by 10 without using two expensive\n// division operations. (2 ^ 27) / 10 = 13421772. Add one to\n// value to correct rounding error.\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\n// Append remainder by calculating (value - d * 10).\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nint digits;\nif (value < 1000) {\ndigits = 3;\n} else if (value < 10000) {\ndigits = 4;\n} else {\ndigits = (int)(Math.log(value) / LOG_10) + 1;\n}\nfor (; size > digits; size--) {\nbuf.append('0');\n}\nbuf.append(Integer.toString(value));\n}\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getInstantMillis(Lorg/joda/time/ReadableInstant;)J",
            "method_body": "public static final long getInstantMillis(ReadableInstant instant) {\nif (instant == null) {\nreturn DateTimeUtils.currentTimeMillis();\n}\nreturn instant.getMillis();\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:previousTransition(J)J",
            "method_body": "public long previousTransition(long instant) {\nlong[] transitions = iTransitions;\nint i = Arrays.binarySearch(transitions, instant);\nif (i >= 0) {\nif (instant > Long.MIN_VALUE) {\nreturn instant - 1;\n}\nreturn instant;\n}\ni = ~i;\nif (i < transitions.length) {\nif (i > 0) {\nlong prev = transitions[i - 1];\nif (prev > Long.MIN_VALUE) {\nreturn prev - 1;\n}\n}\nreturn instant;\n}\nif (iTailZone != null) {\nlong prev = iTailZone.previousTransition(instant);\nif (prev < instant) {\nreturn prev;\n}\n}\nlong prev = transitions[i - 1];\nif (prev > Long.MIN_VALUE) {\nreturn prev - 1;\n}\nreturn instant;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:previousTransition(J)J",
            "method_body": "public long previousTransition(long instant) {\nreturn iZone.previousTransition(instant);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:localToUTC(J)J",
            "method_body": "private long localToUTC(long localInstant) {\nDateTimeZone zone = getZone();\nint offset = zone.getOffsetFromLocal(localInstant);\nlocalInstant -= offset;\nif (offset != zone.getOffset(localInstant)) {\nthrow new IllegalInstantException(localInstant, zone.getID());\n}\nreturn localInstant;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:getDateTimeMillis(IIIIIII)J",
            "method_body": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\nint hourOfDay, int minuteOfHour,\nint secondOfMinute, int millisOfSecond)\nthrows IllegalArgumentException\n{\nreturn localToUTC(getBase().getDateTimeMillis\n(year, monthOfYear, dayOfMonth,\nhourOfDay, minuteOfHour, secondOfMinute, millisOfSecond));\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\n}\nif (iZone != null) {\nchrono = chrono.withZone(iZone);\n}\nreturn chrono;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getOffsetFromLocal(J)I",
            "method_body": "public int getOffsetFromLocal(long instantLocal) {\n// get the offset at instantLocal (first estimate)\nfinal int offsetLocal = getOffset(instantLocal);\n// adjust instantLocal using the estimate and recalc the offset\nfinal long instantAdjusted = instantLocal - offsetLocal;\nfinal int offsetAdjusted = getOffset(instantAdjusted);\n// if the offsets differ, we must be near a DST boundary\nif (offsetLocal != offsetAdjusted) {\n// we need to ensure that time is always after the DST gap\n// this happens naturally for positive offsets, but not for negative\nif ((offsetLocal - offsetAdjusted) < 0) {\n// if we just return offsetAdjusted then the time is pushed\n// back before the transition, whereas it should be\n// on or after the transition\nlong nextLocal = nextTransition(instantAdjusted);\nlong nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\nif (nextLocal != nextAdjusted) {\nreturn offsetLocal;\n}\n}\n} else if (offsetLocal >= 0) {\nlong prev = previousTransition(instantAdjusted);\nif (prev < instantAdjusted) {\nint offsetPrev = getOffset(prev);\nint diff = offsetPrev - offsetLocal;\nif (instantAdjusted - prev <= diff) {\nreturn offsetPrev;\n}\n}\n}\nreturn offsetAdjusted;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:add(JI)J",
            "method_body": "public long add(long instant, int months) {\nif (months == 0) {\nreturn instant; // the easy case\n}\n//\n// Save time part first.\n//\nlong timePart = iChronology.getMillisOfDay(instant);\n//\n//\n// Get this year and month.\n//\nint thisYear = iChronology.getYear(instant);\nint thisMonth = iChronology.getMonthOfYear(instant, thisYear);\n// ----------------------------------------------------------\n//\n// Do not refactor without careful consideration.\n// Order of calculation is important.\n//\nint yearToUse;\n// Initially, monthToUse is zero-based\nint monthToUse = thisMonth - 1 + months;\nif (monthToUse >= 0) {\nyearToUse = thisYear + (monthToUse / iMax);\nmonthToUse = (monthToUse % iMax) + 1;\n} else {\nyearToUse = thisYear + (monthToUse / iMax) - 1;\nmonthToUse = Math.abs(monthToUse);\nint remMonthToUse = monthToUse % iMax;\n// Take care of the boundary condition\nif (remMonthToUse == 0) {\nremMonthToUse = iMax;\n}\nmonthToUse = iMax - remMonthToUse + 1;\n// Take care of the boundary condition\nif (monthToUse == 1) {\nyearToUse += 1;\n}\n}\n// End of do not refactor.\n// ----------------------------------------------------------\n\n//\n// Quietly force DOM to nearest sane value.\n//\nint dayToUse = iChronology.getDayOfMonth(instant, thisYear, thisMonth);\nint maxDay = iChronology.getDaysInYearMonth(yearToUse, monthToUse);\nif (dayToUse > maxDay) {\ndayToUse = maxDay;\n}\n//\n// get proper date part, and return result\n//\nlong datePart =\niChronology.getYearMonthDayMillis(yearToUse, monthToUse, dayToUse);\nreturn datePart + timePart;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:setDayOfWeek(Lorg/joda/time/Chronology;J)J",
            "method_body": "private long setDayOfWeek(Chronology chrono, long instant) {\nint dayOfWeek = chrono.dayOfWeek().get(instant);\nint daysToAdd = iDayOfWeek - dayOfWeek;\nif (daysToAdd != 0) {\nif (iAdvance) {\nif (daysToAdd < 0) {\ndaysToAdd += 7;\n}\n} else {\nif (daysToAdd > 0) {\ndaysToAdd -= 7;\n}\n}\ninstant = chrono.dayOfWeek().add(instant, daysToAdd);\n}\nreturn instant;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence:getSaveMillis()I",
            "method_body": "public int getSaveMillis() {\nreturn iSaveMillis;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:setDayOfMonth(Lorg/joda/time/Chronology;J)J",
            "method_body": "private long setDayOfMonth(Chronology chrono, long instant) {\nif (iDayOfMonth >= 0) {\ninstant = chrono.dayOfMonth().set(instant, iDayOfMonth);\n} else {\ninstant = chrono.dayOfMonth().set(instant, 1);\ninstant = chrono.monthOfYear().add(instant, 1);\ninstant = chrono.dayOfMonth().add(instant, iDayOfMonth);\n}\nreturn instant;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:add(JI)J",
            "method_body": "public long add(long instant, int value) {\nreturn getDurationField().add(instant, value);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.joda.time.field.MillisDurationField:add(JI)J",
            "method_body": "public long add(long instant, int value) {\nreturn FieldUtils.safeAdd(instant, value);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationField:add(JI)J",
            "method_body": "public long add(long instant, int value) {\nlong addition = value * iUnitMillis;  // safe\nreturn FieldUtils.safeAdd(instant, addition);\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:getChronology()Lorg/joda/time/Chronology;",
            "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType:getField(Lorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
            "method_body": "public DateTimeField getField(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\n\nswitch (iOrdinal) {\ncase ERA:\nreturn chronology.era();\ncase YEAR_OF_ERA:\nreturn chronology.yearOfEra();\ncase CENTURY_OF_ERA:\nreturn chronology.centuryOfEra();\ncase YEAR_OF_CENTURY:\nreturn chronology.yearOfCentury();\ncase YEAR:\nreturn chronology.year();\ncase DAY_OF_YEAR:\nreturn chronology.dayOfYear();\ncase MONTH_OF_YEAR:\nreturn chronology.monthOfYear();\ncase DAY_OF_MONTH:\nreturn chronology.dayOfMonth();\ncase WEEKYEAR_OF_CENTURY:\nreturn chronology.weekyearOfCentury();\ncase WEEKYEAR:\nreturn chronology.weekyear();\ncase WEEK_OF_WEEKYEAR:\nreturn chronology.weekOfWeekyear();\ncase DAY_OF_WEEK:\nreturn chronology.dayOfWeek();\ncase HALFDAY_OF_DAY:\nreturn chronology.halfdayOfDay();\ncase HOUR_OF_HALFDAY:\nreturn chronology.hourOfHalfday();\ncase CLOCKHOUR_OF_HALFDAY:\nreturn chronology.clockhourOfHalfday();\ncase CLOCKHOUR_OF_DAY:\nreturn chronology.clockhourOfDay();\ncase HOUR_OF_DAY:\nreturn chronology.hourOfDay();\ncase MINUTE_OF_DAY:\nreturn chronology.minuteOfDay();\ncase MINUTE_OF_HOUR:\nreturn chronology.minuteOfHour();\ncase SECOND_OF_DAY:\nreturn chronology.secondOfDay();\ncase SECOND_OF_MINUTE:\nreturn chronology.secondOfMinute();\ncase MILLIS_OF_DAY:\nreturn chronology.millisOfDay();\ncase MILLIS_OF_SECOND:\nreturn chronology.millisOfSecond();\ndefault:\n// Shouldn't happen.\nthrow new InternalError();\n}\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeAdd(JJ)J",
            "method_body": "public static long safeAdd(long val1, long val2) {\nlong sum = val1 + val2;\n// If there is a sign change, but the two values have the same sign...\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nthrow new ArithmeticException\n(\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n}\nreturn sum;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:getMillis()J",
            "method_body": "public long getMillis() {\nreturn iMillis;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMonthOfYear(J)I",
            "method_body": "int getMonthOfYear(long millis) {\nreturn getMonthOfYear(millis, getYear(millis));\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getMonthOfYear(instant);\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getDateTimeMillis(IIIIIII)J",
            "method_body": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\nint hourOfDay, int minuteOfHour,\nint secondOfMinute, int millisOfSecond)\nthrows IllegalArgumentException\n{\nChronology base;\nif ((base = iBase) != null && (iBaseFlags & 5) == 5) {\n// Only call specialized implementation if applicable fields are the same.\nreturn base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\nhourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n}\nreturn super.getDateTimeMillis(year, monthOfYear, dayOfMonth,\nhourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getDayOfWeek(instant);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfWeek(J)I",
            "method_body": "int getDayOfWeek(long instant) {\n// 1970-01-01 is day of week 4, Thursday.\n\nlong daysSince19700101;\nif (instant >= 0) {\ndaysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n} else {\ndaysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n/ DateTimeConstants.MILLIS_PER_DAY;\nif (daysSince19700101 < -3) {\nreturn 7 + (int) ((daysSince19700101 + 4) % 7);\n}\n}\n\nreturn 1 + (int) ((daysSince19700101 + 3) % 7);\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getDaysInMonthMaxForSet(JI)I",
            "method_body": "int getDaysInMonthMaxForSet(long instant, int value) {\nreturn ((value > 28 || value < 1) ? getDaysInMonthMax(instant) : 28);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getMaximumValueForSet(JI)I",
            "method_body": "protected int getMaximumValueForSet(long instant, int value) {\nreturn iChronology.getDaysInMonthMaxForSet(instant, value);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfMonth(JI)I",
            "method_body": "int getDayOfMonth(long millis, int year) {\nint month = getMonthOfYear(millis, year);\nreturn getDayOfMonth(millis, year, month);\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\n//\nint thisYear = iChronology.getYear(instant);\n//\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\n// Quietly force DOM to nearest sane value.\nthisDom = maxDom;\n}\n// Return newly calculated millis value\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\niChronology.getMillisOfDay(instant);\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDateTimeMillis(IIIIIII)J",
            "method_body": "public long getDateTimeMillis(\nint year, int monthOfYear, int dayOfMonth,\nint hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)\nthrows IllegalArgumentException {\nChronology base;\nif ((base = getBase()) != null) {\nreturn base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\nhourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n}\n\nFieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23);\nFieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59);\nFieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59);\nFieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999);\n\nreturn getDateMidnightMillis(year, monthOfYear, dayOfMonth)\n+ hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n+ minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n+ secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n+ millisOfSecond;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.joda.time.field.PreciseDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int value) {\nFieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());\nreturn instant + (value - get(instant)) * iUnitMillis;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int value) {\nFieldUtils.verifyValueBounds(this, value, getMinimumValue(),\ngetMaximumValueForSet(instant, value));\nreturn instant + (value - get(instant)) * iUnitMillis;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getMinimumValue()I",
            "method_body": "public int getMinimumValue() {\nreturn 1;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMillisOfDay(J)I",
            "method_body": "int getMillisOfDay(long instant) {\nif (instant >= 0) {\nreturn (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n} else {\nreturn (DateTimeConstants.MILLIS_PER_DAY - 1)\n+ (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n}\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:getOffset(J)I",
            "method_body": "public int getOffset(long instant) {\nreturn getInfo(instant).getOffset(instant);\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone$Info:getOffset(J)I",
            "method_body": "public int getOffset(long millis) {\nif (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\nif (iOffset == Integer.MIN_VALUE) {\niOffset = iZoneRef.getOffset(iPeriodStart);\n}\nreturn iOffset;\n}\nreturn iNextInfo.getOffset(millis);\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:getInfo(J)Lorg/joda/time/tz/CachedDateTimeZone$Info;",
            "method_body": "private Info getInfo(long millis) {\nint period = (int)(millis >> 32);\nInfo[] cache = iInfoCache;\nint index = period & cInfoCacheMask;\nInfo info = cache[index];\nif (info == null || (int)((info.iPeriodStart >> 32)) != period) {\ninfo = createInfo(millis);\ncache[index] = info;\n}\nreturn info;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nChronology base;\nif ((base = iBase) != null) {\nreturn base.getZone();\n}\nreturn null;\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
            "method_body": "public BaseDateTime(\nint year,\nint monthOfYear,\nint dayOfMonth,\nint hourOfDay,\nint minuteOfHour,\nint secondOfMinute,\nint millisOfSecond,\nChronology chronology) {\nsuper();\niChronology = checkChronology(chronology);\nlong instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\nhourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\niMillis = checkInstant(instant, iChronology);\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.joda.time.field.PreciseDateTimeField:getMaximumValue()I",
            "method_body": "public int getMaximumValue() {\nreturn iRange - 1;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfMonth(J)I",
            "method_body": "abstract int getMonthOfYear(long millis, int year);\n\n/**\n* @param millis from 1970-01-01T00:00:00Z\n*/\nint getDayOfMonth(long millis) {\nint year = getYear(millis);\nint month = getMonthOfYear(millis, year);\nreturn getDayOfMonth(millis, year, month);\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:verifyValueBounds(Lorg/joda/time/DateTimeField;III)V",
            "method_body": "public static void verifyValueBounds(DateTimeField field,\nint value, int lowerBound, int upperBound) {\nif ((value < lowerBound) || (value > upperBound)) {\nthrow new IllegalFieldValueException\n(field.getType(), Integer.valueOf(value),\nInteger.valueOf(lowerBound), Integer.valueOf(upperBound));\n}\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getDayOfMonth(instant);\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.joda.time.chrono.BasicYearDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getYear(instant);\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfMonth(JII)I",
            "method_body": "int getDayOfMonth(long millis, int year, int month) {\nlong dateMillis = getYearMillis(year);\ndateMillis += getTotalMillisByYearMonth(year, month);\nreturn (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.joda.time.field.PreciseDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nif (instant >= 0) {\nreturn (int) ((instant / getUnitMillis()) % iRange);\n} else {\nreturn iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\n}\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDateMidnightMillis(III)J",
            "method_body": "long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\nFieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\nFieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\nFieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\nreturn getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMaxMonth(I)I",
            "method_body": "abstract long getYearDifference(long minuendInstant, long subtrahendInstant);\n\n/**\n* Is the specified year a leap year?\n*\n* @param year  the year to test\n* @return true if leap\n*/\nabstract boolean isLeapYear(int year);\n\n/**\n* Gets the number of days in the specified month and year.\n*\n* @param year  the year\n* @param month  the month\n* @return the number of days\n*/\nabstract int getDaysInYearMonth(int year, int month);\n\n/**\n* Gets the maximum days in the specified month.\n*\n* @param month  the month\n* @return the max days\n*/\nabstract int getDaysInMonthMax(int month);\n\n/**\n* Gets the total number of millis elapsed in this year at the start\n* of the specified month, such as zero for month 1.\n*\n* @param year  the year\n* @param month  the month\n* @return the elapsed millis at the start of the month\n*/\nabstract long getTotalMillisByYearMonth(int year, int month);\n\n/**\n* Gets the millisecond value of the first day of the year.\n*\n* @return the milliseconds for the first of the year\n*/\nabstract long calculateFirstDayOfYearMillis(int year);\n\n/**\n* Gets the minimum supported year.\n*\n* @return the year\n*/\nabstract int getMinYear();\n\n/**\n* Gets the maximum supported year.\n*\n* @return the year\n*/\nabstract int getMaxYear();\n\n/**\n* Gets the maximum month for the specified year.\n* This implementation calls getMaxMonth().\n*\n* @param year  the year\n* @return the maximum month value\n*/\nint getMaxMonth(int year) {\nreturn getMaxMonth();\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:verifyValueBounds(Lorg/joda/time/DateTimeFieldType;III)V",
            "method_body": "public static void verifyValueBounds(DateTimeFieldType fieldType,\nint value, int lowerBound, int upperBound) {\nif ((value < lowerBound) || (value > upperBound)) {\nthrow new IllegalFieldValueException\n(fieldType, Integer.valueOf(value),\nInteger.valueOf(lowerBound), Integer.valueOf(upperBound));\n}\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getMonthOfYear(JI)I",
            "method_body": "int getMonthOfYear(long millis, int year) {\n// Perform a binary search to get the month. To make it go even faster,\n// compare using ints instead of longs. The number of milliseconds per\n// year exceeds the limit of a 32-bit int's capacity, so divide by\n// 1024. No precision is lost (except time of day) since the number of\n// milliseconds per day contains 1024 as a factor. After the division,\n// the instant isn't measured in milliseconds, but in units of\n// (128/125)seconds.\n\nint i = (int)((millis - getYearMillis(year)) >> 10);\n\n// There are 86400000 milliseconds per day, but divided by 1024 is\n// 84375. There are 84375 (128/125)seconds per day.\n\nreturn\n(isLeapYear(year))\n? ((i < 182 * 84375)\n? ((i < 91 * 84375)\n? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n: ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n: ((i < 274 * 84375)\n? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n: ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n: ((i < 181 * 84375)\n? ((i < 90 * 84375)\n? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n: ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n: ((i < 273 * 84375)\n? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n: ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getDaysInYearMonth(II)I",
            "method_body": "int getDaysInYearMonth(int year, int month) {\nif (isLeapYear(year)) {\nreturn MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n} else {\nreturn MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n}\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getAverageMillisPerYearDividedByTwo()J",
            "method_body": "long getAverageMillisPerYearDividedByTwo() {\nreturn MILLIS_PER_YEAR / 2;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getApproxMillisAtEpochDividedByTwo()J",
            "method_body": "long getApproxMillisAtEpochDividedByTwo() {\nreturn (1970L * MILLIS_PER_YEAR) / 2;\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYear(J)I",
            "method_body": "int getYear(long instant) {\n// Get an initial estimate of the year, and the millis value that\n// represents the start of that year. Then verify estimate and fix if\n// necessary.\n\n// Initial estimate uses values divided by two to avoid overflow.\nlong unitMillis = getAverageMillisPerYearDividedByTwo();\nlong i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\nif (i2 < 0) {\ni2 = i2 - unitMillis + 1;\n}\nint year = (int) (i2 / unitMillis);\n\nlong yearStart = getYearMillis(year);\nlong diff = instant - yearStart;\n\nif (diff < 0) {\nyear--;\n} else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n// One year may need to be added to fix estimate.\nlong oneYear;\nif (isLeapYear(year)) {\noneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n} else {\noneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n}\n\nyearStart += oneYear;\n\nif (yearStart <= instant) {\n// Didn't go too far, so actually add one year.\nyear++;\n}\n}\n\nreturn year;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getMinYear()I",
            "method_body": "int getMinYear() {\nreturn MIN_YEAR;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getTotalMillisByYearMonth(II)J",
            "method_body": "long getTotalMillisByYearMonth(int year, int month) {\nif (isLeapYear(year)) {\nreturn MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n} else {\nreturn MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n}\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:isLeapYear(I)Z",
            "method_body": "boolean isLeapYear(int year) {\nreturn ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:checkInstant(JLorg/joda/time/Chronology;)J",
            "method_body": "protected long checkInstant(long instant, Chronology chronology) {\nreturn instant;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:checkChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "protected Chronology checkChronology(Chronology chronology) {\nreturn DateTimeUtils.getChronology(chronology);\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.joda.time.base.AbstractDateTime:<init>()V",
            "method_body": "protected AbstractDateTime() {\nsuper();\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYearMonthDayMillis(III)J",
            "method_body": "long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\nlong millis = getYearMillis(year);\nmillis += getTotalMillisByYearMonth(year, month);\nreturn millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYearMillis(I)J",
            "method_body": "long getYearMillis(int year) {\nreturn getYearInfo(year).iFirstDayMillis;\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYearInfo(I)Lorg/joda/time/chrono/BasicChronology$YearInfo;",
            "method_body": "abstract long getAverageMillisPerYear();\n\n/**\n* Gets an average value for the milliseconds per year, divided by two.\n*\n* @return the millis per year divided by two\n*/\nabstract long getAverageMillisPerYearDividedByTwo();\n\n/**\n* Gets an average value for the milliseconds per month.\n*\n* @return the millis per month\n*/\nabstract long getAverageMillisPerMonth();\n\n/**\n* Returns a constant representing the approximate number of milliseconds\n* elapsed from year 0 of this chronology, divided by two. This constant\n* <em>must</em> be defined as:\n* <pre>\n*    (yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch) / 2\n* </pre>\n* where epoch is 1970-01-01 (Gregorian).\n*/\nabstract long getApproxMillisAtEpochDividedByTwo();\n\n/**\n* Sets the year from an instant and year.\n*\n* @param instant  millis from 1970-01-01T00:00:00Z\n* @param year  the year to set\n* @return the updated millis\n*/\nabstract long setYear(long instant, int year);\n\n//-----------------------------------------------------------------------\n// Although accessed by multiple threads, this method doesn't need to be synchronized.\nprivate YearInfo getYearInfo(int year) {\nYearInfo info = iYearInfoCache[year & CACHE_MASK];\nif (info == null || info.iYear != year) {\ninfo = new YearInfo(year, calculateFirstDayOfYearMillis(year));\niYearInfoCache[year & CACHE_MASK] = info;\n}\nreturn info;\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.joda.time.base.AbstractInstant:<init>()V",
            "method_body": "protected AbstractInstant() {\nsuper();\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nzone = DateTimeZone.getDefault();\n}\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\n}\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:setCurrentMillisFixed(J)V",
            "method_body": "public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\ncheckPermission();\ncMillisProvider = new FixedMillisProvider(fixedMillis);\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils$FixedMillisProvider:<init>(J)V",
            "method_body": "FixedMillisProvider(long fixedMillis) {\niMillis = fixedMillis;\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:setCurrentMillisSystem()V",
            "method_body": "public static final void setCurrentMillisSystem() throws SecurityException {\ncheckPermission();\ncMillisProvider = SYSTEM_MILLIS_PROVIDER;\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:checkPermission()V",
            "method_body": "private static void checkPermission() throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nsm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n}\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:withUTC()Lorg/joda/time/Chronology;",
            "method_body": "public Chronology withUTC() {\nreturn INSTANCE_UTC;\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:hashCode()I",
            "method_body": "public int hashCode() {\nreturn iZone.hashCode();\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:setDefault(Lorg/joda/time/DateTimeZone;)V",
            "method_body": "public static void setDefault(DateTimeZone zone) throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nsm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n}\nif (zone == null) {\nthrow new IllegalArgumentException(\"The datetime zone must not be null\");\n}\nsynchronized(DateTimeZone.class) {\ncDefault = zone;\n}\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:hashCode()I",
            "method_body": "public abstract boolean equals(Object object);\n\n/**\n* Gets a hash code compatable with equals.\n*\n* @return suitable hashcode\n*/\npublic int hashCode() {\nreturn 57 + getID().hashCode();\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nreturn (DateTimeZone)getParam();\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getParam()Ljava/lang/Object;",
            "method_body": "protected final Object getParam() {\nreturn iParam;\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\n}\nreturn chrono;\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:getDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getDurationField() {\nreturn iUnitField;\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getMaxYear()I",
            "method_body": "int getMaxYear() {\nreturn MAX_YEAR;\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMaxMonth()I",
            "method_body": "int getMaxMonth() {\nreturn 12;\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:millisOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField millisOfDay() {\nreturn iMillisOfDay;\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:secondOfMinute()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField secondOfMinute() {\nreturn iSecondOfMinute;\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:secondOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField secondOfDay() {\nreturn iSecondOfDay;\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:minuteOfHour()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField minuteOfHour() {\nreturn iMinuteOfHour;\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:hours()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField hours() {\nreturn iHours;\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:hourOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField hourOfDay() {\nreturn iHourOfDay;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:days()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField days() {\nreturn iDays;\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:dayOfWeek()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField dayOfWeek() {\nreturn iDayOfWeek;\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:dayOfMonth()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField dayOfMonth() {\nreturn iDayOfMonth;\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:monthOfYear()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField monthOfYear() {\nreturn iMonthOfYear;\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:year()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField year() {\nreturn iYear;\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getBase()Lorg/joda/time/Chronology;",
            "method_body": "protected abstract void assemble(Fields fields);\n\n/**\n* Returns the same base chronology as passed into the constructor.\n*/\nprotected final Chronology getBase() {\nreturn iBase;\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:millisOfSecond()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType millisOfSecond() {\nreturn MILLIS_OF_SECOND_TYPE;\n}",
            "method_id": 119
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:getMinimumValue()I",
            "method_body": "public int getMinimumValue() {\nreturn 0;\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\ntry {\ntry {\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n}\n} catch (RuntimeException ex) {\n// ignored\n}\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\n} catch (IllegalArgumentException ex) {\n// ignored\n}\nif (temp == null) {\ntemp = UTC;\n}\ncDefault = zone = temp;\n}\n}\n}\nreturn zone;\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:getUnitMillis()J",
            "method_body": "public final long getUnitMillis() {\nreturn iUnitMillis;\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nreturn getDefault();\n}\nif (id.equals(\"UTC\")) {\nreturn DateTimeZone.UTC;\n}\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nint offset = parseOffset(id);\nif (offset == 0L) {\nreturn DateTimeZone.UTC;\n} else {\nid = printOffset(offset);\nreturn fixedOffsetZone(id, offset);\n}\n}\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
            "method_body": "public final String getID() {\nreturn iID;\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.joda.time.tz.ZoneInfoProvider:getZone(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone(String id) {\nif (id == null) {\nreturn null;\n}\n\nObject obj = iZoneInfoMap.get(id);\nif (obj == null) {\nreturn null;\n}\n\nif (id.equals(obj)) {\n// Load zone data for the first time.\nreturn loadZoneData(id);\n}\n\nif (obj instanceof SoftReference<?>) {\n@SuppressWarnings(\"unchecked\")\nSoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\nDateTimeZone tz = ref.get();\nif (tz != null) {\nreturn tz;\n}\n// Reference cleared; load data again.\nreturn loadZoneData(id);\n}\n\n// If this point is reached, mapping must link to another.\nreturn getZone((String)obj);\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nif (obj instanceof DSTZone) {\nDSTZone other = (DSTZone)obj;\nreturn\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nif (obj instanceof Recurrence) {\nRecurrence other = (Recurrence)obj;\nreturn\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nif (obj instanceof PrecalculatedZone) {\nPrecalculatedZone other = (PrecalculatedZone)obj;\nreturn\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nif (obj instanceof CachedDateTimeZone) {\nreturn iZone.equals(((CachedDateTimeZone)obj).iZone);\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nif (obj instanceof OfYear) {\nOfYear other = (OfYear)obj;\nreturn\n}",
            "method_id": 136
        }
    ]
}