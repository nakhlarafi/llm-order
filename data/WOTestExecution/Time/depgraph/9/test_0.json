{
    "bug_id": 9,
    "test_id": 0,
    "test_name": "org.joda.time.TestDateTimeZone.testForOffsetHoursMinutes_int_int",
    "test_body": "public void testForOffsetHoursMinutes_int_int() {\nassertEquals(DateTimeZone.UTC, DateTimeZone.forOffsetHoursMinutes(0, 0));\nassertEquals(DateTimeZone.forID(\"+23:59\"), DateTimeZone.forOffsetHoursMinutes(23, 59));\nassertEquals(DateTimeZone.forID(\"+03:15\"), DateTimeZone.forOffsetHoursMinutes(3, 15));\nassertEquals(DateTimeZone.forID(\"-02:00\"), DateTimeZone.forOffsetHoursMinutes(-2, 0));\nassertEquals(DateTimeZone.forID(\"-02:30\"), DateTimeZone.forOffsetHoursMinutes(-2, 30));\nassertEquals(DateTimeZone.forID(\"-23:59\"), DateTimeZone.forOffsetHoursMinutes(-23, 59));\ntry {\nDateTimeZone.forOffsetHoursMinutes(2, 60);\nfail();\n} catch (IllegalArgumentException ex) {}\ntry {\nDateTimeZone.forOffsetHoursMinutes(-2, 60);\nfail();\n} catch (IllegalArgumentException ex) {}\ntry {\nDateTimeZone.forOffsetHoursMinutes(2, -1);\nfail();\n} catch (IllegalArgumentException ex) {}\ntry {\nDateTimeZone.forOffsetHoursMinutes(-2, -1);\nfail();\n} catch (IllegalArgumentException ex) {}\ntry {\nDateTimeZone.forOffsetHoursMinutes(24, 0);\nfail();\n} catch (IllegalArgumentException ex) {}\ntry {\nDateTimeZone.forOffsetHoursMinutes(-24, 0);\nfail();\n} catch (IllegalArgumentException ex) {}\n}        \n",
    "stack_trace": "junit.framework.AssertionFailedError\nat junit.framework.Assert.fail(Assert.java:55)\nat junit.framework.Assert.fail(Assert.java:64)\nat junit.framework.TestCase.fail(TestCase.java:235)\nat org.joda.time.TestDateTimeZone.testForOffsetHoursMinutes_int_int(TestDateTimeZone.java:328)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.DateTimeZone:forOffsetHoursMinutes(II)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\nif (hoursOffset == 0 && minutesOffset == 0) {\nreturn DateTimeZone.UTC;\n}\nif (minutesOffset < 0 || minutesOffset > 59) {\nthrow new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n}\nint offset = 0;\ntry {\nint hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\nif (hoursInMinutes < 0) {\nminutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n} else {\nminutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n}\noffset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n} catch (ArithmeticException ex) {\nthrow new IllegalArgumentException(\"Offset is too large\");\n}\nreturn forOffsetMillis(offset);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
            "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\n} else {\nbuf.append('-');\noffset = -offset;\n}\n\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}\n\nint seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, seconds, 2);\noffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\nif (offset == 0) {\nreturn buf.toString();\n}\n\nbuf.append('.');\nFormatUtils.appendPaddedInteger(buf, offset, 3);\nreturn buf.toString();\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
            "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nreturn DateTimeZone.UTC;\n}\nif (iFixedOffsetCache == null) {\niFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n}\nDateTimeZone zone;\nReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\nif (ref != null) {\nzone = ref.get();\nif (zone != null) {\nreturn zone;\n}\n}\nzone = new FixedDateTimeZone(id, null, offset, offset);\niFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\nreturn zone;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:offsetFormatter()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "private static synchronized DateTimeFormatter offsetFormatter() {\nif (cOffsetFormatter == null) {\ncOffsetFormatter = new DateTimeFormatterBuilder()\n.appendTimeZoneOffset(null, true, 2, 4)\n.toFormatter();\n}\nreturn cOffsetFormatter;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nreturn getDefault();\n}\nif (id.equals(\"UTC\")) {\nreturn DateTimeZone.UTC;\n}\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nint offset = parseOffset(id);\nif (offset == 0L) {\nreturn DateTimeZone.UTC;\n} else {\nid = printOffset(offset);\nreturn fixedOffsetZone(id, offset);\n}\n}\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:parseMillis(Ljava/lang/String;)J",
            "method_body": "public long parseMillis(String text) {\nDateTimeParser parser = requireParser();\n\nChronology chrono = selectChronology(iChrono);\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nreturn bucket.computeMillis(true, text);\n}\n} else {\nnewPos = ~newPos;\n}\nthrow new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
            "method_body": "private DateTimeFormatter(\nDateTimePrinter printer, DateTimeParser parser,\nLocale locale, boolean offsetParsed,\nChronology chrono, DateTimeZone zone,\nInteger pivotYear, int defaultYear) {\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
            "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nLocale locale, Integer pivotYear, int defaultYear) {\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niZone = chrono.getZone();\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
            "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\niSavedFields = savedFields = (SavedField[])iSavedFields.clone();\niSavedFieldsShared = false;\n}\nsort(savedFields, count);\nif (count > 0) {\n// alter base year for parsing if first field is month or day\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nsaveField(DateTimeFieldType.year(), iDefaultYear);\nreturn computeMillis(resetFields, text);\n}\n}\n\nlong millis = iMillis;\ntry {\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n}\nif (resetFields) {\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, i == (count - 1));\n}\n}\n} catch (IllegalFieldValueException e) {\nif (text != null) {\ne.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n}\nthrow e;\n}\n\nif (iOffset != null) {\nmillis -= iOffset;\n} else if (iZone != null) {\nint offset = iZone.getOffsetFromLocal(millis);\nmillis -= offset;\nif (offset != iZone.getOffset(millis)) {\nString message = \"Illegal instant due to time zone offset transition (\" + iZone + ')';\nif (text != null) {\nmessage = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n}\nthrow new IllegalInstantException(message);\n}\n}\n\nreturn millis;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\n}\nif (iZone != null) {\nchrono = chrono.withZone(iZone);\n}\nreturn chrono;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:withChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public DateTimeFormatter withChronology(Chronology chrono) {\nif (iChrono == chrono) {\nreturn this;\n}\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\niOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
            "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nthrow new UnsupportedOperationException(\"Parsing not supported\");\n}\nreturn parser;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\ntry {\ntry {\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n}\n} catch (RuntimeException ex) {\n// ignored\n}\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\n} catch (IllegalArgumentException ex) {\n// ignored\n}\nif (temp == null) {\ntemp = UTC;\n}\ncDefault = zone = temp;\n}\n}\n}\nreturn zone;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
            "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nArrays.sort(array, 0, high);\n} else {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}\n}\n}\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.joda.time.tz.FixedDateTimeZone:<init>(Ljava/lang/String;Ljava/lang/String;II)V",
            "method_body": "public FixedDateTimeZone(String id, String nameKey,\nint wallOffset, int standardOffset) {\nsuper(id);\niNameKey = nameKey;\niWallOffset = wallOffset;\niStandardOffset = standardOffset;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:setDefault(Lorg/joda/time/DateTimeZone;)V",
            "method_body": "public static void setDefault(DateTimeZone zone) throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nsm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n}\nif (zone == null) {\nthrow new IllegalArgumentException(\"The datetime zone must not be null\");\n}\nsynchronized(DateTimeZone.class) {\ncDefault = zone;\n}\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeMultiply(II)I",
            "method_body": "public static int safeMultiply(int val1, int val2) {\nlong total = (long) val1 * (long) val2;\nif (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\nthrow new ArithmeticException(\"Multiplication overflows an int: \" + val1 + \" * \" + val2);\n}\nreturn (int) total;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
            "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nbuf.append('-');\nif (value != Integer.MIN_VALUE) {\nvalue = -value;\n} else {\nfor (; size > 10; size--) {\nbuf.append('0');\n}\nbuf.append(\"\" + -(long)Integer.MIN_VALUE);\nreturn;\n}\n}\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\n}\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nbuf.append('0');\n}\n// Calculate value div/mod by 10 without using two expensive\n// division operations. (2 ^ 27) / 10 = 13421772. Add one to\n// value to correct rounding error.\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\n// Append remainder by calculating (value - d * 10).\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nint digits;\nif (value < 1000) {\ndigits = 3;\n} else if (value < 10000) {\ndigits = 4;\n} else {\ndigits = (int)(Math.log(value) / LOG_10) + 1;\n}\nfor (; size > digits; size--) {\nbuf.append('0');\n}\nbuf.append(Integer.toString(value));\n}\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:<init>(Ljava/lang/String;)V",
            "method_body": "protected DateTimeZone(String id) {\nif (id == null) {\nthrow new IllegalArgumentException(\"Id must not be null\");\n}\niID = id;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeAdd(II)I",
            "method_body": "public static int safeAdd(int val1, int val2) {\nint sum = val1 + val2;\n// If there is a sign change, but the two values have the same sign...\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nthrow new ArithmeticException\n(\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n}\nreturn sum;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\n}\nreturn chrono;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:digitCount(Ljava/lang/String;II)I",
            "method_body": "private int digitCount(String text, int position, int amount) {\nint limit = Math.min(text.length() - position, amount);\namount = 0;\nfor (; limit > 0; limit--) {\nchar c = text.charAt(position + amount);\nif (c < '0' || c > '9') {\nbreak;\n}\namount++;\n}\nreturn amount;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.joda.time.format.FormatUtils:parseTwoDigits(Ljava/lang/String;I)I",
            "method_body": "static int parseTwoDigits(String text, int position) {\nint value = text.charAt(position) - '0';\nreturn ((value << 3) + (value << 1)) + text.charAt(position + 1) - '0';\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:setOffset(Ljava/lang/Integer;)V",
            "method_body": "public void setOffset(Integer offset) {\niSavedState = null;\niOffset = offset;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nint limit = text.length() - position;\n\nzeroOffset:\nif (iZeroOffsetParseText != null) {\nif (iZeroOffsetParseText.length() == 0) {\n// Peek ahead, looking for sign character.\nif (limit > 0) {\nchar c = text.charAt(position);\nif (c == '-' || c == '+') {\nbreak zeroOffset;\n}\n}\nbucket.setOffset(Integer.valueOf(0));\nreturn position;\n}\nif (text.regionMatches(true, position, iZeroOffsetParseText, 0, iZeroOffsetParseText.length())) {\nbucket.setOffset(Integer.valueOf(0));\nreturn position + iZeroOffsetParseText.length();\n}\n}\n\n// Format to expect is sign character followed by at least one digit.\n\nif (limit <= 1) {\nreturn ~position;\n}\n\nboolean negative;\nchar c = text.charAt(position);\nif (c == '-') {\nnegative = true;\n} else if (c == '+') {\nnegative = false;\n} else {\nreturn ~position;\n}\n\nlimit--;\nposition++;\n\n// Format following sign is one of:\n//\n// hh\n// hhmm\n// hhmmss\n// hhmmssSSS\n// hh:mm\n// hh:mm:ss\n// hh:mm:ss.SSS\n\n// First parse hours.\n\nif (digitCount(text, position, 2) < 2) {\n// Need two digits for hour.\nreturn ~position;\n}\n\nint offset;\n\nint hours = FormatUtils.parseTwoDigits(text, position);\nif (hours > 23) {\nreturn ~position;\n}\noffset = hours * DateTimeConstants.MILLIS_PER_HOUR;\nlimit -= 2;\nposition += 2;\n\nparse: {\n// Need to decide now if separators are expected or parsing\n// stops at hour field.\n\nif (limit <= 0) {\nbreak parse;\n}\n\nboolean expectSeparators;\nc = text.charAt(position);\nif (c == ':') {\nexpectSeparators = true;\nlimit--;\nposition++;\n} else if (c >= '0' && c <= '9') {\nexpectSeparators = false;\n} else {\nbreak parse;\n}\n\n// Proceed to parse minutes.\n\nint count = digitCount(text, position, 2);\nif (count == 0 && !expectSeparators) {\nbreak parse;\n} else if (count < 2) {\n// Need two digits for minute.\nreturn ~position;\n}\n\nint minutes = FormatUtils.parseTwoDigits(text, position);\nif (minutes > 59) {\nreturn ~position;\n}\noffset += minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nlimit -= 2;\nposition += 2;\n\n// Proceed to parse seconds.\n\nif (limit <= 0) {\nbreak parse;\n}\n\nif (expectSeparators) {\nif (text.charAt(position) != ':') {\nbreak parse;\n}\nlimit--;\nposition++;\n}\n\ncount = digitCount(text, position, 2);\nif (count == 0 && !expectSeparators) {\nbreak parse;\n} else if (count < 2) {\n// Need two digits for second.\nreturn ~position;\n}\n\nint seconds = FormatUtils.parseTwoDigits(text, position);\nif (seconds > 59) {\nreturn ~position;\n}\noffset += seconds * DateTimeConstants.MILLIS_PER_SECOND;\nlimit -= 2;\nposition += 2;\n\n// Proceed to parse fraction of second.\n\nif (limit <= 0) {\nbreak parse;\n}\n\nif (expectSeparators) {\nif (text.charAt(position) != '.' && text.charAt(position) != ',') {\nbreak parse;\n}\nlimit--;\nposition++;\n}\n\ncount = digitCount(text, position, 3);\nif (count == 0 && !expectSeparators) {\nbreak parse;\n} else if (count < 1) {\n// Need at least one digit for fraction of second.\nreturn ~position;\n}\n\noffset += (text.charAt(position++) - '0') * 100;\nif (count > 1) {\noffset += (text.charAt(position++) - '0') * 10;\nif (count > 2) {\noffset += text.charAt(position++) - '0';\n}\n}\n}\n\nbucket.setOffset(Integer.valueOf(negative ? -offset : offset));\nreturn position;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.joda.time.chrono.BaseChronology:<init>()V",
            "method_body": "protected BaseChronology() {\nsuper();\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.joda.time.tz.FixedDateTimeZone:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nreturn true;\n}\nif (obj instanceof FixedDateTimeZone) {\nFixedDateTimeZone other = (FixedDateTimeZone) obj;\nreturn\ngetID().equals(other.getID()) &&\niStandardOffset == other.iStandardOffset &&\niWallOffset == other.iWallOffset;\n}\nreturn false;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.joda.time.tz.ZoneInfoProvider:getZone(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone(String id) {\nif (id == null) {\nreturn null;\n}\n\nObject obj = iZoneInfoMap.get(id);\nif (obj == null) {\nreturn null;\n}\n\nif (id.equals(obj)) {\n// Load zone data for the first time.\nreturn loadZoneData(id);\n}\n\nif (obj instanceof SoftReference<?>) {\n@SuppressWarnings(\"unchecked\")\nSoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\nDateTimeZone tz = ref.get();\nif (tz != null) {\nreturn tz;\n}\n// Reference cleared; load data again.\nreturn loadZoneData(id);\n}\n\n// If this point is reached, mapping must link to another.\nreturn getZone((String)obj);\n}",
            "method_id": 28
        }
    ]
}