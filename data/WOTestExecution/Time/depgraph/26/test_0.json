{
    "bug_id": 26,
    "test_id": 0,
    "test_name": "org.joda.time.TestDateTimeZoneCutover.testBug2182444_usCentral",
    "test_body": "public void testBug2182444_usCentral() {\nChronology chronUSCentral = GregorianChronology.getInstance(DateTimeZone.forID(\"US/Central\"));\nChronology chronUTC = GregorianChronology.getInstance(DateTimeZone.UTC);\nDateTime usCentralStandardInUTC = new DateTime(2008, 11, 2, 7, 0, 0, 0, chronUTC);\nDateTime usCentralDaylightInUTC = new DateTime(2008, 11, 2, 6, 0, 0, 0, chronUTC);\nassertTrue(\"Should be standard time\", chronUSCentral.getZone().isStandardOffset(usCentralStandardInUTC.getMillis()));\nassertFalse(\"Should be daylight time\", chronUSCentral.getZone().isStandardOffset(usCentralDaylightInUTC.getMillis()));\nDateTime usCentralStandardInUSCentral = usCentralStandardInUTC.toDateTime(chronUSCentral);\nDateTime usCentralDaylightInUSCentral = usCentralDaylightInUTC.toDateTime(chronUSCentral);\nassertEquals(1, usCentralStandardInUSCentral.getHourOfDay());\nassertEquals(usCentralStandardInUSCentral.getHourOfDay(), usCentralDaylightInUSCentral.getHourOfDay());\nassertTrue(usCentralStandardInUSCentral.getMillis() != usCentralDaylightInUSCentral.getMillis());\nassertEquals(usCentralStandardInUSCentral, usCentralStandardInUSCentral.withHourOfDay(1));\nassertEquals(usCentralStandardInUSCentral.getMillis() + 3, usCentralStandardInUSCentral.withMillisOfSecond(3).getMillis());\nassertEquals(usCentralDaylightInUSCentral, usCentralDaylightInUSCentral.withHourOfDay(1));\nassertEquals(usCentralDaylightInUSCentral.getMillis() + 3, usCentralDaylightInUSCentral.withMillisOfSecond(3).getMillis());\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<2008-11-02T01:00:00.000-06:00> but was:<2008-11-02T01:00:00.000-05:00>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.Assert.assertEquals(Assert.java:86)\nat junit.framework.TestCase.assertEquals(TestCase.java:253)\nat org.joda.time.TestDateTimeZoneCutover.testBug2182444_usCentral(TestDateTimeZoneCutover.java:1166)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.DateTime:toDateTime(Lorg/joda/time/Chronology;)Lorg/joda/time/DateTime;",
            "method_body": "public DateTime toDateTime(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\nif (getChronology() == chronology) {\nreturn this;\n}\nreturn super.toDateTime(chronology);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;I)Lorg/joda/time/chrono/GregorianChronology;",
            "method_body": "public static GregorianChronology getInstance(DateTimeZone zone, int minDaysInFirstWeek) {\nif (zone == null) {\nzone = DateTimeZone.getDefault();\n}\nGregorianChronology chrono;\nsynchronized (cCache) {\nGregorianChronology[] chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new GregorianChronology[7];\ncCache.put(zone, chronos);\n}\ntry {\nchrono = chronos[minDaysInFirstWeek - 1];\n} catch (ArrayIndexOutOfBoundsException e) {\nthrow new IllegalArgumentException\n(\"Invalid min days in first week: \" + minDaysInFirstWeek);\n}\nif (chrono == null) {\nif (zone == DateTimeZone.UTC) {\nchrono = new GregorianChronology(null, null, minDaysInFirstWeek);\n} else {\nchrono = getInstance(DateTimeZone.UTC, minDaysInFirstWeek);\nchrono = new GregorianChronology\n(ZonedChronology.getInstance(chrono, zone), null, minDaysInFirstWeek);\n}\nchronos[minDaysInFirstWeek - 1] = chrono;\n}\n}\nreturn chrono;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
            "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nbuf.append('-');\nif (value != Integer.MIN_VALUE) {\nvalue = -value;\n} else {\nfor (; size > 10; size--) {\nbuf.append('0');\n}\nbuf.append(\"\" + -(long)Integer.MIN_VALUE);\nreturn;\n}\n}\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\n}\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nbuf.append('0');\n}\n// Calculate value div/mod by 10 without using two expensive\n// division operations. (2 ^ 27) / 10 = 13421772. Add one to\n// value to correct rounding error.\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\n// Append remainder by calculating (value - d * 10).\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nint digits;\nif (value < 1000) {\ndigits = 3;\n} else if (value < 10000) {\ndigits = 4;\n} else {\ndigits = (int)(Math.log(value) / LOG_10) + 1;\n}\nfor (; size > digits; size--) {\nbuf.append('0');\n}\nbuf.append(Integer.toString(value));\n}\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:isStandardOffset(J)Z",
            "method_body": "public boolean isStandardOffset(long instant) {\nreturn getOffset(instant) == getStandardOffset(instant);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeAdd(II)I",
            "method_body": "public static int safeAdd(int val1, int val2) {\nint sum = val1 + val2;\n// If there is a sign change, but the two values have the same sign...\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nthrow new ArithmeticException\n(\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n}\nreturn sum;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.joda.time.DateTime:withHourOfDay(I)Lorg/joda/time/DateTime;",
            "method_body": "public DateTime withHourOfDay(int hour) {\nreturn withMillis(getChronology().hourOfDay().set(getMillis(), hour));\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
            "method_body": "private GregorianChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:getInstance(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ZonedChronology;",
            "method_body": "public static ZonedChronology getInstance(Chronology base, DateTimeZone zone) {\nif (base == null) {\nthrow new IllegalArgumentException(\"Must supply a chronology\");\n}\nbase = base.withUTC();\nif (base == null) {\nthrow new IllegalArgumentException(\"UTC chronology must not be null\");\n}\nif (zone == null) {\nthrow new IllegalArgumentException(\"DateTimeZone must not be null\");\n}\nreturn new ZonedChronology(base, zone);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/GregorianChronology;",
            "method_body": "public static GregorianChronology getInstance(DateTimeZone zone) {\nreturn getInstance(zone, 4);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:<init>(Lorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;)V",
            "method_body": "private ZonedChronology(Chronology base, DateTimeZone zone) {\nsuper(base, zone);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int value) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nlocalInstant = iField.set(localInstant, value);\nlong result = iZone.convertLocalToUTC(localInstant, false);\nif (get(result) != value) {\nthrow new IllegalFieldValueException(iField.getType(), new Integer(value),\n\"Illegal instant due to time zone offset transition: \" +\nDateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(localInstant)) +\n\" (\" + iZone.getID() + \")\");\n}\nreturn result;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\n}\nif (iZone != null) {\nchrono = chrono.withZone(iZone);\n}\nreturn chrono;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:<init>(Lorg/joda/time/DateTimeField;Lorg/joda/time/DateTimeZone;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)V",
            "method_body": "ZonedDateTimeField(DateTimeField field,\nDateTimeZone zone,\nDurationField durationField,\nDurationField rangeDurationField,\nDurationField leapDurationField) {\nsuper(field.getType());\nif (!field.isSupported()) {\nthrow new IllegalArgumentException();\n}\niField = field;\niZone = zone;\niDurationField = durationField;\niTimeField = useTimeArithmetic(durationField);\niRangeDurationField = rangeDurationField;\niLeapDurationField = leapDurationField;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nlong localInstant = iZone.convertUTCToLocal(instant);\nreturn iField.get(localInstant);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:forID(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone forID(String id) {\nif (id == null) {\nreturn getDefault();\n}\nif (id.equals(\"UTC\")) {\nreturn DateTimeZone.UTC;\n}\nDateTimeZone zone = cProvider.getZone(id);\nif (zone != null) {\nreturn zone;\n}\nif (id.startsWith(\"+\") || id.startsWith(\"-\")) {\nint offset = parseOffset(id);\nif (offset == 0L) {\nreturn DateTimeZone.UTC;\n} else {\nid = printOffset(offset);\nreturn fixedOffsetZone(id, offset);\n}\n}\nthrow new IllegalArgumentException(\"The datetime zone id '\" + id + \"' is not recognised\");\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.joda.time.DateTime:<init>(JLorg/joda/time/Chronology;)V",
            "method_body": "public DateTime(long instant, Chronology chronology) {\nsuper(instant, chronology);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.joda.time.DateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
            "method_body": "public DateTime(\nint year,\nint monthOfYear,\nint dayOfMonth,\nint hourOfDay,\nint minuteOfHour,\nint secondOfMinute,\nint millisOfSecond,\nChronology chronology) {\nsuper(year, monthOfYear, dayOfMonth,\nhourOfDay, minuteOfHour, secondOfMinute, millisOfSecond, chronology);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\n}\nreturn chrono;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.joda.time.DateTime:withMillis(J)Lorg/joda/time/DateTime;",
            "method_body": "public DateTime withMillis(long newMillis) {\nreturn (newMillis == getMillis() ? this : new DateTime(newMillis, getChronology()));\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField:getUnitMillis()J",
            "method_body": "public long getUnitMillis() {\nreturn iUnitMillis;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:hourOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField hourOfDay() {\nreturn iHourOfDay;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:minuteOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField minuteOfDay() {\nreturn iMinuteOfDay;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYear(J)I",
            "method_body": "int getYear(long instant) {\n// Get an initial estimate of the year, and the millis value that\n// represents the start of that year. Then verify estimate and fix if\n// necessary.\n\n// Initial estimate uses values divided by two to avoid overflow.\nlong unitMillis = getAverageMillisPerYearDividedByTwo();\nlong i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\nif (i2 < 0) {\ni2 = i2 - unitMillis + 1;\n}\nint year = (int) (i2 / unitMillis);\n\nlong yearStart = getYearMillis(year);\nlong diff = instant - yearStart;\n\nif (diff < 0) {\nyear--;\n} else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n// One year may need to be added to fix estimate.\nlong oneYear;\nif (isLeapYear(year)) {\noneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n} else {\noneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n}\n\nyearStart += oneYear;\n\nif (yearStart <= instant) {\n// Didn't go too far, so actually add one year.\nyear++;\n}\n}\n\nreturn year;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:<init>(Ljava/lang/String;)V",
            "method_body": "protected DateTimeZone(String id) {\nif (id == null) {\nthrow new IllegalArgumentException(\"Id must not be null\");\n}\niID = id;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.joda.time.field.BaseDurationField:<init>(Lorg/joda/time/DurationFieldType;)V",
            "method_body": "protected BaseDurationField(DurationFieldType type) {\nsuper();\nif (type == null) {\nthrow new IllegalArgumentException(\"The type must not be null\");\n}\niType = type;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:readFrom(Ljava/io/DataInput;)Lorg/joda/time/tz/DateTimeZoneBuilder$OfYear;",
            "method_body": "static OfYear readFrom(DataInput in) throws IOException {\nreturn new OfYear((char)in.readUnsignedByte(),\n(int)in.readUnsignedByte(),\n(int)in.readByte(),\n(int)in.readUnsignedByte(),\nin.readBoolean(),\n(int)readMillis(in));\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:year()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField year() {\nreturn iYear;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.joda.time.field.MillisDurationField:getUnitMillis()J",
            "method_body": "public final long getUnitMillis() {\nreturn 1;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence:getSaveMillis()I",
            "method_body": "public int getSaveMillis() {\nreturn iSaveMillis;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfMonth(J)I",
            "method_body": "abstract int getMonthOfYear(long millis, int year);\n\n/**\n* @param millis from 1970-01-01T00:00:00Z\n*/\nint getDayOfMonth(long millis) {\nint year = getYear(millis);\nint month = getMonthOfYear(millis, year);\nreturn getDayOfMonth(millis, year, month);\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:getOffset(J)I",
            "method_body": "public int getOffset(long instant) {\nreturn getInfo(instant).getOffset(instant);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence:readFrom(Ljava/io/DataInput;)Lorg/joda/time/tz/DateTimeZoneBuilder$Recurrence;",
            "method_body": "static Recurrence readFrom(DataInput in) throws IOException {\nreturn new Recurrence(OfYear.readFrom(in), in.readUTF(), (int)readMillis(in));\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:secondOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField secondOfDay() {\nreturn iSecondOfDay;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.joda.time.field.PreciseDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nif (instant >= 0) {\nreturn (int) ((instant / getUnitMillis()) % iRange);\n} else {\nreturn iRange - 1 + (int) (((instant + 1) / getUnitMillis()) % iRange);\n}\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.joda.time.base.AbstractInstant:<init>()V",
            "method_body": "protected AbstractInstant() {\nsuper();\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:setDayOfWeek(Lorg/joda/time/Chronology;J)J",
            "method_body": "private long setDayOfWeek(Chronology chrono, long instant) {\nint dayOfWeek = chrono.dayOfWeek().get(instant);\nint daysToAdd = iDayOfWeek - dayOfWeek;\nif (daysToAdd != 0) {\nif (iAdvance) {\nif (daysToAdd < 0) {\ndaysToAdd += 7;\n}\n} else {\nif (daysToAdd > 0) {\ndaysToAdd -= 7;\n}\n}\ninstant = chrono.dayOfWeek().add(instant, daysToAdd);\n}\nreturn instant;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYearInfo(I)Lorg/joda/time/chrono/BasicChronology$YearInfo;",
            "method_body": "abstract long getAverageMillisPerYear();\n\n/**\n* Gets an average value for the milliseconds per year, divided by two.\n*\n* @return the millis per year divided by two\n*/\nabstract long getAverageMillisPerYearDividedByTwo();\n\n/**\n* Gets an average value for the milliseconds per month.\n*\n* @return the millis per month\n*/\nabstract long getAverageMillisPerMonth();\n\n/**\n* Returns a constant representing the approximate number of milliseconds\n* elapsed from year 0 of this chronology, divided by two. This constant\n* <em>must</em> be defined as:\n* <pre>\n*    (yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch) / 2\n* </pre>\n* where epoch is 1970-01-01 (Gregorian).\n*/\nabstract long getApproxMillisAtEpochDividedByTwo();\n\n/**\n* Sets the year from an instant and year.\n*\n* @param instant  millis from 1970-01-01T00:00:00Z\n* @param year  the year to set\n* @return the updated millis\n*/\nabstract long setYear(long instant, int year);\n\n//-----------------------------------------------------------------------\n// Although accessed by multiple threads, this method doesn't need to be synchronized.\nprivate YearInfo getYearInfo(int year) {\nYearInfo info = iYearInfoCache[year & CACHE_MASK];\nif (info == null || info.iYear != year) {\ninfo = new YearInfo(year, calculateFirstDayOfYearMillis(year));\niYearInfoCache[year & CACHE_MASK] = info;\n}\nreturn info;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.joda.time.tz.FixedDateTimeZone:hashCode()I",
            "method_body": "public int hashCode() {\nreturn getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:getStandardOffset(J)I",
            "method_body": "public int getStandardOffset(long instant) {\nlong[] transitions = iTransitions;\nint i = Arrays.binarySearch(transitions, instant);\nif (i >= 0) {\nreturn iStandardOffsets[i];\n}\ni = ~i;\nif (i < transitions.length) {\nif (i > 0) {\nreturn iStandardOffsets[i - 1];\n}\nreturn 0;\n}\nif (iTailZone == null) {\nreturn iStandardOffsets[i - 1];\n}\nreturn iTailZone.getStandardOffset(instant);\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.joda.time.field.MillisDurationField:isSupported()Z",
            "method_body": "public boolean isSupported() {\nreturn true;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.joda.time.chrono.BasicWeekyearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn null;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfMonth(JII)I",
            "method_body": "int getDayOfMonth(long millis, int year, int month) {\nlong dateMillis = getYearMillis(year);\ndateMillis += getTotalMillisByYearMonth(year, month);\nreturn (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:getMinimumValue()I",
            "method_body": "public int getMinimumValue() {\nreturn 0;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
            "method_body": "public final String getID() {\nreturn iID;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.joda.time.field.ImpreciseDateTimeField:getDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField getDurationField() {\nreturn iDurationField;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:hourOfDay()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType hourOfDay() {\nreturn HOUR_OF_DAY_TYPE;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getAverageMillisPerYearDividedByTwo()J",
            "method_body": "long getAverageMillisPerYearDividedByTwo() {\nreturn MILLIS_PER_YEAR / 2;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.joda.time.field.OffsetDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getLeapDurationField() {\nreturn getWrappedField().getLeapDurationField();\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfYear(JI)I",
            "method_body": "int getDayOfYear(long instant, int year) {\nlong yearStart = getYearMillis(year);\nreturn (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:<init>(Lorg/joda/time/DateTimeZone;)V",
            "method_body": "private CachedDateTimeZone(DateTimeZone zone) {\nsuper(zone.getID());\niZone = zone;\niInfoCache = new Info[cInfoCacheMask + 1];\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;)V",
            "method_body": "protected AssembledChronology(Chronology base, Object param) {\niBase = base;\niParam = param;\nsetFields();\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:nextTransition(J)J",
            "method_body": "public long nextTransition(long instant) {\nint standardOffset = iStandardOffset;\nRecurrence startRecurrence = iStartRecurrence;\nRecurrence endRecurrence = iEndRecurrence;\n\nlong start, end;\n\ntry {\nstart = startRecurrence.next\n(instant, standardOffset, endRecurrence.getSaveMillis());\nif (instant > 0 && start < 0) {\n// Overflowed.\nstart = instant;\n}\n} catch (IllegalArgumentException e) {\n// Overflowed.\nstart = instant;\n} catch (ArithmeticException e) {\n// Overflowed.\nstart = instant;\n}\n\ntry {\nend = endRecurrence.next\n(instant, standardOffset, startRecurrence.getSaveMillis());\nif (instant > 0 && end < 0) {\n// Overflowed.\nend = instant;\n}\n} catch (IllegalArgumentException e) {\n// Overflowed.\nend = instant;\n} catch (ArithmeticException e) {\n// Overflowed.\nend = instant;\n}\n\nreturn (start > end) ? end : start;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:monthOfYear()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField monthOfYear() {\nreturn iMonthOfYear;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:eras()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField eras() {\nreturn iEras;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.joda.time.chrono.BaseChronology:eras()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField eras() {\nreturn UnsupportedDurationField.getInstance(DurationFieldType.eras());\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nreturn iPrintedLengthEstimate;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.joda.time.field.PreciseDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn iRangeField;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nreturn (DateTimeZone)getParam();\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:remainder(J)J",
            "method_body": "public long remainder(long instant) {\nif (instant >= 0) {\nreturn instant % iUnitMillis;\n} else {\nreturn (instant + 1) % iUnitMillis + iUnitMillis - 1;\n}\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfWeek(J)I",
            "method_body": "int getDayOfWeek(long instant) {\n// 1970-01-01 is day of week 4, Thursday.\n\nlong daysSince19700101;\nif (instant >= 0) {\ndaysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n} else {\ndaysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n/ DateTimeConstants.MILLIS_PER_DAY;\nif (daysSince19700101 < -3) {\nreturn 7 + (int) ((daysSince19700101 + 4) % 7);\n}\n}\n\nreturn 1 + (int) ((daysSince19700101 + 3) % 7);\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:getDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getDurationField() {\nreturn iUnitField;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology$Fields:isSupported(Lorg/joda/time/DateTimeField;)Z",
            "method_body": "private static boolean isSupported(DateTimeField field) {\nreturn field == null ? false : field.isSupported();\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:getChronology()Lorg/joda/time/Chronology;",
            "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:weeks()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField weeks() {\nreturn iWeeks;\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:secondOfMinute()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType secondOfMinute() {\nreturn SECOND_OF_MINUTE_TYPE;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getMinYear()I",
            "method_body": "int getMinYear() {\nreturn MIN_YEAR;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:dayOfYear()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField dayOfYear() {\nreturn iDayOfYear;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
            "method_body": "BasicGJChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param, minDaysInFirstWeek);\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:yearOfCentury()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField yearOfCentury() {\nreturn iYearOfCentury;\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:hours()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField hours() {\nreturn iHours;\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getParam()Ljava/lang/Object;",
            "method_body": "protected final Object getParam() {\nreturn iParam;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.joda.time.base.AbstractDateTime:getHourOfDay()I",
            "method_body": "public int getHourOfDay() {\nreturn getChronology().hourOfDay().get(getMillis());\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:halfdays()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField halfdays() {\nreturn iHalfdays;\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationField:getUnitMillis()J",
            "method_body": "public final long getUnitMillis() {\nreturn iUnitMillis;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.joda.time.field.MillisDurationField:getType()Lorg/joda/time/DurationFieldType;",
            "method_body": "public DurationFieldType getType() {\nreturn DurationFieldType.millis();\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:<init>(Lorg/joda/time/DurationField;Lorg/joda/time/DateTimeZone;)V",
            "method_body": "ZonedDurationField(DurationField field, DateTimeZone zone) {\nsuper(field.getType());\nif (!field.isSupported()) {\nthrow new IllegalArgumentException();\n}\niField = field;\niTimeField = useTimeArithmetic(field);\niZone = zone;\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone$Info:getOffset(J)I",
            "method_body": "public int getOffset(long millis) {\nif (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\nif (iOffset == Integer.MIN_VALUE) {\niOffset = iZoneRef.getOffset(iPeriodStart);\n}\nreturn iOffset;\n}\nreturn iNextInfo.getOffset(millis);\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:eras()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType eras() {\nreturn ERAS_TYPE;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.joda.time.field.ScaledDurationField:hashCode()I",
            "method_body": "public int hashCode() {\nlong scalar = iScalar;\nint hash = (int) (scalar ^ (scalar >>> 32));\nhash += getType().hashCode();\nhash += getWrappedField().hashCode();\nreturn hash;\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nStringBuffer buf, long instant, Chronology chrono,\nint displayOffset, DateTimeZone displayZone, Locale locale) {\ntry {\nDateTimeField field = iFieldType.getField(chrono);\nFormatUtils.appendPaddedInteger(buf, field.get(instant), iMinPrintedDigits);\n} catch (RuntimeException e) {\nappendUnknownString(buf, iMinPrintedDigits);\n}\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.joda.time.field.UnsupportedDurationField:isSupported()Z",
            "method_body": "public boolean isSupported() {\nreturn false;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.joda.time.format.ISODateTimeFormat:dateTime()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter dateTime() {\nif (dt == null) {\ndt = new DateTimeFormatterBuilder()\n.append(date())\n.append(tTime())\n.toFormatter();\n}\nreturn dt;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:centuries()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField centuries() {\nreturn iCenturies;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeAdd(JJ)J",
            "method_body": "public static long safeAdd(long val1, long val2) {\nlong sum = val1 + val2;\n// If there is a sign change, but the two values have the same sign...\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nthrow new ArithmeticException\n(\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n}\nreturn sum;\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nChronology base;\nif ((base = getBase()) != null) {\nreturn base.getZone();\n}\nreturn DateTimeZone.UTC;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:convertLocalToUTC(JZ)J",
            "method_body": "public long convertLocalToUTC(long instantLocal, boolean strict) {\n// get the offset at instantLocal (first estimate)\nint offsetLocal = getOffset(instantLocal);\n// adjust instantLocal using the estimate and recalc the offset\nint offset = getOffset(instantLocal - offsetLocal);\n// if the offsets differ, we must be near a DST boundary\nif (offsetLocal != offset) {\n// if strict then always check if in DST gap\n// otherwise only check if zone in Western hemisphere (as the\n// value of offset is already correct for Eastern hemisphere)\nif (strict || offsetLocal < 0) {\n// determine if we are in the DST gap\nlong nextLocal = nextTransition(instantLocal - offsetLocal);\nif (nextLocal == (instantLocal - offsetLocal)) {\nnextLocal = Long.MAX_VALUE;\n}\nlong nextAdjusted = nextTransition(instantLocal - offset);\nif (nextAdjusted == (instantLocal - offset)) {\nnextAdjusted = Long.MAX_VALUE;\n}\nif (nextLocal != nextAdjusted) {\n// yes we are in the DST gap\nif (strict) {\n// DST gap is not acceptable\nthrow new IllegalArgumentException(\"Illegal instant due to time zone offset transition: \" +\nDateTimeFormat.forPattern(\"yyyy-MM-dd'T'HH:mm:ss.SSS\").print(new Instant(instantLocal)) +\n\" (\" + getID() + \")\");\n} else {\n// DST gap is acceptable, but for the Western hemisphere\n// the offset is wrong and will result in local times\n// before the cutover so use the offsetLocal instead\noffset = offsetLocal;\n}\n}\n}\n}\n// check for overflow\nlong instantUTC = instantLocal - offset;\n// If there is a sign change, but the two values have different signs...\nif ((instantLocal ^ instantUTC) < 0 && (instantLocal ^ offset) < 0) {\nthrow new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n}\nreturn instantUTC;\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
            "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nthrow new UnsupportedOperationException(\"Printing not supported\");\n}\nreturn printer;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:createInfo(J)Lorg/joda/time/tz/CachedDateTimeZone$Info;",
            "method_body": "private Info createInfo(long millis) {\nlong periodStart = millis & (0xffffffffL << 32);\nInfo info = new Info(iZone, periodStart);\n\nlong end = periodStart | 0xffffffffL;\nInfo chain = info;\nwhile (true) {\nlong next = iZone.nextTransition(periodStart);\nif (next == periodStart || next > end) {\nbreak;\n}\nperiodStart = next;\nchain = (chain.iNextInfo = new Info(iZone, periodStart));\n}\n\nreturn info;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.years();\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.joda.time.field.ZeroIsMaxDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getLeapDurationField() {\nreturn getWrappedField().getLeapDurationField();\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:halfdayOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField halfdayOfDay() {\nreturn iHalfdayOfDay;\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:hashCode()I",
            "method_body": "public int hashCode() {\nreturn iZone.hashCode();\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMillisOfDay(J)I",
            "method_body": "int getMillisOfDay(long instant) {\nif (instant >= 0) {\nreturn (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n} else {\nreturn (DateTimeConstants.MILLIS_PER_DAY - 1)\n+ (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n}\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType:getField(Lorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
            "method_body": "public DateTimeField getField(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\n\nswitch (iOrdinal) {\ncase ERA:\nreturn chronology.era();\ncase YEAR_OF_ERA:\nreturn chronology.yearOfEra();\ncase CENTURY_OF_ERA:\nreturn chronology.centuryOfEra();\ncase YEAR_OF_CENTURY:\nreturn chronology.yearOfCentury();\ncase YEAR:\nreturn chronology.year();\ncase DAY_OF_YEAR:\nreturn chronology.dayOfYear();\ncase MONTH_OF_YEAR:\nreturn chronology.monthOfYear();\ncase DAY_OF_MONTH:\nreturn chronology.dayOfMonth();\ncase WEEKYEAR_OF_CENTURY:\nreturn chronology.weekyearOfCentury();\ncase WEEKYEAR:\nreturn chronology.weekyear();\ncase WEEK_OF_WEEKYEAR:\nreturn chronology.weekOfWeekyear();\ncase DAY_OF_WEEK:\nreturn chronology.dayOfWeek();\ncase HALFDAY_OF_DAY:\nreturn chronology.halfdayOfDay();\ncase HOUR_OF_HALFDAY:\nreturn chronology.hourOfHalfday();\ncase CLOCKHOUR_OF_HALFDAY:\nreturn chronology.clockhourOfHalfday();\ncase CLOCKHOUR_OF_DAY:\nreturn chronology.clockhourOfDay();\ncase HOUR_OF_DAY:\nreturn chronology.hourOfDay();\ncase MINUTE_OF_DAY:\nreturn chronology.minuteOfDay();\ncase MINUTE_OF_HOUR:\nreturn chronology.minuteOfHour();\ncase SECOND_OF_DAY:\nreturn chronology.secondOfDay();\ncase SECOND_OF_MINUTE:\nreturn chronology.secondOfMinute();\ncase MILLIS_OF_DAY:\nreturn chronology.millisOfDay();\ncase MILLIS_OF_SECOND:\nreturn chronology.millisOfSecond();\ndefault:\n// Shouldn't happen.\nthrow new InternalError();\n}\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMonthOfYear(J)I",
            "method_body": "int getMonthOfYear(long millis) {\nreturn getMonthOfYear(millis, getYear(millis));\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYearMillis(I)J",
            "method_body": "long getYearMillis(int year) {\nreturn getYearInfo(year).iFirstDayMillis;\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:<init>(JLorg/joda/time/Chronology;)V",
            "method_body": "public BaseDateTime(long instant, Chronology chronology) {\nsuper();\niChronology = checkChronology(chronology);\niMillis = checkInstant(instant, iChronology);\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.joda.time.chrono.BasicWeekyearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.weeks();\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;)V",
            "method_body": "private void printTo(StringBuffer buf, long instant, Chronology chrono) {\nDateTimePrinter printer = requirePrinter();\nchrono = selectChronology(chrono);\n// Shift instant into local time (UTC) to avoid excessive offset\n// calculations when printing multiple fields in a composite printer.\nDateTimeZone zone = chrono.getZone();\nint offset = zone.getOffset(instant);\nlong adjustedInstant = instant + offset;\nif ((instant ^ adjustedInstant) < 0 && (instant ^ offset) >= 0) {\n// Time zone offset overflow, so revert to UTC.\nzone = DateTimeZone.UTC;\noffset = 0;\nadjustedInstant = instant;\n}\nprinter.printTo(buf, adjustedInstant, chrono.withUTC(), offset, zone, iLocale);\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:readFrom(Ljava/io/DataInput;Ljava/lang/String;)Lorg/joda/time/tz/DateTimeZoneBuilder$DSTZone;",
            "method_body": "static DSTZone readFrom(DataInput in, String id) throws IOException {\nreturn new DSTZone(id, (int)readMillis(in),\nRecurrence.readFrom(in), Recurrence.readFrom(in));\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:setDayOfMonth(Lorg/joda/time/Chronology;J)J",
            "method_body": "private long setDayOfMonth(Chronology chrono, long instant) {\nif (iDayOfMonth >= 0) {\ninstant = chrono.dayOfMonth().set(instant, iDayOfMonth);\n} else {\ninstant = chrono.dayOfMonth().set(instant, 1);\ninstant = chrono.monthOfYear().add(instant, 1);\ninstant = chrono.dayOfMonth().add(instant, iDayOfMonth);\n}\nreturn instant;\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder:readFrom(Ljava/io/DataInput;Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone readFrom(DataInput in, String id) throws IOException {\nswitch (in.readUnsignedByte()) {\ncase 'F':\nDateTimeZone fixed = new FixedDateTimeZone\n(id, in.readUTF(), (int)readMillis(in), (int)readMillis(in));\nif (fixed.equals(DateTimeZone.UTC)) {\nfixed = DateTimeZone.UTC;\n}\nreturn fixed;\ncase 'C':\nreturn CachedDateTimeZone.forZone(PrecalculatedZone.readFrom(in, id));\ncase 'P':\nreturn PrecalculatedZone.readFrom(in, id);\ndefault:\nthrow new IOException(\"Invalid encoding\");\n}\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology$Fields:copyFieldsFrom(Lorg/joda/time/Chronology;)V",
            "method_body": "public void copyFieldsFrom(Chronology chrono) {\n{\nDurationField f;\nif (isSupported(f = chrono.millis())) {\nmillis = f;\n}\nif (isSupported(f = chrono.seconds())) {\nseconds = f;\n}\nif (isSupported(f = chrono.minutes())) {\nminutes = f;\n}\nif (isSupported(f = chrono.hours())) {\nhours = f;\n}\nif (isSupported(f = chrono.halfdays())) {\nhalfdays = f;\n}\nif (isSupported(f = chrono.days())) {\ndays = f;\n}\nif (isSupported(f = chrono.weeks())) {\nweeks = f;\n}\nif (isSupported(f = chrono.weekyears())) {\nweekyears = f;\n}\nif (isSupported(f = chrono.months())) {\nmonths = f;\n}\nif (isSupported(f = chrono.years())) {\nyears = f;\n}\nif (isSupported(f = chrono.centuries())) {\ncenturies = f;\n}\nif (isSupported(f = chrono.eras())) {\neras = f;\n}\n}\n\n{\nDateTimeField f;\nif (isSupported(f = chrono.millisOfSecond())) {\nmillisOfSecond = f;\n}\nif (isSupported(f = chrono.millisOfDay())) {\nmillisOfDay = f;\n}\nif (isSupported(f = chrono.secondOfMinute())) {\nsecondOfMinute = f;\n}\nif (isSupported(f = chrono.secondOfDay())) {\nsecondOfDay = f;\n}\nif (isSupported(f = chrono.minuteOfHour())) {\nminuteOfHour = f;\n}\nif (isSupported(f = chrono.minuteOfDay())) {\nminuteOfDay = f;\n}\nif (isSupported(f = chrono.hourOfDay())) {\nhourOfDay = f;\n}\nif (isSupported(f = chrono.clockhourOfDay())) {\nclockhourOfDay = f;\n}\nif (isSupported(f = chrono.hourOfHalfday())) {\nhourOfHalfday = f;\n}\nif (isSupported(f = chrono.clockhourOfHalfday())) {\nclockhourOfHalfday = f;\n}\nif (isSupported(f = chrono.halfdayOfDay())) {\nhalfdayOfDay = f;\n}\nif (isSupported(f = chrono.dayOfWeek())) {\ndayOfWeek = f;\n}\nif (isSupported(f = chrono.dayOfMonth())) {\ndayOfMonth = f;\n}\nif (isSupported(f = chrono.dayOfYear())) {\ndayOfYear = f;\n}\nif (isSupported(f = chrono.weekOfWeekyear())) {\nweekOfWeekyear = f;\n}\nif (isSupported(f = chrono.weekyear())) {\nweekyear = f;\n}\nif (isSupported(f = chrono.weekyearOfCentury())) {\nweekyearOfCentury = f;\n}\nif (isSupported(f = chrono.monthOfYear())) {\nmonthOfYear = f;\n}\nif (isSupported(f = chrono.year())) {\nyear = f;\n}\nif (isSupported(f = chrono.yearOfEra())) {\nyearOfEra = f;\n}\nif (isSupported(f = chrono.yearOfCentury())) {\nyearOfCentury = f;\n}\nif (isSupported(f = chrono.centuryOfEra())) {\ncenturyOfEra = f;\n}\nif (isSupported(f = chrono.era())) {\nera = f;\n}\n}\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getInstantMillis(Lorg/joda/time/ReadableInstant;)J",
            "method_body": "public static final long getInstantMillis(ReadableInstant instant) {\nif (instant == null) {\nreturn DateTimeUtils.currentTimeMillis();\n}\nreturn instant.getMillis();\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:verifyValueBounds(Lorg/joda/time/DateTimeField;III)V",
            "method_body": "public static void verifyValueBounds(DateTimeField field,\nint value, int lowerBound, int upperBound) {\nif ((value < lowerBound) || (value > upperBound)) {\nthrow new IllegalFieldValueException\n(field.getType(), new Integer(value),\nnew Integer(lowerBound), new Integer(upperBound));\n}\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.joda.time.field.DecoratedDateTimeField:getDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getDurationField() {\nreturn iField.getDurationField();\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getBase()Lorg/joda/time/Chronology;",
            "method_body": "protected abstract void assemble(Fields fields);\n\n/**\n* Returns the same base chronology as passed into the constructor.\n*/\nprotected final Chronology getBase() {\nreturn iBase;\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.joda.time.field.RemainderDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn iRangeField;\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:seconds()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField seconds() {\nreturn iSeconds;\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getMinimumValue()I",
            "method_body": "public int getMinimumValue() {\nreturn 1;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstanceUTC()Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstanceUTC() {\nreturn INSTANCE_UTC;\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfMonth(JI)I",
            "method_body": "int getDayOfMonth(long millis, int year) {\nint month = getMonthOfYear(millis, year);\nreturn getDayOfMonth(millis, year, month);\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\n//\nint thisYear = iChronology.getYear(instant);\n//\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\n// Quietly force DOM to nearest sane value.\nthisDom = maxDom;\n}\n// Return newly calculated millis value\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\niChronology.getMillisOfDay(instant);\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:<init>(Lorg/joda/time/DateTimeFieldType;)V",
            "method_body": "protected BaseDateTimeField(DateTimeFieldType type) {\nsuper();\nif (type == null) {\nthrow new IllegalArgumentException(\"The type must not be null\");\n}\niType = type;\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDateMidnightMillis(III)J",
            "method_body": "long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\nFieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\nFieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\nFieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\nreturn getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.weeks();\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.joda.time.field.BaseDurationField:getType()Lorg/joda/time/DurationFieldType;",
            "method_body": "public final DurationFieldType getType() {\nreturn iType;\n}",
            "method_id": 119
        },
        {
            "method_signature": "org.joda.time.field.MillisDurationField:add(JI)J",
            "method_body": "public long add(long instant, int value) {\nreturn FieldUtils.safeAdd(instant, value);\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:weekyear()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField weekyear() {\nreturn iWeekyear;\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:yearOfEra()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField yearOfEra() {\nreturn iYearOfEra;\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.joda.time.field.UnsupportedDurationField:getUnitMillis()J",
            "method_body": "public long getUnitMillis() {\nreturn 0;\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:millisOfSecond()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField millisOfSecond() {\nreturn iMillisOfSecond;\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:verifyValueBounds(Lorg/joda/time/DateTimeFieldType;III)V",
            "method_body": "public static void verifyValueBounds(DateTimeFieldType fieldType,\nint value, int lowerBound, int upperBound) {\nif ((value < lowerBound) || (value > upperBound)) {\nthrow new IllegalFieldValueException\n(fieldType, new Integer(value),\nnew Integer(lowerBound), new Integer(upperBound));\n}\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:convertField(Lorg/joda/time/DateTimeField;Ljava/util/HashMap;)Lorg/joda/time/DateTimeField;",
            "method_body": "private DateTimeField convertField(DateTimeField field, HashMap<Object, Object> converted) {\nif (field == null || !field.isSupported()) {\nreturn field;\n}\nif (converted.containsKey(field)) {\nreturn (DateTimeField)converted.get(field);\n}\nZonedDateTimeField zonedField =\nnew ZonedDateTimeField(field, getZone(),\nconvertField(field.getDurationField(), converted),\nconvertField(field.getRangeDurationField(), converted),\nconvertField(field.getLeapDurationField(), converted));\nconverted.put(field, zonedField);\nreturn zonedField;\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nStringBuffer buf, long instant, Chronology chrono,\nint displayOffset, DateTimeZone displayZone, Locale locale) {\nDateTimePrinter[] elements = iPrinters;\nif (elements == null) {\nthrow new UnsupportedOperationException();\n}\n\nif (locale == null) {\n// Guard against default locale changing concurrently.\nlocale = Locale.getDefault();\n}\n\nint len = elements.length;\nfor (int i = 0; i < len; i++) {\nelements[i].printTo(buf, instant, chrono, displayOffset, displayZone, locale);\n}\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:checkChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "protected Chronology checkChronology(Chronology chronology) {\nreturn DateTimeUtils.getChronology(chronology);\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.joda.time.chrono.BaseChronology:<init>()V",
            "method_body": "protected BaseChronology() {\nsuper();\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getMonthOfYear(instant);\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int value) {\nFieldUtils.verifyValueBounds(this, value, getMinimumValue(),\ngetMaximumValueForSet(instant, value));\nreturn instant + (value - get(instant)) * iUnitMillis;\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:useTimeArithmetic(Lorg/joda/time/DurationField;)Z",
            "method_body": "static boolean useTimeArithmetic(DurationField field) {\n// Use time of day arithmetic rules for unit durations less than\n// typical time zone offsets.\nreturn field != null && field.getUnitMillis() < DateTimeConstants.MILLIS_PER_HOUR * 12;\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getLeapDurationField() {\nreturn null;\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.joda.time.field.DividedDateTimeField:getDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getDurationField() {\nreturn iDurationField;\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:secondOfMinute()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField secondOfMinute() {\nreturn iSecondOfMinute;\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:minuteOfHour()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField minuteOfHour() {\nreturn iMinuteOfHour;\n}",
            "method_id": 136
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:<init>(Ljava/lang/String;ILorg/joda/time/tz/DateTimeZoneBuilder$Recurrence;Lorg/joda/time/tz/DateTimeZoneBuilder$Recurrence;)V",
            "method_body": "DSTZone(String id, int standardOffset,\nRecurrence startRecurrence, Recurrence endRecurrence) {\nsuper(id);\niStandardOffset = standardOffset;\niStartRecurrence = startRecurrence;\niEndRecurrence = endRecurrence;\n}",
            "method_id": 137
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadableInstant;)V",
            "method_body": "public void printTo(StringBuffer buf, ReadableInstant instant) {\nlong millis = DateTimeUtils.getInstantMillis(instant);\nChronology chrono = DateTimeUtils.getInstantChronology(instant);\nprintTo(buf, millis, chrono);\n}",
            "method_id": 138
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:millis()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField millis() {\nreturn iMillis;\n}",
            "method_id": 139
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:convertField(Lorg/joda/time/DurationField;Ljava/util/HashMap;)Lorg/joda/time/DurationField;",
            "method_body": "private DurationField convertField(DurationField field, HashMap<Object, Object> converted) {\nif (field == null || !field.isSupported()) {\nreturn field;\n}\nif (converted.containsKey(field)) {\nreturn (DurationField)converted.get(field);\n}\nZonedDurationField zonedField = new ZonedDurationField(field, getZone());\nconverted.put(field, zonedField);\nreturn zonedField;\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getMaxYear()I",
            "method_body": "int getMaxYear() {\nreturn MAX_YEAR;\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:withUTC()Lorg/joda/time/Chronology;",
            "method_body": "public Chronology withUTC() {\nreturn INSTANCE_UTC;\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getApproxMillisAtEpochDividedByTwo()J",
            "method_body": "long getApproxMillisAtEpochDividedByTwo() {\nreturn (1970L * MILLIS_PER_YEAR) / 2;\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:getOffset(J)I",
            "method_body": "public int getOffset(long instant) {\nreturn iStandardOffset + findMatchingRecurrence(instant).getSaveMillis();\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:getStandardOffset(J)I",
            "method_body": "public int getStandardOffset(long instant) {\nreturn iStandardOffset;\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:next(JII)J",
            "method_body": "public long next(long instant, int standardOffset, int saveMillis) {\nint offset;\nif (iMode == 'w') {\noffset = standardOffset + saveMillis;\n} else if (iMode == 's') {\noffset = standardOffset;\n} else {\noffset = 0;\n}\n\n// Convert from UTC to local time.\ninstant += offset;\n\nChronology chrono = ISOChronology.getInstanceUTC();\nlong next = chrono.monthOfYear().set(instant, iMonthOfYear);\n// Be lenient with millisOfDay.\nnext = chrono.millisOfDay().set(next, 0);\nnext = chrono.millisOfDay().add(next, iMillisOfDay);\nnext = setDayOfMonthNext(chrono, next);\n\nif (iDayOfWeek == 0) {\nif (next <= instant) {\nnext = chrono.year().add(next, 1);\nnext = setDayOfMonthNext(chrono, next);\n}\n} else {\nnext = setDayOfWeek(chrono, next);\nif (next <= instant) {\nnext = chrono.year().add(next, 1);\nnext = chrono.monthOfYear().set(next, iMonthOfYear);\nnext = setDayOfMonthNext(chrono, next);\nnext = setDayOfWeek(chrono, next);\n}\n}\n\n// Convert from local time to UTC.\nreturn next - offset;\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:era()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField era() {\nreturn iEra;\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$DSTZone:findMatchingRecurrence(J)Lorg/joda/time/tz/DateTimeZoneBuilder$Recurrence;",
            "method_body": "private Recurrence findMatchingRecurrence(long instant) {\nint standardOffset = iStandardOffset;\nRecurrence startRecurrence = iStartRecurrence;\nRecurrence endRecurrence = iEndRecurrence;\n\nlong start, end;\n\ntry {\nstart = startRecurrence.next\n(instant, standardOffset, endRecurrence.getSaveMillis());\n} catch (IllegalArgumentException e) {\n// Overflowed.\nstart = instant;\n} catch (ArithmeticException e) {\n// Overflowed.\nstart = instant;\n}\n\ntry {\nend = endRecurrence.next\n(instant, standardOffset, startRecurrence.getSaveMillis());\n} catch (IllegalArgumentException e) {\n// Overflowed.\nend = instant;\n} catch (ArithmeticException e) {\n// Overflowed.\nend = instant;\n}\n\nreturn (start > end) ? startRecurrence : endRecurrence;\n}",
            "method_id": 149
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nStringBuffer buf, long instant, Chronology chrono,\nint displayOffset, DateTimeZone displayZone, Locale locale) {\nbuf.append(iValue);\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:hourOfHalfday()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField hourOfHalfday() {\nreturn iHourOfHalfday;\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.joda.time.chrono.GJEraDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn null;\n}",
            "method_id": 152
        },
        {
            "method_signature": "org.joda.time.base.AbstractInstant:toString()Ljava/lang/String;",
            "method_body": "public String toString() {\nreturn ISODateTimeFormat.dateTime().print(this);\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:checkInstant(JLorg/joda/time/Chronology;)J",
            "method_body": "protected long checkInstant(long instant, Chronology chronology) {\nreturn instant;\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:isLeapYear(I)Z",
            "method_body": "boolean isLeapYear(int year) {\nreturn ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationField:add(JI)J",
            "method_body": "public long add(long instant, int value) {\nlong addition = value * iUnitMillis;  // safe\nreturn FieldUtils.safeAdd(instant, addition);\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.joda.time.tz.ZoneInfoProvider:loadZoneData(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "private DateTimeZone loadZoneData(String id) {\nInputStream in = null;\ntry {\nin = openResource(id);\nDateTimeZone tz = DateTimeZoneBuilder.readFrom(in, id);\niZoneInfoMap.put(id, new SoftReference<DateTimeZone>(tz));\nreturn tz;\n} catch (IOException e) {\nuncaughtException(e);\niZoneInfoMap.remove(id);\nreturn null;\n} finally {\ntry {\nif (in != null) {\nin.close();\n}\n} catch (IOException e) {\n}\n}\n}",
            "method_id": 157
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:months()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField months() {\nreturn iMonths;\n}",
            "method_id": 158
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:weekOfWeekyear()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField weekOfWeekyear() {\nreturn iWeekOfWeekyear;\n}",
            "method_id": 159
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:add(JI)J",
            "method_body": "public long add(long instant, int value) {\nreturn getDurationField().add(instant, value);\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:getOffset(J)I",
            "method_body": "public int getOffset(long instant) {\nlong[] transitions = iTransitions;\nint i = Arrays.binarySearch(transitions, instant);\nif (i >= 0) {\nreturn iWallOffsets[i];\n}\ni = ~i;\nif (i < transitions.length) {\nif (i > 0) {\nreturn iWallOffsets[i - 1];\n}\nreturn 0;\n}\nif (iTailZone == null) {\nreturn iWallOffsets[i - 1];\n}\nreturn iTailZone.getOffset(instant);\n}",
            "method_id": 161
        },
        {
            "method_signature": "org.joda.time.field.ScaledDurationField:getUnitMillis()J",
            "method_body": "public long getUnitMillis() {\nreturn getWrappedField().getUnitMillis() * iScalar;\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:getUnitMillis()J",
            "method_body": "public long getUnitMillis() {\nreturn iField.getUnitMillis();\n}",
            "method_id": 163
        },
        {
            "method_signature": "org.joda.time.field.BaseDurationField:isSupported()Z",
            "method_body": "public final boolean isSupported() {\nreturn true;\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone$Info:<init>(Lorg/joda/time/DateTimeZone;J)V",
            "method_body": "Info(DateTimeZone zone, long periodStart) {\niPeriodStart = periodStart;\niZoneRef = zone;\n}",
            "method_id": 165
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:millis()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType millis() {\nreturn MILLIS_TYPE;\n}",
            "method_id": 166
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone$Info:getStandardOffset(J)I",
            "method_body": "public int getStandardOffset(long millis) {\nif (iNextInfo == null || millis < iNextInfo.iPeriodStart) {\nif (iStandardOffset == Integer.MIN_VALUE) {\niStandardOffset = iZoneRef.getStandardOffset(iPeriodStart);\n}\nreturn iStandardOffset;\n}\nreturn iNextInfo.getStandardOffset(millis);\n}",
            "method_id": 167
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:weekyearOfCentury()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField weekyearOfCentury() {\nreturn iWeekyearOfCentury;\n}",
            "method_id": 168
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:<init>(IIIIIIILorg/joda/time/Chronology;)V",
            "method_body": "public BaseDateTime(\nint year,\nint monthOfYear,\nint dayOfMonth,\nint hourOfDay,\nint minuteOfHour,\nint secondOfMinute,\nint millisOfSecond,\nChronology chronology) {\nsuper();\niChronology = checkChronology(chronology);\nlong instant = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth,\nhourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\niMillis = checkInstant(instant, iChronology);\n}",
            "method_id": 169
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:assemble(Lorg/joda/time/chrono/AssembledChronology$Fields;)V",
            "method_body": "protected void assemble(Fields fields) {\n// Keep a local cache of converted fields so as not to create redundant\n// objects.\nHashMap<Object, Object> converted = new HashMap<Object, Object>();\n\n// Convert duration fields...\n\nfields.eras = convertField(fields.eras, converted);\nfields.centuries = convertField(fields.centuries, converted);\nfields.years = convertField(fields.years, converted);\nfields.months = convertField(fields.months, converted);\nfields.weekyears = convertField(fields.weekyears, converted);\nfields.weeks = convertField(fields.weeks, converted);\nfields.days = convertField(fields.days, converted);\n\nfields.halfdays = convertField(fields.halfdays, converted);\nfields.hours = convertField(fields.hours, converted);\nfields.minutes = convertField(fields.minutes, converted);\nfields.seconds = convertField(fields.seconds, converted);\nfields.millis = convertField(fields.millis, converted);\n\n// Convert datetime fields...\n\nfields.year = convertField(fields.year, converted);\nfields.yearOfEra = convertField(fields.yearOfEra, converted);\nfields.yearOfCentury = convertField(fields.yearOfCentury, converted);\nfields.centuryOfEra = convertField(fields.centuryOfEra, converted);\nfields.era = convertField(fields.era, converted);\nfields.dayOfWeek = convertField(fields.dayOfWeek, converted);\nfields.dayOfMonth = convertField(fields.dayOfMonth, converted);\nfields.dayOfYear = convertField(fields.dayOfYear, converted);\nfields.monthOfYear = convertField(fields.monthOfYear, converted);\nfields.weekOfWeekyear = convertField(fields.weekOfWeekyear, converted);\nfields.weekyear = convertField(fields.weekyear, converted);\nfields.weekyearOfCentury = convertField(fields.weekyearOfCentury, converted);\n\nfields.millisOfSecond = convertField(fields.millisOfSecond, converted);\nfields.millisOfDay = convertField(fields.millisOfDay, converted);\nfields.secondOfMinute = convertField(fields.secondOfMinute, converted);\nfields.secondOfDay = convertField(fields.secondOfDay, converted);\nfields.minuteOfHour = convertField(fields.minuteOfHour, converted);\nfields.minuteOfDay = convertField(fields.minuteOfDay, converted);\nfields.hourOfDay = convertField(fields.hourOfDay, converted);\nfields.hourOfHalfday = convertField(fields.hourOfHalfday, converted);\nfields.clockhourOfDay = convertField(fields.clockhourOfDay, converted);\nfields.clockhourOfHalfday = convertField(fields.clockhourOfHalfday, converted);\nfields.halfdayOfDay = convertField(fields.halfdayOfDay, converted);\n}",
            "method_id": 170
        },
        {
            "method_signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getDayOfWeek(instant);\n}",
            "method_id": 171
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:setYear(JI)J",
            "method_body": "long setYear(long instant, int year) {\nint thisYear = getYear(instant);\nint dayOfYear = getDayOfYear(instant, thisYear);\nint millisOfDay = getMillisOfDay(instant);\n\nif (dayOfYear > (31 + 28)) { // after Feb 28\nif (isLeapYear(thisYear)) {\n// Current date is Feb 29 or later.\nif (!isLeapYear(year)) {\n// Moving to a non-leap year, Feb 29 does not exist.\ndayOfYear--;\n}\n} else {\n// Current date is Mar 01 or later.\nif (isLeapYear(year)) {\n// Moving to a leap year, account for Feb 29.\ndayOfYear++;\n}\n}\n}\n\ninstant = getYearMonthDayMillis(year, 1, dayOfYear);\ninstant += millisOfDay;\n\nreturn instant;\n}",
            "method_id": 172
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:days()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField days() {\nreturn iDays;\n}",
            "method_id": 173
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:isSupported()Z",
            "method_body": "public final boolean isSupported() {\nreturn true;\n}",
            "method_id": 174
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology$Fields:isSupported(Lorg/joda/time/DurationField;)Z",
            "method_body": "private static boolean isSupported(DurationField field) {\nreturn field == null ? false : field.isSupported();\n}",
            "method_id": 175
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:forZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/tz/CachedDateTimeZone;",
            "method_body": "public static CachedDateTimeZone forZone(DateTimeZone zone) {\nif (zone instanceof CachedDateTimeZone) {\nreturn (CachedDateTimeZone)zone;\n}\nreturn new CachedDateTimeZone(zone);\n}",
            "method_id": 176
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:dayOfWeek()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField dayOfWeek() {\nreturn iDayOfWeek;\n}",
            "method_id": 177
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:clockhourOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField clockhourOfDay() {\nreturn iClockhourOfDay;\n}",
            "method_id": 178
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:getInfo(J)Lorg/joda/time/tz/CachedDateTimeZone$Info;",
            "method_body": "private Info getInfo(long millis) {\nint period = (int)(millis >> 32);\nInfo[] cache = iInfoCache;\nint index = period & cInfoCacheMask;\nInfo info = cache[index];\nif (info == null || (int)((info.iPeriodStart >> 32)) != period) {\ninfo = createInfo(millis);\ncache[index] = info;\n}\nreturn info;\n}",
            "method_id": 179
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence:<init>(Lorg/joda/time/tz/DateTimeZoneBuilder$OfYear;Ljava/lang/String;I)V",
            "method_body": "Recurrence(OfYear ofYear, String nameKey, int saveMillis) {\niOfYear = ofYear;\niNameKey = nameKey;\niSaveMillis = saveMillis;\n}",
            "method_id": 180
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:assemble(Lorg/joda/time/chrono/AssembledChronology$Fields;)V",
            "method_body": "protected void assemble(Fields fields) {\nif (getBase() == null) {\nsuper.assemble(fields);\n}\n}",
            "method_id": 181
        },
        {
            "method_signature": "org.joda.time.base.AbstractDateTime:<init>()V",
            "method_body": "protected AbstractDateTime() {\nsuper();\n}",
            "method_id": 182
        },
        {
            "method_signature": "org.joda.time.base.AbstractInstant:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object readableInstant) {\n// must be to fulfil ReadableInstant contract\nif (this == readableInstant) {\nreturn true;\n}\nif (readableInstant instanceof ReadableInstant == false) {\nreturn false;\n}\nReadableInstant otherInstant = (ReadableInstant) readableInstant;\nreturn\ngetMillis() == otherInstant.getMillis() &&\nFieldUtils.equals(getChronology(), otherInstant.getChronology());\n}",
            "method_id": 183
        },
        {
            "method_signature": "org.joda.time.field.PreciseDateTimeField:getMaximumValue()I",
            "method_body": "public int getMaximumValue() {\nreturn iRange - 1;\n}",
            "method_id": 184
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder:readFrom(Ljava/io/InputStream;Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone readFrom(InputStream in, String id) throws IOException {\nif (in instanceof DataInput) {\nreturn readFrom((DataInput)in, id);\n} else {\nreturn readFrom((DataInput)new DataInputStream(in), id);\n}\n}",
            "method_id": 185
        },
        {
            "method_signature": "org.joda.time.chrono.BasicYearDateTimeField:getLeapDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getLeapDurationField() {\nreturn iChronology.days();\n}",
            "method_id": 186
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Fraction:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nStringBuffer buf, long instant, Chronology chrono,\nint displayOffset, DateTimeZone displayZone, Locale locale) {\ntry {\nprintTo(buf, null, instant, chrono);\n} catch (IOException e) {\n// Not gonna happen.\n}\n}",
            "method_id": 187
        },
        {
            "method_signature": "org.joda.time.field.DecoratedDateTimeField:getWrappedField()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField getWrappedField() {\nreturn iField;\n}",
            "method_id": 188
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:millisOfDay()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField millisOfDay() {\nreturn iMillisOfDay;\n}",
            "method_id": 189
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:printTo(Ljava/lang/StringBuffer;JLorg/joda/time/Chronology;ILorg/joda/time/DateTimeZone;Ljava/util/Locale;)V",
            "method_body": "public void printTo(\nStringBuffer buf, long instant, Chronology chrono,\nint displayOffset, DateTimeZone displayZone, Locale locale) {\nif (displayZone == null) {\nreturn;  // no zone\n}\nif (displayOffset == 0 && iZeroOffsetPrintText != null) {\nbuf.append(iZeroOffsetPrintText);\nreturn;\n}\nif (displayOffset >= 0) {\nbuf.append('+');\n} else {\nbuf.append('-');\ndisplayOffset = -displayOffset;\n}\n\nint hours = displayOffset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\nif (iMaxFields == 1) {\nreturn;\n}\ndisplayOffset -= hours * (int)DateTimeConstants.MILLIS_PER_HOUR;\nif (displayOffset == 0 && iMinFields <= 1) {\nreturn;\n}\n\nint minutes = displayOffset / DateTimeConstants.MILLIS_PER_MINUTE;\nif (iShowSeparators) {\nbuf.append(':');\n}\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\nif (iMaxFields == 2) {\nreturn;\n}\ndisplayOffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (displayOffset == 0 && iMinFields <= 2) {\nreturn;\n}\n\nint seconds = displayOffset / DateTimeConstants.MILLIS_PER_SECOND;\nif (iShowSeparators) {\nbuf.append(':');\n}\nFormatUtils.appendPaddedInteger(buf, seconds, 2);\nif (iMaxFields == 3) {\nreturn;\n}\ndisplayOffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\nif (displayOffset == 0 && iMinFields <= 3) {\nreturn;\n}\n\nif (iShowSeparators) {\nbuf.append('.');\n}\nFormatUtils.appendPaddedInteger(buf, displayOffset, 3);\n}",
            "method_id": 190
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getDayOfMonth(instant);\n}",
            "method_id": 191
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:minutes()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField minutes() {\nreturn iMinutes;\n}",
            "method_id": 192
        },
        {
            "method_signature": "org.joda.time.tz.CachedDateTimeZone:getStandardOffset(J)I",
            "method_body": "public int getStandardOffset(long instant) {\nreturn getInfo(instant).getStandardOffset(instant);\n}",
            "method_id": 193
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getDaysInMonthMaxForSet(JI)I",
            "method_body": "int getDaysInMonthMaxForSet(long instant, int value) {\nreturn (value > 28 ? getDaysInMonthMax(instant) : 28);\n}",
            "method_id": 194
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:millisOfSecond()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType millisOfSecond() {\nreturn MILLIS_OF_SECOND_TYPE;\n}",
            "method_id": 195
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getInstantChronology(Lorg/joda/time/ReadableInstant;)Lorg/joda/time/Chronology;",
            "method_body": "public static final Chronology getInstantChronology(ReadableInstant instant) {\nif (instant == null) {\nreturn ISOChronology.getInstance();\n}\nChronology chrono = instant.getChronology();\nif (chrono == null) {\nreturn ISOChronology.getInstance();\n}\nreturn chrono;\n}",
            "method_id": 196
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:setDayOfMonthNext(Lorg/joda/time/Chronology;J)J",
            "method_body": "private long setDayOfMonthNext(Chronology chrono, long next) {\ntry {\nnext = setDayOfMonth(chrono, next);\n} catch (IllegalArgumentException e) {\nif (iMonthOfYear == 2 && iDayOfMonth == 29) {\nwhile (chrono.year().isLeap(next) == false) {\nnext = chrono.year().add(next, 1);\n}\nnext = setDayOfMonth(chrono, next);\n} else {\nthrow e;\n}\n}\nreturn next;\n}",
            "method_id": 197
        },
        {
            "method_signature": "org.joda.time.field.DecoratedDurationField:getWrappedField()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField getWrappedField() {\nreturn iField;\n}",
            "method_id": 198
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:centuryOfEra()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField centuryOfEra() {\nreturn iCenturyOfEra;\n}",
            "method_id": 199
        },
        {
            "method_signature": "org.joda.time.tz.ZoneInfoProvider:getZone(Ljava/lang/String;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone(String id) {\nif (id == null) {\nreturn null;\n}\n\nObject obj = iZoneInfoMap.get(id);\nif (obj == null) {\nreturn null;\n}\n\nif (id.equals(obj)) {\n// Load zone data for the first time.\nreturn loadZoneData(id);\n}\n\nif (obj instanceof SoftReference<?>) {\n@SuppressWarnings(\"unchecked\")\nSoftReference<DateTimeZone> ref = (SoftReference<DateTimeZone>) obj;\nDateTimeZone tz = ref.get();\nif (tz != null) {\nreturn tz;\n}\n// Reference cleared; load data again.\nreturn loadZoneData(id);\n}\n\n// If this point is reached, mapping must link to another.\nreturn getZone((String)obj);\n}",
            "method_id": 200
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getTotalMillisByYearMonth(II)J",
            "method_body": "long getTotalMillisByYearMonth(int year, int month) {\nif (isLeapYear(year)) {\nreturn MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n} else {\nreturn MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n}\n}",
            "method_id": 201
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:readFrom(Ljava/io/DataInput;Ljava/lang/String;)Lorg/joda/time/tz/DateTimeZoneBuilder$PrecalculatedZone;",
            "method_body": "static PrecalculatedZone readFrom(DataInput in, String id) throws IOException {\n// Read string pool.\nint poolSize = in.readUnsignedShort();\nString[] pool = new String[poolSize];\nfor (int i=0; i<poolSize; i++) {\npool[i] = in.readUTF();\n}\n\nint size = in.readInt();\nlong[] transitions = new long[size];\nint[] wallOffsets = new int[size];\nint[] standardOffsets = new int[size];\nString[] nameKeys = new String[size];\n\nfor (int i=0; i<size; i++) {\ntransitions[i] = readMillis(in);\nwallOffsets[i] = (int)readMillis(in);\nstandardOffsets[i] = (int)readMillis(in);\ntry {\nint index;\nif (poolSize < 256) {\nindex = in.readUnsignedByte();\n} else {\nindex = in.readUnsignedShort();\n}\nnameKeys[i] = pool[index];\n} catch (ArrayIndexOutOfBoundsException e) {\nthrow new IOException(\"Invalid encoding\");\n}\n}\n\nDSTZone tailZone = null;\nif (in.readBoolean()) {\ntailZone = DSTZone.readFrom(in, id);\n}\n\nreturn new PrecalculatedZone\n(id, transitions, wallOffsets, standardOffsets, nameKeys, tailZone);\n}",
            "method_id": 202
        },
        {
            "method_signature": "org.joda.time.chrono.BasicYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn null;\n}",
            "method_id": 203
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:getUnitMillis()J",
            "method_body": "public final long getUnitMillis() {\nreturn iUnitMillis;\n}",
            "method_id": 204
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYearMonthDayMillis(III)J",
            "method_body": "long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\nlong millis = getYearMillis(year);\nmillis += getTotalMillisByYearMonth(year, month);\nreturn millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n}",
            "method_id": 205
        },
        {
            "method_signature": "org.joda.time.tz.ZoneInfoProvider:openResource(Ljava/lang/String;)Ljava/io/InputStream;",
            "method_body": "private InputStream openResource(String name) throws IOException {\nInputStream in;\nif (iFileDir != null) {\nin = new FileInputStream(new File(iFileDir, name));\n} else {\nString path = iResourcePath.concat(name);\nif (iLoader != null) {\nin = iLoader.getResourceAsStream(path);\n} else {\nin = ClassLoader.getSystemResourceAsStream(path);\n}\nif (in == null) {\nStringBuffer buf = new StringBuffer(40)\n.append(\"Resource not found: \\\"\")\n.append(path)\n.append(\"\\\" ClassLoader: \")\n.append(iLoader != null ? iLoader.toString() : \"system\");\nthrow new IOException(buf.toString());\n}\n}\nreturn in;\n}",
            "method_id": 206
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getMaximumValueForSet(JI)I",
            "method_body": "protected int getMaximumValueForSet(long instant, int value) {\nreturn iChronology.getDaysInMonthMaxForSet(instant, value);\n}",
            "method_id": 207
        },
        {
            "method_signature": "org.joda.time.field.PreciseDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int value) {\nFieldUtils.verifyValueBounds(this, value, getMinimumValue(), getMaximumValue());\nreturn instant + (value - get(instant)) * iUnitMillis;\n}",
            "method_id": 208
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:convertUTCToLocal(J)J",
            "method_body": "public long convertUTCToLocal(long instantUTC) {\nint offset = getOffset(instantUTC);\nlong instantLocal = instantUTC + offset;\n// If there is a sign change, but the two values have the same sign...\nif ((instantUTC ^ instantLocal) < 0 && (instantUTC ^ offset) >= 0) {\nthrow new ArithmeticException(\"Adding time zone offset caused overflow\");\n}\nreturn instantLocal;\n}",
            "method_id": 209
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$PrecalculatedZone:<init>(Ljava/lang/String;[J[I[I[Ljava/lang/String;Lorg/joda/time/tz/DateTimeZoneBuilder$DSTZone;)V",
            "method_body": "private PrecalculatedZone(String id, long[] transitions, int[] wallOffsets,\nint[] standardOffsets, String[] nameKeys, DSTZone tailZone)\n{\nsuper(id);\niTransitions = transitions;\niWallOffsets = wallOffsets;\niStandardOffsets = standardOffsets;\niNameKeys = nameKeys;\niTailZone = tailZone;\n}",
            "method_id": 210
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:minuteOfHour()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType minuteOfHour() {\nreturn MINUTE_OF_HOUR_TYPE;\n}",
            "method_id": 211
        },
        {
            "method_signature": "org.joda.time.chrono.BasicYearDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int year) {\nFieldUtils.verifyValueBounds\n(this, year, iChronology.getMinYear(), iChronology.getMaxYear());\nreturn iChronology.setYear(instant, year);\n}",
            "method_id": 212
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getMonthOfYear(JI)I",
            "method_body": "int getMonthOfYear(long millis, int year) {\n// Perform a binary search to get the month. To make it go even faster,\n// compare using ints instead of longs. The number of milliseconds per\n// year exceeds the limit of a 32-bit int's capacity, so divide by\n// 1024. No precision is lost (except time of day) since the number of\n// milliseconds per day contains 1024 as a factor. After the division,\n// the instant isn't measured in milliseconds, but in units of\n// (128/125)seconds.\n\nint i = (int)((millis - getYearMillis(year)) >> 10);\n\n// There are 86400000 milliseconds per day, but divided by 1024 is\n// 84375. There are 84375 (128/125)seconds per day.\n\nreturn\n(isLeapYear(year))\n? ((i < 182 * 84375)\n? ((i < 91 * 84375)\n? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n: ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n: ((i < 274 * 84375)\n? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n: ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n: ((i < 181 * 84375)\n? ((i < 90 * 84375)\n? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n: ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n: ((i < 273 * 84375)\n? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n: ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n}",
            "method_id": 213
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$OfYear:<init>(CIIIZI)V",
            "method_body": "OfYear(char mode,\nint monthOfYear,\nint dayOfMonth,\nint dayOfWeek, boolean advanceDayOfWeek,\nint millisOfDay)\n{\nif (mode != 'u' && mode != 'w' && mode != 's') {\nthrow new IllegalArgumentException(\"Unknown mode: \" + mode);\n}\n\niMode = mode;\niMonthOfYear = monthOfYear;\niDayOfMonth = dayOfMonth;\niDayOfWeek = dayOfWeek;\niAdvance = advanceDayOfWeek;\niMillisOfDay = millisOfDay;\n}",
            "method_id": 214
        },
        {
            "method_signature": "org.joda.time.base.BaseDateTime:getMillis()J",
            "method_body": "public long getMillis() {\nreturn iMillis;\n}",
            "method_id": 215
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:years()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField years() {\nreturn iYears;\n}",
            "method_id": 216
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder:readMillis(Ljava/io/DataInput;)J",
            "method_body": "static long readMillis(DataInput in) throws IOException {\nint v = in.readUnsignedByte();\nswitch (v >> 6) {\ncase 0: default:\n// Form 00 (6 bits effective precision)\nv = (v << (32 - 6)) >> (32 - 6);\nreturn v * (30 * 60000L);\n\ncase 1:\n// Form 01 (30 bits effective precision)\nv = (v << (32 - 6)) >> (32 - 30);\nv |= (in.readUnsignedByte()) << 16;\nv |= (in.readUnsignedByte()) << 8;\nv |= (in.readUnsignedByte());\nreturn v * 60000L;\n\ncase 2:\n// Form 10 (38 bits effective precision)\nlong w = (((long)v) << (64 - 6)) >> (64 - 38);\nw |= (in.readUnsignedByte()) << 24;\nw |= (in.readUnsignedByte()) << 16;\nw |= (in.readUnsignedByte()) << 8;\nw |= (in.readUnsignedByte());\nreturn w * 1000L;\n\ncase 3:\n// Form 11 (64 bits effective precision)\nreturn in.readLong();\n}\n}",
            "method_id": 217
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMaxMonth()I",
            "method_body": "int getMaxMonth() {\nreturn 12;\n}",
            "method_id": 218
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:<init>(Lorg/joda/time/Chronology;Ljava/lang/Object;I)V",
            "method_body": "BasicChronology(Chronology base, Object param, int minDaysInFirstWeek) {\nsuper(base, param);\n\nif (minDaysInFirstWeek < 1 || minDaysInFirstWeek > 7) {\nthrow new IllegalArgumentException\n(\"Invalid min days in first week: \" + minDaysInFirstWeek);\n}\n\niMinDaysInFirstWeek = minDaysInFirstWeek;\n}",
            "method_id": 219
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.years();\n}",
            "method_id": 220
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getDaysInYearMonth(II)I",
            "method_body": "int getDaysInYearMonth(int year, int month) {\nif (isLeapYear(year)) {\nreturn MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n} else {\nreturn MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n}\n}",
            "method_id": 221
        },
        {
            "method_signature": "org.joda.time.tz.DateTimeZoneBuilder$Recurrence:next(JII)J",
            "method_body": "public long next(long instant, int standardOffset, int saveMillis) {\nreturn iOfYear.next(instant, standardOffset, saveMillis);\n}",
            "method_id": 222
        },
        {
            "method_signature": "org.joda.time.chrono.BasicYearDateTimeField:add(JI)J",
            "method_body": "public long add(long instant, int years) {\nif (years == 0) {\nreturn instant;\n}\nint thisYear = get(instant);\nint newYear = FieldUtils.safeAdd(thisYear, years);\nreturn set(instant, newYear);\n}",
            "method_id": 223
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:getType()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public final DateTimeFieldType getType() {\nreturn iType;\n}",
            "method_id": 224
        },
        {
            "method_signature": "org.joda.time.chrono.GJEraDateTimeField:getDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getDurationField() {\nreturn UnsupportedDurationField.getInstance(DurationFieldType.eras());\n}",
            "method_id": 225
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationField:hashCode()I",
            "method_body": "public int hashCode() {\nlong millis = iUnitMillis;\nint hash = (int) (millis ^ (millis >>> 32));\nhash += getType().hashCode();\nreturn hash;\n}",
            "method_id": 226
        },
        {
            "method_signature": "org.joda.time.base.AbstractInstant:toDateTime(Lorg/joda/time/Chronology;)Lorg/joda/time/DateTime;",
            "method_body": "public DateTime toDateTime(Chronology chronology) {\nreturn new DateTime(getMillis(), chronology);\n}",
            "method_id": 227
        },
        {
            "method_signature": "org.joda.time.field.UnsupportedDurationField:getInstance(Lorg/joda/time/DurationFieldType;)Lorg/joda/time/field/UnsupportedDurationField;",
            "method_body": "public static synchronized UnsupportedDurationField getInstance(DurationFieldType type) {\nUnsupportedDurationField field;\nif (cCache == null) {\ncCache = new HashMap<DurationFieldType, UnsupportedDurationField>(7);\nfield = null;\n} else {\nfield = cCache.get(type);\n}\nif (field == null) {\nfield = new UnsupportedDurationField(type);\ncCache.put(type, field);\n}\nreturn field;\n}",
            "method_id": 228
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadableInstant;)Ljava/lang/String;",
            "method_body": "public String print(ReadableInstant instant) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, instant);\nreturn buf.toString();\n}",
            "method_id": 229
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:dayOfMonth()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField dayOfMonth() {\nreturn iDayOfMonth;\n}",
            "method_id": 230
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDateTimeMillis(IIIIIII)J",
            "method_body": "public long getDateTimeMillis(\nint year, int monthOfYear, int dayOfMonth,\nint hourOfDay, int minuteOfHour, int secondOfMinute, int millisOfSecond)\nthrows IllegalArgumentException {\nChronology base;\nif ((base = getBase()) != null) {\nreturn base.getDateTimeMillis(year, monthOfYear, dayOfMonth,\nhourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n}\n\nFieldUtils.verifyValueBounds(DateTimeFieldType.hourOfDay(), hourOfDay, 0, 23);\nFieldUtils.verifyValueBounds(DateTimeFieldType.minuteOfHour(), minuteOfHour, 0, 59);\nFieldUtils.verifyValueBounds(DateTimeFieldType.secondOfMinute(), secondOfMinute, 0, 59);\nFieldUtils.verifyValueBounds(DateTimeFieldType.millisOfSecond(), millisOfSecond, 0, 999);\n\nreturn getDateMidnightMillis(year, monthOfYear, dayOfMonth)\n+ hourOfDay * DateTimeConstants.MILLIS_PER_HOUR\n+ minuteOfHour * DateTimeConstants.MILLIS_PER_MINUTE\n+ secondOfMinute * DateTimeConstants.MILLIS_PER_SECOND\n+ millisOfSecond;\n}",
            "method_id": 231
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.months();\n}",
            "method_id": 232
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:clockhourOfHalfday()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField clockhourOfHalfday() {\nreturn iClockhourOfHalfday;\n}",
            "method_id": 233
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:weekyears()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField weekyears() {\nreturn iWeekyears;\n}",
            "method_id": 234
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMaxMonth(I)I",
            "method_body": "abstract long getYearDifference(long minuendInstant, long subtrahendInstant);\n\n/**\n* Is the specified year a leap year?\n*\n* @param year  the year to test\n* @return true if leap\n*/\nabstract boolean isLeapYear(int year);\n\n/**\n* Gets the number of days in the specified month and year.\n*\n* @param year  the year\n* @param month  the month\n* @return the number of days\n*/\nabstract int getDaysInYearMonth(int year, int month);\n\n/**\n* Gets the maximum days in the specified month.\n*\n* @param month  the month\n* @return the max days\n*/\nabstract int getDaysInMonthMax(int month);\n\n/**\n* Gets the total number of millis elapsed in this year at the start\n* of the specified month, such as zero for month 1.\n*\n* @param year  the year\n* @param month  the month\n* @return the elapsed millis at the start of the month\n*/\nabstract long getTotalMillisByYearMonth(int year, int month);\n\n/**\n* Gets the millisecond value of the first day of the year.\n*\n* @return the milliseconds for the first of the year\n*/\nabstract long calculateFirstDayOfYearMillis(int year);\n\n/**\n* Gets the minimum supported year.\n*\n* @return the year\n*/\nabstract int getMinYear();\n\n/**\n* Gets the maximum supported year.\n*\n* @return the year\n*/\nabstract int getMaxYear();\n\n/**\n* Gets the maximum month for the specified year.\n* This implementation calls getMaxMonth().\n*\n* @param year  the year\n* @return the maximum month value\n*/\nint getMaxMonth(int year) {\nreturn getMaxMonth();\n}",
            "method_id": 235
        },
        {
            "method_signature": "org.joda.time.field.DecoratedDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn iField.getRangeDurationField();\n}",
            "method_id": 236
        },
        {
            "method_signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn iChronology.weekyears();\n}",
            "method_id": 237
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:setFields()V",
            "method_body": "private void setFields() {\nFields fields = new Fields();\nif (iBase != null) {\nfields.copyFieldsFrom(iBase);\n}\nassemble(fields);\n\n{\nDurationField f;\niMillis    = (f = fields.millis)    != null ? f : super.millis();\niSeconds   = (f = fields.seconds)   != null ? f : super.seconds();\niMinutes   = (f = fields.minutes)   != null ? f : super.minutes();\niHours     = (f = fields.hours)     != null ? f : super.hours();\niHalfdays  = (f = fields.halfdays)  != null ? f : super.halfdays();\niDays      = (f = fields.days)      != null ? f : super.days();\niWeeks     = (f = fields.weeks)     != null ? f : super.weeks();\niWeekyears = (f = fields.weekyears) != null ? f : super.weekyears();\niMonths    = (f = fields.months)    != null ? f : super.months();\niYears     = (f = fields.years)     != null ? f : super.years();\niCenturies = (f = fields.centuries) != null ? f : super.centuries();\niEras      = (f = fields.eras)      != null ? f : super.eras();\n}\n\n{\nDateTimeField f;\niMillisOfSecond     = (f = fields.millisOfSecond)     != null ? f : super.millisOfSecond();\niMillisOfDay        = (f = fields.millisOfDay)        != null ? f : super.millisOfDay();\niSecondOfMinute     = (f = fields.secondOfMinute)     != null ? f : super.secondOfMinute();\niSecondOfDay        = (f = fields.secondOfDay)        != null ? f : super.secondOfDay();\niMinuteOfHour       = (f = fields.minuteOfHour)       != null ? f : super.minuteOfHour();\niMinuteOfDay        = (f = fields.minuteOfDay)        != null ? f : super.minuteOfDay();\niHourOfDay          = (f = fields.hourOfDay)          != null ? f : super.hourOfDay();\niClockhourOfDay     = (f = fields.clockhourOfDay)     != null ? f : super.clockhourOfDay();\niHourOfHalfday      = (f = fields.hourOfHalfday)      != null ? f : super.hourOfHalfday();\niClockhourOfHalfday = (f = fields.clockhourOfHalfday) != null ? f : super.clockhourOfHalfday();\niHalfdayOfDay       = (f = fields.halfdayOfDay)       != null ? f : super.halfdayOfDay();\niDayOfWeek          = (f = fields.dayOfWeek)          != null ? f : super.dayOfWeek();\niDayOfMonth         = (f = fields.dayOfMonth)         != null ? f : super.dayOfMonth();\niDayOfYear          = (f = fields.dayOfYear)          != null ? f : super.dayOfYear();\niWeekOfWeekyear     = (f = fields.weekOfWeekyear)     != null ? f : super.weekOfWeekyear();\niWeekyear           = (f = fields.weekyear)           != null ? f : super.weekyear();\niWeekyearOfCentury  = (f = fields.weekyearOfCentury)  != null ? f : super.weekyearOfCentury();\niMonthOfYear        = (f = fields.monthOfYear)        != null ? f : super.monthOfYear();\niYear               = (f = fields.year)               != null ? f : super.year();\niYearOfEra          = (f = fields.yearOfEra)          != null ? f : super.yearOfEra();\niYearOfCentury      = (f = fields.yearOfCentury)      != null ? f : super.yearOfCentury();\niCenturyOfEra       = (f = fields.centuryOfEra)       != null ? f : super.centuryOfEra();\niEra                = (f = fields.era)                != null ? f : super.era();\n}\n\nint flags;\nif (iBase == null) {\nflags = 0;\n} else {\nflags =\n((iHourOfDay      == iBase.hourOfDay()      &&\niMinuteOfHour   == iBase.minuteOfHour()   &&\niSecondOfMinute == iBase.secondOfMinute() &&\niMillisOfSecond == iBase.millisOfSecond()   ) ? 1 : 0) |\n\n((iMillisOfDay == iBase.millisOfDay()) ? 2 : 0) |\n\n((iYear        == iBase.year()        &&\niMonthOfYear == iBase.monthOfYear() &&\niDayOfMonth  == iBase.dayOfMonth()    ) ? 4 : 0);\n}\n\niBaseFlags = flags;\n}",
            "method_id": 238
        },
        {
            "method_signature": "org.joda.time.chrono.BasicYearDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getYear(instant);\n}",
            "method_id": 239
        }
    ]
}