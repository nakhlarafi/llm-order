{
    "bug_id": 22,
    "test_id": 0,
    "test_name": "org.joda.time.TestPeriod_Constructors.testConstructor_long_fixedZone",
    "test_body": "public void testConstructor_long_fixedZone() throws Throwable {\nDateTimeZone zone = DateTimeZone.getDefault();\ntry {\nDateTimeZone.setDefault(DateTimeZone.forOffsetHours(2));\nlong length =\n(4L + (3L * 7L) + (2L * 30L) + 365L) * DateTimeConstants.MILLIS_PER_DAY +\n5L * DateTimeConstants.MILLIS_PER_HOUR +\n6L * DateTimeConstants.MILLIS_PER_MINUTE +\n7L * DateTimeConstants.MILLIS_PER_SECOND + 8L;\nPeriod test = new Period(length);\nassertEquals(PeriodType.standard(), test.getPeriodType());\n// only time fields are precise in AllType\nassertEquals(0, test.getYears());  // (4 + (3 * 7) + (2 * 30) + 365) == 450\nassertEquals(0, test.getMonths());\nassertEquals(0, test.getWeeks());\nassertEquals(0, test.getDays());\nassertEquals((450 * 24) + 5, test.getHours());\nassertEquals(6, test.getMinutes());\nassertEquals(7, test.getSeconds());\nassertEquals(8, test.getMillis());\n} finally {\nDateTimeZone.setDefault(zone);\n}\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<0> but was:<64>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.Assert.assertEquals(Assert.java:234)\nat junit.framework.Assert.assertEquals(Assert.java:241)\nat junit.framework.TestCase.assertEquals(TestCase.java:409)\nat org.joda.time.TestPeriod_Constructors.testConstructor_long_fixedZone(TestPeriod_Constructors.java:188)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.DateTimeZone:forOffsetHoursMinutes(II)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone forOffsetHoursMinutes(int hoursOffset, int minutesOffset) throws IllegalArgumentException {\nif (hoursOffset == 0 && minutesOffset == 0) {\nreturn DateTimeZone.UTC;\n}\nif (minutesOffset < 0 || minutesOffset > 59) {\nthrow new IllegalArgumentException(\"Minutes out of range: \" + minutesOffset);\n}\nint offset = 0;\ntry {\nint hoursInMinutes = FieldUtils.safeMultiply(hoursOffset, 60);\nif (hoursInMinutes < 0) {\nminutesOffset = FieldUtils.safeAdd(hoursInMinutes, -minutesOffset);\n} else {\nminutesOffset = FieldUtils.safeAdd(hoursInMinutes, minutesOffset);\n}\noffset = FieldUtils.safeMultiply(minutesOffset, DateTimeConstants.MILLIS_PER_MINUTE);\n} catch (ArithmeticException ex) {\nthrow new IllegalArgumentException(\"Offset is too large\");\n}\nreturn forOffsetMillis(offset);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:setDefault(Lorg/joda/time/DateTimeZone;)V",
            "method_body": "public static void setDefault(DateTimeZone zone) throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nsm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n}\nif (zone == null) {\nthrow new IllegalArgumentException(\"The datetime zone must not be null\");\n}\nsynchronized(DateTimeZone.class) {\ncDefault = zone;\n}\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
            "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nreturn DateTimeZone.UTC;\n}\nif (iFixedOffsetCache == null) {\niFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n}\nDateTimeZone zone;\nReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\nif (ref != null) {\nzone = ref.get();\nif (zone != null) {\nreturn zone;\n}\n}\nzone = new FixedDateTimeZone(id, null, offset, offset);\niFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\nreturn zone;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
            "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\n} else {\nbuf.append('-');\noffset = -offset;\n}\n\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}\n\nint seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, seconds, 2);\noffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\nif (offset == 0) {\nreturn buf.toString();\n}\n\nbuf.append('.');\nFormatUtils.appendPaddedInteger(buf, offset, 3);\nreturn buf.toString();\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeMultiply(II)I",
            "method_body": "public static int safeMultiply(int val1, int val2) {\nlong total = (long) val1 * (long) val2;\nif (total < Integer.MIN_VALUE || total > Integer.MAX_VALUE) {\nthrow new ArithmeticException\n(\"The calculation caused an overflow: \" + val1 + \" * \" + val2);\n}\nreturn (int) total;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.joda.time.Period:<init>(J)V",
            "method_body": "public Period(long duration) {\nsuper(duration);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:forOffsetHours(I)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone forOffsetHours(int hoursOffset) throws IllegalArgumentException {\nreturn forOffsetHoursMinutes(hoursOffset, 0);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeAdd(JJ)J",
            "method_body": "public static long safeAdd(long val1, long val2) {\nlong sum = val1 + val2;\n// If there is a sign change, but the two values have the same sign...\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nthrow new ArithmeticException\n(\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n}\nreturn sum;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeAdd(II)I",
            "method_body": "public static int safeAdd(int val1, int val2) {\nint sum = val1 + val2;\n// If there is a sign change, but the two values have the same sign...\nif ((val1 ^ sum) < 0 && (val1 ^ val2) >= 0) {\nthrow new ArithmeticException\n(\"The calculation caused an overflow: \" + val1 + \" + \" + val2);\n}\nreturn sum;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.joda.time.PeriodType:standard()Lorg/joda/time/PeriodType;",
            "method_body": "public static PeriodType standard() {\nPeriodType type = cStandard;\nif (type == null) {\ntype = new PeriodType(\n\"Standard\",\nnew DurationFieldType[] {\nDurationFieldType.years(), DurationFieldType.months(),\nDurationFieldType.weeks(), DurationFieldType.days(),\nDurationFieldType.hours(), DurationFieldType.minutes(),\nDurationFieldType.seconds(), DurationFieldType.millis(),\n},\nnew int[] { 0, 1, 2, 3, 4, 5, 6, 7, }\n);\ncStandard = type;\n}\nreturn type;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.joda.time.format.FormatUtils:appendPaddedInteger(Ljava/lang/StringBuffer;II)V",
            "method_body": "public static void appendPaddedInteger(StringBuffer buf, int value, int size) {\nif (value < 0) {\nbuf.append('-');\nif (value != Integer.MIN_VALUE) {\nvalue = -value;\n} else {\nfor (; size > 10; size--) {\nbuf.append('0');\n}\nbuf.append(\"\" + -(long)Integer.MIN_VALUE);\nreturn;\n}\n}\nif (value < 10) {\nfor (; size > 1; size--) {\nbuf.append('0');\n}\nbuf.append((char)(value + '0'));\n} else if (value < 100) {\nfor (; size > 2; size--) {\nbuf.append('0');\n}\n// Calculate value div/mod by 10 without using two expensive\n// division operations. (2 ^ 27) / 10 = 13421772. Add one to\n// value to correct rounding error.\nint d = ((value + 1) * 13421772) >> 27;\nbuf.append((char) (d + '0'));\n// Append remainder by calculating (value - d * 10).\nbuf.append((char) (value - (d << 3) - (d << 1) + '0'));\n} else {\nint digits;\nif (value < 1000) {\ndigits = 3;\n} else if (value < 10000) {\ndigits = 4;\n} else {\ndigits = (int)(Math.log(value) / LOG_10) + 1;\n}\nfor (; size > digits; size--) {\nbuf.append('0');\n}\nbuf.append(Integer.toString(value));\n}\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nzone = DateTimeZone.getDefault();\n}\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\n}\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.joda.time.Period:getYears()I",
            "method_body": "public int getYears() {\nreturn getPeriodType().getIndexedField(this, PeriodType.YEAR_INDEX);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.joda.time.Period:getMonths()I",
            "method_body": "public int getMonths() {\nreturn getPeriodType().getIndexedField(this, PeriodType.MONTH_INDEX);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.joda.time.Period:getWeeks()I",
            "method_body": "public int getWeeks() {\nreturn getPeriodType().getIndexedField(this, PeriodType.WEEK_INDEX);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.joda.time.PeriodType:getIndexedField(Lorg/joda/time/ReadablePeriod;I)I",
            "method_body": "int getIndexedField(ReadablePeriod period, int index) {\nint realIndex = iIndices[index];\nreturn (realIndex == -1 ? 0 : period.getValue(realIndex));\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\n}\nreturn chrono;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\ntry {\ntry {\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n}\n} catch (RuntimeException ex) {\n// ignored\n}\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\n} catch (IllegalArgumentException ex) {\n// ignored\n}\nif (temp == null) {\ntemp = UTC;\n}\ncDefault = zone = temp;\n}\n}\n}\nreturn zone;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.joda.time.tz.FixedDateTimeZone:isFixed()Z",
            "method_body": "public boolean isFixed() {\nreturn true;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nChronology base;\nif ((base = iBase) != null) {\nreturn base.getZone();\n}\nreturn null;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.joda.time.tz.FixedDateTimeZone:getOffsetFromLocal(J)I",
            "method_body": "public int getOffsetFromLocal(long instantLocal) {\nreturn iWallOffset;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nreturn (DateTimeZone)getParam();\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getParam()Ljava/lang/Object;",
            "method_body": "protected final Object getParam() {\nreturn iParam;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:millis()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField millis() {\nreturn iMillis;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:seconds()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField seconds() {\nreturn iSeconds;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:minutes()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField minutes() {\nreturn iMinutes;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:hours()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField hours() {\nreturn iHours;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:days()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField days() {\nreturn iDays;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:weeks()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField weeks() {\nreturn iWeeks;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:months()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField months() {\nreturn iMonths;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:years()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField years() {\nreturn iYears;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationField:isPrecise()Z",
            "method_body": "public final boolean isPrecise() {\nreturn true;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.joda.time.field.MillisDurationField:isPrecise()Z",
            "method_body": "public final boolean isPrecise() {\nreturn true;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.joda.time.DurationFieldType$StandardDurationFieldType:getField(Lorg/joda/time/Chronology;)Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getField(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\n\nswitch (iOrdinal) {\ncase ERAS:\nreturn chronology.eras();\ncase CENTURIES:\nreturn chronology.centuries();\ncase WEEKYEARS:\nreturn chronology.weekyears();\ncase YEARS:\nreturn chronology.years();\ncase MONTHS:\nreturn chronology.months();\ncase WEEKS:\nreturn chronology.weeks();\ncase DAYS:\nreturn chronology.days();\ncase HALFDAYS:\nreturn chronology.halfdays();\ncase HOURS:\nreturn chronology.hours();\ncase MINUTES:\nreturn chronology.minutes();\ncase SECONDS:\nreturn chronology.seconds();\ncase MILLIS:\nreturn chronology.millis();\ndefault:\n// Shouldn't happen.\nthrow new InternalError();\n}\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:isPrecise()Z",
            "method_body": "public boolean isPrecise() {\nreturn iTimeField ? iField.isPrecise() : iField.isPrecise() && this.iZone.isFixed();\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField:isPrecise()Z",
            "method_body": "public boolean isPrecise() {\nreturn false;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:getOffsetFromLocalToSubtract(J)I",
            "method_body": "private int getOffsetFromLocalToSubtract(long instant) {\nint offset = this.iZone.getOffsetFromLocal(instant);\nlong diff = instant - offset;\n// If there is a sign change, but the two values have different signs...\nif ((instant ^ diff) < 0 && (instant ^ offset) < 0) {\nthrow new ArithmeticException(\"Subtracting time zone offset caused overflow\");\n}\nreturn offset;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.joda.time.field.MillisDurationField:getDifference(JJ)I",
            "method_body": "public int getDifference(long minuendInstant, long subtrahendInstant) {\nreturn FieldUtils.safeToInt(FieldUtils.safeSubtract(minuendInstant, subtrahendInstant));\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:getDifference(JJ)I",
            "method_body": "public int getDifference(long minuendInstant, long subtrahendInstant) {\nint offset = getOffsetToAdd(subtrahendInstant);\nreturn iField.getDifference\n(minuendInstant + (iTimeField ? offset : getOffsetToAdd(minuendInstant)),\nsubtrahendInstant + offset);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.joda.time.PeriodType:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object obj) {\nif (this == obj) {\nreturn true;\n}\nif (obj instanceof PeriodType == false) {\nreturn false;\n}\nPeriodType other = (PeriodType) obj;\nreturn (Arrays.equals(iTypes, other.iTypes));\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationField:getDifferenceAsLong(JJ)J",
            "method_body": "public long getDifferenceAsLong(long minuendInstant, long subtrahendInstant) {\nlong difference = FieldUtils.safeSubtract(minuendInstant, subtrahendInstant);\nreturn difference / iUnitMillis;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.joda.time.field.BaseDurationField:getDifference(JJ)I",
            "method_body": "public int getDifference(long minuendInstant, long subtrahendInstant) {\nreturn FieldUtils.safeToInt(getDifferenceAsLong(minuendInstant, subtrahendInstant));\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeSubtract(JJ)J",
            "method_body": "public static long safeSubtract(long val1, long val2) {\nlong diff = val1 - val2;\n// If there is a sign change, but the two values have different signs...\nif ((val1 ^ diff) < 0 && (val1 ^ val2) < 0) {\nthrow new ArithmeticException\n(\"The calculation caused an overflow: \" + val1 + \" - \" + val2);\n}\nreturn diff;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:add(JI)J",
            "method_body": "public long add(long instant, int value) {\nint offset = getOffsetToAdd(instant);\ninstant = iField.add(instant + offset, value);\nreturn instant - (iTimeField ? offset : getOffsetFromLocalToSubtract(instant));\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.joda.time.PeriodType:size()I",
            "method_body": "public int size() {\nreturn iTypes.length;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.joda.time.tz.FixedDateTimeZone:getOffset(J)I",
            "method_body": "public int getOffset(long instant) {\nreturn iWallOffset;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology$ZonedDurationField:getOffsetToAdd(J)I",
            "method_body": "private int getOffsetToAdd(long instant) {\nint offset = this.iZone.getOffset(instant);\nlong sum = instant + offset;\n// If there is a sign change, but the two values have the same sign...\nif ((instant ^ sum) < 0 && (instant ^ offset) >= 0) {\nthrow new ArithmeticException(\"Adding time zone offset caused overflow\");\n}\nreturn offset;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:safeToInt(J)I",
            "method_body": "public static int safeToInt(long value) {\nif (Integer.MIN_VALUE <= value && value <= Integer.MAX_VALUE) {\nreturn (int) value;\n}\nthrow new ArithmeticException(\"Value cannot fit in an int: \" + value);\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.joda.time.PeriodType:getFieldType(I)Lorg/joda/time/DurationFieldType;",
            "method_body": "public DurationFieldType getFieldType(int index) {\nreturn iTypes[index];\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:<init>(JLorg/joda/time/PeriodType;Lorg/joda/time/Chronology;)V",
            "method_body": "protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\nsuper();\ntype = checkPeriodType(type);\nchrono = DateTimeUtils.getChronology(chrono);\niType = type;\niValues = chrono.get(this, duration);\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.joda.time.chrono.BaseChronology:get(Lorg/joda/time/ReadablePeriod;J)[I",
            "method_body": "public int[] get(ReadablePeriod period, long duration) {\nint size = period.size();\nint[] values = new int[size];\nif (duration != 0) {\nlong current = 0;\nfor (int i = 0; i < size; i++) {\nDurationField field = period.getFieldType(i).getField(this);\nif (field.isPrecise()) {\nint value = field.getDifference(duration, current);\ncurrent = field.add(current, value);\nvalues[i] = value;\n}\n}\n}\nreturn values;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.joda.time.base.AbstractPeriod:<init>()V",
            "method_body": "protected AbstractPeriod() {\nsuper();\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getPeriodType(Lorg/joda/time/PeriodType;)Lorg/joda/time/PeriodType;",
            "method_body": "public static final PeriodType getPeriodType(PeriodType type) {\nif (type == null) {\nreturn PeriodType.standard();\n}\nreturn type;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.joda.time.field.MillisDurationField:add(JI)J",
            "method_body": "public long add(long instant, int value) {\nreturn FieldUtils.safeAdd(instant, value);\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationField:add(JI)J",
            "method_body": "public long add(long instant, int value) {\nlong addition = value * iUnitMillis;  // safe\nreturn FieldUtils.safeAdd(instant, addition);\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:setCurrentMillisFixed(J)V",
            "method_body": "public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\ncheckPermission();\ncMillisProvider = new FixedMillisProvider(fixedMillis);\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils$FixedMillisProvider:<init>(J)V",
            "method_body": "FixedMillisProvider(long fixedMillis) {\niMillis = fixedMillis;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:setCurrentMillisSystem()V",
            "method_body": "public static final void setCurrentMillisSystem() throws SecurityException {\ncheckPermission();\ncMillisProvider = SYSTEM_MILLIS_PROVIDER;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:checkPermission()V",
            "method_body": "private static void checkPermission() throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nsm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n}\n}",
            "method_id": 60
        }
    ]
}