{
    "bug_id": 27,
    "test_id": 0,
    "test_name": "org.joda.time.format.TestPeriodFormatterBuilder.testBug2495455",
    "test_body": "public void testBug2495455() {\nPeriodFormatter pfmt1 = new PeriodFormatterBuilder()\n.appendLiteral(\"P\")\n.appendYears()\n.appendSuffix(\"Y\")\n.appendMonths()\n.appendSuffix(\"M\")\n.appendWeeks()\n.appendSuffix(\"W\")\n.appendDays()\n.appendSuffix(\"D\")\n.appendSeparatorIfFieldsAfter(\"T\")\n.appendHours()\n.appendSuffix(\"H\")\n.appendMinutes()\n.appendSuffix(\"M\")\n.appendSecondsWithOptionalMillis()\n.appendSuffix(\"S\")\n.toFormatter();\nPeriodFormatter pfmt2 = new PeriodFormatterBuilder()\n.append(ISOPeriodFormat.standard())\n.toFormatter();\npfmt1.parsePeriod(\"PT1003199059S\");\npfmt2.parsePeriod(\"PT1003199059S\");\n}\n",
    "stack_trace": "java.lang.IllegalArgumentException: Invalid format: \"PT1003199059S\" is malformed at \"1003199059S\"\nat org.joda.time.format.PeriodFormatter.parseMutablePeriod(PeriodFormatter.java:326)\nat org.joda.time.format.PeriodFormatter.parsePeriod(PeriodFormatter.java:304)\nat org.joda.time.format.TestPeriodFormatterBuilder.testBug2495455(TestPeriodFormatterBuilder.java:869)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:parseInto(Lorg/joda/time/ReadWritablePeriod;Ljava/lang/String;ILjava/util/Locale;)I",
            "method_body": "public int parseInto(\nReadWritablePeriod period, String text,\nint position, Locale locale) {\n\nboolean mustParse = (iPrintZeroSetting == PRINT_ZERO_ALWAYS);\n\n// Shortcut test.\nif (position >= text.length()) {\nreturn mustParse ? ~position : position;\n}\n\nif (iPrefix != null) {\nposition = iPrefix.parse(text, position);\nif (position >= 0) {\n// If prefix is found, then the parse must finish.\nmustParse = true;\n} else {\n// Prefix not found, so bail.\nif (!mustParse) {\n// It's okay because parsing of this field is not\n// required. Don't return an error. Fields down the\n// chain can continue on, trying to parse.\nreturn ~position;\n}\nreturn position;\n}\n}\n\nint suffixPos = -1;\nif (iSuffix != null && !mustParse) {\n// Pre-scan the suffix, to help determine if this field must be\n// parsed.\nsuffixPos = iSuffix.scan(text, position);\nif (suffixPos >= 0) {\n// If suffix is found, then parse must finish.\nmustParse = true;\n} else {\n// Suffix not found, so bail.\nif (!mustParse) {\n// It's okay because parsing of this field is not\n// required. Don't return an error. Fields down the\n// chain can continue on, trying to parse.\nreturn ~suffixPos;\n}\nreturn suffixPos;\n}\n}\n\nif (!mustParse && !isSupported(period.getPeriodType(), iFieldType)) {\n// If parsing is not required and the field is not supported,\n// exit gracefully so that another parser can continue on.\nreturn position;\n}\n\nint limit;\nif (suffixPos > 0) {\nlimit = Math.min(iMaxParsedDigits, suffixPos - position);\n} else {\nlimit = Math.min(iMaxParsedDigits, text.length() - position);\n}\n\n// validate input number\nint length = 0;\nint fractPos = -1;\nboolean hasDigits = false;\nwhile (length < limit) {\nchar c = text.charAt(position + length);\n// leading sign\nif (length == 0 && (c == '-' || c == '+') && !iRejectSignedValues) {\nboolean negative = c == '-';\n\n// Next character must be a digit.\nif (length + 1 >= limit ||\n(c = text.charAt(position + length + 1)) < '0' || c > '9')\n{\nbreak;\n}\n\nif (negative) {\nlength++;\n} else {\n// Skip the '+' for parseInt to succeed.\nposition++;\n}\n// Expand the limit to disregard the sign character.\nlimit = Math.min(limit + 1, text.length() - position);\ncontinue;\n}\n// main number\nif (c >= '0' && c <= '9') {\nhasDigits = true;\n} else {\nif ((c == '.' || c == ',')\n&& (iFieldType == SECONDS_MILLIS || iFieldType == SECONDS_OPTIONAL_MILLIS)) {\nif (fractPos >= 0) {\n// can't have two decimals\nbreak;\n}\nfractPos = position + length + 1;\n// Expand the limit to disregard the decimal point.\nlimit = Math.min(limit + 1, text.length() - position);\n} else {\nbreak;\n}\n}\nlength++;\n}\n\nif (!hasDigits) {\nreturn ~position;\n}\n\nif (suffixPos >= 0 && position + length != suffixPos) {\n// If there are additional non-digit characters before the\n// suffix is reached, then assume that the suffix found belongs\n// to a field not yet reached. Return original position so that\n// another parser can continue on.\nreturn position;\n}\n\nif (iFieldType != SECONDS_MILLIS && iFieldType != SECONDS_OPTIONAL_MILLIS) {\n// Handle common case.\nsetFieldValue(period, iFieldType, parseInt(text, position, length));\n} else if (fractPos < 0) {\nsetFieldValue(period, SECONDS, parseInt(text, position, length));\nsetFieldValue(period, MILLIS, 0);\n} else {\nint wholeValue = parseInt(text, position, fractPos - position - 1);\nsetFieldValue(period, SECONDS, wholeValue);\n\nint fractLen = position + length - fractPos;\nint fractValue;\nif (fractLen <= 0) {\nfractValue = 0;\n} else {\nif (fractLen >= 3) {\nfractValue = parseInt(text, fractPos, 3);\n} else {\nfractValue = parseInt(text, fractPos, fractLen);\nif (fractLen == 1) {\nfractValue *= 100;\n} else {\nfractValue *= 10;\n}\n}\nif (wholeValue < 0) {\nfractValue = -fractValue;\n}\n}\n\nsetFieldValue(period, MILLIS, fractValue);\n}\n\nposition += length;\n\nif (position >= 0 && iSuffix != null) {\nposition = iSuffix.parse(text, position);\n}\n\nreturn position;\n}",
            "method_id": 0,
            "loc": 161
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix:<init>(Ljava/lang/String;)V",
            "method_body": "int calculatePrintedLength(int value);\n\nvoid printTo(StringBuffer buf, int value);\n\nvoid printTo(Writer out, int value) throws IOException;\n\n/**\n* @return new position after parsing affix, or ~position of failure\n*/\nint parse(String periodStr, int position);\n\n/**\n* @return position where affix starts, or original ~position if not found\n*/\nint scan(String periodStr, int position);\n}\n\n//-----------------------------------------------------------------------\n/**\n* Implements an affix where the text does not vary by the amount.\n*/\nstatic class SimpleAffix implements PeriodFieldAffix {\nprivate final String iText;\n\nSimpleAffix(String text) {\niText = text;\n}\n\npublic int calculatePrintedLength(int value) {\nreturn iText.length();\n}\n\npublic void printTo(StringBuffer buf, int value) {\nbuf.append(iText);\n}\n\npublic void printTo(Writer out, int value) throws IOException {\nout.write(iText);\n}\n\npublic int parse(String periodStr, int position) {\nString text = iText;\nint textLength = text.length();\nif (periodStr.regionMatches(true, position, text, 0, textLength)) {\nreturn position + textLength;\n}\nreturn ~position;\n}\n\npublic int scan(String periodStr, final int position) {\nString text = iText;\nint textLength = text.length();\nint sourceLength = periodStr.length();\nsearch:\nfor (int pos = position; pos < sourceLength; pos++) {\nif (periodStr.regionMatches(true, pos, text, 0, textLength)) {\nreturn pos;\n}\n// Only allow number characters to be skipped in search of suffix.\nswitch (periodStr.charAt(pos)) {\ncase '0': case '1': case '2': case '3': case '4':\ncase '5': case '6': case '7': case '8': case '9':\ncase '.': case ',': case '+': case '-':\nbreak;\ndefault:\nbreak search;\n}\n}\nreturn ~position;\n}\n}",
            "method_id": 1,
            "loc": 71
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix:parse(Ljava/lang/String;I)I",
            "method_body": "int calculatePrintedLength(int value);\n\nvoid printTo(StringBuffer buf, int value);\n\nvoid printTo(Writer out, int value) throws IOException;\n\n/**\n* @return new position after parsing affix, or ~position of failure\n*/\nint parse(String periodStr, int position);\n\n/**\n* @return position where affix starts, or original ~position if not found\n*/\nint scan(String periodStr, int position);\n}\n\n//-----------------------------------------------------------------------\n/**\n* Implements an affix where the text does not vary by the amount.\n*/\nstatic class SimpleAffix implements PeriodFieldAffix {\nprivate final String iText;\n\nSimpleAffix(String text) {\niText = text;\n}\n\npublic int calculatePrintedLength(int value) {\nreturn iText.length();\n}\n\npublic void printTo(StringBuffer buf, int value) {\nbuf.append(iText);\n}\n\npublic void printTo(Writer out, int value) throws IOException {\nout.write(iText);\n}\n\npublic int parse(String periodStr, int position) {\nString text = iText;\nint textLength = text.length();\nif (periodStr.regionMatches(true, position, text, 0, textLength)) {\nreturn position + textLength;\n}\nreturn ~position;\n}\n\npublic int scan(String periodStr, final int position) {\nString text = iText;\nint textLength = text.length();\nint sourceLength = periodStr.length();\nsearch:\nfor (int pos = position; pos < sourceLength; pos++) {\nif (periodStr.regionMatches(true, pos, text, 0, textLength)) {\nreturn pos;\n}\n// Only allow number characters to be skipped in search of suffix.\nswitch (periodStr.charAt(pos)) {\ncase '0': case '1': case '2': case '3': case '4':\ncase '5': case '6': case '7': case '8': case '9':\ncase '.': case ',': case '+': case '-':\nbreak;\ndefault:\nbreak search;\n}\n}\nreturn ~position;\n}\n}",
            "method_id": 2,
            "loc": 71
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$SimpleAffix:scan(Ljava/lang/String;I)I",
            "method_body": "int calculatePrintedLength(int value);\n\nvoid printTo(StringBuffer buf, int value);\n\nvoid printTo(Writer out, int value) throws IOException;\n\n/**\n* @return new position after parsing affix, or ~position of failure\n*/\nint parse(String periodStr, int position);\n\n/**\n* @return position where affix starts, or original ~position if not found\n*/\nint scan(String periodStr, int position);\n}\n\n//-----------------------------------------------------------------------\n/**\n* Implements an affix where the text does not vary by the amount.\n*/\nstatic class SimpleAffix implements PeriodFieldAffix {\nprivate final String iText;\n\nSimpleAffix(String text) {\niText = text;\n}\n\npublic int calculatePrintedLength(int value) {\nreturn iText.length();\n}\n\npublic void printTo(StringBuffer buf, int value) {\nbuf.append(iText);\n}\n\npublic void printTo(Writer out, int value) throws IOException {\nout.write(iText);\n}\n\npublic int parse(String periodStr, int position) {\nString text = iText;\nint textLength = text.length();\nif (periodStr.regionMatches(true, position, text, 0, textLength)) {\nreturn position + textLength;\n}\nreturn ~position;\n}\n\npublic int scan(String periodStr, final int position) {\nString text = iText;\nint textLength = text.length();\nint sourceLength = periodStr.length();\nsearch:\nfor (int pos = position; pos < sourceLength; pos++) {\nif (periodStr.regionMatches(true, pos, text, 0, textLength)) {\nreturn pos;\n}\n// Only allow number characters to be skipped in search of suffix.\nswitch (periodStr.charAt(pos)) {\ncase '0': case '1': case '2': case '3': case '4':\ncase '5': case '6': case '7': case '8': case '9':\ncase '.': case ',': case '+': case '-':\nbreak;\ndefault:\nbreak search;\n}\n}\nreturn ~position;\n}\n}",
            "method_id": 3,
            "loc": 71
        },
        {
            "method_signature": "org.joda.time.convert.ConverterSet:select(Ljava/lang/Class;)Lorg/joda/time/convert/Converter;",
            "method_body": "Converter select(Class<?> type) throws IllegalStateException {\n// Check the hashtable first.\nEntry[] entries = iSelectEntries;\nint length = entries.length;\nint index = type == null ? 0 : type.hashCode() & (length - 1);\n\nEntry e;\n// This loop depends on there being at least one null slot.\nwhile ((e = entries[index]) != null) {\nif (e.iType == type) {\nreturn e.iConverter;\n}\nif (++index >= length) {\nindex = 0;\n}\n}\n\n// Not found in the hashtable, so do actual work.\n\nConverter converter = selectSlow(this, type);\ne = new Entry(type, converter);\n\n// Save the entry for future selects. This class must be threadsafe,\n// but there is no synchronization. Since the hashtable is being used\n// as a cache, it is okay to destroy existing entries. This isn't\n// likely to occur unless there is a high amount of concurrency. As\n// time goes on, cache updates will occur less often, and the cache\n// will fill with all the necessary entries.\n\n// Do all updates on a copy: slots in iSelectEntries must not be\n// updated by multiple threads as this can allow all null slots to be\n// consumed.\nentries = (Entry[])entries.clone();\n\n// Add new entry.\nentries[index] = e;\n\n// Verify that at least one null slot exists!\nfor (int i=0; i<length; i++) {\nif (entries[i] == null) {\n// Found a null slot, swap in new hashtable.\niSelectEntries = entries;\nreturn converter;\n}\n}\n\n// Double capacity and re-hash.\n\nint newLength = length << 1;\nEntry[] newEntries = new Entry[newLength];\nfor (int i=0; i<length; i++) {\ne = entries[i];\ntype = e.iType;\nindex = type == null ? 0 : type.hashCode() & (newLength - 1);\nwhile (newEntries[index] != null) {\nif (++index >= newLength) {\nindex = 0;\n}\n}\nnewEntries[index] = e;\n}\n\n// Swap in new hashtable.\niSelectEntries = newEntries;\nreturn converter;\n}",
            "method_id": 4,
            "loc": 66
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSeparator(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;ZZ)Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "private PeriodFormatterBuilder appendSeparator(String text, String finalText,\nString[] variants,\nboolean useBefore, boolean useAfter) {\nif (text == null || finalText == null) {\nthrow new IllegalArgumentException();\n}\n\nclearPrefix();\n\n// optimise zero formatter case\nList<Object> pairs = iElementPairs;\nif (pairs.size() == 0) {\nif (useAfter && useBefore == false) {\nSeparator separator = new Separator(\ntext, finalText, variants,\nLiteral.EMPTY, Literal.EMPTY, useBefore, useAfter);\nappend0(separator, separator);\n}\nreturn this;\n}\n\n// find the last separator added\nint i;\nSeparator lastSeparator = null;\nfor (i=pairs.size(); --i>=0; ) {\nif (pairs.get(i) instanceof Separator) {\nlastSeparator = (Separator) pairs.get(i);\npairs = pairs.subList(i + 1, pairs.size());\nbreak;\n}\ni--;  // element pairs\n}\n\n// merge formatters\nif (lastSeparator != null && pairs.size() == 0) {\nthrow new IllegalStateException(\"Cannot have two adjacent separators\");\n} else {\nObject[] comp = createComposite(pairs);\npairs.clear();\nSeparator separator = new Separator(\ntext, finalText, variants,\n(PeriodPrinter) comp[0], (PeriodParser) comp[1],\nuseBefore, useAfter);\npairs.add(separator);\npairs.add(separator);\n}\n\nreturn this;\n}",
            "method_id": 5,
            "loc": 49
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Separator:parseInto(Lorg/joda/time/ReadWritablePeriod;Ljava/lang/String;ILjava/util/Locale;)I",
            "method_body": "public int parseInto(\nReadWritablePeriod period, String periodStr,\nint position, Locale locale) {\nint oldPos = position;\nposition = iBeforeParser.parseInto(period, periodStr, position, locale);\n\nif (position < 0) {\nreturn position;\n}\n\nboolean found = false;\nif (position > oldPos) {\n// Consume this separator.\nString[] parsedForms = iParsedForms;\nint length = parsedForms.length;\nfor (int i=0; i < length; i++) {\nString parsedForm = parsedForms[i];\nif ((parsedForm == null || parsedForm.length() == 0) ||\nperiodStr.regionMatches\n(true, position, parsedForm, 0, parsedForm.length())) {\n\nposition += parsedForm.length();\nfound = true;\nbreak;\n}\n}\n}\n\noldPos = position;\nposition = iAfterParser.parseInto(period, periodStr, position, locale);\n\nif (position < 0) {\nreturn position;\n}\n\nif (found && position == oldPos) {\n// Separator should not have been supplied.\nreturn ~oldPos;\n}\n\nif (position > oldPos && !found && !iUseBefore) {\n// Separator was required.\nreturn ~oldPos;\n}\n\nreturn position;\n}",
            "method_id": 6,
            "loc": 47
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\ntry {\ntry {\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n}\n} catch (RuntimeException ex) {\n// ignored\n}\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\n} catch (IllegalArgumentException ex) {\n// ignored\n}\nif (temp == null) {\ntemp = UTC;\n}\ncDefault = zone = temp;\n}\n}\n}\nreturn zone;\n}",
            "method_id": 7,
            "loc": 31
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Separator:<init>(Ljava/lang/String;Ljava/lang/String;[Ljava/lang/String;Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;ZZ)V",
            "method_body": "Separator(String text, String finalText, String[] variants,\nPeriodPrinter beforePrinter, PeriodParser beforeParser,\nboolean useBefore, boolean useAfter) {\niText = text;\niFinalText = finalText;\n\nif ((finalText == null || text.equals(finalText)) &&\n(variants == null || variants.length == 0)) {\n\niParsedForms = new String[] {text};\n} else {\n// Filter and reverse sort the parsed forms.\nTreeSet<String> parsedSet = new TreeSet<String>(String.CASE_INSENSITIVE_ORDER);\nparsedSet.add(text);\nparsedSet.add(finalText);\nif (variants != null) {\nfor (int i=variants.length; --i>=0; ) {\nparsedSet.add(variants[i]);\n}\n}\nArrayList<String> parsedList = new ArrayList<String>(parsedSet);\nCollections.reverse(parsedList);\niParsedForms = parsedList.toArray(new String[parsedList.size()]);\n}\n\niBeforePrinter = beforePrinter;\niBeforeParser = beforeParser;\niUseBefore = useBefore;\niUseAfter = useAfter;\n}",
            "method_id": 8,
            "loc": 30
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:setFieldValue(Lorg/joda/time/ReadWritablePeriod;II)V",
            "method_body": "void setFieldValue(ReadWritablePeriod period, int field, int value) {\nswitch (field) {\ndefault:\nbreak;\ncase YEARS:\nperiod.setYears(value);\nbreak;\ncase MONTHS:\nperiod.setMonths(value);\nbreak;\ncase WEEKS:\nperiod.setWeeks(value);\nbreak;\ncase DAYS:\nperiod.setDays(value);\nbreak;\ncase HOURS:\nperiod.setHours(value);\nbreak;\ncase MINUTES:\nperiod.setMinutes(value);\nbreak;\ncase SECONDS:\nperiod.setSeconds(value);\nbreak;\ncase MILLIS:\nperiod.setMillis(value);\nbreak;\n}\n}",
            "method_id": 9,
            "loc": 30
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:parseInt(Ljava/lang/String;II)I",
            "method_body": "private int parseInt(String text, int position, int length) {\nif (length >= 10) {\n// Since value may exceed max, use stock parser which checks for this.\nreturn Integer.parseInt(text.substring(position, position + length));\n}\nif (length <= 0) {\nreturn 0;\n}\nint value = text.charAt(position++);\nlength--;\nboolean negative;\nif (value == '-') {\nif (--length < 0) {\nreturn 0;\n}\nnegative = true;\nvalue = text.charAt(position++);\n} else {\nnegative = false;\n}\nvalue -= '0';\nwhile (length-- > 0) {\nvalue = ((value << 3) + (value << 1)) + text.charAt(position++) - '0';\n}\nreturn negative ? -value : value;\n}",
            "method_id": 10,
            "loc": 26
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSuffix(Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;)Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "private PeriodFormatterBuilder appendSuffix(PeriodFieldAffix suffix) {\nfinal Object originalPrinter;\nfinal Object originalParser;\nif (iElementPairs.size() > 0) {\noriginalPrinter = iElementPairs.get(iElementPairs.size() - 2);\noriginalParser = iElementPairs.get(iElementPairs.size() - 1);\n} else {\noriginalPrinter = null;\noriginalParser = null;\n}\n\nif (originalPrinter == null || originalParser == null ||\noriginalPrinter != originalParser ||\n!(originalPrinter instanceof FieldFormatter)) {\nthrow new IllegalStateException(\"No field to apply suffix to\");\n}\n\nclearPrefix();\nFieldFormatter newField = new FieldFormatter((FieldFormatter) originalPrinter, suffix);\niElementPairs.set(iElementPairs.size() - 2, newField);\niElementPairs.set(iElementPairs.size() - 1, newField);\niFieldFormatters[newField.getFieldType()] = newField;\n\nreturn this;\n}",
            "method_id": 11,
            "loc": 25
        },
        {
            "method_signature": "org.joda.time.format.ISOPeriodFormat:standard()Lorg/joda/time/format/PeriodFormatter;",
            "method_body": "public static PeriodFormatter standard() {\nif (cStandard == null) {\ncStandard = new PeriodFormatterBuilder()\n.appendLiteral(\"P\")\n.appendYears()\n.appendSuffix(\"Y\")\n.appendMonths()\n.appendSuffix(\"M\")\n.appendWeeks()\n.appendSuffix(\"W\")\n.appendDays()\n.appendSuffix(\"D\")\n.appendSeparatorIfFieldsAfter(\"T\")\n.appendHours()\n.appendSuffix(\"H\")\n.appendMinutes()\n.appendSuffix(\"M\")\n.appendSecondsWithOptionalMillis()\n.appendSuffix(\"S\")\n.toFormatter();\n}\nreturn cStandard;\n}",
            "method_id": 12,
            "loc": 23
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Composite:decompose(Ljava/util/List;Ljava/util/List;Ljava/util/List;)V",
            "method_body": "private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\nint size = elementPairs.size();\nfor (int i=0; i<size; i+=2) {\nObject element = elementPairs.get(i);\nif (element instanceof PeriodPrinter) {\nif (element instanceof Composite) {\naddArrayToList(printerList, ((Composite) element).iPrinters);\n} else {\nprinterList.add(element);\n}\n}\n\nelement = elementPairs.get(i + 1);\nif (element instanceof PeriodParser) {\nif (element instanceof Composite) {\naddArrayToList(parserList, ((Composite) element).iParsers);\n} else {\nparserList.add(element);\n}\n}\n}\n}",
            "method_id": 13,
            "loc": 22
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:toFormatter(Ljava/util/List;ZZ)Lorg/joda/time/format/PeriodFormatter;",
            "method_body": "private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\nif (notPrinter && notParser) {\nthrow new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n}\nint size = elementPairs.size();\nif (size >= 2 && elementPairs.get(0) instanceof Separator) {\nSeparator sep = (Separator) elementPairs.get(0);\nPeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\nsep = sep.finish(f.getPrinter(), f.getParser());\nreturn new PeriodFormatter(sep, sep);\n}\nObject[] comp = createComposite(elementPairs);\nif (notPrinter) {\nreturn new PeriodFormatter(null, (PeriodParser) comp[1]);\n} else if (notParser) {\nreturn new PeriodFormatter((PeriodPrinter) comp[0], null);\n} else {\nreturn new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n}\n}",
            "method_id": 14,
            "loc": 20
        },
        {
            "method_signature": "org.joda.time.format.FormatUtils:createErrorMessage(Ljava/lang/String;I)Ljava/lang/String;",
            "method_body": "static String createErrorMessage(final String text, final int errorPos) {\nint sampleLen = errorPos + 32;\nString sampleText;\nif (text.length() <= sampleLen + 3) {\nsampleText = text;\n} else {\nsampleText = text.substring(0, sampleLen).concat(\"...\");\n}\n\nif (errorPos <= 0) {\nreturn \"Invalid format: \\\"\" + sampleText + '\"';\n}\n\nif (errorPos >= text.length()) {\nreturn \"Invalid format: \\\"\" + sampleText + \"\\\" is too short\";\n}\n\nreturn \"Invalid format: \\\"\" + sampleText + \"\\\" is malformed at \\\"\" +\nsampleText.substring(errorPos) + '\"';\n}",
            "method_id": 15,
            "loc": 20
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
            "method_body": "Composite(List<Object> elementPairs) {\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\n\ndecompose(elementPairs, printerList, parserList);\n\nif (printerList.size() <= 0) {\niPrinters = null;\n} else {\niPrinters = printerList.toArray(\nnew PeriodPrinter[printerList.size()]);\n}\n\nif (parserList.size() <= 0) {\niParsers = null;\n} else {\niParsers = parserList.toArray(\nnew PeriodParser[parserList.size()]);\n}\n}",
            "method_id": 16,
            "loc": 20
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nzone = DateTimeZone.getDefault();\n}\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\n}\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}",
            "method_id": 17,
            "loc": 19
        },
        {
            "method_signature": "org.joda.time.PeriodType:standard()Lorg/joda/time/PeriodType;",
            "method_body": "public static PeriodType standard() {\nPeriodType type = cStandard;\nif (type == null) {\ntype = new PeriodType(\n\"Standard\",\nnew DurationFieldType[] {\nDurationFieldType.years(), DurationFieldType.months(),\nDurationFieldType.weeks(), DurationFieldType.days(),\nDurationFieldType.hours(), DurationFieldType.minutes(),\nDurationFieldType.seconds(), DurationFieldType.millis(),\n},\nnew int[] { 0, 1, 2, 3, 4, 5, 6, 7, }\n);\ncStandard = type;\n}\nreturn type;\n}",
            "method_id": 18,
            "loc": 17
        },
        {
            "method_signature": "org.joda.time.chrono.BaseChronology:get(Lorg/joda/time/ReadablePeriod;J)[I",
            "method_body": "public int[] get(ReadablePeriod period, long duration) {\nint size = period.size();\nint[] values = new int[size];\nif (duration != 0) {\nlong current = 0;\nfor (int i = 0; i < size; i++) {\nDurationField field = period.getFieldType(i).getField(this);\nif (field.isPrecise()) {\nint value = field.getDifference(duration, current);\ncurrent = field.add(current, value);\nvalues[i] = value;\n}\n}\n}\nreturn values;\n}",
            "method_id": 19,
            "loc": 16
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:clear()V",
            "method_body": "public void clear() {\niMinPrintedDigits = 1;\niPrintZeroSetting = PRINT_ZERO_RARELY_LAST;\niMaxParsedDigits = 10;\niRejectSignedValues = false;\niPrefix = null;\nif (iElementPairs == null) {\niElementPairs = new ArrayList<Object>();\n} else {\niElementPairs.clear();\n}\niNotPrinter = false;\niNotParser = false;\niFieldFormatters = new FieldFormatter[10];\n}",
            "method_id": 20,
            "loc": 15
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatter:parseMutablePeriod(Ljava/lang/String;)Lorg/joda/time/MutablePeriod;",
            "method_body": "public MutablePeriod parseMutablePeriod(String text) {\ncheckParser();\n\nMutablePeriod period = new MutablePeriod(0, iParseType);\nint newPos = getParser().parseInto(period, text, 0, iLocale);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nreturn period;\n}\n} else {\nnewPos = ~newPos;\n}\nthrow new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
            "method_id": 21,
            "loc": 14
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Composite:parseInto(Lorg/joda/time/ReadWritablePeriod;Ljava/lang/String;ILjava/util/Locale;)I",
            "method_body": "public int parseInto(\nReadWritablePeriod period, String periodStr,\nint position, Locale locale) {\nPeriodParser[] parsers = iParsers;\nif (parsers == null) {\nthrow new UnsupportedOperationException();\n}\n\nint len = parsers.length;\nfor (int i=0; i<len && position >= 0; i++) {\nposition = parsers[i].parseInto(period, periodStr, position, locale);\n}\nreturn position;\n}",
            "method_id": 22,
            "loc": 14
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:<init>(Ljava/lang/Object;Lorg/joda/time/PeriodType;Lorg/joda/time/Chronology;)V",
            "method_body": "protected BasePeriod(Object period, PeriodType type, Chronology chrono) {\nsuper();\nPeriodConverter converter = ConverterManager.getInstance().getPeriodConverter(period);\ntype = (type == null ? converter.getPeriodType(period) : type);\ntype = checkPeriodType(type);\niType = type;\nif (this instanceof ReadWritablePeriod) {\niValues = new int[size()];\nchrono = DateTimeUtils.getChronology(chrono);\nconverter.setInto((ReadWritablePeriod) this, period, chrono);\n} else {\niValues = new MutablePeriod(period, type, chrono).getValues();\n}\n}",
            "method_id": 23,
            "loc": 14
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:<init>(Lorg/joda/time/format/PeriodFormatterBuilder$FieldFormatter;Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;)V",
            "method_body": "FieldFormatter(FieldFormatter field, PeriodFieldAffix suffix) {\niMinPrintedDigits = field.iMinPrintedDigits;\niPrintZeroSetting = field.iPrintZeroSetting;\niMaxParsedDigits = field.iMaxParsedDigits;\niRejectSignedValues = field.iRejectSignedValues;\niFieldType = field.iFieldType;\niFieldFormatters = field.iFieldFormatters;\niPrefix = field.iPrefix;\nif (field.iSuffix != null) {\nsuffix = new CompositeAffix(field.iSuffix, suffix);\n}\niSuffix = suffix;\n}",
            "method_id": 24,
            "loc": 13
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:<init>(IIIZI[Lorg/joda/time/format/PeriodFormatterBuilder$FieldFormatter;Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;Lorg/joda/time/format/PeriodFormatterBuilder$PeriodFieldAffix;)V",
            "method_body": "FieldFormatter(int minPrintedDigits, int printZeroSetting,\nint maxParsedDigits, boolean rejectSignedValues,\nint fieldType, FieldFormatter[] fieldFormatters,\nPeriodFieldAffix prefix, PeriodFieldAffix suffix) {\niMinPrintedDigits = minPrintedDigits;\niPrintZeroSetting = printZeroSetting;\niMaxParsedDigits = maxParsedDigits;\niRejectSignedValues = rejectSignedValues;\niFieldType = fieldType;\niFieldFormatters = fieldFormatters;\niPrefix = prefix;\niSuffix = suffix;\n}",
            "method_id": 25,
            "loc": 13
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:setDefault(Lorg/joda/time/DateTimeZone;)V",
            "method_body": "public static void setDefault(DateTimeZone zone) throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nsm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n}\nif (zone == null) {\nthrow new IllegalArgumentException(\"The datetime zone must not be null\");\n}\nsynchronized(DateTimeZone.class) {\ncDefault = zone;\n}\n}",
            "method_id": 26,
            "loc": 12
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:createComposite(Ljava/util/List;)[Ljava/lang/Object;",
            "method_body": "private static Object[] createComposite(List<Object> elementPairs) {\nswitch (elementPairs.size()) {\ncase 0:\nreturn new Object[] {Literal.EMPTY, Literal.EMPTY};\ncase 1:\nreturn new Object[] {elementPairs.get(0), elementPairs.get(1)};\ndefault:\nComposite comp = new Composite(elementPairs);\nreturn new Object[] {comp, comp};\n}\n}",
            "method_id": 27,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:checkAndUpdate(Lorg/joda/time/DurationFieldType;[II)V",
            "method_body": "private void checkAndUpdate(DurationFieldType type, int[] values, int newValue) {\nint index = indexOf(type);\nif (index == -1) {\nif (newValue != 0) {\nthrow new IllegalArgumentException(\n\"Period does not support field '\" + type.getName() + \"'\");\n}\n} else {\nvalues[index] = newValue;\n}\n}",
            "method_id": 28,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:setFieldInto([ILorg/joda/time/DurationFieldType;I)V",
            "method_body": "protected void setFieldInto(int[] values, DurationFieldType field, int value) {\nint index = indexOf(field);\nif (index == -1) {\nif (value != 0 || field == null) {\nthrow new IllegalArgumentException(\n\"Period does not support field '\" + field + \"'\");\n}\n} else {\nvalues[index] = value;\n}\n}",
            "method_id": 29,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendLiteral(Ljava/lang/String;)Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendLiteral(String text) {\nif (text == null) {\nthrow new IllegalArgumentException(\"Literal must not be null\");\n}\nclearPrefix();\nLiteral literal = new Literal(text);\nappend0(literal, literal);\nreturn this;\n}",
            "method_id": 30,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.convert.ConverterManager:getPeriodConverter(Ljava/lang/Object;)Lorg/joda/time/convert/PeriodConverter;",
            "method_body": "public PeriodConverter getPeriodConverter(Object object) {\nPeriodConverter converter =\n(PeriodConverter)iPeriodConverters.select(object == null ? null : object.getClass());\nif (converter != null) {\nreturn converter;\n}\nthrow new IllegalArgumentException(\"No period converter found for type: \" +\n(object == null ? \"null\" : object.getClass().getName()));\n}",
            "method_id": 31,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:setPeriodInternal(Lorg/joda/time/ReadablePeriod;)V",
            "method_body": "private void setPeriodInternal(ReadablePeriod period) {\nint[] newValues = new int[size()];\nfor (int i = 0, isize = period.size(); i < isize; i++) {\nDurationFieldType type = period.getFieldType(i);\nint value = period.getValue(i);\ncheckAndUpdate(type, newValues, value);\n}\niValues = newValues;\n}",
            "method_id": 32,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:append(Lorg/joda/time/format/PeriodFormatter;)Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder append(PeriodFormatter formatter) {\nif (formatter == null) {\nthrow new IllegalArgumentException(\"No formatter supplied\");\n}\nclearPrefix();\nappend0(formatter.getPrinter(), formatter.getParser());\nreturn this;\n}",
            "method_id": 33,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Literal:parseInto(Lorg/joda/time/ReadWritablePeriod;Ljava/lang/String;ILjava/util/Locale;)I",
            "method_body": "public int parseInto(\nReadWritablePeriod period, String periodStr,\nint position, Locale locale) {\nif (periodStr.regionMatches(true, position, iText, 0, iText.length())) {\nreturn position + iText.length();\n}\nreturn ~position;\n}",
            "method_id": 34,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.PeriodType:indexOf(Lorg/joda/time/DurationFieldType;)I",
            "method_body": "public int indexOf(DurationFieldType type) {\nfor (int i = 0, isize = size(); i < isize; i++) {\nif (iTypes[i] == type) {\nreturn i;\n}\n}\nreturn -1;\n}",
            "method_id": 35,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatter:<init>(Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;)V",
            "method_body": "public PeriodFormatter(\nPeriodPrinter printer, PeriodParser parser) {\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niParseType = null;\n}",
            "method_id": 36,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendField(II)V",
            "method_body": "private void appendField(int type, int minPrinted) {\nFieldFormatter field = new FieldFormatter(minPrinted, iPrintZeroSetting,\niMaxParsedDigits, iRejectSignedValues, type, iFieldFormatters, iPrefix, null);\nappend0(field, field);\niFieldFormatters[type] = field;\niPrefix = null;\n}",
            "method_id": 37,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.base.AbstractPeriod:getValues()[I",
            "method_body": "public int[] getValues() {\nint[] result = new int[size()];\nfor (int i = 0; i < result.length; i++) {\nresult[i] = getValue(i);\n}\nreturn result;\n}",
            "method_id": 38,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nChronology base;\nif ((base = iBase) != null) {\nreturn base.getZone();\n}\nreturn null;\n}",
            "method_id": 39,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:setPeriod(Lorg/joda/time/ReadablePeriod;)V",
            "method_body": "protected void setPeriod(ReadablePeriod period) {\nif (period == null) {\nsetValues(new int[size()]);\n} else {\nsetPeriodInternal(period);\n}\n}",
            "method_id": 40,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:<init>(JLorg/joda/time/PeriodType;Lorg/joda/time/Chronology;)V",
            "method_body": "protected BasePeriod(long duration, PeriodType type, Chronology chrono) {\nsuper();\ntype = checkPeriodType(type);\nchrono = DateTimeUtils.getChronology(chrono);\niType = type;\niValues = chrono.get(this, duration);\n}",
            "method_id": 41,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:append0(Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;)Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "private PeriodFormatterBuilder append0(PeriodPrinter printer, PeriodParser parser) {\niElementPairs.add(printer);\niElementPairs.add(parser);\niNotPrinter |= (printer == null);\niNotParser |= (parser == null);\nreturn this;\n}",
            "method_id": 42,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:clearPrefix()V",
            "method_body": "private void clearPrefix() throws IllegalStateException {\nif (iPrefix != null) {\nthrow new IllegalStateException(\"Prefix not followed by field\");\n}\niPrefix = null;\n}",
            "method_id": 43,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSuffix(Ljava/lang/String;)Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendSuffix(String text) {\nif (text == null) {\nthrow new IllegalArgumentException();\n}\nreturn appendSuffix(new SimpleAffix(text));\n}",
            "method_id": 44,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:checkPermission()V",
            "method_body": "private static void checkPermission() throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nsm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n}\n}",
            "method_id": 45,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getPeriodType(Lorg/joda/time/PeriodType;)Lorg/joda/time/PeriodType;",
            "method_body": "public static final PeriodType getPeriodType(PeriodType type) {\nif (type == null) {\nreturn PeriodType.standard();\n}\nreturn type;\n}",
            "method_id": 46,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\n}\nreturn chrono;\n}",
            "method_id": 47,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.convert.ConverterManager:getInstance()Lorg/joda/time/convert/ConverterManager;",
            "method_body": "public static ConverterManager getInstance() {\nif (INSTANCE == null) {\nINSTANCE = new ConverterManager();\n}\nreturn INSTANCE;\n}",
            "method_id": 48,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:toFormatter()Lorg/joda/time/format/PeriodFormatter;",
            "method_body": "public PeriodFormatter toFormatter() {\nPeriodFormatter formatter = toFormatter(iElementPairs, iNotPrinter, iNotParser);\niFieldFormatters = (FieldFormatter[]) iFieldFormatters.clone();\nreturn formatter;\n}",
            "method_id": 49,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatter:parsePeriod(Ljava/lang/String;)Lorg/joda/time/Period;",
            "method_body": "public Period parsePeriod(String text) {\ncheckParser();\n\nreturn parseMutablePeriod(text).toPeriod();\n}",
            "method_id": 50,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatter:checkParser()V",
            "method_body": "private void checkParser() {\nif (iParser == null) {\nthrow new UnsupportedOperationException(\"Parsing not supported\");\n}\n}",
            "method_id": 51,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Separator:finish(Lorg/joda/time/format/PeriodPrinter;Lorg/joda/time/format/PeriodParser;)Lorg/joda/time/format/PeriodFormatterBuilder$Separator;",
            "method_body": "Separator finish(PeriodPrinter afterPrinter, PeriodParser afterParser) {\niAfterPrinter = afterPrinter;\niAfterParser = afterParser;\nreturn this;\n}",
            "method_id": 52,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendYears()Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendYears() {\nappendField(YEARS);\nreturn this;\n}",
            "method_id": 53,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendMonths()Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendMonths() {\nappendField(MONTHS);\nreturn this;\n}",
            "method_id": 54,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendWeeks()Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendWeeks() {\nappendField(WEEKS);\nreturn this;\n}",
            "method_id": 55,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendDays()Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendDays() {\nappendField(DAYS);\nreturn this;\n}",
            "method_id": 56,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendHours()Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendHours() {\nappendField(HOURS);\nreturn this;\n}",
            "method_id": 57,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendMinutes()Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendMinutes() {\nappendField(MINUTES);\nreturn this;\n}",
            "method_id": 58,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSecondsWithOptionalMillis()Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendSecondsWithOptionalMillis() {\nappendField(SECONDS_OPTIONAL_MILLIS);\nreturn this;\n}",
            "method_id": 59,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.convert.ReadablePeriodConverter:getPeriodType(Ljava/lang/Object;)Lorg/joda/time/PeriodType;",
            "method_body": "public PeriodType getPeriodType(Object object) {\nReadablePeriod period = (ReadablePeriod) object;\nreturn period.getPeriodType();\n}",
            "method_id": 60,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:setCurrentMillisSystem()V",
            "method_body": "public static final void setCurrentMillisSystem() throws SecurityException {\ncheckPermission();\ncMillisProvider = SYSTEM_MILLIS_PROVIDER;\n}",
            "method_id": 61,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:setCurrentMillisFixed(J)V",
            "method_body": "public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\ncheckPermission();\ncMillisProvider = new FixedMillisProvider(fixedMillis);\n}",
            "method_id": 62,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:<init>()V",
            "method_body": "public PeriodFormatterBuilder() {\nclear();\n}",
            "method_id": 63,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$Literal:<init>(Ljava/lang/String;)V",
            "method_body": "Literal(String text) {\niText = text;\n}",
            "method_id": 64,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendField(I)V",
            "method_body": "private void appendField(int type) {\nappendField(type, iMinPrintedDigits);\n}",
            "method_id": 65,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder:appendSeparatorIfFieldsAfter(Ljava/lang/String;)Lorg/joda/time/format/PeriodFormatterBuilder;",
            "method_body": "public PeriodFormatterBuilder appendSeparatorIfFieldsAfter(String text) {\nreturn appendSeparator(text, text, null, false, true);\n}",
            "method_id": 66,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.base.AbstractPeriod:<init>()V",
            "method_body": "protected AbstractPeriod() {\nsuper();\n}",
            "method_id": 67,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.PeriodType:getFieldType(I)Lorg/joda/time/DurationFieldType;",
            "method_body": "public DurationFieldType getFieldType(int index) {\nreturn iTypes[index];\n}",
            "method_id": 68,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.PeriodType:size()I",
            "method_body": "public int size() {\nreturn iTypes.length;\n}",
            "method_id": 69,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:getValue(I)I",
            "method_body": "public int getValue(int index) {\nreturn iValues[index];\n}",
            "method_id": 70,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:getFieldType(I)Lorg/joda/time/DurationFieldType;",
            "method_body": "public DurationFieldType getFieldType(int index) {\nreturn iType.getFieldType(index);\n}",
            "method_id": 71,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:size()I",
            "method_body": "public int size() {\nreturn iType.size();\n}",
            "method_id": 72,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatterBuilder$FieldFormatter:getFieldType()I",
            "method_body": "int getFieldType() {\nreturn iFieldType;\n}",
            "method_id": 73,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.MutablePeriod:setPeriod(Lorg/joda/time/ReadablePeriod;)V",
            "method_body": "public void setPeriod(ReadablePeriod period) {\nsuper.setPeriod(period);\n}",
            "method_id": 74,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.base.AbstractPeriod:toPeriod()Lorg/joda/time/Period;",
            "method_body": "public Period toPeriod() {\nreturn new Period(this);\n}",
            "method_id": 75,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:setField(Lorg/joda/time/DurationFieldType;I)V",
            "method_body": "protected void setField(DurationFieldType field, int value) {\nsetFieldInto(iValues, field, value);\n}",
            "method_id": 76,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nreturn (DateTimeZone)getParam();\n}",
            "method_id": 77,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:millis()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType millis() {\nreturn MILLIS_TYPE;\n}",
            "method_id": 78,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.MutablePeriod:<init>(Ljava/lang/Object;Lorg/joda/time/PeriodType;Lorg/joda/time/Chronology;)V",
            "method_body": "public MutablePeriod(Object period, PeriodType type, Chronology chrono) {\nsuper(period, type, chrono);\n}",
            "method_id": 79,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatter:getParser()Lorg/joda/time/format/PeriodParser;",
            "method_body": "public PeriodParser getParser() {\nreturn iParser;\n}",
            "method_id": 80,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.MutablePeriod:setSeconds(I)V",
            "method_body": "public void setSeconds(int seconds) {\nsuper.setField(DurationFieldType.seconds(), seconds);\n}",
            "method_id": 81,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.MutablePeriod:<init>(JLorg/joda/time/PeriodType;)V",
            "method_body": "public MutablePeriod(long duration, PeriodType type) {\nsuper(duration, type, null);\n}",
            "method_id": 82,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getParam()Ljava/lang/Object;",
            "method_body": "protected final Object getParam() {\nreturn iParam;\n}",
            "method_id": 83,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.convert.ReadablePeriodConverter:setInto(Lorg/joda/time/ReadWritablePeriod;Ljava/lang/Object;Lorg/joda/time/Chronology;)V",
            "method_body": "public void setInto(ReadWritablePeriod duration, Object object, Chronology chrono) {\nduration.setPeriod((ReadablePeriod) object);\n}",
            "method_id": 84,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.Period:<init>(Ljava/lang/Object;)V",
            "method_body": "public Period(Object period) {\nsuper(period, null, null);\n}",
            "method_id": 85,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:seconds()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType seconds() {\nreturn SECONDS_TYPE;\n}",
            "method_id": 86,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:getPeriodType()Lorg/joda/time/PeriodType;",
            "method_body": "public PeriodType getPeriodType() {\nreturn iType;\n}",
            "method_id": 87,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.PeriodFormatter:getPrinter()Lorg/joda/time/format/PeriodPrinter;",
            "method_body": "public PeriodPrinter getPrinter() {\nreturn iPrinter;\n}",
            "method_id": 88,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.base.BasePeriod:checkPeriodType(Lorg/joda/time/PeriodType;)Lorg/joda/time/PeriodType;",
            "method_body": "protected PeriodType checkPeriodType(PeriodType type) {\nreturn DateTimeUtils.getPeriodType(type);\n}",
            "method_id": 89,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}",
            "method_id": 90,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils$FixedMillisProvider:<init>(J)V",
            "method_body": "FixedMillisProvider(long fixedMillis) {\niMillis = fixedMillis;\n}",
            "method_id": 91,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.MutablePeriod:setMillis(I)V",
            "method_body": "public void setMillis(int millis) {\nsuper.setField(DurationFieldType.millis(), millis);\n}",
            "method_id": 92,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.base.AbstractPeriod:indexOf(Lorg/joda/time/DurationFieldType;)I",
            "method_body": "public int indexOf(DurationFieldType type) {\nreturn getPeriodType().indexOf(type);\n}",
            "method_id": 93,
            "loc": 3
        }
    ]
}