{
    "bug_id": 24,
    "test_id": 4,
    "test_name": "org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2012",
    "test_body": "public void testParseLocalDate_weekyear_month_week_2012() {\nChronology chrono = GJChronology.getInstanceUTC();\nDateTimeFormatter f = DateTimeFormat.forPattern(\"xxxx-MM-ww\").withChronology(chrono);\nassertEquals(new LocalDate(2012, 1, 2, chrono), f.parseLocalDate(\"2012-01-01\"));\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<2012-01-02> but was:<2011-01-03>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.Assert.assertEquals(Assert.java:86)\nat junit.framework.TestCase.assertEquals(TestCase.java:253)\nat org.joda.time.format.TestDateTimeFormatter.testParseLocalDate_weekyear_month_week_2012(TestDateTimeFormatter.java:440)",
    "covered_methods": [
        {
            "method_signature": "org.joda.time.chrono.BasicWeekyearDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int year) {\nFieldUtils.verifyValueBounds(this, Math.abs(year),\niChronology.getMinYear(), iChronology.getMaxYear());\n//\n// Do nothing if no real change is requested.\n//\nint thisWeekyear = get( instant );\nif ( thisWeekyear == year ) {\nreturn instant;\n}\n//\n// Calculate the DayOfWeek (to be preserved).\n//\nint thisDow = iChronology.getDayOfWeek(instant);\n//\n// Calculate the maximum weeks in the target year.\n//\nint weeksInFromYear = iChronology.getWeeksInYear( thisWeekyear );\nint weeksInToYear = iChronology.getWeeksInYear( year );\nint maxOutWeeks = (weeksInToYear < weeksInFromYear) ?\nweeksInToYear : weeksInFromYear;\n//\n// Get the current week of the year. This will be preserved in\n// the output unless it is greater than the maximum possible\n// for the target weekyear.  In that case it is adjusted\n// to the maximum possible.\n//\nint setToWeek = iChronology.getWeekOfWeekyear(instant);\nif ( setToWeek > maxOutWeeks ) {\nsetToWeek = maxOutWeeks;\n}\n//\n// Get a wroking copy of the current date-time.\n// This can be a convenience for debugging.\n//\nlong workInstant = instant; // Get a copy\n//\n// Attempt to get close to the proper weekyear.\n// Note - we cannot currently call ourself, so we just call\n// set for the year.  This at least gets us close.\n//\nworkInstant = iChronology.setYear( workInstant, year );\n//\n// Calculate the weekyear number for the get close to value\n// (which might not be equal to the year just set).\n//\nint workWoyYear = get( workInstant );\n\n//\n// At most we are off by one year, which can be \"fixed\" by\n// adding/subtracting a week.\n//\nif ( workWoyYear < year ) {\nworkInstant += DateTimeConstants.MILLIS_PER_WEEK;\n} else if ( workWoyYear > year ) {\nworkInstant -= DateTimeConstants.MILLIS_PER_WEEK;\n}\n//\n// Set the proper week in the current weekyear.\n//\n\n// BEGIN: possible set WeekOfWeekyear logic.\nint currentWoyWeek = iChronology.getWeekOfWeekyear(workInstant);\n// No range check required (we already know it is OK).\nworkInstant = workInstant + (setToWeek - currentWoyWeek)\n* (long)DateTimeConstants.MILLIS_PER_WEEK;\n// END: possible set WeekOfWeekyear logic.\n\n//\n// Reset DayOfWeek to previous value.\n//\n// Note: This works fine, but it ideally shouldn't invoke other\n// fields from within a field.\nworkInstant = iChronology.dayOfWeek().set( workInstant, thisDow );\n//\n// Return result.\n//\nreturn workInstant;\n}",
            "method_id": 0,
            "loc": 79
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMaxMonth(I)I",
            "method_body": "abstract long getYearDifference(long minuendInstant, long subtrahendInstant);\n\n/**\n* Is the specified year a leap year?\n*\n* @param year  the year to test\n* @return true if leap\n*/\nabstract boolean isLeapYear(int year);\n\n/**\n* Gets the number of days in the specified month and year.\n*\n* @param year  the year\n* @param month  the month\n* @return the number of days\n*/\nabstract int getDaysInYearMonth(int year, int month);\n\n/**\n* Gets the maximum days in the specified month.\n*\n* @param month  the month\n* @return the max days\n*/\nabstract int getDaysInMonthMax(int month);\n\n/**\n* Gets the total number of millis elapsed in this year at the start\n* of the specified month, such as zero for month 1.\n*\n* @param year  the year\n* @param month  the month\n* @return the elapsed millis at the start of the month\n*/\nabstract long getTotalMillisByYearMonth(int year, int month);\n\n/**\n* Gets the millisecond value of the first day of the year.\n*\n* @return the milliseconds for the first of the year\n*/\nabstract long calculateFirstDayOfYearMillis(int year);\n\n/**\n* Gets the minimum supported year.\n*\n* @return the year\n*/\nabstract int getMinYear();\n\n/**\n* Gets the maximum supported year.\n*\n* @return the year\n*/\nabstract int getMaxYear();\n\n/**\n* Gets the maximum month for the specified year.\n* This implementation calls getMaxMonth().\n*\n* @param year  the year\n* @return the maximum month value\n*/\nint getMaxMonth(int year) {\nreturn getMaxMonth();\n}",
            "method_id": 1,
            "loc": 68
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nint limit = Math.min(iMaxParsedDigits, text.length() - position);\n\nboolean negative = false;\nint length = 0;\nwhile (length < limit) {\nchar c = text.charAt(position + length);\nif (length == 0 && (c == '-' || c == '+') && iSigned) {\nnegative = c == '-';\n\n// Next character must be a digit.\nif (length + 1 >= limit ||\n(c = text.charAt(position + length + 1)) < '0' || c > '9')\n{\nbreak;\n}\n\nif (negative) {\nlength++;\n} else {\n// Skip the '+' for parseInt to succeed.\nposition++;\n}\n// Expand the limit to disregard the sign character.\nlimit = Math.min(limit + 1, text.length() - position);\ncontinue;\n}\nif (c < '0' || c > '9') {\nbreak;\n}\nlength++;\n}\n\nif (length == 0) {\nreturn ~position;\n}\n\nint value;\nif (length >= 9) {\n// Since value may exceed integer limits, use stock parser\n// which checks for this.\nvalue = Integer.parseInt(text.substring(position, position += length));\n} else {\nint i = position;\nif (negative) {\ni++;\n}\ntry {\nvalue = text.charAt(i++) - '0';\n} catch (StringIndexOutOfBoundsException e) {\nreturn ~position;\n}\nposition += length;\nwhile (i < position) {\nvalue = ((value << 3) + (value << 1)) + text.charAt(i++) - '0';\n}\nif (negative) {\nvalue = -value;\n}\n}\n\nbucket.saveField(iFieldType, value);\nreturn position;\n}",
            "method_id": 2,
            "loc": 64
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType:getField(Lorg/joda/time/Chronology;)Lorg/joda/time/DateTimeField;",
            "method_body": "public DateTimeField getField(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\n\nswitch (iOrdinal) {\ncase ERA:\nreturn chronology.era();\ncase YEAR_OF_ERA:\nreturn chronology.yearOfEra();\ncase CENTURY_OF_ERA:\nreturn chronology.centuryOfEra();\ncase YEAR_OF_CENTURY:\nreturn chronology.yearOfCentury();\ncase YEAR:\nreturn chronology.year();\ncase DAY_OF_YEAR:\nreturn chronology.dayOfYear();\ncase MONTH_OF_YEAR:\nreturn chronology.monthOfYear();\ncase DAY_OF_MONTH:\nreturn chronology.dayOfMonth();\ncase WEEKYEAR_OF_CENTURY:\nreturn chronology.weekyearOfCentury();\ncase WEEKYEAR:\nreturn chronology.weekyear();\ncase WEEK_OF_WEEKYEAR:\nreturn chronology.weekOfWeekyear();\ncase DAY_OF_WEEK:\nreturn chronology.dayOfWeek();\ncase HALFDAY_OF_DAY:\nreturn chronology.halfdayOfDay();\ncase HOUR_OF_HALFDAY:\nreturn chronology.hourOfHalfday();\ncase CLOCKHOUR_OF_HALFDAY:\nreturn chronology.clockhourOfHalfday();\ncase CLOCKHOUR_OF_DAY:\nreturn chronology.clockhourOfDay();\ncase HOUR_OF_DAY:\nreturn chronology.hourOfDay();\ncase MINUTE_OF_DAY:\nreturn chronology.minuteOfDay();\ncase MINUTE_OF_HOUR:\nreturn chronology.minuteOfHour();\ncase SECOND_OF_DAY:\nreturn chronology.secondOfDay();\ncase SECOND_OF_MINUTE:\nreturn chronology.secondOfMinute();\ncase MILLIS_OF_DAY:\nreturn chronology.millisOfDay();\ncase MILLIS_OF_SECOND:\nreturn chronology.millisOfSecond();\ndefault:\n// Shouldn't happen.\nthrow new InternalError();\n}\n}",
            "method_id": 3,
            "loc": 55
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:computeMillis(ZLjava/lang/String;)J",
            "method_body": "public long computeMillis(boolean resetFields, String text) {\nSavedField[] savedFields = iSavedFields;\nint count = iSavedFieldsCount;\nif (iSavedFieldsShared) {\niSavedFields = savedFields = (SavedField[])iSavedFields.clone();\niSavedFieldsShared = false;\n}\nsort(savedFields, count);\nif (count > 0) {\n// alter base year for parsing if first field is month or day\nDurationField months = DurationFieldType.months().getField(iChrono);\nDurationField days = DurationFieldType.days().getField(iChrono);\nDurationField first = savedFields[0].iField.getDurationField();\nif (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\nsaveField(DateTimeFieldType.year(), iDefaultYear);\nreturn computeMillis(resetFields, text);\n}\n}\n\nlong millis = iMillis;\ntry {\nfor (int i = 0; i < count; i++) {\nmillis = savedFields[i].set(millis, resetFields);\n}\n} catch (IllegalFieldValueException e) {\nif (text != null) {\ne.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n}\nthrow e;\n}\n\nif (iZone == null) {\nmillis -= iOffset;\n} else {\nint offset = iZone.getOffsetFromLocal(millis);\nmillis -= offset;\nif (offset != iZone.getOffset(millis)) {\nString message =\n\"Illegal instant due to time zone offset transition (\" + iZone + ')';\nif (text != null) {\nmessage = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n}\nthrow new IllegalArgumentException(message);\n}\n}\n\nreturn millis;\n}",
            "method_id": 4,
            "loc": 48
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology:getInstance(Lorg/joda/time/DateTimeZone;Lorg/joda/time/ReadableInstant;I)Lorg/joda/time/chrono/GJChronology;",
            "method_body": "public static synchronized GJChronology getInstance(\nDateTimeZone zone,\nReadableInstant gregorianCutover,\nint minDaysInFirstWeek) {\n\nzone = DateTimeUtils.getZone(zone);\nInstant cutoverInstant;\nif (gregorianCutover == null) {\ncutoverInstant = DEFAULT_CUTOVER;\n} else {\ncutoverInstant = gregorianCutover.toInstant();\n}\n\nGJChronology chrono;\n\nArrayList<GJChronology> chronos = cCache.get(zone);\nif (chronos == null) {\nchronos = new ArrayList<GJChronology>(2);\ncCache.put(zone, chronos);\n} else {\nfor (int i=chronos.size(); --i>=0; ) {\nchrono = chronos.get(i);\nif (minDaysInFirstWeek == chrono.getMinimumDaysInFirstWeek() &&\ncutoverInstant.equals(chrono.getGregorianCutover())) {\n\nreturn chrono;\n}\n}\n}\n\nif (zone == DateTimeZone.UTC) {\nchrono = new GJChronology\n(JulianChronology.getInstance(zone, minDaysInFirstWeek),\nGregorianChronology.getInstance(zone, minDaysInFirstWeek),\ncutoverInstant);\n} else {\nchrono = getInstance(DateTimeZone.UTC, cutoverInstant, minDaysInFirstWeek);\nchrono = new GJChronology\n(ZonedChronology.getInstance(chrono, zone),\nchrono.iJulianChronology,\nchrono.iGregorianChronology,\nchrono.iCutoverInstant);\n}\n\nchronos.add(chrono);\n\nreturn chrono;\n}",
            "method_id": 5,
            "loc": 48
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYearInfo(I)Lorg/joda/time/chrono/BasicChronology$YearInfo;",
            "method_body": "abstract long getAverageMillisPerYear();\n\n/**\n* Gets an average value for the milliseconds per year, divided by two.\n*\n* @return the millis per year divided by two\n*/\nabstract long getAverageMillisPerYearDividedByTwo();\n\n/**\n* Gets an average value for the milliseconds per month.\n*\n* @return the millis per month\n*/\nabstract long getAverageMillisPerMonth();\n\n/**\n* Returns a constant representing the approximate number of milliseconds\n* elapsed from year 0 of this chronology, divided by two. This constant\n* <em>must</em> be defined as:\n* <pre>\n*    (yearAtEpoch * averageMillisPerYear + millisOfYearAtEpoch) / 2\n* </pre>\n* where epoch is 1970-01-01 (Gregorian).\n*/\nabstract long getApproxMillisAtEpochDividedByTwo();\n\n/**\n* Sets the year from an instant and year.\n*\n* @param instant  millis from 1970-01-01T00:00:00Z\n* @param year  the year to set\n* @return the updated millis\n*/\nabstract long setYear(long instant, int year);\n\n//-----------------------------------------------------------------------\n// Although accessed by multiple threads, this method doesn't need to be synchronized.\nprivate YearInfo getYearInfo(int year) {\nYearInfo info = iYearInfoCache[year & CACHE_MASK];\nif (info == null || info.iYear != year) {\ninfo = new YearInfo(year, calculateFirstDayOfYearMillis(year));\niYearInfoCache[year & CACHE_MASK] = info;\n}\nreturn info;\n}",
            "method_id": 6,
            "loc": 46
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:<init>(Ljava/util/List;)V",
            "method_body": "Composite(List<Object> elementPairs) {\nsuper();\n\nList<Object> printerList = new ArrayList<Object>();\nList<Object> parserList = new ArrayList<Object>();\n\ndecompose(elementPairs, printerList, parserList);\n\nif (printerList.size() <= 0) {\niPrinters = null;\niPrintedLengthEstimate = 0;\n} else {\nint size = printerList.size();\niPrinters = new DateTimePrinter[size];\nint printEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimePrinter printer = (DateTimePrinter) printerList.get(i);\nprintEst += printer.estimatePrintedLength();\niPrinters[i] = printer;\n}\niPrintedLengthEstimate = printEst;\n}\n\nif (parserList.size() <= 0) {\niParsers = null;\niParsedLengthEstimate = 0;\n} else {\nint size = parserList.size();\niParsers = new DateTimeParser[size];\nint parseEst = 0;\nfor (int i=0; i<size; i++) {\nDateTimeParser parser = (DateTimeParser) parserList.get(i);\nparseEst += parser.estimateParsedLength();\niParsers[i] = parser;\n}\niParsedLengthEstimate = parseEst;\n}\n}",
            "method_id": 7,
            "loc": 38
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYear(J)I",
            "method_body": "int getYear(long instant) {\n// Get an initial estimate of the year, and the millis value that\n// represents the start of that year. Then verify estimate and fix if\n// necessary.\n\n// Initial estimate uses values divided by two to avoid overflow.\nlong unitMillis = getAverageMillisPerYearDividedByTwo();\nlong i2 = (instant >> 1) + getApproxMillisAtEpochDividedByTwo();\nif (i2 < 0) {\ni2 = i2 - unitMillis + 1;\n}\nint year = (int) (i2 / unitMillis);\n\nlong yearStart = getYearMillis(year);\nlong diff = instant - yearStart;\n\nif (diff < 0) {\nyear--;\n} else if (diff >= DateTimeConstants.MILLIS_PER_DAY * 365L) {\n// One year may need to be added to fix estimate.\nlong oneYear;\nif (isLeapYear(year)) {\noneYear = DateTimeConstants.MILLIS_PER_DAY * 366L;\n} else {\noneYear = DateTimeConstants.MILLIS_PER_DAY * 365L;\n}\n\nyearStart += oneYear;\n\nif (yearStart <= instant) {\n// Didn't go too far, so actually add one year.\nyear++;\n}\n}\n\nreturn year;\n}",
            "method_id": 8,
            "loc": 37
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:printOffset(I)Ljava/lang/String;",
            "method_body": "private static String printOffset(int offset) {\nStringBuffer buf = new StringBuffer();\nif (offset >= 0) {\nbuf.append('+');\n} else {\nbuf.append('-');\noffset = -offset;\n}\n\nint hours = offset / DateTimeConstants.MILLIS_PER_HOUR;\nFormatUtils.appendPaddedInteger(buf, hours, 2);\noffset -= hours * (int) DateTimeConstants.MILLIS_PER_HOUR;\n\nint minutes = offset / DateTimeConstants.MILLIS_PER_MINUTE;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, minutes, 2);\noffset -= minutes * DateTimeConstants.MILLIS_PER_MINUTE;\nif (offset == 0) {\nreturn buf.toString();\n}\n\nint seconds = offset / DateTimeConstants.MILLIS_PER_SECOND;\nbuf.append(':');\nFormatUtils.appendPaddedInteger(buf, seconds, 2);\noffset -= seconds * DateTimeConstants.MILLIS_PER_SECOND;\nif (offset == 0) {\nreturn buf.toString();\n}\n\nbuf.append('.');\nFormatUtils.appendPaddedInteger(buf, offset, 3);\nreturn buf.toString();\n}",
            "method_id": 9,
            "loc": 33
        },
        {
            "method_signature": "org.joda.time.DurationFieldType$StandardDurationFieldType:getField(Lorg/joda/time/Chronology;)Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getField(Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\n\nswitch (iOrdinal) {\ncase ERAS:\nreturn chronology.eras();\ncase CENTURIES:\nreturn chronology.centuries();\ncase WEEKYEARS:\nreturn chronology.weekyears();\ncase YEARS:\nreturn chronology.years();\ncase MONTHS:\nreturn chronology.months();\ncase WEEKS:\nreturn chronology.weeks();\ncase DAYS:\nreturn chronology.days();\ncase HALFDAYS:\nreturn chronology.halfdays();\ncase HOURS:\nreturn chronology.hours();\ncase MINUTES:\nreturn chronology.minutes();\ncase SECONDS:\nreturn chronology.seconds();\ncase MILLIS:\nreturn chronology.millis();\ndefault:\n// Shouldn't happen.\nthrow new InternalError();\n}\n}",
            "method_id": 10,
            "loc": 33
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getDefault()Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone getDefault() {\nDateTimeZone zone = cDefault;\nif (zone == null) {\nsynchronized(DateTimeZone.class) {\nzone = cDefault;\nif (zone == null) {\nDateTimeZone temp = null;\ntry {\ntry {\nString id = System.getProperty(\"user.timezone\");\nif (id != null) {  // null check avoids stack overflow\ntemp = forID(id);\n}\n} catch (RuntimeException ex) {\n// ignored\n}\nif (temp == null) {\ntemp = forTimeZone(TimeZone.getDefault());\n}\n} catch (IllegalArgumentException ex) {\n// ignored\n}\nif (temp == null) {\ntemp = UTC;\n}\ncDefault = zone = temp;\n}\n}\n}\nreturn zone;\n}",
            "method_id": 11,
            "loc": 31
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getMonthOfYear(JI)I",
            "method_body": "int getMonthOfYear(long millis, int year) {\n// Perform a binary search to get the month. To make it go even faster,\n// compare using ints instead of longs. The number of milliseconds per\n// year exceeds the limit of a 32-bit int's capacity, so divide by\n// 1024. No precision is lost (except time of day) since the number of\n// milliseconds per day contains 1024 as a factor. After the division,\n// the instant isn't measured in milliseconds, but in units of\n// (128/125)seconds.\n\nint i = (int)((millis - getYearMillis(year)) >> 10);\n\n// There are 86400000 milliseconds per day, but divided by 1024 is\n// 84375. There are 84375 (128/125)seconds per day.\n\nreturn\n(isLeapYear(year))\n? ((i < 182 * 84375)\n? ((i < 91 * 84375)\n? ((i < 31 * 84375) ? 1 : (i < 60 * 84375) ? 2 : 3)\n: ((i < 121 * 84375) ? 4 : (i < 152 * 84375) ? 5 : 6))\n: ((i < 274 * 84375)\n? ((i < 213 * 84375) ? 7 : (i < 244 * 84375) ? 8 : 9)\n: ((i < 305 * 84375) ? 10 : (i < 335 * 84375) ? 11 : 12)))\n: ((i < 181 * 84375)\n? ((i < 90 * 84375)\n? ((i < 31 * 84375) ? 1 : (i < 59 * 84375) ? 2 : 3)\n: ((i < 120 * 84375) ? 4 : (i < 151 * 84375) ? 5 : 6))\n: ((i < 273 * 84375)\n? ((i < 212 * 84375) ? 7 : (i < 243 * 84375) ? 8 : 9)\n: ((i < 304 * 84375) ? 10 : (i < 334 * 84375) ? 11 : 12)));\n}",
            "method_id": 12,
            "loc": 31
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology$CutoverField:set(JI)J",
            "method_body": "public long set(long instant, int value) {\nif (instant >= iCutover) {\ninstant = iGregorianField.set(instant, value);\nif (instant < iCutover) {\n// Only adjust if gap fully crossed.\nif (instant + iGapDuration < iCutover) {\ninstant = gregorianToJulian(instant);\n}\n// Verify that new value stuck.\nif (get(instant) != value) {\nthrow new IllegalFieldValueException\n(iGregorianField.getType(), new Integer(value), null, null);\n}\n}\n} else {\ninstant = iJulianField.set(instant, value);\nif (instant >= iCutover) {\n// Only adjust if gap fully crossed.\nif (instant - iGapDuration >= iCutover) {\ninstant = julianToGregorian(instant);\n}\n// Verify that new value stuck.\nif (get(instant) != value) {\nthrow new IllegalFieldValueException\n(iJulianField.getType(), new Integer(value), null, null);\n}\n}\n}\nreturn instant;\n}",
            "method_id": 13,
            "loc": 30
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:getFormatter()Ljava/lang/Object;",
            "method_body": "private Object getFormatter() {\nObject f = iFormatter;\n\nif (f == null) {\nif (iElementPairs.size() == 2) {\nObject printer = iElementPairs.get(0);\nObject parser = iElementPairs.get(1);\n\nif (printer != null) {\nif (printer == parser || parser == null) {\nf = printer;\n}\n} else {\nf = parser;\n}\n}\n\nif (f == null) {\nf = new Composite(iElementPairs);\n}\n\niFormatter = f;\n}\n\nreturn f;\n}",
            "method_id": 14,
            "loc": 26
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:setYear(JI)J",
            "method_body": "long setYear(long instant, int year) {\nint thisYear = getYear(instant);\nint dayOfYear = getDayOfYear(instant, thisYear);\nint millisOfDay = getMillisOfDay(instant);\n\nif (dayOfYear > (31 + 28)) { // after Feb 28\nif (isLeapYear(thisYear)) {\n// Current date is Feb 29 or later.\nif (!isLeapYear(year)) {\n// Moving to a non-leap year, Feb 29 does not exist.\ndayOfYear--;\n}\n} else {\n// Current date is Mar 01 or later.\nif (isLeapYear(year)) {\n// Moving to a leap year, account for Feb 29.\ndayOfYear++;\n}\n}\n}\n\ninstant = getYearMonthDayMillis(year, 1, dayOfYear);\ninstant += millisOfDay;\n\nreturn instant;\n}",
            "method_id": 15,
            "loc": 26
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology:getDateTimeMillis(IIII)J",
            "method_body": "public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\nint millisOfDay)\nthrows IllegalArgumentException\n{\nChronology base;\nif ((base = getBase()) != null) {\nreturn base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n}\n\n// Assume date is Gregorian.\nlong instant = iGregorianChronology.getDateTimeMillis\n(year, monthOfYear, dayOfMonth, millisOfDay);\nif (instant < iCutoverMillis) {\n// Maybe it's Julian.\ninstant = iJulianChronology.getDateTimeMillis\n(year, monthOfYear, dayOfMonth, millisOfDay);\nif (instant >= iCutoverMillis) {\n// Okay, it's in the illegal cutover gap.\nthrow new IllegalArgumentException(\"Specified date does not exist\");\n}\n}\nreturn instant;\n}",
            "method_id": 16,
            "loc": 23
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:decompose(Ljava/util/List;Ljava/util/List;Ljava/util/List;)V",
            "method_body": "private void decompose(List<Object> elementPairs, List<Object> printerList, List<Object> parserList) {\nint size = elementPairs.size();\nfor (int i=0; i<size; i+=2) {\nObject element = elementPairs.get(i);\nif (element instanceof DateTimePrinter) {\nif (element instanceof Composite) {\naddArrayToList(printerList, ((Composite)element).iPrinters);\n} else {\nprinterList.add(element);\n}\n}\n\nelement = elementPairs.get(i + 1);\nif (element instanceof DateTimeParser) {\nif (element instanceof Composite) {\naddArrayToList(parserList, ((Composite)element).iParsers);\n} else {\nparserList.add(element);\n}\n}\n}\n}",
            "method_id": 17,
            "loc": 22
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nif (position >= text.length()) {\nreturn ~position;\n}\n\nchar a = text.charAt(position);\nchar b = iValue;\n\nif (a != b) {\na = Character.toUpperCase(a);\nb = Character.toUpperCase(b);\nif (a != b) {\na = Character.toLowerCase(a);\nb = Character.toLowerCase(b);\nif (a != b) {\nreturn ~position;\n}\n}\n}\n\nreturn position + 1;\n}",
            "method_id": 18,
            "loc": 22
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDateTime(Ljava/lang/String;)Lorg/joda/time/LocalDateTime;",
            "method_body": "public LocalDateTime parseLocalDateTime(String text) {\nDateTimeParser parser = requireParser();\n\nChronology chrono = selectChronology(null).withUTC();  // always use UTC, avoiding DST gaps\nDateTimeParserBucket bucket = new DateTimeParserBucket(0, chrono, iLocale, iPivotYear, iDefaultYear);\nint newPos = parser.parseInto(bucket, text, 0);\nif (newPos >= 0) {\nif (newPos >= text.length()) {\nlong millis = bucket.computeMillis(true, text);\nif (bucket.getZone() == null) {  // treat withOffsetParsed() as being true\nint parsedOffset = bucket.getOffset();\nDateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\nchrono = chrono.withZone(parsedZone);\n}\nreturn new LocalDateTime(millis, chrono);\n}\n} else {\nnewPos = ~newPos;\n}\nthrow new IllegalArgumentException(FormatUtils.createErrorMessage(text, newPos));\n}",
            "method_id": 19,
            "loc": 21
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:fixedOffsetZone(Ljava/lang/String;I)Lorg/joda/time/DateTimeZone;",
            "method_body": "private static synchronized DateTimeZone fixedOffsetZone(String id, int offset) {\nif (offset == 0) {\nreturn DateTimeZone.UTC;\n}\nif (iFixedOffsetCache == null) {\niFixedOffsetCache = new HashMap<String, SoftReference<DateTimeZone>>();\n}\nDateTimeZone zone;\nReference<DateTimeZone> ref = iFixedOffsetCache.get(id);\nif (ref != null) {\nzone = ref.get();\nif (zone != null) {\nreturn zone;\n}\n}\nzone = new FixedDateTimeZone(id, null, offset, offset);\niFixedOffsetCache.put(id, new SoftReference<DateTimeZone>(zone));\nreturn zone;\n}",
            "method_id": 20,
            "loc": 19
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstance(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstance(DateTimeZone zone) {\nif (zone == null) {\nzone = DateTimeZone.getDefault();\n}\nint index = System.identityHashCode(zone) & (FAST_CACHE_SIZE - 1);\nISOChronology chrono = cFastCache[index];\nif (chrono != null && chrono.getZone() == zone) {\nreturn chrono;\n}\nsynchronized (cCache) {\nchrono = cCache.get(zone);\nif (chrono == null) {\nchrono = new ISOChronology(ZonedChronology.getInstance(INSTANCE_UTC, zone));\ncCache.put(zone, chrono);\n}\n}\ncFastCache[index] = chrono;\nreturn chrono;\n}",
            "method_id": 21,
            "loc": 19
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)V",
            "method_body": "private void saveField(SavedField field) {\nSavedField[] savedFields = iSavedFields;\nint savedFieldsCount = iSavedFieldsCount;\n\nif (savedFieldsCount == savedFields.length || iSavedFieldsShared) {\n// Expand capacity or merely copy if saved fields are shared.\nSavedField[] newArray = new SavedField\n[savedFieldsCount == savedFields.length ? savedFieldsCount * 2 : savedFields.length];\nSystem.arraycopy(savedFields, 0, newArray, 0, savedFieldsCount);\niSavedFields = savedFields = newArray;\niSavedFieldsShared = false;\n}\n\niSavedState = null;\nsavedFields[savedFieldsCount] = field;\niSavedFieldsCount = savedFieldsCount + 1;\n}",
            "method_id": 22,
            "loc": 17
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadablePartial;Ljava/util/Locale;)V",
            "method_body": "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\nDateTimePrinter[] elements = iPrinters;\nif (elements == null) {\nthrow new UnsupportedOperationException();\n}\n\nif (locale == null) {\n// Guard against default locale changing concurrently.\nlocale = Locale.getDefault();\n}\n\nint len = elements.length;\nfor (int i=0; i<len; i++) {\nelements[i].printTo(buf, partial, locale);\n}\n}",
            "method_id": 23,
            "loc": 16
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfWeek(J)I",
            "method_body": "int getDayOfWeek(long instant) {\n// 1970-01-01 is day of week 4, Thursday.\n\nlong daysSince19700101;\nif (instant >= 0) {\ndaysSince19700101 = instant / DateTimeConstants.MILLIS_PER_DAY;\n} else {\ndaysSince19700101 = (instant - (DateTimeConstants.MILLIS_PER_DAY - 1))\n/ DateTimeConstants.MILLIS_PER_DAY;\nif (daysSince19700101 < -3) {\nreturn 7 + (int) ((daysSince19700101 + 4) % 7);\n}\n}\n\nreturn 1 + (int) ((daysSince19700101 + 3) % 7);\n}",
            "method_id": 24,
            "loc": 16
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:toFormatter()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public DateTimeFormatter toFormatter() {\nObject f = getFormatter();\nDateTimePrinter printer = null;\nif (isPrinter(f)) {\nprinter = (DateTimePrinter) f;\n}\nDateTimeParser parser = null;\nif (isParser(f)) {\nparser = (DateTimeParser) f;\n}\nif (printer != null || parser != null) {\nreturn new DateTimeFormatter(printer, parser);\n}\nthrow new UnsupportedOperationException(\"Both printing and parsing not supported\");\n}",
            "method_id": 25,
            "loc": 15
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;Ljava/util/Locale;ZLorg/joda/time/Chronology;Lorg/joda/time/DateTimeZone;Ljava/lang/Integer;I)V",
            "method_body": "private DateTimeFormatter(\nDateTimePrinter printer, DateTimeParser parser,\nLocale locale, boolean offsetParsed,\nChronology chrono, DateTimeZone zone,\nInteger pivotYear, int defaultYear) {\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = locale;\niOffsetParsed = offsetParsed;\niChrono = chrono;\niZone = zone;\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}",
            "method_id": 26,
            "loc": 15
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int month) {\nFieldUtils.verifyValueBounds(this, month, MIN, iMax);\n//\nint thisYear = iChronology.getYear(instant);\n//\nint thisDom = iChronology.getDayOfMonth(instant, thisYear);\nint maxDom = iChronology.getDaysInYearMonth(thisYear, month);\nif (thisDom > maxDom) {\n// Quietly force DOM to nearest sane value.\nthisDom = maxDom;\n}\n// Return newly calculated millis value\nreturn iChronology.getYearMonthDayMillis(thisYear, month, thisDom) +\niChronology.getMillisOfDay(instant);\n}",
            "method_id": 27,
            "loc": 15
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getFirstWeekOfYearMillis(I)J",
            "method_body": "long getFirstWeekOfYearMillis(int year) {\nlong jan1millis = getYearMillis(year);\nint jan1dayOfWeek = getDayOfWeek(jan1millis);\n\nif (jan1dayOfWeek > (8 - iMinDaysInFirstWeek)) {\n// First week is end of previous year because it doesn't have enough days.\nreturn jan1millis + (8 - jan1dayOfWeek)\n* (long)DateTimeConstants.MILLIS_PER_DAY;\n} else {\n// First week is start of this year because it has enough days.\nreturn jan1millis - (jan1dayOfWeek - 1)\n* (long)DateTimeConstants.MILLIS_PER_DAY;\n}\n}",
            "method_id": 28,
            "loc": 14
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology$CutoverField:roundFloor(J)J",
            "method_body": "public long roundFloor(long instant) {\nif (instant >= iCutover) {\ninstant = iGregorianField.roundFloor(instant);\nif (instant < iCutover) {\n// Only adjust if gap fully crossed.\nif (instant + iGapDuration < iCutover) {\ninstant = gregorianToJulian(instant);\n}\n}\n} else {\ninstant = iJulianField.roundFloor(instant);\n}\nreturn instant;\n}",
            "method_id": 29,
            "loc": 14
        },
        {
            "method_signature": "org.joda.time.LocalDate:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object partial) {\n// override to perform faster\nif (this == partial) {\nreturn true;\n}\nif (partial instanceof LocalDate) {\nLocalDate other = (LocalDate) partial;\nif (iChronology.equals(other.iChronology)) {\nreturn iLocalMillis == other.iLocalMillis;\n}\n}\nreturn super.equals(partial);\n}",
            "method_id": 30,
            "loc": 13
        },
        {
            "method_signature": "org.joda.time.field.BaseDurationField:compareTo(Lorg/joda/time/DurationField;)I",
            "method_body": "public int compareTo(DurationField otherField) {\nlong otherMillis = otherField.getUnitMillis();\nlong thisMillis = getUnitMillis();\n// cannot do (thisMillis - otherMillis) as can overflow\nif (thisMillis == otherMillis) {\nreturn 0;\n}\nif (thisMillis < otherMillis) {\nreturn -1;\n} else {\nreturn 1;\n}\n}",
            "method_id": 31,
            "loc": 13
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:sort([Lorg/joda/time/format/DateTimeParserBucket$SavedField;I)V",
            "method_body": "private static void sort(SavedField[] array, int high) {\nif (high > 10) {\nArrays.sort(array, 0, high);\n} else {\nfor (int i=0; i<high; i++) {\nfor (int j=i; j>0 && (array[j-1]).compareTo(array[j])>0; j--) {\nSavedField t = array[j];\narray[j] = array[j-1];\narray[j-1] = t;\n}\n}\n}\n}",
            "method_id": 32,
            "loc": 13
        },
        {
            "method_signature": "org.joda.time.base.AbstractInstant:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object readableInstant) {\n// must be to fulfil ReadableInstant contract\nif (this == readableInstant) {\nreturn true;\n}\nif (readableInstant instanceof ReadableInstant == false) {\nreturn false;\n}\nReadableInstant otherInstant = (ReadableInstant) readableInstant;\nreturn\ngetMillis() == otherInstant.getMillis() &&\nFieldUtils.equals(getChronology(), otherInstant.getChronology());\n}",
            "method_id": 33,
            "loc": 13
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:compareReverse(Lorg/joda/time/DurationField;Lorg/joda/time/DurationField;)I",
            "method_body": "static int compareReverse(DurationField a, DurationField b) {\nif (a == null || !a.isSupported()) {\nif (b == null || !b.isSupported()) {\nreturn 0;\n}\nreturn -1;\n}\nif (b == null || !b.isSupported()) {\nreturn 1;\n}\nreturn -a.compareTo(b);\n}",
            "method_id": 34,
            "loc": 12
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:setDefault(Lorg/joda/time/DateTimeZone;)V",
            "method_body": "public static void setDefault(DateTimeZone zone) throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nsm.checkPermission(new JodaTimePermission(\"DateTimeZone.setDefault\"));\n}\nif (zone == null) {\nthrow new IllegalArgumentException(\"The datetime zone must not be null\");\n}\nsynchronized(DateTimeZone.class) {\ncDefault = zone;\n}\n}",
            "method_id": 35,
            "loc": 12
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:parseInto(Lorg/joda/time/format/DateTimeParserBucket;Ljava/lang/String;I)I",
            "method_body": "public int parseInto(DateTimeParserBucket bucket, String text, int position) {\nDateTimeParser[] elements = iParsers;\nif (elements == null) {\nthrow new UnsupportedOperationException();\n}\n\nint len = elements.length;\nfor (int i=0; i<len && position >= 0; i++) {\nposition = elements[i].parseInto(bucket, text, position);\n}\nreturn position;\n}",
            "method_id": 36,
            "loc": 12
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDateTimeMillis(IIII)J",
            "method_body": "public long getDateTimeMillis(\nint year, int monthOfYear, int dayOfMonth, int millisOfDay)\nthrows IllegalArgumentException {\nChronology base;\nif ((base = getBase()) != null) {\nreturn base.getDateTimeMillis(year, monthOfYear, dayOfMonth, millisOfDay);\n}\n\nFieldUtils.verifyValueBounds\n(DateTimeFieldType.millisOfDay(), millisOfDay, 0, DateTimeConstants.MILLIS_PER_DAY);\nreturn getDateMidnightMillis(year, monthOfYear, dayOfMonth) + millisOfDay;\n}",
            "method_id": 37,
            "loc": 12
        },
        {
            "method_signature": "org.joda.time.LocalDate:isSupported(Lorg/joda/time/DateTimeFieldType;)Z",
            "method_body": "public boolean isSupported(DateTimeFieldType type) {\nif (type == null) {\nreturn false;\n}\nDurationFieldType durType = type.getDurationType();\nif (DATE_DURATION_TYPES.contains(durType) ||\ndurType.getField(getChronology()).getUnitMillis() >=\ngetChronology().days().getUnitMillis()) {\nreturn type.getField(getChronology()).isSupported();\n}\nreturn false;\n}",
            "method_id": 38,
            "loc": 12
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:<init>(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)V",
            "method_body": "public DateTimeFormatter(\nDateTimePrinter printer, DateTimeParser parser) {\nsuper();\niPrinter = printer;\niParser = parser;\niLocale = null;\niOffsetParsed = false;\niChrono = null;\niZone = null;\niPivotYear = null;\niDefaultYear = 2000;\n}",
            "method_id": 39,
            "loc": 12
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:<init>(JLorg/joda/time/Chronology;Ljava/util/Locale;Ljava/lang/Integer;I)V",
            "method_body": "public DateTimeParserBucket(long instantLocal, Chronology chrono,\nLocale locale, Integer pivotYear, int defaultYear) {\nsuper();\nchrono = DateTimeUtils.getChronology(chrono);\niMillis = instantLocal;\niChrono = chrono.withUTC();\niLocale = (locale == null ? Locale.getDefault() : locale);\nsetZone(chrono.getZone());\niPivotYear = pivotYear;\niDefaultYear = defaultYear;\n}",
            "method_id": 40,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getWeekyear(J)I",
            "method_body": "int getWeekyear(long instant) {\nint year = getYear(instant);\nint week = getWeekOfWeekyear(instant, year);\nif (week == 1) {\nreturn getYear(instant + DateTimeConstants.MILLIS_PER_WEEK);\n} else if (week > 51) {\nreturn getYear(instant - (2 * DateTimeConstants.MILLIS_PER_WEEK));\n} else {\nreturn year;\n}\n}",
            "method_id": 41,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:set(JZ)J",
            "method_body": "long set(long millis, boolean reset) {\nif (iText == null) {\nmillis = iField.set(millis, iValue);\n} else {\nmillis = iField.set(millis, iText, iLocale);\n}\nif (reset) {\nmillis = iField.roundFloor(millis);\n}\nreturn millis;\n}",
            "method_id": 42,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getWeekOfWeekyear(JI)I",
            "method_body": "int getWeekOfWeekyear(long instant, int year) {\nlong firstWeekMillis1 = getFirstWeekOfYearMillis(year);\nif (instant < firstWeekMillis1) {\nreturn getWeeksInYear(year - 1);\n}\nlong firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\nif (instant >= firstWeekMillis2) {\nreturn 1;\n}\nreturn (int) ((instant - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK) + 1;\n}",
            "method_id": 43,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.LocalDate:<init>(IIILorg/joda/time/Chronology;)V",
            "method_body": "public LocalDate(\nint year,\nint monthOfYear,\nint dayOfMonth,\nChronology chronology) {\nsuper();\nchronology = DateTimeUtils.getChronology(chronology).withUTC();\nlong instant = chronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, 0);\niChronology = chronology;\niLocalMillis = instant;\n}",
            "method_id": 44,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadablePartial;Ljava/util/Locale;)V",
            "method_body": "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\nif (partial.isSupported(iFieldType)) {\ntry {\nFormatUtils.appendPaddedInteger(buf, partial.get(iFieldType), iMinPrintedDigits);\n} catch (RuntimeException e) {\nappendUnknownString(buf, iMinPrintedDigits);\n}\n} else {\nappendUnknownString(buf, iMinPrintedDigits);\n}\n}",
            "method_id": 45,
            "loc": 11
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfMonth(J)I",
            "method_body": "abstract int getMonthOfYear(long millis, int year);\n\n/**\n* @param millis from 1970-01-01T00:00:00Z\n*/\nint getDayOfMonth(long millis) {\nint year = getYear(millis);\nint month = getMonthOfYear(millis, year);\nreturn getDayOfMonth(millis, year, month);\n}",
            "method_id": 46,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.chrono.BasicWeekyearDateTimeField:roundFloor(J)J",
            "method_body": "public long roundFloor(long instant) {\n// Note: This works fine, but it ideally shouldn't invoke other\n// fields from within a field.\ninstant = iChronology.weekOfWeekyear().roundFloor(instant);\nint wow = iChronology.getWeekOfWeekyear(instant);\nif (wow > 1) {\ninstant -= ((long) DateTimeConstants.MILLIS_PER_WEEK) * (wow - 1);\n}\nreturn instant;\n}",
            "method_id": 47,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.format.ISODateTimeFormat:yearMonthDay()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter yearMonthDay() {\nif (ymd == null) {\nymd = new DateTimeFormatterBuilder()\n.append(yearElement())\n.append(monthElement())\n.append(dayOfMonthElement())\n.toFormatter();\n}\nreturn ymd;\n}",
            "method_id": 48,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nint est = 1 + iMinFields << 1;\nif (iShowSeparators) {\nest += iMinFields - 1;\n}\nif (iZeroOffsetPrintText != null && iZeroOffsetPrintText.length() > est) {\nest = iZeroOffsetPrintText.length();\n}\nreturn est;\n}",
            "method_id": 49,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getMillisKeepLocal(Lorg/joda/time/DateTimeZone;J)J",
            "method_body": "public long getMillisKeepLocal(DateTimeZone newZone, long oldInstant) {\nif (newZone == null) {\nnewZone = DateTimeZone.getDefault();\n}\nif (newZone == this) {\nreturn oldInstant;\n}\nlong instantLocal = convertUTCToLocal(oldInstant);\nreturn newZone.convertLocalToUTC(instantLocal, false, oldInstant);\n}",
            "method_id": 50,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:selectChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "private Chronology selectChronology(Chronology chrono) {\nchrono = DateTimeUtils.getChronology(chrono);\nif (iChrono != null) {\nchrono = iChrono;\n}\nif (iZone != null) {\nchrono = chrono.withZone(iZone);\n}\nreturn chrono;\n}",
            "method_id": 51,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:compareTo(Lorg/joda/time/format/DateTimeParserBucket$SavedField;)I",
            "method_body": "public int compareTo(SavedField obj) {\nDateTimeField other = obj.iField;\nint result = compareReverse\n(iField.getRangeDurationField(), other.getRangeDurationField());\nif (result != 0) {\nreturn result;\n}\nreturn compareReverse\n(iField.getDurationField(), other.getDurationField());\n}",
            "method_id": 52,
            "loc": 10
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isPrinter(Ljava/lang/Object;)Z",
            "method_body": "private boolean isPrinter(Object f) {\nif (f instanceof DateTimePrinter) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isPrinter();\n}\nreturn true;\n}\nreturn false;\n}",
            "method_id": 53,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:isParser(Ljava/lang/Object;)Z",
            "method_body": "private boolean isParser(Object f) {\nif (f instanceof DateTimeParser) {\nif (f instanceof Composite) {\nreturn ((Composite)f).isParser();\n}\nreturn true;\n}\nreturn false;\n}",
            "method_id": 54,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology:withZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/Chronology;",
            "method_body": "public Chronology withZone(DateTimeZone zone) {\nif (zone == null) {\nzone = DateTimeZone.getDefault();\n}\nif (zone == getZone()) {\nreturn this;\n}\nreturn getInstance(zone, iCutoverInstant, getMinimumDaysInFirstWeek());\n}",
            "method_id": 55,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.LocalDate:get(Lorg/joda/time/DateTimeFieldType;)I",
            "method_body": "public int get(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nthrow new IllegalArgumentException(\"The DateTimeFieldType must not be null\");\n}\nif (isSupported(fieldType) == false) {\nthrow new IllegalArgumentException(\"Field '\" + fieldType + \"' is not supported\");\n}\nreturn fieldType.getField(getChronology()).get(getLocalMillis());\n}",
            "method_id": 56,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.format.ISODateTimeFormat:dateTimeNoMillis()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter dateTimeNoMillis() {\nif (dtx == null) {\ndtx = new DateTimeFormatterBuilder()\n.append(date())\n.append(tTimeNoMillis())\n.toFormatter();\n}\nreturn dtx;\n}",
            "method_id": 57,
            "loc": 9
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMillisOfDay(J)I",
            "method_body": "int getMillisOfDay(long instant) {\nif (instant >= 0) {\nreturn (int) (instant % DateTimeConstants.MILLIS_PER_DAY);\n} else {\nreturn (DateTimeConstants.MILLIS_PER_DAY - 1)\n+ (int) ((instant + 1) % DateTimeConstants.MILLIS_PER_DAY);\n}\n}",
            "method_id": 58,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:verifyValueBounds(Lorg/joda/time/DateTimeField;III)V",
            "method_body": "public static void verifyValueBounds(DateTimeField field,\nint value, int lowerBound, int upperBound) {\nif ((value < lowerBound) || (value > upperBound)) {\nthrow new IllegalFieldValueException\n(field.getType(), new Integer(value),\nnew Integer(lowerBound), new Integer(upperBound));\n}\n}",
            "method_id": 59,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getBase()Lorg/joda/time/Chronology;",
            "method_body": "protected abstract void assemble(Fields fields);\n\n/**\n* Returns the same base chronology as passed into the constructor.\n*/\nprotected final Chronology getBase() {\nreturn iBase;\n}",
            "method_id": 60,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.field.FieldUtils:verifyValueBounds(Lorg/joda/time/DateTimeFieldType;III)V",
            "method_body": "public static void verifyValueBounds(DateTimeFieldType fieldType,\nint value, int lowerBound, int upperBound) {\nif ((value < lowerBound) || (value > upperBound)) {\nthrow new IllegalFieldValueException\n(fieldType, new Integer(value),\nnew Integer(lowerBound), new Integer(upperBound));\n}\n}",
            "method_id": 61,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.LocalDate:<init>(JLorg/joda/time/Chronology;)V",
            "method_body": "public LocalDate(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\n\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\nchronology = chronology.withUTC();\niLocalMillis = chronology.dayOfMonth().roundFloor(localMillis);\niChronology = chronology;\n}",
            "method_id": 62,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:roundFloor(J)J",
            "method_body": "public long roundFloor(long instant) {\nif (instant >= 0) {\nreturn instant - instant % iUnitMillis;\n} else {\ninstant += 1;\nreturn instant - instant % iUnitMillis - iUnitMillis;\n}\n}",
            "method_id": 63,
            "loc": 8
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Ljava/lang/Object;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "private DateTimeFormatterBuilder append0(Object element) {\niFormatter = null;\n// Add the element as both a printer and parser.\niElementPairs.add(element);\niElementPairs.add(element);\nreturn this;\n}",
            "method_id": 64,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:requireParser()Lorg/joda/time/format/DateTimeParser;",
            "method_body": "private DateTimeParser requireParser() {\nDateTimeParser parser = iParser;\nif (parser == null) {\nthrow new UnsupportedOperationException(\"Parsing not supported\");\n}\nreturn parser;\n}",
            "method_id": 65,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadablePartial;)V",
            "method_body": "public void printTo(StringBuffer buf, ReadablePartial partial) {\nDateTimePrinter printer = requirePrinter();\nif (partial == null) {\nthrow new IllegalArgumentException(\"The partial must not be null\");\n}\nprinter.printTo(buf, partial, iLocale);\n}",
            "method_id": 66,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append0(Lorg/joda/time/format/DateTimePrinter;Lorg/joda/time/format/DateTimeParser;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "private DateTimeFormatterBuilder append0(\nDateTimePrinter printer, DateTimeParser parser) {\niFormatter = null;\niElementPairs.add(printer);\niElementPairs.add(parser);\nreturn this;\n}",
            "method_id": 67,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.LocalDateTime:<init>(JLorg/joda/time/Chronology;)V",
            "method_body": "public LocalDateTime(long instant, Chronology chronology) {\nchronology = DateTimeUtils.getChronology(chronology);\n\nlong localMillis = chronology.getZone().getMillisKeepLocal(DateTimeZone.UTC, instant);\niLocalMillis = localMillis;\niChronology = chronology.withUTC();\n}",
            "method_id": 68,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getDaysInYearMonth(II)I",
            "method_body": "int getDaysInYearMonth(int year, int month) {\nif (isLeapYear(year)) {\nreturn MAX_DAYS_PER_MONTH_ARRAY[month - 1];\n} else {\nreturn MIN_DAYS_PER_MONTH_ARRAY[month - 1];\n}\n}",
            "method_id": 69,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology$CutoverField:get(J)I",
            "method_body": "public int get(long instant) {\nif (instant >= iCutover) {\nreturn iGregorianField.get(instant);\n} else {\nreturn iJulianField.get(instant);\n}\n}",
            "method_id": 70,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.chrono.BasicGJChronology:getTotalMillisByYearMonth(II)J",
            "method_body": "long getTotalMillisByYearMonth(int year, int month) {\nif (isLeapYear(year)) {\nreturn MAX_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n} else {\nreturn MIN_TOTAL_MILLIS_BY_MONTH_ARRAY[month - 1];\n}\n}",
            "method_id": 71,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nChronology base;\nif ((base = getBase()) != null) {\nreturn base.getZone();\n}\nreturn DateTimeZone.UTC;\n}",
            "method_id": 72,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:addArrayToList(Ljava/util/List;[Ljava/lang/Object;)V",
            "method_body": "private void addArrayToList(List<Object> list, Object[] array) {\nif (array != null) {\nfor (int i=0; i<array.length; i++) {\nlist.add(array[i]);\n}\n}\n}",
            "method_id": 73,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:requirePrinter()Lorg/joda/time/format/DateTimePrinter;",
            "method_body": "private DateTimePrinter requirePrinter() {\nDateTimePrinter printer = iPrinter;\nif (printer == null) {\nthrow new UnsupportedOperationException(\"Printing not supported\");\n}\nreturn printer;\n}",
            "method_id": 74,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:withChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public DateTimeFormatter withChronology(Chronology chrono) {\nif (iChrono == chrono) {\nreturn this;\n}\nreturn new DateTimeFormatter(iPrinter, iParser, iLocale,\niOffsetParsed, chrono, iZone, iPivotYear, iDefaultYear);\n}",
            "method_id": 75,
            "loc": 7
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket$SavedField:<init>(Lorg/joda/time/DateTimeField;I)V",
            "method_body": "SavedField(DateTimeField field, int value) {\niField = field;\niValue = value;\niText = null;\niLocale = null;\n}",
            "method_id": 76,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getZone(Lorg/joda/time/DateTimeZone;)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static final DateTimeZone getZone(DateTimeZone zone) {\nif (zone == null) {\nreturn DateTimeZone.getDefault();\n}\nreturn zone;\n}",
            "method_id": 77,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:append(Lorg/joda/time/format/DateTimeFormatter;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder append(DateTimeFormatter formatter) {\nif (formatter == null) {\nthrow new IllegalArgumentException(\"No formatter supplied\");\n}\nreturn append0(formatter.getPrinter(), formatter.getParser());\n}",
            "method_id": 78,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:getChronology(Lorg/joda/time/Chronology;)Lorg/joda/time/Chronology;",
            "method_body": "public static final Chronology getChronology(Chronology chrono) {\nif (chrono == null) {\nreturn ISOChronology.getInstance();\n}\nreturn chrono;\n}",
            "method_id": 79,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendShortText(Lorg/joda/time/DateTimeFieldType;)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendShortText(DateTimeFieldType fieldType) {\nif (fieldType == null) {\nthrow new IllegalArgumentException(\"Field type must not be null\");\n}\nreturn append0(new TextField(fieldType, true));\n}",
            "method_id": 80,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:checkPermission()V",
            "method_body": "private static void checkPermission() throws SecurityException {\nSecurityManager sm = System.getSecurityManager();\nif (sm != null) {\nsm.checkPermission(new JodaTimePermission(\"CurrentTime.setProvider\"));\n}\n}",
            "method_id": 81,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDateMidnightMillis(III)J",
            "method_body": "long getDateMidnightMillis(int year, int monthOfYear, int dayOfMonth) {\nFieldUtils.verifyValueBounds(DateTimeFieldType.year(), year, getMinYear(), getMaxYear());\nFieldUtils.verifyValueBounds(DateTimeFieldType.monthOfYear(), monthOfYear, 1, getMaxMonth(year));\nFieldUtils.verifyValueBounds(DateTimeFieldType.dayOfMonth(), dayOfMonth, 1, getDaysInYearMonth(year, monthOfYear));\nreturn getYearMonthDayMillis(year, monthOfYear, dayOfMonth);\n}",
            "method_id": 82,
            "loc": 6
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfMonth(JII)I",
            "method_body": "int getDayOfMonth(long millis, int year, int month) {\nlong dateMillis = getYearMillis(year);\ndateMillis += getTotalMillisByYearMonth(year, month);\nreturn (int) ((millis - dateMillis) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n}",
            "method_id": 83,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:roundFloor(J)J",
            "method_body": "public long roundFloor(long instant) {\nint year = iChronology.getYear(instant);\nint month = iChronology.getMonthOfYear(instant, year);\nreturn iChronology.getYearMonthMillis(year, month);\n}",
            "method_id": 84,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:setZone(Lorg/joda/time/DateTimeZone;)V",
            "method_body": "public void setZone(DateTimeZone zone) {\niSavedState = null;\niZone = zone == DateTimeZone.UTC ? null : zone;\niOffset = 0;\n}",
            "method_id": 85,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:set(JI)J",
            "method_body": "public long set(long instant, int value) {\nFieldUtils.verifyValueBounds(this, value, getMinimumValue(),\ngetMaximumValueForSet(instant, value));\nreturn instant + (value - get(instant)) * iUnitMillis;\n}",
            "method_id": 86,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:print(Lorg/joda/time/ReadablePartial;)Ljava/lang/String;",
            "method_body": "public String print(ReadablePartial partial) {\nStringBuffer buf = new StringBuffer(requirePrinter().estimatePrintedLength());\nprintTo(buf, partial);\nreturn buf.toString();\n}",
            "method_id": 87,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getWeeksInYear(I)I",
            "method_body": "int getWeeksInYear(int year) {\nlong firstWeekMillis1 = getFirstWeekOfYearMillis(year);\nlong firstWeekMillis2 = getFirstWeekOfYearMillis(year + 1);\nreturn (int) ((firstWeekMillis2 - firstWeekMillis1) / DateTimeConstants.MILLIS_PER_WEEK);\n}",
            "method_id": 88,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYearMonthMillis(II)J",
            "method_body": "long getYearMonthMillis(int year, int month) {\nlong millis = getYearMillis(year);\nmillis += getTotalMillisByYearMonth(year, month);\nreturn millis;\n}",
            "method_id": 89,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:<init>(Lorg/joda/time/DateTimeFieldType;Z)V",
            "method_body": "TextField(DateTimeFieldType fieldType, boolean isShort) {\nsuper();\niFieldType = fieldType;\niShort = isShort;\n}",
            "method_id": 90,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYearMonthDayMillis(III)J",
            "method_body": "long getYearMonthDayMillis(int year, int month, int dayOfMonth) {\nlong millis = getYearMillis(year);\nmillis += getTotalMillisByYearMonth(year, month);\nreturn millis + (dayOfMonth - 1) * (long)DateTimeConstants.MILLIS_PER_DAY;\n}",
            "method_id": 91,
            "loc": 5
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:<init>()V",
            "method_body": "public DateTimeFormatterBuilder() {\nsuper();\niElementPairs = new ArrayList<Object>();\n}",
            "method_id": 92,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:<init>(C)V",
            "method_body": "CharacterLiteral(char value) {\nsuper();\niValue = value;\n}",
            "method_id": 93,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:forOffsetMillis(I)Lorg/joda/time/DateTimeZone;",
            "method_body": "public static DateTimeZone forOffsetMillis(int millisOffset) {\nString id = printOffset(millisOffset);\nreturn fixedOffsetZone(id, millisOffset);\n}",
            "method_id": 94,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfYear(JI)I",
            "method_body": "int getDayOfYear(long instant, int year) {\nlong yearStart = getYearMillis(year);\nreturn (int) ((instant - yearStart) / DateTimeConstants.MILLIS_PER_DAY) + 1;\n}",
            "method_id": 95,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nif ((base = iBase) != null) {\nreturn base.getZone();\n}",
            "method_id": 96,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField:roundFloor(J)J",
            "method_body": "public long roundFloor(long instant) {\nreturn super.roundFloor(instant + 3 * DateTimeConstants.MILLIS_PER_DAY)\n- 3 * DateTimeConstants.MILLIS_PER_DAY;\n}",
            "method_id": 97,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:setCurrentMillisSystem()V",
            "method_body": "public static final void setCurrentMillisSystem() throws SecurityException {\ncheckPermission();\ncMillisProvider = SYSTEM_MILLIS_PROVIDER;\n}",
            "method_id": 98,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getDayOfMonth(JI)I",
            "method_body": "int getDayOfMonth(long millis, int year) {\nint month = getMonthOfYear(millis, year);\nreturn getDayOfMonth(millis, year, month);\n}",
            "method_id": 99,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils:setCurrentMillisFixed(J)V",
            "method_body": "public static final void setCurrentMillisFixed(long fixedMillis) throws SecurityException {\ncheckPermission();\ncMillisProvider = new FixedMillisProvider(fixedMillis);\n}",
            "method_id": 100,
            "loc": 4
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology:getInstanceUTC()Lorg/joda/time/chrono/GJChronology;",
            "method_body": "public static GJChronology getInstanceUTC() {\nreturn getInstance(DateTimeZone.UTC, DEFAULT_CUTOVER, 4);\n}",
            "method_id": 101,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology:getMinimumDaysInFirstWeek()I",
            "method_body": "public int getMinimumDaysInFirstWeek() {\nreturn iGregorianChronology.getMinimumDaysInFirstWeek();\n}",
            "method_id": 102,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormat:forPattern(Ljava/lang/String;)Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter forPattern(String pattern) {\nreturn createFormatterForPattern(pattern);\n}",
            "method_id": 103,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendDayOfWeekShortText()Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendDayOfWeekShortText() {\nreturn appendShortText(DateTimeFieldType.dayOfWeek());\n}",
            "method_id": 104,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder:appendLiteral(C)Lorg/joda/time/format/DateTimeFormatterBuilder;",
            "method_body": "public DateTimeFormatterBuilder appendLiteral(char c) {\nreturn append0(new CharacterLiteral(c));\n}",
            "method_id": 105,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.base.BaseLocal:<init>()V",
            "method_body": "protected BaseLocal() {\nsuper();\n}",
            "method_id": 106,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.base.AbstractPartial:<init>()V",
            "method_body": "protected AbstractPartial() {\nsuper();\n}",
            "method_id": 107,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.ISOChronology:getInstance()Lorg/joda/time/chrono/ISOChronology;",
            "method_body": "public static ISOChronology getInstance() {\nreturn getInstance(DateTimeZone.getDefault());\n}",
            "method_id": 108,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:parseLocalDate(Ljava/lang/String;)Lorg/joda/time/LocalDate;",
            "method_body": "public LocalDate parseLocalDate(String text) {\nreturn parseLocalDateTime(text).toLocalDate();\n}",
            "method_id": 109,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.LocalDateTime:toLocalDate()Lorg/joda/time/LocalDate;",
            "method_body": "public LocalDate toLocalDate() {\nreturn new LocalDate(getLocalMillis(), getChronology());\n}",
            "method_id": 110,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.field.ImpreciseDateTimeField$LinkedDurationField:getUnitMillis()J",
            "method_body": "public long getUnitMillis() {\nreturn iUnitMillis;\n}",
            "method_id": 111,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology:withUTC()Lorg/joda/time/Chronology;",
            "method_body": "public Chronology withUTC() {\nreturn withZone(DateTimeZone.UTC);\n}",
            "method_id": 112,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.LocalDate:getLocalMillis()J",
            "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}",
            "method_id": 113,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:days()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType days() {\nreturn DAYS_TYPE;\n}",
            "method_id": 114,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nreturn iZone;\n}",
            "method_id": 115,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:getOffset()I",
            "method_body": "public int getOffset() {\nreturn iOffset;\n}",
            "method_id": 116,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.tz.FixedDateTimeZone:hashCode()I",
            "method_body": "public int hashCode() {\nreturn getID().hashCode() + 37 * iStandardOffset + 31 * iWallOffset;\n}",
            "method_id": 117,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:monthOfYear()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField monthOfYear() {\nreturn iMonthOfYear;\n}",
            "method_id": 118,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMaxMonth()I",
            "method_body": "int getMaxMonth() {\nreturn 12;\n}",
            "method_id": 119,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.ZonedChronology:getZone()Lorg/joda/time/DateTimeZone;",
            "method_body": "public DateTimeZone getZone() {\nreturn (DateTimeZone)getParam();\n}",
            "method_id": 120,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:getMaximumValue(J)I",
            "method_body": "public int getMaximumValue(long instant) {\nreturn getMaximumValue();\n}",
            "method_id": 121,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DurationFieldType:months()Lorg/joda/time/DurationFieldType;",
            "method_body": "public static DurationFieldType months() {\nreturn MONTHS_TYPE;\n}",
            "method_id": 122,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getMinYear()I",
            "method_body": "int getMinYear() {\nreturn MIN_YEAR;\n}",
            "method_id": 123,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology$CutoverField:getDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getDurationField() {\nreturn iDurationField;\n}",
            "method_id": 124,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:getParam()Ljava/lang/Object;",
            "method_body": "protected final Object getParam() {\nreturn iParam;\n}",
            "method_id": 125,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationField:getUnitMillis()J",
            "method_body": "public final long getUnitMillis() {\nreturn iUnitMillis;\n}",
            "method_id": 126,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.LocalDate:toString()Ljava/lang/String;",
            "method_body": "public String toString() {\nreturn ISODateTimeFormat.date().print(this);\n}",
            "method_id": 127,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$NumberFormatter:estimateParsedLength()I",
            "method_body": "public int estimateParsedLength() {\nreturn iMaxParsedDigits;\n}",
            "method_id": 128,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:estimateParsedLength()I",
            "method_body": "public int estimateParsedLength() {\nreturn estimatePrintedLength();\n}",
            "method_id": 129,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.LocalDateTime:getLocalMillis()J",
            "method_body": "protected long getLocalMillis() {\nreturn iLocalMillis;\n}",
            "method_id": 130,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:millisOfDay()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType millisOfDay() {\nreturn MILLIS_OF_DAY_TYPE;\n}",
            "method_id": 131,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:months()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField months() {\nreturn iMonths;\n}",
            "method_id": 132,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:monthOfYear()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType monthOfYear() {\nreturn MONTH_OF_YEAR_TYPE;\n}",
            "method_id": 133,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMonthOfYear(J)I",
            "method_body": "int getMonthOfYear(long millis) {\nreturn getMonthOfYear(millis, getYear(millis));\n}",
            "method_id": 134,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getMinimumDaysInFirstWeek()I",
            "method_body": "public int getMinimumDaysInFirstWeek() {\nreturn iMinDaysInFirstWeek;\n}",
            "method_id": 135,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getWeekOfWeekyear(instant);\n}",
            "method_id": 136,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:estimateParsedLength()I",
            "method_body": "public int estimateParsedLength() {\nreturn 1;\n}",
            "method_id": 137,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:dayOfMonth()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType dayOfMonth() {\nreturn DAY_OF_MONTH_TYPE;\n}",
            "method_id": 138,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField:getMinimumValue()I",
            "method_body": "public int getMinimumValue() {\nreturn DateTimeConstants.MONDAY;\n}",
            "method_id": 139,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:isLeapYear(I)Z",
            "method_body": "boolean isLeapYear(int year) {\nreturn ((year & 3) == 0) && ((year % 100) != 0 || (year % 400) == 0);\n}",
            "method_id": 140,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getAverageMillisPerYearDividedByTwo()J",
            "method_body": "long getAverageMillisPerYearDividedByTwo() {\nreturn MILLIS_PER_YEAR / 2;\n}",
            "method_id": 141,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:weekyear()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField weekyear() {\nreturn iWeekyear;\n}",
            "method_id": 142,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField:getMinimumValue()I",
            "method_body": "public int getMinimumValue() {\nreturn 1;\n}",
            "method_id": 143,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicMonthOfYearDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getMonthOfYear(instant);\n}",
            "method_id": 144,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:year()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField year() {\nreturn iYear;\n}",
            "method_id": 145,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.ISODateTimeFormat:date()Lorg/joda/time/format/DateTimeFormatter;",
            "method_body": "public static DateTimeFormatter date() {\nreturn yearMonthDay();\n}",
            "method_id": 146,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.field.DecoratedDurationField:getUnitMillis()J",
            "method_body": "public long getUnitMillis() {\nreturn iField.getUnitMillis();\n}",
            "method_id": 147,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.LocalDateTime:getChronology()Lorg/joda/time/Chronology;",
            "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}",
            "method_id": 148,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:getParser()Lorg/joda/time/format/DateTimeParser;",
            "method_body": "public DateTimeParser getParser() {\nreturn iParser;\n}",
            "method_id": 149,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getMaxYear()I",
            "method_body": "int getMaxYear() {\nreturn MAX_YEAR;\n}",
            "method_id": 150,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GregorianChronology:getApproxMillisAtEpochDividedByTwo()J",
            "method_body": "long getApproxMillisAtEpochDividedByTwo() {\nreturn (1970L * MILLIS_PER_YEAR) / 2;\n}",
            "method_id": 151,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isParser()Z",
            "method_body": "boolean isParser() {\nreturn iParsers != null;\n}",
            "method_id": 152,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.LocalDate:getChronology()Lorg/joda/time/Chronology;",
            "method_body": "public Chronology getChronology() {\nreturn iChronology;\n}",
            "method_id": 153,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType$StandardDateTimeFieldType:getDurationType()Lorg/joda/time/DurationFieldType;",
            "method_body": "public DurationFieldType getDurationType() {\nreturn iUnitType;\n}",
            "method_id": 154,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeParserBucket:saveField(Lorg/joda/time/DateTimeFieldType;I)V",
            "method_body": "public void saveField(DateTimeFieldType fieldType, int value) {\nsaveField(new SavedField(fieldType.getField(iChrono), value));\n}",
            "method_id": 155,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:weekOfWeekyear()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField weekOfWeekyear() {\nreturn iWeekOfWeekyear;\n}",
            "method_id": 156,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.field.PreciseDurationDateTimeField:getMaximumValueForSet(JI)I",
            "method_body": "protected int getMaximumValueForSet(long instant, int value) {\nreturn getMaximumValue(instant);\n}",
            "method_id": 157,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:dayOfWeek()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType dayOfWeek() {\nreturn DAY_OF_WEEK_TYPE;\n}",
            "method_id": 158,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getDayOfWeek(instant);\n}",
            "method_id": 159,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:days()Lorg/joda/time/DurationField;",
            "method_body": "public final DurationField days() {\nreturn iDays;\n}",
            "method_id": 160,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.field.BaseDateTimeField:isSupported()Z",
            "method_body": "public final boolean isSupported() {\nreturn true;\n}",
            "method_id": 161,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:dayOfWeek()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField dayOfWeek() {\nreturn iDayOfWeek;\n}",
            "method_id": 162,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicWeekOfWeekyearDateTimeField:getMaximumValueForSet(JI)I",
            "method_body": "protected int getMaximumValueForSet(long instant, int value) {\nreturn value > 52 ? getMaximumValue(instant) : 52;\n}",
            "method_id": 163,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:isPrinter()Z",
            "method_body": "boolean isPrinter() {\nreturn iPrinters != null;\n}",
            "method_id": 164,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology:getGregorianCutover()Lorg/joda/time/Instant;",
            "method_body": "public Instant getGregorianCutover() {\nreturn iCutoverInstant;\n}",
            "method_id": 165,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:printTo(Ljava/lang/StringBuffer;Lorg/joda/time/ReadablePartial;Ljava/util/Locale;)V",
            "method_body": "public void printTo(StringBuffer buf, ReadablePartial partial, Locale locale) {\nbuf.append(iValue);\n}",
            "method_id": 166,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicWeekyearDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getWeekyear(instant);\n}",
            "method_id": 167,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicDayOfMonthDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getDayOfMonth(instant);\n}",
            "method_id": 168,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GJDayOfWeekDateTimeField:getMaximumValue()I",
            "method_body": "public int getMaximumValue() {\nreturn DateTimeConstants.SUNDAY;\n}",
            "method_id": 169,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.Instant:getMillis()J",
            "method_body": "public long getMillis() {\nreturn iMillis;\n}",
            "method_id": 170,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.field.BaseDurationField:isSupported()Z",
            "method_body": "public final boolean isSupported() {\nreturn true;\n}",
            "method_id": 171,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeZone:getID()Ljava/lang/String;",
            "method_body": "public final String getID() {\nreturn iID;\n}",
            "method_id": 172,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.Instant:toInstant()Lorg/joda/time/Instant;",
            "method_body": "public Instant toInstant() {\nreturn this;\n}",
            "method_id": 173,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getWeekOfWeekyear(J)I",
            "method_body": "int getWeekOfWeekyear(long instant) {\nreturn getWeekOfWeekyear(instant, getYear(instant));\n}",
            "method_id": 174,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TimeZoneOffset:estimateParsedLength()I",
            "method_body": "public int estimateParsedLength() {\nreturn estimatePrintedLength();\n}",
            "method_id": 175,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$Composite:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nreturn iPrintedLengthEstimate;\n}",
            "method_id": 176,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeFieldType:year()Lorg/joda/time/DateTimeFieldType;",
            "method_body": "public static DateTimeFieldType year() {\nreturn YEAR_TYPE;\n}",
            "method_id": 177,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$PaddedNumber:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nreturn iMaxParsedDigits;\n}",
            "method_id": 178,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.DateTimeUtils$FixedMillisProvider:<init>(J)V",
            "method_body": "FixedMillisProvider(long fixedMillis) {\niMillis = fixedMillis;\n}",
            "method_id": 179,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology$CutoverField:getRangeDurationField()Lorg/joda/time/DurationField;",
            "method_body": "public DurationField getRangeDurationField() {\nreturn iRangeDurationField;\n}",
            "method_id": 180,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicChronology:getYearMillis(I)J",
            "method_body": "long getYearMillis(int year) {\nreturn getYearInfo(year).iFirstDayMillis;\n}",
            "method_id": 181,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.GJChronology:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object obj) {\nreturn super.equals(obj);\n}",
            "method_id": 182,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$TextField:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nreturn iShort ? 6 : 20;\n}",
            "method_id": 183,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.AssembledChronology:dayOfMonth()Lorg/joda/time/DateTimeField;",
            "method_body": "public final DateTimeField dayOfMonth() {\nreturn iDayOfMonth;\n}",
            "method_id": 184,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatterBuilder$CharacterLiteral:estimatePrintedLength()I",
            "method_body": "public int estimatePrintedLength() {\nreturn 1;\n}",
            "method_id": 185,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.format.DateTimeFormatter:getPrinter()Lorg/joda/time/format/DateTimePrinter;",
            "method_body": "public DateTimePrinter getPrinter() {\nreturn iPrinter;\n}",
            "method_id": 186,
            "loc": 3
        },
        {
            "method_signature": "org.joda.time.chrono.BasicYearDateTimeField:get(J)I",
            "method_body": "public int get(long instant) {\nreturn iChronology.getYear(instant);\n}",
            "method_id": 187,
            "loc": 3
        }
    ]
}