{
    "bug_id": 5,
    "test_id": 0,
    "test_name": "org.jsoup.parser.ParserTest.parsesQuiteRoughAttributes",
    "test_body": "@Test public void parsesQuiteRoughAttributes() {\nString html = \"<p =a>One<a =a\";\nDocument doc = Jsoup.parse(html);\nassertEquals(\"<p>One<a></a></p>\", doc.body().html());\ndoc = Jsoup.parse(\"<p .....\");\nassertEquals(\"<p></p>\", doc.body().html());\ndoc = Jsoup.parse(\"<p .....<p!!\");\nassertEquals(\"<p></p>\\n<p></p>\", doc.body().html());\n}\n",
    "stack_trace": "java.lang.StringIndexOutOfBoundsException: String index out of range: 14\nat java.lang.String.charAt(String.java:658)\nat org.jsoup.parser.TokenQueue.consume(TokenQueue.java:162)\nat org.jsoup.parser.Parser.parseAttribute(Parser.java:206)\nat org.jsoup.parser.Parser.parseStartTag(Parser.java:139)\nat org.jsoup.parser.Parser.parse(Parser.java:84)\nat org.jsoup.parser.Parser.parse(Parser.java:54)\nat org.jsoup.Jsoup.parse(Jsoup.java:41)\nat org.jsoup.parser.ParserTest.parsesQuiteRoughAttributes(ParserTest.java:45)",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.nodes.Attribute:createFromEncoded(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Attribute;",
            "method_body": "public static Attribute createFromEncoded(String unencodedKey, String encodedValue) {\nString value = Entities.unescape(encodedValue);\nreturn new Attribute(unencodedKey, value);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.jsoup.parser.Parser:parseAttribute()Lorg/jsoup/nodes/Attribute;",
            "method_body": "private Attribute parseAttribute() {\ntq.consumeWhitespace();\nString key = tq.consumeAttributeKey();\nString value = \"\";\ntq.consumeWhitespace();\nif (tq.matchChomp(\"=\")) {\ntq.consumeWhitespace();\n\nif (tq.matchChomp(SQ)) {\nvalue = tq.chompTo(SQ);\n} else if (tq.matchChomp(DQ)) {\nvalue = tq.chompTo(DQ);\n} else {\nStringBuilder valueAccum = new StringBuilder();\n// no ' or \" to look for, so scan to end tag or space (or end of stream)\nwhile (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.matchesWhitespace() && !tq.isEmpty()) {\nvalueAccum.append(tq.consume());\n}\nvalue = valueAccum.toString();\n}\ntq.consumeWhitespace();\n}\nif (key.length() != 0)\nreturn Attribute.createFromEncoded(key, value);\nelse {\ntq.consume();\n\nreturn null;\n}\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:consumeAttributeKey()Ljava/lang/String;",
            "method_body": "public String consumeAttributeKey() {\nint start = pos;\nwhile (!isEmpty() && (matchesWord() || matchesAny('-', '_', ':')))\npos++;\n\nreturn queue.substring(start, pos);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:consume()Ljava/lang/Character;",
            "method_body": "public Character consume() {\nCharacter c = queue.charAt(pos);\npos++;\nreturn c;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:put(Lorg/jsoup/nodes/Attribute;)V",
            "method_body": "public void put(Attribute attribute) {\nValidate.notNull(attribute);\nattributes.put(attribute.getKey(), attribute);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.jsoup.nodes.Attribute:<init>(Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "public Attribute(String key, String value) {\nValidate.notEmpty(key);\nValidate.notNull(value);\nthis.key = key.trim().toLowerCase();\nthis.value = value;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.jsoup.nodes.Attribute:getKey()Ljava/lang/String;",
            "method_body": "public String getKey() {\nreturn key;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.jsoup.Jsoup:parse(Ljava/lang/String;)Lorg/jsoup/nodes/Document;",
            "method_body": "public static Document parse(String html) {\nreturn Parser.parse(html, \"\");\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.jsoup.parser.Tag:getImplicitParent()Lorg/jsoup/parser/Tag;",
            "method_body": "Tag getImplicitParent() {\nreturn (!ancestors.isEmpty()) ? ancestors.get(0) : null;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.jsoup.parser.Parser:parse(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Document;",
            "method_body": "public static Document parse(String html, String baseUri) {\nParser parser = new Parser(html, baseUri, false);\nreturn parser.parse();\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.jsoup.parser.Parser:parseStartTag()V",
            "method_body": "private void parseStartTag() {\ntq.consume(\"<\");\nString tagName = tq.consumeTagName();\nValidate.notEmpty(tagName, \"Unexpectedly empty tagname. (This should not occur, please report!)\");\n\ntq.consumeWhitespace();\nAttributes attributes = new Attributes();\nwhile (!tq.matchesAny(\"<\", \"/>\", \">\") && !tq.isEmpty()) {\nAttribute attribute = parseAttribute();\nif (attribute != null)\nattributes.put(attribute);\n}\n\nTag tag = Tag.valueOf(tagName);\nElement child = new Element(tag, baseUri, attributes);\n\nboolean isEmptyElement = tag.isEmpty(); // empty element if empty tag (e.g. img) or self-closed el (<div/>\nif (tq.matchChomp(\"/>\")) { // close empty element or tag\nisEmptyElement = true;\nif (!tag.isKnownTag()) // if unknown and a self closed, allow it to be self closed on output. this doesn't force all instances to be empty\ntag.setSelfClosing();\n} else {\ntq.matchChomp(\">\");\n}\naddChildToParent(child, isEmptyElement);\n\n// pc data only tags (textarea, script): chomp to end tag, add content as text node\nif (tag.isData()) {\nString data = tq.chompToIgnoreCase(\"</\" + tagName);\ntq.chompTo(\">\");\npopStackToClose(tag);\n\nNode dataNode;\nif (tag.equals(titleTag) || tag.equals(textareaTag)) // want to show as text, but not contain inside tags (so not a data tag?)\ndataNode = TextNode.createFromEncoded(data, baseUri);\nelse\ndataNode = new DataNode(data, baseUri); // data not encoded but raw (for \" in script)\nchild.appendChild(dataNode);\n}\n\n// <base href>: update the base uri\nif (child.tagName().equals(\"base\")) {\nString href = child.absUrl(\"href\");\nif (href.length() != 0) { // ignore <base target> etc\nbaseUri = href;\ndoc.setBaseUri(href); // set on the doc so doc.createElement(Tag) will get updated base\n}\n}\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.jsoup.parser.Parser:addChildToParent(Lorg/jsoup/nodes/Element;Z)Lorg/jsoup/nodes/Element;",
            "method_body": "private Element addChildToParent(Element child, boolean isEmptyElement) {\nElement parent = popStackToSuitableContainer(child.tag());\nTag childTag = child.tag();\nboolean validAncestor = stackHasValidParent(childTag);\n\nif (!validAncestor && !relaxed) {\n// create implicit parent around this child\nTag parentTag = childTag.getImplicitParent();\nElement implicit = new Element(parentTag, baseUri);\n// special case: make sure there's a head before putting in body\nif (child.tag().equals(bodyTag)) {\nElement head = new Element(headTag, baseUri);\nimplicit.appendChild(head);\n}\nimplicit.appendChild(child);\n\n// recurse to ensure somewhere to put parent\nElement root = addChildToParent(implicit, false);\nif (!isEmptyElement)\nstack.addLast(child);\nreturn root;\n}\n\nparent.appendChild(child);\n\nif (!isEmptyElement)\nstack.addLast(child);\nreturn parent;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.jsoup.parser.Parser:stackHasValidParent(Lorg/jsoup/parser/Tag;)Z",
            "method_body": "private boolean stackHasValidParent(Tag childTag) {\nif (stack.size() == 1 && childTag.equals(htmlTag))\nreturn true; // root is valid for html node\n\nif (childTag.requiresSpecificParent())\nreturn stack.getLast().tag().isValidParent(childTag);\n\n// otherwise, look up the stack for valid ancestors\nfor (int i = stack.size() -1; i >= 0; i--) {\nElement el = stack.get(i);\nTag parent2 = el.tag();\nif (parent2.isValidAncestor(childTag)) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.jsoup.parser.Parser:popStackToSuitableContainer(Lorg/jsoup/parser/Tag;)Lorg/jsoup/nodes/Element;",
            "method_body": "private Element popStackToSuitableContainer(Tag tag) {\nwhile (!stack.isEmpty()) {\nif (last().tag().canContain(tag))\nreturn last();\nelse\nstack.removeLast();\n}\nreturn null;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.jsoup.parser.Tag:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn empty;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.jsoup.parser.Tag:isValidAncestor(Lorg/jsoup/parser/Tag;)Z",
            "method_body": "boolean isValidAncestor(Tag child) {\nif (child.ancestors.isEmpty())\nreturn true; // HTML tag\n\nfor (int i = 0; i < child.ancestors.size(); i++)\nif (this.equals(child.ancestors.get(i)))\nreturn true;\n\nreturn false;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notEmpty(Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "public static void notEmpty(String string, String msg) {\nif (string == null || string.length() == 0)\nthrow new IllegalArgumentException(msg);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchesAny([Ljava/lang/String;)Z",
            "method_body": "public boolean matchesAny(String... seq) {\nfor (String s : seq) {\nif (matches(s))\nreturn true;\n}\nreturn false;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchesAny([C)Z",
            "method_body": "public boolean matchesAny(char... seq) {\nif (isEmpty())\nreturn false;\n\nfor (char c: seq) {\nif (queue.charAt(pos) == c)\nreturn true;\n}\nreturn false;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchesWhitespace()Z",
            "method_body": "public boolean matchesWhitespace() {\nreturn !isEmpty() && Character.isWhitespace(queue.charAt(pos));\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchesWord()Z",
            "method_body": "public boolean matchesWord() {\nreturn !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:consume(Ljava/lang/String;)V",
            "method_body": "public void consume(String seq) {\nif (!matches(seq))\nthrow new IllegalStateException(\"Queue did not match expected sequence\");\nint len = seq.length();\nif (len > remainingLength())\nthrow new IllegalStateException(\"Queue not long enough to consume sequence\");\n\npos += len;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:consumeWhitespace()Z",
            "method_body": "public boolean consumeWhitespace() {\nboolean seen = false;\nwhile (matchesWhitespace()) {\npos++;\nseen = true;\n}\nreturn seen;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:consumeTagName()Ljava/lang/String;",
            "method_body": "public String consumeTagName() {\nint start = pos;\nwhile (!isEmpty() && (matchesWord() || matchesAny(':', '_', '-')))\npos++;\n\nreturn queue.substring(start, pos);\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.jsoup.nodes.Element:tag()Lorg/jsoup/parser/Tag;",
            "method_body": "public Tag tag() {\nreturn tag;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:unescape(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "static String unescape(String string) {\nif (!string.contains(\"&\"))\nreturn string;\n\nMatcher m = unescapePattern.matcher(string); // &(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+);?\nStringBuffer accum = new StringBuffer(string.length()); // pity matcher can't use stringbuilder, avoid syncs\n\nwhile (m.find()) {\nint charval = -1;\nString num = m.group(3);\nif (num != null) {\ntry {\nint base = m.group(2) != null ? 16 : 10; // 2 is hex indicator\ncharval = Integer.valueOf(num, base);\n} catch (NumberFormatException e) {\n} // skip\n} else {\nString name = m.group(1);\nif (full.containsKey(name))\ncharval = full.get(name);\n}\n\nif (charval != -1 || charval > 0xFFFF) { // out of range\nString c = Character.toString((char) charval);\nm.appendReplacement(accum, c);\n} else {\nm.appendReplacement(accum, m.group(0)); // replace with original string\n}\n}\nm.appendTail(accum);\nreturn accum.toString();\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.jsoup.parser.Parser:last()Lorg/jsoup/nodes/Element;",
            "method_body": "private Element last() {\nreturn stack.getLast();\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchesStartTag()Z",
            "method_body": "public boolean matchesStartTag() {\n// micro opt for matching \"<x\"\nreturn (remainingLength() >= 2 && queue.charAt(pos) == '<' && Character.isLetterOrDigit(queue.charAt(pos+1)));\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchChomp(Ljava/lang/String;)Z",
            "method_body": "public boolean matchChomp(String seq) {\nif (matches(seq)) {\npos += seq.length();\nreturn true;\n} else {\nreturn false;\n}\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.jsoup.nodes.Element:tagName()Ljava/lang/String;",
            "method_body": "public String tagName() {\nreturn tag.getName();\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:<clinit>()V",
            "method_body": "private static final Object[][] baseArray = {\n{\"AElig\", 0x000C6},\n{\"AMP\", 0x00026},\n{\"Aacute\", 0x000C1},\n{\"Acirc\", 0x000C2},\n{\"Agrave\", 0x000C0},\n{\"Aring\", 0x000C5},\n{\"Atilde\", 0x000C3},\n{\"Auml\", 0x000C4},\n{\"COPY\", 0x000A9},\n{\"Ccedil\", 0x000C7},\n{\"ETH\", 0x000D0},\n{\"Eacute\", 0x000C9},\n{\"Ecirc\", 0x000CA},\n{\"Egrave\", 0x000C8},\n{\"Euml\", 0x000CB},\n{\"GT\", 0x0003E},\n{\"Iacute\", 0x000CD},\n{\"Icirc\", 0x000CE},\n{\"Igrave\", 0x000CC},\n{\"Iuml\", 0x000CF},\n{\"LT\", 0x0003C},\n{\"Ntilde\", 0x000D1},\n{\"Oacute\", 0x000D3},\n{\"Ocirc\", 0x000D4},\n{\"Ograve\", 0x000D2},\n{\"Oslash\", 0x000D8},\n{\"Otilde\", 0x000D5},\n{\"Ouml\", 0x000D6},\n{\"QUOT\", 0x00022},\n{\"REG\", 0x000AE},\n{\"THORN\", 0x000DE},\n{\"Uacute\", 0x000DA},\n{\"Ucirc\", 0x000DB},\n{\"Ugrave\", 0x000D9},\n{\"Uuml\", 0x000DC},\n{\"Yacute\", 0x000DD},\n{\"aacute\", 0x000E1},\n{\"acirc\", 0x000E2},\n{\"acute\", 0x000B4},\n{\"aelig\", 0x000E6},\n{\"agrave\", 0x000E0},\n{\"amp\", 0x00026},\n{\"aring\", 0x000E5},\n{\"atilde\", 0x000E3},\n{\"auml\", 0x000E4},\n{\"brvbar\", 0x000A6},\n{\"ccedil\", 0x000E7},\n{\"cedil\", 0x000B8},\n{\"cent\", 0x000A2},\n{\"copy\", 0x000A9},\n{\"curren\", 0x000A4},\n{\"deg\", 0x000B0},\n{\"divide\", 0x000F7},\n{\"eacute\", 0x000E9},\n{\"ecirc\", 0x000EA},\n{\"egrave\", 0x000E8},\n{\"eth\", 0x000F0},\n{\"euml\", 0x000EB},\n{\"frac12\", 0x000BD},\n{\"frac14\", 0x000BC},\n{\"frac34\", 0x000BE},\n{\"gt\", 0x0003E},\n{\"iacute\", 0x000ED},\n{\"icirc\", 0x000EE},\n{\"iexcl\", 0x000A1},\n{\"igrave\", 0x000EC},\n{\"iquest\", 0x000BF},\n{\"iuml\", 0x000EF},\n{\"laquo\", 0x000AB},\n{\"lt\", 0x0003C},\n{\"macr\", 0x000AF},\n{\"micro\", 0x000B5},\n{\"middot\", 0x000B7},\n{\"nbsp\", 0x000A0},\n{\"not\", 0x000AC},\n{\"ntilde\", 0x000F1},\n{\"oacute\", 0x000F3},\n{\"ocirc\", 0x000F4},\n{\"ograve\", 0x000F2},\n{\"ordf\", 0x000AA},\n{\"ordm\", 0x000BA},\n{\"oslash\", 0x000F8},\n{\"otilde\", 0x000F5},\n{\"ouml\", 0x000F6},\n{\"para\", 0x000B6},\n{\"plusmn\", 0x000B1},\n{\"pound\", 0x000A3},\n{\"quot\", 0x00022},\n{\"raquo\", 0x000BB},\n{\"reg\", 0x000AE},\n{\"sect\", 0x000A7},\n{\"shy\", 0x000AD},\n{\"sup1\", 0x000B9},\n{\"sup2\", 0x000B2},\n{\"sup3\", 0x000B3},\n{\"szlig\", 0x000DF},\n{\"thorn\", 0x000FE},\n{\"times\", 0x000D7},\n{\"uacute\", 0x000FA},\n{\"ucirc\", 0x000FB},\n{\"ugrave\", 0x000F9},\n{\"uml\", 0x000A8},\n{\"uuml\", 0x000FC},\n{\"yacute\", 0x000FD},\n{\"yen\", 0x000A5},\n{\"yuml\", 0x000FF}\n};",
            "method_id": 30
        },
        {
            "method_signature": "org.jsoup.parser.Parser:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
            "method_body": "private Parser(String html, String baseUri, boolean isBodyFragment) {\nValidate.notNull(html);\nValidate.notNull(baseUri);\n\nstack = new LinkedList<Element>();\ntq = new TokenQueue(html);\nthis.baseUri = baseUri;\n\nif (isBodyFragment) {\ndoc = Document.createShell(baseUri);\nstack.add(doc.body());\n} else {\ndoc = new Document(baseUri);\nstack.add(doc);\n}\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.jsoup.parser.Parser:<clinit>()V",
            "method_body": "private static final String SQ = \"'\";\nprivate static final String DQ = \"\\\"\";\n\nprivate static final Tag htmlTag = Tag.valueOf(\"html\");\nprivate static final Tag headTag = Tag.valueOf(\"head\");\nprivate static final Tag bodyTag = Tag.valueOf(\"body\");\nprivate static final Tag titleTag = Tag.valueOf(\"title\");\nprivate static final Tag textareaTag = Tag.valueOf(\"textarea\");\n\nprivate final LinkedList<Element> stack;\nprivate final TokenQueue tq;\nprivate final Document doc;\nprivate String baseUri;\nprivate boolean relaxed = false;\n\nprivate Parser(String html, String baseUri, boolean isBodyFragment) {\nValidate.notNull(html);\nValidate.notNull(baseUri);\n\nstack = new LinkedList<Element>();\ntq = new TokenQueue(html);\nthis.baseUri = baseUri;\n\nif (isBodyFragment) {\ndoc = Document.createShell(baseUri);\nstack.add(doc.body());\n} else {\ndoc = new Document(baseUri);\nstack.add(doc);\n}\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.jsoup.parser.Parser:parse()Lorg/jsoup/nodes/Document;",
            "method_body": "private Document parse() {\nwhile (!tq.isEmpty()) {\nif (tq.matchesStartTag()) {\nparseStartTag();\n} else if (tq.matchesCS(\"</\")) {\nparseEndTag();\n} else if (tq.matchesCS(\"<!--\")) {\nparseComment();\n} else if (tq.matches(\"<![CDATA[\")) {\nparseCdata();\n} else if (tq.matchesCS(\"<?\") || tq.matchesCS(\"<!\")) {\nparseXmlDecl();\n} else {\nparseTextNode();\n}\n}\nreturn doc.normalise();\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.jsoup.parser.Tag:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn tagName;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matches(Ljava/lang/String;)Z",
            "method_body": "public boolean matches(String seq) {\nint count = seq.length();\nif (count > remainingLength())\nreturn false;\n\nwhile (--count >= 0) {\nif (Character.toLowerCase(seq.charAt(count)) != Character.toLowerCase(queue.charAt(pos+count)))\nreturn false;\n}\nreturn true;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.jsoup.nodes.Node:setParentNode(Lorg/jsoup/nodes/Node;)V",
            "method_body": "protected void setParentNode(Node parentNode) {\nif (this.parentNode != null)\nthis.parentNode.removeChild(this);\nthis.parentNode = parentNode;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.jsoup.nodes.Node:addChildren([Lorg/jsoup/nodes/Node;)V",
            "method_body": "protected void addChildren(Node... children) {\n//most used. short circuit addChildren(int), which hits reindex children and array copy\nfor (Node child: children) {\nreparentChild(child);\nchildNodes.add(child);\nchild.setSiblingIndex(childNodes.size()-1);\n}\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.jsoup.nodes.Node:reparentChild(Lorg/jsoup/nodes/Node;)V",
            "method_body": "private void reparentChild(Node child) {\nif (child.parentNode != null)\nchild.parentNode.removeChild(child);\nchild.setParentNode(this);\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.jsoup.nodes.Node:setSiblingIndex(I)V",
            "method_body": "protected void setSiblingIndex(int siblingIndex) {\nthis.siblingIndex = siblingIndex;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<init>(Lorg/jsoup/parser/Tag;Ljava/lang/String;)V",
            "method_body": "public Element(Tag tag, String baseUri) {\nthis(tag, baseUri, new Attributes());\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.jsoup.nodes.Element:appendChild(Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Element;",
            "method_body": "public Element appendChild(Node child) {\nValidate.notNull(child);\n\naddChildren(child);\nreturn this;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.jsoup.nodes.Document:<init>(Ljava/lang/String;)V",
            "method_body": "private OutputSettings outputSettings = new OutputSettings();\n\n/**\nCreate a new, empty Document.\n@param baseUri base URI of document\n@see org.jsoup.Jsoup#parse\n@see #createShell\n*/\npublic Document(String baseUri) {\nsuper(Tag.valueOf(\"#root\"), baseUri);\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:<init>(Lorg/jsoup/nodes/Document;)V",
            "method_body": "private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;\nprivate Charset charset = Charset.forName(\"UTF-8\");\nprivate CharsetEncoder charsetEncoder = charset.newEncoder();\n\npublic OutputSettings() {}",
            "method_id": 43
        },
        {
            "method_signature": "org.jsoup.nodes.Node:<init>(Ljava/lang/String;Lorg/jsoup/nodes/Attributes;)V",
            "method_body": "protected Node(String baseUri, Attributes attributes) {\nValidate.notNull(baseUri);\nValidate.notNull(attributes);\n\nchildNodes = new ArrayList<Node>(4);\nthis.baseUri = baseUri.trim();\nthis.attributes = attributes;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<init>(Lorg/jsoup/parser/Tag;Ljava/lang/String;Lorg/jsoup/nodes/Attributes;)V",
            "method_body": "public Element(Tag tag, String baseUri, Attributes attributes) {\nsuper(baseUri, attributes);\n\nValidate.notNull(tag);\nthis.tag = tag;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:<init>()V",
            "method_body": "protected static final String dataPrefix = \"data-\";\n\nprivate LinkedHashMap<String, Attribute> attributes = new LinkedHashMap<String, Attribute>(2);\n// linked hash map to preserve insertion order.\n\n/**\nGet an attribute value by key.\n@param key the attribute key\n@return the attribute value if set; or empty string if not set.\n@see #hasKey(String)\n*/\npublic String get(String key) {\nValidate.notEmpty(key);\n\nAttribute attr = attributes.get(key.toLowerCase());\nreturn attr != null ? attr.getValue() : \"\";\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.jsoup.parser.Tag:isData()Z",
            "method_body": "public boolean isData() {\nreturn !canContainInline && !isEmpty();\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.jsoup.parser.Tag:requiresSpecificParent()Z",
            "method_body": "boolean requiresSpecificParent() {\nreturn directDescendant;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.jsoup.parser.Tag:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object o) {\nif (this == o) return true;\nif (o == null || getClass() != o.getClass()) return false;\n\nTag tag = (Tag) o;\n\nif (tagName != null ? !tagName.equals(tag.tagName) : tag.tagName != null) return false;\n\nreturn true;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.jsoup.parser.Tag:canContain(Lorg/jsoup/parser/Tag;)Z",
            "method_body": "boolean canContain(Tag child) {\nValidate.notNull(child);\n\nif (child.isBlock && !this.canContainBlock)\nreturn false;\n\nif (!child.isBlock && !this.canContainInline) // not block == inline\nreturn false;\n\nif (this.optionalClosing && this.equals(child))\nreturn false;\n\nif (this.empty || this.isData())\nreturn false;\n\n// don't allow children to contain their parent (directly)\nif (this.requiresSpecificParent() && this.getImplicitParent().equals(child))\nreturn false;\n\n// confirm limited children\nif (limitChildren) {\nfor (Tag childParent : child.ancestors) {\nif (childParent.equals(this))\nreturn true;\n}\nreturn false;\n}\n\n// exclude children\nif (!excludes.isEmpty()) {\nfor (Tag excluded: excludes) {\nif (child.equals(excluded))\nreturn false;\n}\n}\n\nreturn true;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:<init>(Ljava/lang/String;)V",
            "method_body": "private String queue;\nprivate int pos = 0;\n\nprivate static final Character ESC = '\\\\'; // escape char for chomp balanced.\n\n/**\nCreate a new TokenQueue.\n@param data string of data to back queue.\n*/\npublic TokenQueue(String data) {\nValidate.notNull(data);\nqueue = data;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn remainingLength() == 0;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:remainingLength()I",
            "method_body": "private int remainingLength() {\nreturn queue.length() - pos;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:<clinit>()V",
            "method_body": "private String queue;\nprivate int pos = 0;\n\nprivate static final Character ESC = '\\\\'; // escape char for chomp balanced.\n\n/**\nCreate a new TokenQueue.\n@param data string of data to back queue.\n*/\npublic TokenQueue(String data) {\nValidate.notNull(data);\nqueue = data;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.jsoup.parser.Tag:<init>(Ljava/lang/String;)V",
            "method_body": "private String tagName;\nprivate boolean knownTag = false; // if pre-defined or auto-created\nprivate boolean isBlock = true; // block or inline\nprivate boolean canContainBlock = true; // Can this tag hold block level tags?\nprivate boolean canContainInline = true; // only pcdata if not\nprivate boolean optionalClosing = false; // If tag is open, and another seen, close previous tag\nprivate boolean empty = false; // can hold nothing; e.g. img\nprivate boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.\nprivate boolean preserveWhitespace = false; // for pre, textarea, script etc\nprivate List<Tag> ancestors; // elements must be a descendant of one of these ancestors\nprivate List<Tag> excludes = Collections.emptyList(); // cannot contain these tags\nprivate boolean directDescendant; // if true, must directly descend from one of the ancestors\nprivate boolean limitChildren; // if true, only contain children that've registered parents\n\nprivate Tag(String tagName) {\nthis.tagName = tagName.toLowerCase();\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.jsoup.parser.Tag:valueOf(Ljava/lang/String;)Lorg/jsoup/parser/Tag;",
            "method_body": "public static Tag valueOf(String tagName) {\nValidate.notNull(tagName);\ntagName = tagName.trim().toLowerCase();\nValidate.notEmpty(tagName);\n\nsynchronized (tags) {\nTag tag = tags.get(tagName);\nif (tag == null) {\n// not defined: create default; go anywhere, do anything! (incl be inside a <p>)\ntag = new Tag(tagName);\ntag.setAncestor(defaultAncestor.tagName);\ntag.setExcludes();\ntag.isBlock = false;\ntag.canContainBlock = true;\n}\nreturn tag;\n}\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.jsoup.parser.Tag:createBlock(Ljava/lang/String;)Lorg/jsoup/parser/Tag;",
            "method_body": "private static Tag createBlock(String tagName) {\nreturn register(new Tag(tagName));\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.jsoup.parser.Tag:createInline(Ljava/lang/String;)Lorg/jsoup/parser/Tag;",
            "method_body": "private static Tag createInline(String tagName) {\nTag inline = new Tag(tagName);\ninline.isBlock = false;\ninline.canContainBlock = false;\nreturn register(inline);\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.jsoup.parser.Tag:register(Lorg/jsoup/parser/Tag;)Lorg/jsoup/parser/Tag;",
            "method_body": "private static Tag register(Tag tag) {\ntag.setAncestor(defaultAncestor.tagName);\ntag.setKnownTag();\nsynchronized (tags) {\ntags.put(tag.tagName, tag);\n}\nreturn tag;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.jsoup.parser.Tag:setContainInlineOnly()Lorg/jsoup/parser/Tag;",
            "method_body": "private Tag setContainInlineOnly() {\ncanContainBlock = false;\ncanContainInline = true;\nreturn this;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.jsoup.parser.Tag:setContainDataOnly()Lorg/jsoup/parser/Tag;",
            "method_body": "private Tag setContainDataOnly() {\ncanContainBlock = false;\ncanContainInline = false;\npreserveWhitespace = true;\nreturn this;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.jsoup.parser.Tag:setEmpty()Lorg/jsoup/parser/Tag;",
            "method_body": "private Tag setEmpty() {\ncanContainBlock = false;\ncanContainInline = false;\nempty = true;\nreturn this;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.jsoup.parser.Tag:setOptionalClosing()Lorg/jsoup/parser/Tag;",
            "method_body": "private Tag setOptionalClosing() {\noptionalClosing = true;\nreturn this;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.jsoup.parser.Tag:setPreserveWhitespace()Lorg/jsoup/parser/Tag;",
            "method_body": "private Tag setPreserveWhitespace() {\npreserveWhitespace = true;\nreturn this;\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.jsoup.parser.Tag:setAncestor([Ljava/lang/String;)Lorg/jsoup/parser/Tag;",
            "method_body": "private Tag setAncestor(String... tagNames) {\nif (tagNames == null || tagNames.length == 0) {\nancestors = Collections.emptyList();\n} else {\nancestors = new ArrayList<Tag>(tagNames.length);\nfor (String name : tagNames) {\nancestors.add(Tag.valueOf(name));\n}\n}\nreturn this;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.jsoup.parser.Tag:setExcludes([Ljava/lang/String;)Lorg/jsoup/parser/Tag;",
            "method_body": "private Tag setExcludes(String... tagNames) {\nif (tagNames == null || tagNames.length == 0) {\nexcludes = Collections.emptyList();\n} else {\nexcludes = new ArrayList<Tag>(tagNames.length);\nfor (String name : tagNames) {\nexcludes.add(Tag.valueOf(name));\n}\n}\nreturn this;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.jsoup.parser.Tag:setParent([Ljava/lang/String;)Lorg/jsoup/parser/Tag;",
            "method_body": "private Tag setParent(String... tagNames) {\ndirectDescendant = true;\nsetAncestor(tagNames);\nreturn this;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.jsoup.parser.Tag:setLimitChildren()Lorg/jsoup/parser/Tag;",
            "method_body": "private Tag setLimitChildren() {\nlimitChildren = true;\nreturn this;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.jsoup.parser.Tag:setKnownTag()Lorg/jsoup/parser/Tag;",
            "method_body": "private Tag setKnownTag() {\nknownTag = true;\nreturn this;\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notEmpty(Ljava/lang/String;)V",
            "method_body": "public static void notEmpty(String string) {\nif (string == null || string.length() == 0)\nthrow new IllegalArgumentException(\"String must not be empty\");\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notNull(Ljava/lang/Object;)V",
            "method_body": "public static void notNull(Object obj) {\nif (obj == null)\nthrow new IllegalArgumentException(\"Object must not be null\");\n}",
            "method_id": 71
        }
    ]
}