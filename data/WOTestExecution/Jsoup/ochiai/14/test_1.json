{
    "bug_id": 14,
    "test_id": 1,
    "test_name": "org.jsoup.parser.ParserTest.handlesUnclosedTitle",
    "test_body": "@Test public void handlesUnclosedTitle() {\nDocument one = Jsoup.parse(\"<title>One <b>Two <b>Three</TITLE><p>Test</p>\"); // has title, so <b> is plain text\nassertEquals(\"One <b>Two <b>Three\", one.title());\nassertEquals(\"Test\", one.select(\"p\").first().text());\nDocument two = Jsoup.parse(\"<title>One<b>Two <p>Test</p>\"); // no title, so <b> causes </title> breakout\nassertEquals(\"One\", two.title());\nassertEquals(\"<b>Two <p>Test</p></b>\", two.body().html());\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<One[]> but was:<One[<b>Two <p>Test</p]>\nat org.junit.Assert.assertEquals(Assert.java:115)\nat org.junit.Assert.assertEquals(Assert.java:144)\nat org.jsoup.parser.ParserTest.handlesUnclosedTitle(ParserTest.java:560)",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.parser.TokeniserState$13:anythingElse(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "private void anythingElse(Tokeniser t, CharacterReader r) {\nt.emit(\"</\" + t.dataBuffer.toString());\nt.transition(Rcdata);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$11:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.matches('/')) {\nt.createTempBuffer();\nt.advanceTransition(RCDATAEndTagOpen);\n// diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n// consuming to EOF; break out here\n} else {\nt.emit(\"<\");\nt.transition(Rcdata);\n}\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$3:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\ncase '&':\nt.advanceTransition(CharacterReferenceInRcdata);\nbreak;\ncase '<':\nt.advanceTransition(RcdataLessthanSign);\nbreak;\ncase nullChar:\nt.error(this);\nr.advance();\nt.emit(replacementChar);\nbreak;\ncase eof:\nt.emit(new Token.EOF());\nbreak;\ndefault:\nString data = r.consumeToAny('&', '<', nullChar);\nt.emit(data);\nbreak;\n}\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$8:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (t.isCharacter()) {\ntb.insert(t.asCharacter());\n} else if (t.isEOF()) {\ntb.error(this);\n// if current node is script: already started\ntb.pop();\ntb.transition(tb.originalState());\nreturn tb.process(t);\n} else if (t.isEndTag()) {\n// if: An end tag whose tag name is \"script\" -- scripting nesting level, if evaluating scripts\ntb.pop();\ntb.transition(tb.originalState());\n}\nreturn true;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:markInsertionMode()V",
            "method_body": "void markInsertionMode() {\noriginalState = state;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:originalState()Lorg/jsoup/parser/TreeBuilderState;",
            "method_body": "TreeBuilderState originalState() {\nreturn originalState;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.jsoup.nodes.Document:title()Ljava/lang/String;",
            "method_body": "public String title() {\nElement titleEl = getElementsByTag(\"title\").first();\nreturn titleEl != null ? titleEl.text().trim() : \"\";\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matches(C)Z",
            "method_body": "boolean matches(char c) {\nreturn !isEmpty() && input.charAt(pos) == c;\n\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.jsoup.parser.Token:isEOF()Z",
            "method_body": "boolean isEOF() {\nreturn type == TokenType.EOF;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:error(Lorg/jsoup/parser/TreeBuilderState;)V",
            "method_body": "void error(TreeBuilderState state) {\nif (trackErrors)\nerrors.add(new ParseError(\"Unexpected token\", state, currentToken, reader.pos()));\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:lastCharIsWhitespace(Ljava/lang/StringBuilder;)Z",
            "method_body": "static boolean lastCharIsWhitespace(StringBuilder sb) {\nreturn sb.length() != 0 && sb.charAt(sb.length() - 1) == ' ';\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.jsoup.nodes.Element:text()Ljava/lang/String;",
            "method_body": "public String text() {\nStringBuilder sb = new StringBuilder();\ntext(sb);\nreturn sb.toString().trim();\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.jsoup.nodes.Element:text(Ljava/lang/StringBuilder;)V",
            "method_body": "private void text(StringBuilder accum) {\nappendWhitespaceIfBr(this, accum);\n\nfor (Node child : childNodes) {\nif (child instanceof TextNode) {\nTextNode textNode = (TextNode) child;\nappendNormalisedText(accum, textNode);\n} else if (child instanceof Element) {\nElement element = (Element) child;\nif (accum.length() > 0 && element.isBlock() && !TextNode.lastCharIsWhitespace(accum))\naccum.append(\" \");\nelement.text(accum);\n}\n}\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.jsoup.nodes.Element:appendNormalisedText(Ljava/lang/StringBuilder;Lorg/jsoup/nodes/TextNode;)V",
            "method_body": "private void appendNormalisedText(StringBuilder accum, TextNode textNode) {\nString text = textNode.getWholeText();\n\nif (!preserveWhitespace()) {\ntext = TextNode.normaliseWhitespace(text);\nif (TextNode.lastCharIsWhitespace(accum))\ntext = TextNode.stripLeadingWhitespace(text);\n}\naccum.append(text);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.jsoup.nodes.Element:appendWhitespaceIfBr(Lorg/jsoup/nodes/Element;Ljava/lang/StringBuilder;)V",
            "method_body": "private static void appendWhitespaceIfBr(Element element, StringBuilder accum) {\nif (element.tag.getName().equals(\"br\") && !TextNode.lastCharIsWhitespace(accum))\naccum.append(\" \");\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState:handleRcData(Lorg/jsoup/parser/Token$StartTag;Lorg/jsoup/parser/TreeBuilder;)V",
            "method_body": "private static void handleRcData(Token.StartTag startTag, TreeBuilder tb) {\ntb.insert(startTag);\ntb.tokeniser.transition(TokeniserState.Rcdata);\ntb.markInsertionMode();\ntb.transition(Text);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$12:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.matchesLetter()) {\nt.createTagPending(false);\nt.tagPending.appendTagName(Character.toLowerCase(r.current()));\nt.dataBuffer.append(Character.toLowerCase(r.current()));\nt.advanceTransition(RCDATAEndTagName);\n} else {\nt.emit(\"</\");\nt.transition(Rcdata);\n}\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$13:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.matchesLetter()) {\nString name = r.consumeLetterSequence();\nt.tagPending.appendTagName(name.toLowerCase());\nt.dataBuffer.append(name);\nreturn;\n}\n\nchar c = r.consume();\nswitch (c) {\ncase '\\t':\ncase '\\n':\ncase '\\f':\ncase ' ':\nif (t.isAppropriateEndTagToken())\nt.transition(BeforeAttributeName);\nelse\nanythingElse(t, r);\nbreak;\ncase '/':\nif (t.isAppropriateEndTagToken())\nt.transition(SelfClosingStartTag);\nelse\nanythingElse(t, r);\nbreak;\ncase '>':\nif (t.isAppropriateEndTagToken()) {\nt.emitTagPending();\nt.transition(Data);\n}\nelse\nanythingElse(t, r);\nbreak;\ndefault:\nanythingElse(t, r);\n}\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:appendTagName(C)V",
            "method_body": "void appendTagName(char append) {\nappendTagName(String.valueOf(append));\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.jsoup.nodes.Element:getElementsByTag(Ljava/lang/String;)Lorg/jsoup/select/Elements;",
            "method_body": "public Elements getElementsByTag(String tagName) {\nValidate.notEmpty(tagName);\ntagName = tagName.toLowerCase().trim();\n\nreturn Collector.collect(new Evaluator.Tag(tagName), this);\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.jsoup.select.Elements:first()Lorg/jsoup/nodes/Element;",
            "method_body": "public Element first() {\nreturn contents.isEmpty() ? null : contents.get(0);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:createTempBuffer()V",
            "method_body": "void createTempBuffer() {\ndataBuffer = new StringBuilder();\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:isAppropriateEndTagToken()Z",
            "method_body": "boolean isAppropriateEndTagToken() {\nreturn tagPending.tagName.equals(lastStartTag.tagName);\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.jsoup.select.QueryParser:byTag()V",
            "method_body": "private void byTag() {\nString tagName = tq.consumeElementSelector();\nValidate.notEmpty(tagName);\n\n// namespaces: if element name is \"abc:def\", selector must be \"abc|def\", so flip:\nif (tagName.contains(\"|\"))\ntagName = tagName.replace(\"|\", \":\");\n\nevals.add(new Evaluator.Tag(tagName.trim().toLowerCase()));\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:consumeElementSelector()Ljava/lang/String;",
            "method_body": "public String consumeElementSelector() {\nint start = pos;\nwhile (!isEmpty() && (matchesWord() || matchesAny('|', '_', '-')))\npos++;\n\nreturn queue.substring(start, pos);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.jsoup.nodes.Element:select(Ljava/lang/String;)Lorg/jsoup/select/Elements;",
            "method_body": "public Elements select(String query) {\nreturn Selector.select(query, this);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.jsoup.select.Selector:<init>(Ljava/lang/String;Lorg/jsoup/nodes/Element;)V",
            "method_body": "private Selector(String query, Element root) {\nValidate.notNull(query);\nquery = query.trim();\nValidate.notEmpty(query);\nValidate.notNull(root);\n\nthis.evaluator = QueryParser.parse(query);\nthis.root = root;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.jsoup.select.Selector:select(Ljava/lang/String;Lorg/jsoup/nodes/Element;)Lorg/jsoup/select/Elements;",
            "method_body": "public static Elements select(String query, Element root) {\nreturn new Selector(query, root).select();\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.jsoup.select.Selector:select()Lorg/jsoup/select/Elements;",
            "method_body": "private Elements select() {\nreturn Collector.collect(evaluator, root);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.jsoup.select.QueryParser:<init>(Ljava/lang/String;)V",
            "method_body": "private QueryParser(String query) {\nthis.query = query;\nthis.tq = new TokenQueue(query);\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.jsoup.select.QueryParser:<clinit>()V",
            "method_body": "private final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};\nprivate final static String[] combinators = {\",\", \">\", \"+\", \"~\", \" \"};",
            "method_id": 30
        },
        {
            "method_signature": "org.jsoup.select.QueryParser:parse(Ljava/lang/String;)Lorg/jsoup/select/Evaluator;",
            "method_body": "public static Evaluator parse(String query) {\nQueryParser p = new QueryParser(query);\nreturn p.parse();\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.jsoup.select.QueryParser:parse()Lorg/jsoup/select/Evaluator;",
            "method_body": "Evaluator parse() {\ntq.consumeWhitespace();\n\nif (tq.matchesAny(combinators)) { // if starts with a combinator, use root as elements\nevals.add(new StructuralEvaluator.Root());\ncombinator(tq.consume());\n} else {\nfindElements();\n}\n\nwhile (!tq.isEmpty()) {\n// hierarchy and extras\nboolean seenWhite = tq.consumeWhitespace();\n\nif (tq.matchChomp(\",\")) { // group or\nCombiningEvaluator.Or or = new CombiningEvaluator.Or(evals);\nevals.clear();\nevals.add(or);\nwhile (!tq.isEmpty()) {\nString subQuery = tq.chompTo(\",\");\nor.add(parse(subQuery));\n}\n} else if (tq.matchesAny(combinators)) {\ncombinator(tq.consume());\n} else if (seenWhite) {\ncombinator(' ');\n} else { // E.class, E#id, E[attr] etc. AND\nfindElements(); // take next el, #. etc off queue\n}\n}\n\nif (evals.size() == 1)\nreturn evals.get(0);\n\nreturn new CombiningEvaluator.And(evals);\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.jsoup.select.QueryParser:findElements()V",
            "method_body": "private void findElements() {\nif (tq.matchChomp(\"#\"))\nbyId();\nelse if (tq.matchChomp(\".\"))\nbyClass();\nelse if (tq.matchesWord())\nbyTag();\nelse if (tq.matches(\"[\"))\nbyAttribute();\nelse if (tq.matchChomp(\"*\"))\nallElements();\nelse if (tq.matchChomp(\":lt(\"))\nindexLessThan();\nelse if (tq.matchChomp(\":gt(\"))\nindexGreaterThan();\nelse if (tq.matchChomp(\":eq(\"))\nindexEquals();\nelse if (tq.matches(\":has(\"))\nhas();\nelse if (tq.matches(\":contains(\"))\ncontains(false);\nelse if (tq.matches(\":containsOwn(\"))\ncontains(true);\nelse if (tq.matches(\":matches(\"))\nmatches(false);\nelse if (tq.matches(\":matchesOwn(\"))\nmatches(true);\nelse if (tq.matches(\":not(\"))\nnot();\nelse // unhandled\nthrow new Selector.SelectorParseException(\"Could not parse query '%s': unexpected token at '%s'\", query, tq.remainder());\n\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchesAny([Ljava/lang/String;)Z",
            "method_body": "public boolean matchesAny(String... seq) {\nfor (String s : seq) {\nif (matches(s))\nreturn true;\n}\nreturn false;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchesWhitespace()Z",
            "method_body": "public boolean matchesWhitespace() {\nreturn !isEmpty() && Character.isWhitespace(queue.charAt(pos));\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:consumeWhitespace()Z",
            "method_body": "public boolean consumeWhitespace() {\nboolean seen = false;\nwhile (matchesWhitespace()) {\npos++;\nseen = true;\n}\nreturn seen;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchesWord()Z",
            "method_body": "public boolean matchesWord() {\nreturn !isEmpty() && Character.isLetterOrDigit(queue.charAt(pos));\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matches(Ljava/lang/String;)Z",
            "method_body": "public boolean matches(String seq) {\nreturn queue.regionMatches(true, pos, seq, 0, seq.length());\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:matchChomp(Ljava/lang/String;)Z",
            "method_body": "public boolean matchChomp(String seq) {\nif (matches(seq)) {\npos += seq.length();\nreturn true;\n} else {\nreturn false;\n}\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeLetterSequence()Ljava/lang/String;",
            "method_body": "String consumeLetterSequence() {\nint start = pos;\nwhile (!isEmpty()) {\nchar c = input.charAt(pos);\nif ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))\npos++;\nelse\nbreak;\n}\n\nreturn input.substring(start, pos);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:normaliseWhitespace(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "static String normaliseWhitespace(String text) {\ntext = StringUtil.normaliseWhitespace(text);\nreturn text;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:normaliseWhitespace(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "public static String normaliseWhitespace(String string) {\nStringBuilder sb = new StringBuilder(string.length());\n\nboolean lastWasWhite = false;\nboolean modified = false;\n\nint l = string.length();\nfor (int i = 0; i < l; i++) {\nint c = string.codePointAt(i);\nif (Character.isWhitespace(c)) {\nif (lastWasWhite) {\nmodified = true;\ncontinue;\n}\nif (c != ' ')\nmodified = true;\nsb.append(' ');\nlastWasWhite = true;\n}\nelse {\nsb.appendCodePoint(c);\nlastWasWhite = false;\n}\n}\nreturn modified ? sb.toString() : string;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:<init>(Ljava/lang/String;)V",
            "method_body": "public TokenQueue(String data) {\nValidate.notNull(data);\nqueue = data;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn remainingLength() == 0;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.jsoup.parser.TokenQueue:remainingLength()I",
            "method_body": "private int remainingLength() {\nreturn queue.length() - pos;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.jsoup.select.Evaluator$Tag:<init>(Ljava/lang/String;)V",
            "method_body": "public abstract boolean matches(Element root, Element element);\n\n/**\n* Evaluator for tag name\n*/\npublic static final class Tag extends Evaluator {\nprivate String tagName;\n\npublic Tag(String tagName) {\nthis.tagName = tagName;\n}\n\n@Override\npublic boolean matches(Element root, Element element) {\nreturn (element.tagName().equals(tagName));\n}\n\n@Override\npublic String toString() {\nreturn String.format(\"%s\", tagName);\n}\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.jsoup.select.Evaluator$Tag:matches(Lorg/jsoup/nodes/Element;Lorg/jsoup/nodes/Element;)Z",
            "method_body": "public abstract boolean matches(Element root, Element element);\n\n/**\n* Evaluator for tag name\n*/\npublic static final class Tag extends Evaluator {\nprivate String tagName;\n\npublic Tag(String tagName) {\nthis.tagName = tagName;\n}\n\n@Override\npublic boolean matches(Element root, Element element) {\nreturn (element.tagName().equals(tagName));\n}\n\n@Override\npublic String toString() {\nreturn String.format(\"%s\", tagName);\n}\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.jsoup.nodes.Element:preserveWhitespace()Z",
            "method_body": "boolean preserveWhitespace() {\nreturn tag.preserveWhitespace() || parent() != null && parent().preserveWhitespace();\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.jsoup.parser.Tag:preserveWhitespace()Z",
            "method_body": "public boolean preserveWhitespace() {\nreturn preserveWhitespace;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:getWholeText()Ljava/lang/String;",
            "method_body": "public String getWholeText() {\nreturn attributes == null ? text : attributes.get(TEXT_KEY);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.jsoup.select.Elements:add(Lorg/jsoup/nodes/Element;)Z",
            "method_body": "public boolean add(Element element) {return contents.add(element);}\npublic boolean add(Element element) {return contents.add(element);}",
            "method_id": 51
        },
        {
            "method_signature": "org.jsoup.select.Evaluator:<init>()V",
            "method_body": "Evaluator() {\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.jsoup.select.Collector:collect(Lorg/jsoup/select/Evaluator;Lorg/jsoup/nodes/Element;)Lorg/jsoup/select/Elements;",
            "method_body": "public static Elements collect (Evaluator eval, Element root) {\nElements elements = new Elements();\nnew NodeTraversor(new Accumulator(root, elements, eval)).traverse(root);\nreturn elements;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.jsoup.select.Elements:<init>()V",
            "method_body": "public Elements() {\ncontents = new ArrayList<Element>();\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.jsoup.select.Collector$Accumulator:<init>(Lorg/jsoup/nodes/Element;Lorg/jsoup/select/Elements;Lorg/jsoup/select/Evaluator;)V",
            "method_body": "Accumulator(Element root, Elements elements, Evaluator eval) {\nthis.root = root;\nthis.elements = elements;\nthis.eval = eval;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.jsoup.select.Collector$Accumulator:head(Lorg/jsoup/nodes/Node;I)V",
            "method_body": "public void head(Node node, int depth) {\nif (node instanceof Element) {\nElement el = (Element) node;\nif (eval.matches(root, el))\nelements.add(el);\n}\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.jsoup.select.Collector$Accumulator:tail(Lorg/jsoup/nodes/Node;I)V",
            "method_body": "public void tail(Node node, int depth) {\n// void\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:inButtonScope(Ljava/lang/String;)Z",
            "method_body": "boolean inButtonScope(String targetName) {\nreturn inScope(targetName, new String[]{\"button\"});\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.jsoup.nodes.Node:parent()Lorg/jsoup/nodes/Node;",
            "method_body": "public Node parent() {\nreturn parentNode;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$2:anythingElse(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "private boolean anythingElse(Token t, TreeBuilder tb) {\ntb.insert(\"html\");\ntb.transition(BeforeHead);\nreturn tb.process(t);\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:insert(Ljava/lang/String;)Lorg/jsoup/nodes/Element;",
            "method_body": "Element insert(String startTagName) {\nElement el = new Element(Tag.valueOf(startTagName), baseUri);\ninsert(el);\nreturn el;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.jsoup.Jsoup:parse(Ljava/lang/String;)Lorg/jsoup/nodes/Document;",
            "method_body": "public static Document parse(String html) {\nreturn Parser.parse(html, \"\");\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$4:anythingElse(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "private boolean anythingElse(Token t, TreeBuilder tb) {\ntb.process(new Token.EndTag(\"head\"));\nreturn tb.process(t);\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:insert(Lorg/jsoup/parser/Token$Character;)V",
            "method_body": "void insert(Token.Character characterToken) {\nNode node;\n// characters in script and style go in as datanodes, not text nodes\nif (StringUtil.in(currentElement().tagName(), \"script\", \"style\"))\nnode = new DataNode(characterToken.getData(), baseUri);\nelse\nnode = new TextNode(characterToken.getData(), baseUri);\ncurrentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.jsoup.nodes.Node:<init>()V",
            "method_body": "protected Node() {\nchildNodes = Collections.emptyList();\nattributes = null;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Ljava/lang/String;)V",
            "method_body": "void emit(String str) {\n// buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n// does not set isEmitPending; read checks that\ncharBuffer.append(str);\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.jsoup.parser.Token:asCharacter()Lorg/jsoup/parser/Token$Character;",
            "method_body": "Character asCharacter() {\nreturn (Character) this;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:<init>(Ljava/lang/String;)V",
            "method_body": "Character(String data) {\ntype = TokenType.Character;\nthis.data = data;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:getData()Ljava/lang/String;",
            "method_body": "String getData() {\nreturn data;\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:<init>(Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "public TextNode(String text, String baseUri) {\nthis.baseUri = baseUri;\nthis.text = text;\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.jsoup.parser.Token$StartTag:<init>(Ljava/lang/String;)V",
            "method_body": "StartTag(String name) {\nthis();\nthis.tagName = name;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.jsoup.parser.Token$EndTag:<init>(Ljava/lang/String;)V",
            "method_body": "EndTag(String name) {\nthis();\nthis.tagName = name;\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:inSpecificScope(Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\nreturn inSpecificScope(new String[]{targetName}, baseTypes, extraTypes);\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:inSpecificScope([Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\nIterator<Element> it = stack.descendingIterator();\nwhile (it.hasNext()) {\nElement el = it.next();\nString elName = el.nodeName();\nif (StringUtil.in(elName, targetNames))\nreturn true;\nif (StringUtil.in(elName, baseTypes))\nreturn false;\nif (extraTypes != null && StringUtil.in(elName, extraTypes))\nreturn false;\n}\nValidate.fail(\"Should not be reachable\");\nreturn false;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:inScope(Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "boolean inScope(String targetName, String[] extras) {\nreturn inSpecificScope(targetName, new String[]{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}, extras);\n// todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n// todo: in svg namespace: forignOjbect, desc, title\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.jsoup.parser.Parser:parse(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Document;",
            "method_body": "public static Document parse(String html, String baseUri) {\nTreeBuilder treeBuilder = new TreeBuilder();\nreturn treeBuilder.parse(html, baseUri);\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:parse(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Document;",
            "method_body": "Document parse(String input, String baseUri) {\nstate = TreeBuilderState.Initial;\ninitialiseParse(input, baseUri);\nrunParser();\nreturn doc;\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:setHeadElement(Lorg/jsoup/nodes/Element;)V",
            "method_body": "void setHeadElement(Element headElement) {\nthis.headElement = headElement;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$1:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (isWhitespace(t)) {\nreturn true; // ignore whitespace\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (t.isDoctype()) {\n// todo: parse error check on expected doctypes\n// todo: quirk state check on doctype ids\nToken.Doctype d = t.asDoctype();\nDocumentType doctype = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\ntb.getDocument().appendChild(doctype);\nif (d.isForceQuirks())\ntb.getDocument().quirksMode(Document.QuirksMode.quirks);\ntb.transition(BeforeHtml);\n} else {\n// todo: check not iframe srcdoc\ntb.transition(BeforeHtml);\nreturn tb.process(t); // re-process token\n}\nreturn true;\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$2:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (t.isDoctype()) {\ntb.error(this);\nreturn false;\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (isWhitespace(t)) {\nreturn true; // ignore whitespace\n} else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\ntb.insert(t.asStartTag());\ntb.transition(BeforeHead);\n} else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\nreturn anythingElse(t, tb);\n} else if (t.isEndTag()) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$3:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (isWhitespace(t)) {\nreturn true;\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (t.isDoctype()) {\ntb.error(this);\nreturn false;\n} else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\nreturn InBody.process(t, tb); // does not transition\n} else if (t.isStartTag() && t.asStartTag().name().equals(\"head\")) {\nElement head = tb.insert(t.asStartTag());\ntb.setHeadElement(head);\ntb.transition(InHead);\n} else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\ntb.process(new Token.StartTag(\"head\"));\nreturn tb.process(t);\n} else if (t.isEndTag()) {\ntb.error(this);\nreturn false;\n} else {\ntb.process(new Token.StartTag(\"head\"));\nreturn tb.process(t);\n}\nreturn true;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$4:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (isWhitespace(t)) {\ntb.insert(t.asCharacter());\nreturn true;\n}\nswitch (t.type) {\ncase Comment:\ntb.insert(t.asComment());\nbreak;\ncase Doctype:\ntb.error(this);\nreturn false;\ncase StartTag:\nToken.StartTag start = t.asStartTag();\nString name = start.name();\nif (name.equals(\"html\")) {\nreturn InBody.process(t, tb);\n} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\nElement el = tb.insertEmpty(start);\n// jsoup special: update base as it is seen. todo: flip to current browser behaviour of one shot\nif (name.equals(\"base\") && el.hasAttr(\"href\"))\ntb.setBaseUri(el);\n} else if (name.equals(\"meta\")) {\nElement meta = tb.insertEmpty(start);\n// todo: charset switches\n} else if (name.equals(\"title\")) {\nhandleRcData(start, tb);\n} else if (StringUtil.in(name, \"noframes\", \"style\")) {\nhandleRawtext(start, tb);\n} else if (name.equals(\"noscript\")) {\n// else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)\ntb.insert(start);\ntb.transition(InHeadNoscript);\n} else if (name.equals(\"script\")) {\n// skips some script rules as won't execute them\ntb.insert(start);\ntb.tokeniser.transition(TokeniserState.ScriptData);\ntb.markInsertionMode();\ntb.transition(Text);\n} else if (name.equals(\"head\")) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\nbreak;\ncase EndTag:\nToken.EndTag end = t.asEndTag();\nname = end.name();\nif (name.equals(\"head\")) {\ntb.pop();\ntb.transition(AfterHead);\n} else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\nreturn anythingElse(t, tb);\n} else {\ntb.error(this);\nreturn false;\n}\nbreak;\ndefault:\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$6:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (isWhitespace(t)) {\ntb.insert(t.asCharacter());\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (t.isDoctype()) {\ntb.error(this);\n} else if (t.isStartTag()) {\nToken.StartTag startTag = t.asStartTag();\nString name = startTag.name();\nif (name.equals(\"html\")) {\nreturn tb.process(t, InBody);\n} else if (name.equals(\"body\")) {\ntb.insert(startTag);\ntb.framesetOk(false);\ntb.transition(InBody);\n} else if (name.equals(\"frameset\")) {\ntb.insert(startTag);\ntb.transition(InFrameset);\n} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\ntb.error(this);\nElement head = tb.getHeadElement();\ntb.push(head);\ntb.process(t, InHead);\ntb.removeFromStack(head);\n} else if (name.equals(\"head\")) {\ntb.error(this);\nreturn false;\n} else {\nanythingElse(t, tb);\n}\n} else if (t.isEndTag()) {\nif (StringUtil.in(t.asEndTag().name(), \"body\", \"html\")) {\nanythingElse(t, tb);\n} else {\ntb.error(this);\nreturn false;\n}\n} else {\nanythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:pop()Lorg/jsoup/nodes/Element;",
            "method_body": "Element pop() {\n// todo - dev, remove validation check\nif (stack.peekLast().nodeName().equals(\"td\") && !state.name().equals(\"InCell\"))\nValidate.isFalse(true, \"pop td not in cell\");\nif (stack.peekLast().nodeName().equals(\"html\"))\nValidate.isFalse(true, \"popping html!\");\nreturn stack.pollLast();\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.jsoup.parser.Token:isDoctype()Z",
            "method_body": "boolean isDoctype() {\nreturn type == TokenType.Doctype;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.jsoup.parser.Token:isStartTag()Z",
            "method_body": "boolean isStartTag() {\nreturn type == TokenType.StartTag;\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.jsoup.parser.Token:isEndTag()Z",
            "method_body": "boolean isEndTag() {\nreturn type == TokenType.EndTag;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.jsoup.parser.Token:isComment()Z",
            "method_body": "boolean isComment() {\nreturn type == TokenType.Comment;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.jsoup.nodes.Node:childNode(I)Lorg/jsoup/nodes/Node;",
            "method_body": "public Node childNode(int index) {\nreturn childNodes.get(index);\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.jsoup.nodes.Node:nextSibling()Lorg/jsoup/nodes/Node;",
            "method_body": "public Node nextSibling() {\nif (parentNode == null)\nreturn null; // root\n\nList<Node> siblings = parentNode.childNodes;\nInteger index = siblingIndex();\nValidate.notNull(index);\nif (siblings.size() > index+1)\nreturn siblings.get(index+1);\nelse\nreturn null;\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.jsoup.select.NodeTraversor:<init>(Lorg/jsoup/select/NodeVisitor;)V",
            "method_body": "public NodeTraversor(NodeVisitor visitor) {\nthis.visitor = visitor;\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.jsoup.select.NodeTraversor:traverse(Lorg/jsoup/nodes/Node;)V",
            "method_body": "public void traverse(Node root) {\nNode node = root;\nint depth = 0;\n\nwhile (node != null) {\nvisitor.head(node, depth);\nif (node.childNodes().size() > 0) {\nnode = node.childNode(0);\ndepth++;\n} else {\nwhile (node.nextSibling() == null && depth > 0) {\nvisitor.tail(node, depth);\nnode = node.parent();\ndepth--;\n}\nvisitor.tail(node, depth);\nif (node == root)\nbreak;\nnode = node.nextSibling();\n}\n}\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.jsoup.nodes.Node:childNodes()Ljava/util/List;",
            "method_body": "public List<Node> childNodes() {\nreturn Collections.unmodifiableList(childNodes);\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.jsoup.nodes.Node:siblingIndex()I",
            "method_body": "public int siblingIndex() {\nreturn siblingIndex;\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.jsoup.nodes.Element:parent()Lorg/jsoup/nodes/Element;",
            "method_body": "public final Element parent() {\nreturn (Element) parentNode;\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emitTagPending()V",
            "method_body": "void emitTagPending() {\ntagPending.finaliseTag();\nemit(tagPending);\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:finaliseTag()V",
            "method_body": "void finaliseTag() {\n// finalises for emit\nif (pendingAttributeName != null) {\n// todo: check if attribute name exists; if so, drop and error\nnewAttribute();\n}\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState:isWhitespace(Lorg/jsoup/parser/Token;)Z",
            "method_body": "abstract boolean process(Token t, TreeBuilder tb);\n\nprivate static boolean isWhitespace(Token t) {\nif (t.isCharacter()) {\nString data = t.asCharacter().getData();\n// todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\nfor (int i = 0; i < data.length(); i++) {\nchar c = data.charAt(i);\nif (!Character.isWhitespace(c))\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matchesLetter()Z",
            "method_body": "boolean matchesLetter() {\nif (isEmpty())\nreturn false;\nchar c = input.charAt(pos);\nreturn (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:createTagPending(Z)Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Token.Tag createTagPending(boolean start) {\ntagPending = start ? new Token.StartTag() : new Token.EndTag();\nreturn tagPending;\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$8:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\ncase '!':\nt.advanceTransition(MarkupDeclarationOpen);\nbreak;\ncase '/':\nt.advanceTransition(EndTagOpen);\nbreak;\ncase '?':\nt.advanceTransition(BogusComment);\nbreak;\ndefault:\nif (r.matchesLetter()) {\nt.createTagPending(true);\nt.transition(TagName);\n} else {\nt.error(this);\nt.emit('<'); // char that got us here\nt.transition(Data);\n}\nbreak;\n}\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$10:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\n// previous TagOpen state did NOT consume, will have a letter char in current\nString tagName = r.consumeToAny('\\t', '\\n', '\\f', ' ', '/', '>', nullChar).toLowerCase();\nt.tagPending.appendTagName(tagName);\n\nswitch (r.consume()) {\ncase '\\t':\ncase '\\n':\ncase '\\f':\ncase ' ':\nt.transition(BeforeAttributeName);\nbreak;\ncase '/':\nt.transition(SelfClosingStartTag);\nbreak;\ncase '>':\nt.emitTagPending();\nt.transition(Data);\nbreak;\ncase nullChar: // replacement\nt.tagPending.appendTagName(replacementStr);\nbreak;\ncase eof: // should emit pending tag?\nt.eofError(this);\nt.transition(Data);\n// no default, as covered with above consumeToAny\n}\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.jsoup.parser.Token:isCharacter()Z",
            "method_body": "boolean isCharacter() {\nreturn type == TokenType.Character;\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:appendTagName(Ljava/lang/String;)V",
            "method_body": "void appendTagName(String append) {\ntagName = tagName == null ? append : tagName.concat(append);\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:in(Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "public static boolean in(String needle, String... haystack) {\nfor (String hay : haystack) {\nif (hay.equals(needle))\nreturn true;\n}\nreturn false;\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:insert(Lorg/jsoup/parser/Token$StartTag;)Lorg/jsoup/nodes/Element;",
            "method_body": "Element insert(Token.StartTag startTag) {\n// handle empty unknown tags\n// when the spec expects an empty tag, will directly hit insertEmpty, so won't generate fake end tag.\nif (startTag.isSelfClosing() && !Tag.isKnownTag(startTag.name())) {\nElement el =  insertEmpty(startTag);\nprocess(new Token.EndTag(el.tagName())); // ensure we get out of whatever state we are in\nreturn el;\n}\n\nElement el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\ninsert(el);\nreturn el;\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:insert(Lorg/jsoup/nodes/Element;)V",
            "method_body": "void insert(Element el) {\ninsertNode(el);\nstack.add(el);\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.jsoup.nodes.Element:tagName()Ljava/lang/String;",
            "method_body": "public String tagName() {\nreturn tag.getName();\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consume()C",
            "method_body": "char consume() {\nreturn isEmpty() ? EOF : input.charAt(pos++);\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.jsoup.parser.Token:asEndTag()Lorg/jsoup/parser/Token$EndTag;",
            "method_body": "EndTag asEndTag() {\nreturn (EndTag) this;\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.jsoup.parser.Token$EndTag:<init>()V",
            "method_body": "EndTag() {\nsuper();\ntype = TokenType.EndTag;\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:framesetOk(Z)V",
            "method_body": "void framesetOk(boolean framesetOk) {\nthis.framesetOk = framesetOk;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:advance()V",
            "method_body": "void advance() {\npos++;\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeToAny([C)Ljava/lang/String;",
            "method_body": "String consumeToAny(char... seq) {\nint start = pos;\n\nOUTER: while (!isEmpty()) {\nchar c = input.charAt(pos);\nfor (char seek : seq) {\nif (seek == c)\nbreak OUTER;\n}\npos++;\n}\n\nreturn pos > start ? input.substring(start, pos) : \"\";\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:transition(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void transition(TokeniserState state) {\nthis.state = state;\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:advanceTransition(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void advanceTransition(TokeniserState state) {\nreader.advance();\nthis.state = state;\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:<init>()V",
            "method_body": "CharacterReader reader;\nTokeniser tokeniser;\n\nprivate TreeBuilderState state; // the current state\nprivate TreeBuilderState originalState; // original / marked state\nprivate Document doc; // current doc we are building into\nprivate LinkedList<Element> stack; // the stack of open elements\n\nprivate String baseUri; // current base uri, for creating new elements\nprivate Token currentToken; // currentToken is used only for error tracking.\nprivate Element headElement; // the current head element\nprivate Element formElement; // the current form element\nprivate Element contextElement; // fragment parse context -- could be null even if fragment parsing\nprivate LinkedList<Element> formattingElements = new LinkedList<Element>(); // active (open) formatting elements\nprivate List<Token.Character> pendingTableCharacters = new ArrayList<Token.Character>(); // chars in table to be shifted out\n\nprivate boolean framesetOk = true; // if ok to go into frameset\nprivate boolean fosterInserts = false; // if next inserts should be fostered\nprivate boolean fragmentParsing = false; // if parsing a fragment of html\n\nprivate boolean trackErrors = false;\nprivate List<ParseError> errors = new ArrayList<ParseError>();\n\nTreeBuilder() {}",
            "method_id": 117
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:initialiseParse(Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "private void initialiseParse(String input, String baseUri) {\ndoc = new Document(baseUri);\nreader = new CharacterReader(input);\ntokeniser = new Tokeniser(reader);\nstack = new LinkedList<Element>();\nthis.baseUri = baseUri;\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:runParser()V",
            "method_body": "private void runParser() {\nwhile (true) {\n// todo: handle foreign content checks\n\nToken token = tokeniser.read();\nprocess(token);\n\nif (token.type == Token.TokenType.EOF)\nbreak;\n}\n}",
            "method_id": 119
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:process(Lorg/jsoup/parser/Token;)Z",
            "method_body": "boolean process(Token token) {\ncurrentToken = token;\nreturn this.state.process(token, this);\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:transition(Lorg/jsoup/parser/TreeBuilderState;)V",
            "method_body": "void transition(TreeBuilderState state) {\nthis.state = state;\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:currentElement()Lorg/jsoup/nodes/Element;",
            "method_body": "Element currentElement() {\nreturn stack.getLast();\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:insertNode(Lorg/jsoup/nodes/Node;)V",
            "method_body": "private void insertNode(Node node) {\n// if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\nif (stack.size() == 0)\ndoc.appendChild(node);\nelse if (isFosterInserts())\ninsertInFosterParent(node);\nelse\ncurrentElement().appendChild(node);\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:isFosterInserts()Z",
            "method_body": "boolean isFosterInserts() {\nreturn fosterInserts;\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState:<init>(Ljava/lang/String;I)V",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (isWhitespace(t)) {\ntb.insert(t.asCharacter());\nreturn true;\n}\nswitch (t.type) {\ncase Comment:\ntb.insert(t.asComment());\nbreak;\ncase Doctype:\ntb.error(this);\nreturn false;\ncase StartTag:\nToken.StartTag start = t.asStartTag();\nString name = start.name();\nif (name.equals(\"html\")) {\nreturn InBody.process(t, tb);\n} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\nElement el = tb.insertEmpty(start);\n// jsoup special: update base as it is seen. todo: flip to current browser behaviour of one shot\nif (name.equals(\"base\") && el.hasAttr(\"href\"))\ntb.setBaseUri(el);\n} else if (name.equals(\"meta\")) {\nElement meta = tb.insertEmpty(start);\n// todo: charset switches\n} else if (name.equals(\"title\")) {\nhandleRcData(start, tb);\n} else if (StringUtil.in(name, \"noframes\", \"style\")) {\nhandleRawtext(start, tb);\n} else if (name.equals(\"noscript\")) {\n// else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)\ntb.insert(start);\ntb.transition(InHeadNoscript);\n} else if (name.equals(\"script\")) {\n// skips some script rules as won't execute them\ntb.insert(start);\ntb.tokeniser.transition(TokeniserState.ScriptData);\ntb.markInsertionMode();\ntb.transition(Text);\n} else if (name.equals(\"head\")) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\nbreak;\ncase EndTag:\nToken.EndTag end = t.asEndTag();\nname = end.name();\nif (name.equals(\"head\")) {\ntb.pop();\ntb.transition(AfterHead);\n} else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\nreturn anythingElse(t, tb);\n} else {\ntb.error(this);\nreturn false;\n}\nbreak;\ndefault:\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.jsoup.nodes.Node:setParentNode(Lorg/jsoup/nodes/Node;)V",
            "method_body": "protected void setParentNode(Node parentNode) {\nif (this.parentNode != null)\nthis.parentNode.removeChild(this);\nthis.parentNode = parentNode;\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.jsoup.nodes.Node:addChildren([Lorg/jsoup/nodes/Node;)V",
            "method_body": "protected void addChildren(Node... children) {\n//most used. short circuit addChildren(int), which hits reindex children and array copy\nfor (Node child: children) {\nreparentChild(child);\nchildNodes.add(child);\nchild.setSiblingIndex(childNodes.size()-1);\n}\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.jsoup.nodes.Node:reparentChild(Lorg/jsoup/nodes/Node;)V",
            "method_body": "private void reparentChild(Node child) {\nif (child.parentNode != null)\nchild.parentNode.removeChild(child);\nchild.setParentNode(this);\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.jsoup.nodes.Node:setSiblingIndex(I)V",
            "method_body": "protected void setSiblingIndex(int siblingIndex) {\nthis.siblingIndex = siblingIndex;\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.jsoup.nodes.Element:nodeName()Ljava/lang/String;",
            "method_body": "public String nodeName() {\nreturn tag.getName();\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.jsoup.nodes.Element:appendChild(Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Element;",
            "method_body": "public Element appendChild(Node child) {\nValidate.notNull(child);\n\naddChildren(child);\nreturn this;\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.jsoup.parser.Tag:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn tagName;\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isFalse(Z)V",
            "method_body": "public static void isFalse(boolean val) {\nif (val)\nthrow new IllegalArgumentException(\"Must be false\");\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isFalse(ZLjava/lang/String;)V",
            "method_body": "public static void isFalse(boolean val, String msg) {\nif (val)\nthrow new IllegalArgumentException(msg);\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/lang/String;)V",
            "method_body": "static final char EOF = (char) -1;\n\nprivate final String input;\nprivate final int length;\nprivate int pos = 0;\nprivate int mark = 0;\n\nCharacterReader(String input) {\nthis.input = input;\nthis.length = input.length();\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:isEmpty()Z",
            "method_body": "boolean isEmpty() {\nreturn pos >= length;\n}",
            "method_id": 136
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:current()C",
            "method_body": "char current() {\nreturn isEmpty() ? EOF : input.charAt(pos);\n}",
            "method_id": 137
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:<init>(Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "Tokeniser(CharacterReader reader) {\nthis.reader = reader;\n}",
            "method_id": 138
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:read()Lorg/jsoup/parser/Token;",
            "method_body": "Token read() {\nif (!selfClosingFlagAcknowledged) {\nerror(\"Self closing flag not acknowledged\");\nselfClosingFlagAcknowledged = true;\n}\n\nwhile (!isEmitPending)\nstate.read(this, reader);\n\n// if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\nif (charBuffer.length() > 0) {\nString str = charBuffer.toString();\ncharBuffer.delete(0, charBuffer.length());\nreturn new Token.Character(str);\n} else {\nisEmitPending = false;\nreturn emitPending;\n}\n}",
            "method_id": 139
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Lorg/jsoup/parser/Token;)V",
            "method_body": "void emit(Token token) {\nValidate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\nemitPending = token;\nisEmitPending = true;\n\nif (token.type == Token.TokenType.StartTag) {\nToken.StartTag startTag = (Token.StartTag) token;\nlastStartTag = startTag;\nif (startTag.selfClosing)\nselfClosingFlagAcknowledged = false;\n} else if (token.type == Token.TokenType.EndTag) {\nToken.EndTag endTag = (Token.EndTag) token;\nif (endTag.attributes.size() > 0)\nerror(\"Attributes incorrectly present on end tag\");\n}\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$1:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\ncase '&':\nt.advanceTransition(CharacterReferenceInData);\nbreak;\ncase '<':\nt.advanceTransition(TagOpen);\nbreak;\ncase nullChar:\nt.error(this); // NOT replacement character (oddly?)\nt.emit(r.consume());\nbreak;\ncase eof:\nt.emit(new Token.EOF());\nbreak;\ndefault:\nString data = r.consumeToAny('&', '<', nullChar);\nt.emit(data);\nbreak;\n}\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.jsoup.parser.Token:<init>()V",
            "method_body": "private Token() {\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.jsoup.parser.Token:asStartTag()Lorg/jsoup/parser/Token$StartTag;",
            "method_body": "StartTag asStartTag() {\nreturn (StartTag) this;\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:<init>()V",
            "method_body": "protected String tagName;\nprivate String pendingAttributeName;\nprivate String pendingAttributeValue;\n\nboolean selfClosing = false;\nAttributes attributes = new Attributes(); // todo: allow nodes to not have attributes\n\nvoid newAttribute() {\nif (pendingAttributeName != null) {\nif (pendingAttributeValue == null)\npendingAttributeValue = \"\";\nAttribute attribute = new Attribute(pendingAttributeName, pendingAttributeValue);\nattributes.put(attribute);\n}\npendingAttributeName = null;\npendingAttributeValue = null;\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:name()Ljava/lang/String;",
            "method_body": "String name() {\nValidate.isFalse(tagName.isEmpty());\nreturn tagName;\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:isSelfClosing()Z",
            "method_body": "boolean isSelfClosing() {\nreturn selfClosing;\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.jsoup.parser.Token$StartTag:<init>()V",
            "method_body": "StartTag() {\nsuper();\ntype = TokenType.StartTag;\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$24:<clinit>()V",
            "method_body": "boolean process(Token t, TreeBuilder tb) {\nif (isWhitespace(t)) {\ntb.insert(t.asCharacter());\nreturn true;\n}\nswitch (t.type) {\ncase Comment:\ntb.insert(t.asComment());\nbreak;\ncase Doctype:\ntb.error(this);\nreturn false;\ncase StartTag:\nToken.StartTag start = t.asStartTag();\nString name = start.name();\nif (name.equals(\"html\")) {\nreturn InBody.process(t, tb);\n} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\nElement el = tb.insertEmpty(start);\n// jsoup special: update base as it is seen. todo: flip to current browser behaviour of one shot\nif (name.equals(\"base\") && el.hasAttr(\"href\"))\ntb.setBaseUri(el);\n} else if (name.equals(\"meta\")) {\nElement meta = tb.insertEmpty(start);\n// todo: charset switches\n} else if (name.equals(\"title\")) {\nhandleRcData(start, tb);\n} else if (StringUtil.in(name, \"noframes\", \"style\")) {\nhandleRawtext(start, tb);\n} else if (name.equals(\"noscript\")) {\n// else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)\ntb.insert(start);\ntb.transition(InHeadNoscript);\n} else if (name.equals(\"script\")) {\n// skips some script rules as won't execute them\ntb.insert(start);\ntb.tokeniser.transition(TokeniserState.ScriptData);\ntb.markInsertionMode();\ntb.transition(Text);\n} else if (name.equals(\"head\")) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\nbreak;\ncase EndTag:\nToken.EndTag end = t.asEndTag();\nname = end.name();\nif (name.equals(\"head\")) {\ntb.pop();\ntb.transition(AfterHead);\n} else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\nreturn anythingElse(t, tb);\n} else {\ntb.error(this);\nreturn false;\n}\nbreak;\ndefault:\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.jsoup.parser.Token$EOF:<init>()V",
            "method_body": "EOF() {\ntype = Token.TokenType.EOF;\n}",
            "method_id": 149
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<init>(Lorg/jsoup/parser/Tag;Ljava/lang/String;)V",
            "method_body": "public Element(Tag tag, String baseUri) {\nthis(tag, baseUri, new Attributes());\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.jsoup.nodes.Document:<init>(Ljava/lang/String;)V",
            "method_body": "private OutputSettings outputSettings = new OutputSettings();\nprivate QuirksMode quirksMode = QuirksMode.noQuirks;\n\n/**\nCreate a new, empty Document.\n@param baseUri base URI of document\n@see org.jsoup.Jsoup#parse\n@see #createShell\n*/\npublic Document(String baseUri) {\nsuper(Tag.valueOf(\"#root\"), baseUri);\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:<init>()V",
            "method_body": "private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;\nprivate Charset charset = Charset.forName(\"UTF-8\");\nprivate CharsetEncoder charsetEncoder = charset.newEncoder();\nprivate boolean prettyPrint = true;\nprivate int indentAmount = 1;\n\npublic OutputSettings() {}",
            "method_id": 152
        },
        {
            "method_signature": "org.jsoup.nodes.Node:<init>(Ljava/lang/String;Lorg/jsoup/nodes/Attributes;)V",
            "method_body": "protected Node(String baseUri, Attributes attributes) {\nValidate.notNull(baseUri);\nValidate.notNull(attributes);\n\nchildNodes = new ArrayList<Node>(4);\nthis.baseUri = baseUri.trim();\nthis.attributes = attributes;\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<init>(Lorg/jsoup/parser/Tag;Ljava/lang/String;Lorg/jsoup/nodes/Attributes;)V",
            "method_body": "public Element(Tag tag, String baseUri, Attributes attributes) {\nsuper(baseUri, attributes);\n\nValidate.notNull(tag);\nthis.tag = tag;\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:<init>()V",
            "method_body": "protected static final String dataPrefix = \"data-\";\n\nprivate LinkedHashMap<String, Attribute> attributes = null;\n// linked hash map to preserve insertion order.\n// null be default as so many elements have no attributes -- saves a good chunk of memory\n\n/**\nGet an attribute value by key.\n@param key the attribute key\n@return the attribute value if set; or empty string if not set.\n@see #hasKey(String)\n*/\npublic String get(String key) {\nValidate.notEmpty(key);\n\nif (attributes == null)\nreturn \"\";\n\nAttribute attr = attributes.get(key.toLowerCase());\nreturn attr != null ? attr.getValue() : \"\";\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.jsoup.nodes.Entities$EscapeMode:<init>(Ljava/lang/String;ILjava/util/Map;)V",
            "method_body": "EscapeMode(Map<Character, String> map) {\nthis.map = map;\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:<clinit>()V",
            "method_body": "private static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \", \"         \", \"          \"};\nprivate static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \", \"         \", \"          \"};",
            "method_id": 157
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:<clinit>()V",
            "method_body": "private static final Map<String, Character> full;\nprivate static final Map<Character, String> xhtmlByVal;\nprivate static final Map<Character, String> baseByVal;\nprivate static final Map<Character, String> fullByVal;\nprivate static final Pattern unescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);?\");\nprivate static final Pattern strictUnescapePattern = Pattern.compile(\"&(#(x|X)?([0-9a-fA-F]+)|[a-zA-Z]+\\\\d*);\");\n\nprivate Entities() {}",
            "method_id": 158
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notEmpty(Ljava/lang/String;)V",
            "method_body": "public static void notEmpty(String string) {\nif (string == null || string.length() == 0)\nthrow new IllegalArgumentException(\"String must not be empty\");\n}",
            "method_id": 159
        },
        {
            "method_signature": "org.jsoup.parser.Tag:<init>(Ljava/lang/String;)V",
            "method_body": "private Tag(String tagName) {\nthis.tagName = tagName.toLowerCase();\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.jsoup.parser.Tag:valueOf(Ljava/lang/String;)Lorg/jsoup/parser/Tag;",
            "method_body": "public static Tag valueOf(String tagName) {\nValidate.notNull(tagName);\ntagName = tagName.trim().toLowerCase();\nValidate.notEmpty(tagName);\n\nsynchronized (tags) {\nTag tag = tags.get(tagName);\nif (tag == null) {\n// not defined: create default; go anywhere, do anything! (incl be inside a <p>)\ntag = new Tag(tagName);\ntag.isBlock = false;\ntag.canContainBlock = true;\n}\nreturn tag;\n}\n}",
            "method_id": 161
        },
        {
            "method_signature": "org.jsoup.parser.Tag:register(Lorg/jsoup/parser/Tag;)Lorg/jsoup/parser/Tag;",
            "method_body": "private static Tag register(Tag tag) {\nsynchronized (tags) {\ntags.put(tag.tagName, tag);\n}\nreturn tag;\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notNull(Ljava/lang/Object;)V",
            "method_body": "public static void notNull(Object obj) {\nif (obj == null)\nthrow new IllegalArgumentException(\"Object must not be null\");\n}",
            "method_id": 163
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:generateImpliedEndTags(Ljava/lang/String;)V",
            "method_body": "void generateImpliedEndTags(String excludeTag) {\nwhile ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\nStringUtil.in(currentElement().nodeName(), \"dd\", \"dt\", \"li\", \"option\", \"optgroup\", \"p\", \"rp\", \"rt\"))\npop();\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilderState$6:anythingElse(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "private boolean anythingElse(Token t, TreeBuilder tb) {\ntb.process(new Token.StartTag(\"body\"));\ntb.framesetOk(true);\nreturn tb.process(t);\n}",
            "method_id": 165
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$9:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.isEmpty()) {\nt.eofError(this);\nt.emit(\"</\");\nt.transition(Data);\n} else if (r.matchesLetter()) {\nt.createTagPending(false);\nt.transition(TagName);\n} else if (r.matches('>')) {\nt.error(this);\nt.advanceTransition(Data);\n} else {\nt.error(this);\nt.advanceTransition(BogusComment);\n}\n}",
            "method_id": 166
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:popStackToClose(Ljava/lang/String;)V",
            "method_body": "void popStackToClose(String elName) {\nIterator<Element> it = stack.descendingIterator();\nwhile (it.hasNext()) {\nElement next = it.next();\nif (next.nodeName().equals(elName)) {\nit.remove();\nbreak;\n} else {\nit.remove();\n}\n}\n}",
            "method_id": 167
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:size()I",
            "method_body": "public int size() {\nif (attributes == null)\nreturn 0;\nreturn attributes.size();\n}",
            "method_id": 168
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:reconstructFormattingElements()V",
            "method_body": "void reconstructFormattingElements() {\nint size = formattingElements.size();\nif (size == 0 || formattingElements.getLast() == null || onStack(formattingElements.getLast()))\nreturn;\n\nElement entry = formattingElements.getLast();\nint pos = size - 1;\nboolean skip = false;\nwhile (true) {\nif (pos == 0) { // step 4. if none before, skip to 8\nskip = true;\nbreak;\n}\nentry = formattingElements.get(--pos); // step 5. one earlier than entry\nif (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\nbreak; // jump to 8, else continue back to 4\n}\nwhile(true) {\nif (!skip) // step 7: on later than entry\nentry = formattingElements.get(++pos);\n\n// 8. create new element from element, 9 insert into current node, onto stack\nskip = false; // can only skip increment from 4.\nElement newEl = insert(entry.nodeName()); // todo: avoid fostering here?\n// newEl.namespace(entry.namespace()); // todo: namespaces\nnewEl.attributes().addAll(entry.attributes());\n\n// 10. replace entry with new entry\nformattingElements.add(pos, newEl);\nformattingElements.remove(pos + 1);\n\n// 11\nif (pos == size-1) // if not last entry in list, jump to 7\nbreak;\n}\n}",
            "method_id": 169
        }
    ]
}