{
    "bug_id": 45,
    "test_id": 0,
    "test_name": "org.jsoup.parser.HtmlParserTest.testReinsertionModeForThCelss",
    "test_body": "@Test public void testReinsertionModeForThCelss() {\nString body = \"<body> <table> <tr> <th> <table><tr><td></td></tr></table> <div> <table><tr><td></td></tr></table> </div> <div></div> <div></div> <div></div> </th> </tr> </table> </body>\";\nDocument doc = Jsoup.parse(body);\nassertEquals(1, doc.body().children().size());\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<1> but was:<5>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:118)\nat org.junit.Assert.assertEquals(Assert.java:555)\nat org.junit.Assert.assertEquals(Assert.java:542)\nat org.jsoup.parser.HtmlParserTest.testReinsertionModeForThCelss(HtmlParserTest.java:877)",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.Jsoup:parse(Ljava/lang/String;)Lorg/jsoup/nodes/Document;",
            "method_body": "public static Document parse(String html) {\nreturn Parser.parse(html, \"\");\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.jsoup.parser.Parser:parse(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Document;",
            "method_body": "public static Document parse(String html, String baseUri) {\nTreeBuilder treeBuilder = new HtmlTreeBuilder();\nreturn treeBuilder.parse(html, baseUri, ParseErrorList.noTracking());\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:initialiseParse(Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/parser/ParseErrorList;)V",
            "method_body": "protected void initialiseParse(String input, String baseUri, ParseErrorList errors) {\nValidate.notNull(input, \"String input must not be null\");\nValidate.notNull(baseUri, \"BaseURI must not be null\");\n\ndoc = new Document(baseUri);\nreader = new CharacterReader(input);\nthis.errors = errors;\ntokeniser = new Tokeniser(reader, errors);\nstack = new ArrayList<Element>(32);\nthis.baseUri = baseUri;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:parse(Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/parser/ParseErrorList;)Lorg/jsoup/nodes/Document;",
            "method_body": "Document parse(String input, String baseUri, ParseErrorList errors) {\ninitialiseParse(input, baseUri, errors);\nrunParser();\nreturn doc;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:runParser()V",
            "method_body": "protected void runParser() {\nwhile (true) {\nToken token = tokeniser.read();\nprocess(token);\ntoken.reset();\n\nif (token.type == Token.TokenType.EOF)\nbreak;\n}\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:processStartTag(Ljava/lang/String;)Z",
            "method_body": "protected abstract boolean process(Token token);\n\nprotected boolean processStartTag(String name) {\nif (currentToken == start) { // don't recycle an in-use token\nreturn process(new Token.StartTag().name(name));\n}\nreturn process(start.reset().name(name));\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:processEndTag(Ljava/lang/String;)Z",
            "method_body": "protected boolean processEndTag(String name) {\nif (currentToken == end) { // don't recycle an in-use token\nreturn process(new Token.EndTag().name(name));\n}\nreturn process(end.reset().name(name));\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:currentElement()Lorg/jsoup/nodes/Element;",
            "method_body": "protected Element currentElement() {\nint size = stack.size();\nreturn size > 0 ? stack.get(size-1) : null;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:<init>()V",
            "method_body": "private HtmlTreeBuilderState state; // the current state\nprivate HtmlTreeBuilderState originalState; // original / marked state\n\nprivate boolean baseUriSetFromDoc = false;\nprivate Element headElement; // the current head element\nprivate FormElement formElement; // the current form element\nprivate Element contextElement; // fragment parse context -- could be null even if fragment parsing\nprivate ArrayList<Element> formattingElements = new ArrayList<Element>(); // active (open) formatting elements\nprivate List<String> pendingTableCharacters = new ArrayList<String>(); // chars in table to be shifted out\nprivate Token.EndTag emptyEnd = new Token.EndTag(); // reused empty end tag\n\nprivate boolean framesetOk = true; // if ok to go into frameset\nprivate boolean fosterInserts = false; // if next inserts should be fostered\nprivate boolean fragmentParsing = false; // if parsing a fragment of html\n\nHtmlTreeBuilder() {}",
            "method_id": 8
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:<clinit>()V",
            "method_body": "private static final String[] TagSearchButton = new String[]{\"button\"};\nprivate static final String[] TagSearchButton = new String[]{\"button\"};",
            "method_id": 9
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:parse(Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/parser/ParseErrorList;)Lorg/jsoup/nodes/Document;",
            "method_body": "Document parse(String input, String baseUri, ParseErrorList errors) {\nstate = HtmlTreeBuilderState.Initial;\nbaseUriSetFromDoc = false;\nreturn super.parse(input, baseUri, errors);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:process(Lorg/jsoup/parser/Token;)Z",
            "method_body": "protected boolean process(Token token) {\ncurrentToken = token;\nreturn this.state.process(token, this);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilderState;)Z",
            "method_body": "boolean process(Token token, HtmlTreeBuilderState state) {\ncurrentToken = token;\nreturn state.process(token, this);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:transition(Lorg/jsoup/parser/HtmlTreeBuilderState;)V",
            "method_body": "void transition(HtmlTreeBuilderState state) {\nthis.state = state;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:markInsertionMode()V",
            "method_body": "void markInsertionMode() {\noriginalState = state;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:originalState()Lorg/jsoup/parser/HtmlTreeBuilderState;",
            "method_body": "HtmlTreeBuilderState originalState() {\nreturn originalState;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:framesetOk(Z)V",
            "method_body": "void framesetOk(boolean framesetOk) {\nthis.framesetOk = framesetOk;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:framesetOk()Z",
            "method_body": "boolean framesetOk() {\nreturn framesetOk;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:getDocument()Lorg/jsoup/nodes/Document;",
            "method_body": "Document getDocument() {\nreturn doc;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:error(Lorg/jsoup/parser/HtmlTreeBuilderState;)V",
            "method_body": "void error(HtmlTreeBuilderState state) {\nif (errors.canAddError())\nerrors.add(new ParseError(reader.pos(), \"Unexpected token [%s] when in state [%s]\", currentToken.tokenType(), state));\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insert(Lorg/jsoup/parser/Token$StartTag;)Lorg/jsoup/nodes/Element;",
            "method_body": "Element insert(Token.StartTag startTag) {\n// handle empty unknown tags\n// when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\nif (startTag.isSelfClosing()) {\nElement el = insertEmpty(startTag);\nstack.add(el);\ntokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\ntokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\nreturn el;\n}\n\nElement el = new Element(Tag.valueOf(startTag.name()), baseUri, startTag.attributes);\ninsert(el);\nreturn el;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insertStartTag(Ljava/lang/String;)Lorg/jsoup/nodes/Element;",
            "method_body": "Element insertStartTag(String startTagName) {\nElement el = new Element(Tag.valueOf(startTagName), baseUri);\ninsert(el);\nreturn el;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insert(Lorg/jsoup/nodes/Element;)V",
            "method_body": "void insert(Element el) {\ninsertNode(el);\nstack.add(el);\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insert(Lorg/jsoup/parser/Token$Character;)V",
            "method_body": "void insert(Token.Character characterToken) {\nNode node;\n// characters in script and style go in as datanodes, not text nodes\nString tagName = currentElement().tagName();\nif (tagName.equals(\"script\") || tagName.equals(\"style\"))\nnode = new DataNode(characterToken.getData(), baseUri);\nelse\nnode = new TextNode(characterToken.getData(), baseUri);\ncurrentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insertNode(Lorg/jsoup/nodes/Node;)V",
            "method_body": "private void insertNode(Node node) {\n// if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\nif (stack.size() == 0)\ndoc.appendChild(node);\nelse if (isFosterInserts())\ninsertInFosterParent(node);\nelse\ncurrentElement().appendChild(node);\n\n// connect form controls to their form element\nif (node instanceof Element && ((Element) node).tag().isFormListed()) {\nif (formElement != null)\nformElement.addElement((Element) node);\n}\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:pop()Lorg/jsoup/nodes/Element;",
            "method_body": "Element pop() {\nint size = stack.size();\nreturn stack.remove(size-1);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:getStack()Ljava/util/ArrayList;",
            "method_body": "ArrayList<Element> getStack() {\nreturn stack;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:popStackToClose(Ljava/lang/String;)V",
            "method_body": "void popStackToClose(String elName) {\nfor (int pos = stack.size() -1; pos >= 0; pos--) {\nElement next = stack.get(pos);\nstack.remove(pos);\nif (next.nodeName().equals(elName))\nbreak;\n}\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:clearStackToTableContext()V",
            "method_body": "void clearStackToTableContext() {\nclearStackToContext(\"table\");\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:clearStackToTableBodyContext()V",
            "method_body": "void clearStackToTableBodyContext() {\nclearStackToContext(\"tbody\", \"tfoot\", \"thead\");\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:clearStackToTableRowContext()V",
            "method_body": "void clearStackToTableRowContext() {\nclearStackToContext(\"tr\");\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:clearStackToContext([Ljava/lang/String;)V",
            "method_body": "private void clearStackToContext(String... nodeNames) {\nfor (int pos = stack.size() -1; pos >= 0; pos--) {\nElement next = stack.get(pos);\nif (StringUtil.in(next.nodeName(), nodeNames) || next.nodeName().equals(\"html\"))\nbreak;\nelse\nstack.remove(pos);\n}\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:resetInsertionMode()V",
            "method_body": "void resetInsertionMode() {\nboolean last = false;\nfor (int pos = stack.size() -1; pos >= 0; pos--) {\nElement node = stack.get(pos);\nif (pos == 0) {\nlast = true;\nnode = contextElement;\n}\nString name = node.nodeName();\nif (\"select\".equals(name)) {\ntransition(HtmlTreeBuilderState.InSelect);\nbreak; // frag\n} else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {\ntransition(HtmlTreeBuilderState.InCell);\nbreak;\n} else if (\"tr\".equals(name)) {\ntransition(HtmlTreeBuilderState.InRow);\nbreak;\n} else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\ntransition(HtmlTreeBuilderState.InTableBody);\nbreak;\n} else if (\"caption\".equals(name)) {\ntransition(HtmlTreeBuilderState.InCaption);\nbreak;\n} else if (\"colgroup\".equals(name)) {\ntransition(HtmlTreeBuilderState.InColumnGroup);\nbreak; // frag\n} else if (\"table\".equals(name)) {\ntransition(HtmlTreeBuilderState.InTable);\nbreak;\n} else if (\"head\".equals(name)) {\ntransition(HtmlTreeBuilderState.InBody);\nbreak; // frag\n} else if (\"body\".equals(name)) {\ntransition(HtmlTreeBuilderState.InBody);\nbreak;\n} else if (\"frameset\".equals(name)) {\ntransition(HtmlTreeBuilderState.InFrameset);\nbreak; // frag\n} else if (\"html\".equals(name)) {\ntransition(HtmlTreeBuilderState.BeforeHead);\nbreak; // frag\n} else if (last) {\ntransition(HtmlTreeBuilderState.InBody);\nbreak; // frag\n}\n}\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inSpecificScope(Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\nspecificScopeTarget[0] = targetName;\nreturn inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inSpecificScope([Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\nfor (int pos = stack.size() -1; pos >= 0; pos--) {\nElement el = stack.get(pos);\nString elName = el.nodeName();\nif (StringUtil.in(elName, targetNames))\nreturn true;\nif (StringUtil.in(elName, baseTypes))\nreturn false;\nif (extraTypes != null && StringUtil.in(elName, extraTypes))\nreturn false;\n}\nValidate.fail(\"Should not be reachable\");\nreturn false;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inScope(Ljava/lang/String;)Z",
            "method_body": "boolean inScope(String targetName) {\nreturn inScope(targetName, null);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inScope(Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "boolean inScope(String targetName, String[] extras) {\nreturn inSpecificScope(targetName, TagsSearchInScope, extras);\n// todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n// todo: in svg namespace: forignOjbect, desc, title\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inButtonScope(Ljava/lang/String;)Z",
            "method_body": "boolean inButtonScope(String targetName) {\nreturn inScope(targetName, TagSearchButton);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inTableScope(Ljava/lang/String;)Z",
            "method_body": "boolean inTableScope(String targetName) {\nreturn inSpecificScope(targetName, TagSearchTableScope, null);\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:setHeadElement(Lorg/jsoup/nodes/Element;)V",
            "method_body": "void setHeadElement(Element headElement) {\nthis.headElement = headElement;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:isFosterInserts()Z",
            "method_body": "boolean isFosterInserts() {\nreturn fosterInserts;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:newPendingTableCharacters()V",
            "method_body": "void newPendingTableCharacters() {\npendingTableCharacters = new ArrayList<String>();\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:getPendingTableCharacters()Ljava/util/List;",
            "method_body": "List<String> getPendingTableCharacters() {\nreturn pendingTableCharacters;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:generateImpliedEndTags(Ljava/lang/String;)V",
            "method_body": "void generateImpliedEndTags(String excludeTag) {\nwhile ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\nStringUtil.in(currentElement().nodeName(), TagSearchEndTags))\npop();\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:generateImpliedEndTags()V",
            "method_body": "void generateImpliedEndTags() {\ngenerateImpliedEndTags(null);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:isSpecial(Lorg/jsoup/nodes/Element;)Z",
            "method_body": "boolean isSpecial(Element el) {\n// todo: mathml's mi, mo, mn\n// todo: svg's foreigObject, desc, title\nString name = el.nodeName();\nreturn StringUtil.in(name, TagSearchSpecial);\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:lastFormattingElement()Lorg/jsoup/nodes/Element;",
            "method_body": "Element lastFormattingElement() {\nreturn formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:removeLastFormattingElement()Lorg/jsoup/nodes/Element;",
            "method_body": "Element removeLastFormattingElement() {\nint size = formattingElements.size();\nif (size > 0)\nreturn formattingElements.remove(size-1);\nelse\nreturn null;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:reconstructFormattingElements()V",
            "method_body": "void reconstructFormattingElements() {\nElement last = lastFormattingElement();\nif (last == null || onStack(last))\nreturn;\n\nElement entry = last;\nint size = formattingElements.size();\nint pos = size - 1;\nboolean skip = false;\nwhile (true) {\nif (pos == 0) { // step 4. if none before, skip to 8\nskip = true;\nbreak;\n}\nentry = formattingElements.get(--pos); // step 5. one earlier than entry\nif (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\nbreak; // jump to 8, else continue back to 4\n}\nwhile(true) {\nif (!skip) // step 7: on later than entry\nentry = formattingElements.get(++pos);\nValidate.notNull(entry); // should not occur, as we break at last element\n\n// 8. create new element from element, 9 insert into current node, onto stack\nskip = false; // can only skip increment from 4.\nElement newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n// newEl.namespace(entry.namespace()); // todo: namespaces\nnewEl.attributes().addAll(entry.attributes());\n\n// 10. replace entry with new entry\nformattingElements.set(pos, newEl);\n\n// 11\nif (pos == size-1) // if not last entry in list, jump to 7\nbreak;\n}\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:clearFormattingElementsToLastMarker()V",
            "method_body": "void clearFormattingElementsToLastMarker() {\nwhile (!formattingElements.isEmpty()) {\nElement el = removeLastFormattingElement();\nif (el == null)\nbreak;\n}\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insertMarkerToFormattingElements()V",
            "method_body": "void insertMarkerToFormattingElements() {\nformattingElements.add(null);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.jsoup.parser.Token:<init>()V",
            "method_body": "private Token() {\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.jsoup.parser.Token:reset(Ljava/lang/StringBuilder;)V",
            "method_body": "abstract Token reset();\n\nstatic void reset(StringBuilder sb) {\nif (sb != null) {\nsb.delete(0, sb.length());\n}\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.jsoup.parser.Token:isDoctype()Z",
            "method_body": "final boolean isDoctype() {\nreturn type == TokenType.Doctype;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.jsoup.parser.Token:isStartTag()Z",
            "method_body": "final boolean isStartTag() {\nreturn type == TokenType.StartTag;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.jsoup.parser.Token:asStartTag()Lorg/jsoup/parser/Token$StartTag;",
            "method_body": "final StartTag asStartTag() {\nreturn (StartTag) this;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.jsoup.parser.Token:isEndTag()Z",
            "method_body": "final boolean isEndTag() {\nreturn type == TokenType.EndTag;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.jsoup.parser.Token:asEndTag()Lorg/jsoup/parser/Token$EndTag;",
            "method_body": "final EndTag asEndTag() {\nreturn (EndTag) this;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.jsoup.parser.Token:isComment()Z",
            "method_body": "final boolean isComment() {\nreturn type == TokenType.Comment;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.jsoup.parser.Token:isCharacter()Z",
            "method_body": "final boolean isCharacter() {\nreturn type == TokenType.Character;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.jsoup.parser.Token:asCharacter()Lorg/jsoup/parser/Token$Character;",
            "method_body": "final Character asCharacter() {\nreturn (Character) this;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.jsoup.parser.Token:isEOF()Z",
            "method_body": "final boolean isEOF() {\nreturn type == TokenType.EOF;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:<init>()V",
            "method_body": "protected String tagName;\nprivate String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\nprivate StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\nprivate boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value\nprivate boolean hasPendingAttributeValue = false;\nboolean selfClosing = false;\nAttributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n@Override\nTag reset() {\ntagName = null;\npendingAttributeName = null;\nreset(pendingAttributeValue);\nhasEmptyAttributeValue = false;\nhasPendingAttributeValue = false;\nselfClosing = false;\nattributes = null;\nreturn this;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:reset()Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Tag reset() {\ntagName = null;\npendingAttributeName = null;\nreset(pendingAttributeValue);\nhasEmptyAttributeValue = false;\nhasPendingAttributeValue = false;\nselfClosing = false;\nattributes = null;\nreturn this;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:finaliseTag()V",
            "method_body": "final void finaliseTag() {\n// finalises for emit\nif (pendingAttributeName != null) {\n// todo: check if attribute name exists; if so, drop and error\nnewAttribute();\n}\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:name()Ljava/lang/String;",
            "method_body": "final String name() {\nValidate.isFalse(tagName == null || tagName.length() == 0);\nreturn tagName;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:name(Ljava/lang/String;)Lorg/jsoup/parser/Token$Tag;",
            "method_body": "final Tag name(String name) {\ntagName = name;\nreturn this;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:isSelfClosing()Z",
            "method_body": "final boolean isSelfClosing() {\nreturn selfClosing;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:appendTagName(Ljava/lang/String;)V",
            "method_body": "final void appendTagName(String append) {\ntagName = tagName == null ? append : tagName.concat(append);\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.jsoup.parser.Token$StartTag:<init>()V",
            "method_body": "StartTag() {\nsuper();\nattributes = new Attributes();\ntype = TokenType.StartTag;\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.jsoup.parser.Token$StartTag:reset()Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Tag reset() {\nsuper.reset();\nattributes = new Attributes();\n// todo - would prefer these to be null, but need to check Element assertions\nreturn this;\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.jsoup.parser.Token$EndTag:<init>()V",
            "method_body": "EndTag() {\nsuper();\ntype = TokenType.EndTag;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.jsoup.parser.ParseErrorList:<init>(II)V",
            "method_body": "ParseErrorList(int initialCapacity, int maxSize) {\nsuper(initialCapacity);\nthis.maxSize = maxSize;\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.jsoup.parser.ParseErrorList:canAddError()Z",
            "method_body": "boolean canAddError() {\nreturn size() < maxSize;\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.jsoup.parser.ParseErrorList:noTracking()Lorg/jsoup/parser/ParseErrorList;",
            "method_body": "static ParseErrorList noTracking() {\nreturn new ParseErrorList(0, 0);\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState:isWhitespace(Lorg/jsoup/parser/Token;)Z",
            "method_body": "abstract boolean process(Token t, HtmlTreeBuilder tb);\n\nprivate static boolean isWhitespace(Token t) {\nif (t.isCharacter()) {\nString data = t.asCharacter().getData();\nreturn isWhitespace(data);\n}\nreturn false;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState:isWhitespace(Ljava/lang/String;)Z",
            "method_body": "private static boolean isWhitespace(String data) {\n// todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\nfor (int i = 0; i < data.length(); i++) {\nchar c = data.charAt(i);\nif (!StringUtil.isWhitespace(c))\nreturn false;\n}\nreturn true;\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$1:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\nreturn true; // ignore whitespace\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (t.isDoctype()) {\n// todo: parse error check on expected doctypes\n// todo: quirk state check on doctype ids\nToken.Doctype d = t.asDoctype();\nDocumentType doctype = new DocumentType(d.getName(), d.getPublicIdentifier(), d.getSystemIdentifier(), tb.getBaseUri());\ntb.getDocument().appendChild(doctype);\nif (d.isForceQuirks())\ntb.getDocument().quirksMode(Document.QuirksMode.quirks);\ntb.transition(BeforeHtml);\n} else {\n// todo: check not iframe srcdoc\ntb.transition(BeforeHtml);\nreturn tb.process(t); // re-process token\n}\nreturn true;\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$2:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (t.isDoctype()) {\ntb.error(this);\nreturn false;\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (isWhitespace(t)) {\nreturn true; // ignore whitespace\n} else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\ntb.insert(t.asStartTag());\ntb.transition(BeforeHead);\n} else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\nreturn anythingElse(t, tb);\n} else if (t.isEndTag()) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$2:anythingElse(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\ntb.insertStartTag(\"html\");\ntb.transition(BeforeHead);\nreturn tb.process(t);\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$3:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\nreturn true;\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (t.isDoctype()) {\ntb.error(this);\nreturn false;\n} else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\nreturn InBody.process(t, tb); // does not transition\n} else if (t.isStartTag() && t.asStartTag().name().equals(\"head\")) {\nElement head = tb.insert(t.asStartTag());\ntb.setHeadElement(head);\ntb.transition(InHead);\n} else if (t.isEndTag() && (StringUtil.in(t.asEndTag().name(), \"head\", \"body\", \"html\", \"br\"))) {\ntb.processStartTag(\"head\");\nreturn tb.process(t);\n} else if (t.isEndTag()) {\ntb.error(this);\nreturn false;\n} else {\ntb.processStartTag(\"head\");\nreturn tb.process(t);\n}\nreturn true;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$4:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\ntb.insert(t.asCharacter());\nreturn true;\n}\nswitch (t.type) {\ncase Comment:\ntb.insert(t.asComment());\nbreak;\ncase Doctype:\ntb.error(this);\nreturn false;\ncase StartTag:\nToken.StartTag start = t.asStartTag();\nString name = start.name();\nif (name.equals(\"html\")) {\nreturn InBody.process(t, tb);\n} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\nElement el = tb.insertEmpty(start);\n// jsoup special: update base the frist time it is seen\nif (name.equals(\"base\") && el.hasAttr(\"href\"))\ntb.maybeSetBaseUri(el);\n} else if (name.equals(\"meta\")) {\nElement meta = tb.insertEmpty(start);\n// todo: charset switches\n} else if (name.equals(\"title\")) {\nhandleRcData(start, tb);\n} else if (StringUtil.in(name, \"noframes\", \"style\")) {\nhandleRawtext(start, tb);\n} else if (name.equals(\"noscript\")) {\n// else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)\ntb.insert(start);\ntb.transition(InHeadNoscript);\n} else if (name.equals(\"script\")) {\n// skips some script rules as won't execute them\n\ntb.tokeniser.transition(TokeniserState.ScriptData);\ntb.markInsertionMode();\ntb.transition(Text);\ntb.insert(start);\n} else if (name.equals(\"head\")) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\nbreak;\ncase EndTag:\nToken.EndTag end = t.asEndTag();\nname = end.name();\nif (name.equals(\"head\")) {\ntb.pop();\ntb.transition(AfterHead);\n} else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\nreturn anythingElse(t, tb);\n} else {\ntb.error(this);\nreturn false;\n}\nbreak;\ndefault:\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$4:anythingElse(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "private boolean anythingElse(Token t, TreeBuilder tb) {\ntb.processEndTag(\"head\");\nreturn tb.process(t);\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$6:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\ntb.insert(t.asCharacter());\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (t.isDoctype()) {\ntb.error(this);\n} else if (t.isStartTag()) {\nToken.StartTag startTag = t.asStartTag();\nString name = startTag.name();\nif (name.equals(\"html\")) {\nreturn tb.process(t, InBody);\n} else if (name.equals(\"body\")) {\ntb.insert(startTag);\ntb.framesetOk(false);\ntb.transition(InBody);\n} else if (name.equals(\"frameset\")) {\ntb.insert(startTag);\ntb.transition(InFrameset);\n} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\ntb.error(this);\nElement head = tb.getHeadElement();\ntb.push(head);\ntb.process(t, InHead);\ntb.removeFromStack(head);\n} else if (name.equals(\"head\")) {\ntb.error(this);\nreturn false;\n} else {\nanythingElse(t, tb);\n}\n} else if (t.isEndTag()) {\nif (StringUtil.in(t.asEndTag().name(), \"body\", \"html\")) {\nanythingElse(t, tb);\n} else {\ntb.error(this);\nreturn false;\n}\n} else {\nanythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$7:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nswitch (t.type) {\ncase Character: {\nToken.Character c = t.asCharacter();\nif (c.getData().equals(nullString)) {\n// todo confirm that check\ntb.error(this);\nreturn false;\n} else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\ntb.reconstructFormattingElements();\ntb.insert(c);\n} else {\ntb.reconstructFormattingElements();\ntb.insert(c);\ntb.framesetOk(false);\n}\nbreak;\n}\ncase Comment: {\ntb.insert(t.asComment());\nbreak;\n}\ncase Doctype: {\ntb.error(this);\nreturn false;\n}\ncase StartTag:\nToken.StartTag startTag = t.asStartTag();\nString name = startTag.name();\nif (name.equals(\"html\")) {\ntb.error(this);\n// merge attributes onto real html\nElement html = tb.getStack().get(0);\nfor (Attribute attribute : startTag.getAttributes()) {\nif (!html.hasAttr(attribute.getKey()))\nhtml.attributes().put(attribute);\n}\n} else if (StringUtil.in(name, Constants.InBodyStartToHead)) {\nreturn tb.process(t, InHead);\n} else if (name.equals(\"body\")) {\ntb.error(this);\nArrayList<Element> stack = tb.getStack();\nif (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n// only in fragment case\nreturn false; // ignore\n} else {\ntb.framesetOk(false);\nElement body = stack.get(1);\nfor (Attribute attribute : startTag.getAttributes()) {\nif (!body.hasAttr(attribute.getKey()))\nbody.attributes().put(attribute);\n}\n}\n} else if (name.equals(\"frameset\")) {\ntb.error(this);\nArrayList<Element> stack = tb.getStack();\nif (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n// only in fragment case\nreturn false; // ignore\n} else if (!tb.framesetOk()) {\nreturn false; // ignore frameset\n} else {\nElement second = stack.get(1);\nif (second.parent() != null)\nsecond.remove();\n// pop up to html element\nwhile (stack.size() > 1)\nstack.remove(stack.size()-1);\ntb.insert(startTag);\ntb.transition(InFrameset);\n}\n} else if (StringUtil.in(name, Constants.InBodyStartPClosers)) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\n} else if (StringUtil.in(name, Constants.Headings)) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\nif (StringUtil.in(tb.currentElement().nodeName(), Constants.Headings)) {\ntb.error(this);\ntb.pop();\n}\ntb.insert(startTag);\n} else if (StringUtil.in(name, Constants.InBodyStartPreListing)) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\n// todo: ignore LF if next token\ntb.framesetOk(false);\n} else if (name.equals(\"form\")) {\nif (tb.getFormElement() != null) {\ntb.error(this);\nreturn false;\n}\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insertForm(startTag, true);\n} else if (name.equals(\"li\")) {\ntb.framesetOk(false);\nArrayList<Element> stack = tb.getStack();\nfor (int i = stack.size() - 1; i > 0; i--) {\nElement el = stack.get(i);\nif (el.nodeName().equals(\"li\")) {\ntb.processEndTag(\"li\");\nbreak;\n}\nif (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\nbreak;\n}\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\n} else if (StringUtil.in(name, Constants.DdDt)) {\ntb.framesetOk(false);\nArrayList<Element> stack = tb.getStack();\nfor (int i = stack.size() - 1; i > 0; i--) {\nElement el = stack.get(i);\nif (StringUtil.in(el.nodeName(), Constants.DdDt)) {\ntb.processEndTag(el.nodeName());\nbreak;\n}\nif (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), Constants.InBodyStartLiBreakers))\nbreak;\n}\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\n} else if (name.equals(\"plaintext\")) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\ntb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n} else if (name.equals(\"button\")) {\nif (tb.inButtonScope(\"button\")) {\n// close and reprocess\ntb.error(this);\ntb.processEndTag(\"button\");\ntb.process(startTag);\n} else {\ntb.reconstructFormattingElements();\ntb.insert(startTag);\ntb.framesetOk(false);\n}\n} else if (name.equals(\"a\")) {\nif (tb.getActiveFormattingElement(\"a\") != null) {\ntb.error(this);\ntb.processEndTag(\"a\");\n\n// still on stack?\nElement remainingA = tb.getFromStack(\"a\");\nif (remainingA != null) {\ntb.removeFromActiveFormattingElements(remainingA);\ntb.removeFromStack(remainingA);\n}\n}\ntb.reconstructFormattingElements();\nElement a = tb.insert(startTag);\ntb.pushActiveFormattingElements(a);\n} else if (StringUtil.in(name, Constants.Formatters)) {\ntb.reconstructFormattingElements();\nElement el = tb.insert(startTag);\ntb.pushActiveFormattingElements(el);\n} else if (name.equals(\"nobr\")) {\ntb.reconstructFormattingElements();\nif (tb.inScope(\"nobr\")) {\ntb.error(this);\ntb.processEndTag(\"nobr\");\ntb.reconstructFormattingElements();\n}\nElement el = tb.insert(startTag);\ntb.pushActiveFormattingElements(el);\n} else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\ntb.reconstructFormattingElements();\ntb.insert(startTag);\ntb.insertMarkerToFormattingElements();\ntb.framesetOk(false);\n} else if (name.equals(\"table\")) {\nif (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\ntb.framesetOk(false);\ntb.transition(InTable);\n} else if (StringUtil.in(name, Constants.InBodyStartEmptyFormatters)) {\ntb.reconstructFormattingElements();\ntb.insertEmpty(startTag);\ntb.framesetOk(false);\n} else if (name.equals(\"input\")) {\ntb.reconstructFormattingElements();\nElement el = tb.insertEmpty(startTag);\nif (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\ntb.framesetOk(false);\n} else if (StringUtil.in(name, Constants.InBodyStartMedia)) {\ntb.insertEmpty(startTag);\n} else if (name.equals(\"hr\")) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insertEmpty(startTag);\ntb.framesetOk(false);\n} else if (name.equals(\"image\")) {\nif (tb.getFromStack(\"svg\") == null)\nreturn tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\nelse\ntb.insert(startTag);\n} else if (name.equals(\"isindex\")) {\n// how much do we care about the early 90s?\ntb.error(this);\nif (tb.getFormElement() != null)\nreturn false;\n\ntb.tokeniser.acknowledgeSelfClosingFlag();\ntb.processStartTag(\"form\");\nif (startTag.attributes.hasKey(\"action\")) {\nElement form = tb.getFormElement();\nform.attr(\"action\", startTag.attributes.get(\"action\"));\n}\ntb.processStartTag(\"hr\");\ntb.processStartTag(\"label\");\n// hope you like english.\nString prompt = startTag.attributes.hasKey(\"prompt\") ?\nstartTag.attributes.get(\"prompt\") :\n\"This is a searchable index. Enter search keywords: \";\n\ntb.process(new Token.Character().data(prompt));\n\n// input\nAttributes inputAttribs = new Attributes();\nfor (Attribute attr : startTag.attributes) {\nif (!StringUtil.in(attr.getKey(), Constants.InBodyStartInputAttribs))\ninputAttribs.put(attr);\n}\ninputAttribs.put(\"name\", \"isindex\");\ntb.processStartTag(\"input\", inputAttribs);\ntb.processEndTag(\"label\");\ntb.processStartTag(\"hr\");\ntb.processEndTag(\"form\");\n} else if (name.equals(\"textarea\")) {\ntb.insert(startTag);\n// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\ntb.tokeniser.transition(TokeniserState.Rcdata);\ntb.markInsertionMode();\ntb.framesetOk(false);\ntb.transition(Text);\n} else if (name.equals(\"xmp\")) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.reconstructFormattingElements();\ntb.framesetOk(false);\nhandleRawtext(startTag, tb);\n} else if (name.equals(\"iframe\")) {\ntb.framesetOk(false);\nhandleRawtext(startTag, tb);\n} else if (name.equals(\"noembed\")) {\n// also handle noscript if script enabled\nhandleRawtext(startTag, tb);\n} else if (name.equals(\"select\")) {\ntb.reconstructFormattingElements();\ntb.insert(startTag);\ntb.framesetOk(false);\n\nHtmlTreeBuilderState state = tb.state();\nif (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\ntb.transition(InSelectInTable);\nelse\ntb.transition(InSelect);\n} else if (StringUtil.in(name, Constants.InBodyStartOptions)) {\nif (tb.currentElement().nodeName().equals(\"option\"))\ntb.processEndTag(\"option\");\ntb.reconstructFormattingElements();\ntb.insert(startTag);\n} else if (StringUtil.in(name, Constants.InBodyStartRuby)) {\nif (tb.inScope(\"ruby\")) {\ntb.generateImpliedEndTags();\nif (!tb.currentElement().nodeName().equals(\"ruby\")) {\ntb.error(this);\ntb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n}\ntb.insert(startTag);\n}\n} else if (name.equals(\"math\")) {\ntb.reconstructFormattingElements();\n// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\ntb.insert(startTag);\ntb.tokeniser.acknowledgeSelfClosingFlag();\n} else if (name.equals(\"svg\")) {\ntb.reconstructFormattingElements();\n// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\ntb.insert(startTag);\ntb.tokeniser.acknowledgeSelfClosingFlag();\n} else if (StringUtil.in(name, Constants.InBodyStartDrop)) {\ntb.error(this);\nreturn false;\n} else {\ntb.reconstructFormattingElements();\ntb.insert(startTag);\n}\nbreak;\n\ncase EndTag:\nToken.EndTag endTag = t.asEndTag();\nname = endTag.name();\nif (name.equals(\"body\")) {\nif (!tb.inScope(\"body\")) {\ntb.error(this);\nreturn false;\n} else {\n// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\ntb.transition(AfterBody);\n}\n} else if (name.equals(\"html\")) {\nboolean notIgnored = tb.processEndTag(\"body\");\nif (notIgnored)\nreturn tb.process(endTag);\n} else if (StringUtil.in(name, Constants.InBodyEndClosers)) {\nif (!tb.inScope(name)) {\n// nothing to close\ntb.error(this);\nreturn false;\n} else {\ntb.generateImpliedEndTags();\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(name);\n}\n} else if (name.equals(\"form\")) {\nElement currentForm = tb.getFormElement();\ntb.setFormElement(null);\nif (currentForm == null || !tb.inScope(name)) {\ntb.error(this);\nreturn false;\n} else {\ntb.generateImpliedEndTags();\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\n// remove currentForm from stack. will shift anything under up.\ntb.removeFromStack(currentForm);\n}\n} else if (name.equals(\"p\")) {\nif (!tb.inButtonScope(name)) {\ntb.error(this);\ntb.processStartTag(name); // if no p to close, creates an empty <p></p>\nreturn tb.process(endTag);\n} else {\ntb.generateImpliedEndTags(name);\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(name);\n}\n} else if (name.equals(\"li\")) {\nif (!tb.inListItemScope(name)) {\ntb.error(this);\nreturn false;\n} else {\ntb.generateImpliedEndTags(name);\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(name);\n}\n} else if (StringUtil.in(name, Constants.DdDt)) {\nif (!tb.inScope(name)) {\ntb.error(this);\nreturn false;\n} else {\ntb.generateImpliedEndTags(name);\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(name);\n}\n} else if (StringUtil.in(name, Constants.Headings)) {\nif (!tb.inScope(Constants.Headings)) {\ntb.error(this);\nreturn false;\n} else {\ntb.generateImpliedEndTags(name);\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(Constants.Headings);\n}\n} else if (name.equals(\"sarcasm\")) {\n// *sigh*\nreturn anyOtherEndTag(t, tb);\n} else if (StringUtil.in(name, Constants.InBodyEndAdoptionFormatters)) {\n// Adoption Agency Algorithm.\nfor (int i = 0; i < 8; i++) {\nElement formatEl = tb.getActiveFormattingElement(name);\nif (formatEl == null)\nreturn anyOtherEndTag(t, tb);\nelse if (!tb.onStack(formatEl)) {\ntb.error(this);\ntb.removeFromActiveFormattingElements(formatEl);\nreturn true;\n} else if (!tb.inScope(formatEl.nodeName())) {\ntb.error(this);\nreturn false;\n} else if (tb.currentElement() != formatEl)\ntb.error(this);\n\nElement furthestBlock = null;\nElement commonAncestor = null;\nboolean seenFormattingElement = false;\nArrayList<Element> stack = tb.getStack();\n// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n// run-aways\nfinal int stackSize = stack.size();\nfor (int si = 0; si < stackSize && si < 64; si++) {\nElement el = stack.get(si);\nif (el == formatEl) {\ncommonAncestor = stack.get(si - 1);\nseenFormattingElement = true;\n} else if (seenFormattingElement && tb.isSpecial(el)) {\nfurthestBlock = el;\nbreak;\n}\n}\nif (furthestBlock == null) {\ntb.popStackToClose(formatEl.nodeName());\ntb.removeFromActiveFormattingElements(formatEl);\nreturn true;\n}\n\n// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n// does that mean: int pos of format el in list?\nElement node = furthestBlock;\nElement lastNode = furthestBlock;\nfor (int j = 0; j < 3; j++) {\nif (tb.onStack(node))\nnode = tb.aboveOnStack(node);\nif (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\ntb.removeFromStack(node);\ncontinue;\n} else if (node == formatEl)\nbreak;\n\nElement replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri());\ntb.replaceActiveFormattingElement(node, replacement);\ntb.replaceOnStack(node, replacement);\nnode = replacement;\n\nif (lastNode == furthestBlock) {\n// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n// not getting how this bookmark both straddles the element above, but is inbetween here...\n}\nif (lastNode.parent() != null)\nlastNode.remove();\nnode.appendChild(lastNode);\n\nlastNode = node;\n}\n\nif (StringUtil.in(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\nif (lastNode.parent() != null)\nlastNode.remove();\ntb.insertInFosterParent(lastNode);\n} else {\nif (lastNode.parent() != null)\nlastNode.remove();\ncommonAncestor.appendChild(lastNode);\n}\n\nElement adopter = new Element(formatEl.tag(), tb.getBaseUri());\nadopter.attributes().addAll(formatEl.attributes());\nNode[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\nfor (Node childNode : childNodes) {\nadopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n}\nfurthestBlock.appendChild(adopter);\ntb.removeFromActiveFormattingElements(formatEl);\n// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\ntb.removeFromStack(formatEl);\ntb.insertOnStackAfter(furthestBlock, adopter);\n}\n} else if (StringUtil.in(name, Constants.InBodyStartApplets)) {\nif (!tb.inScope(\"name\")) {\nif (!tb.inScope(name)) {\ntb.error(this);\nreturn false;\n}\ntb.generateImpliedEndTags();\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(name);\ntb.clearFormattingElementsToLastMarker();\n}\n} else if (name.equals(\"br\")) {\ntb.error(this);\ntb.processStartTag(\"br\");\nreturn false;\n} else {\nreturn anyOtherEndTag(t, tb);\n}\n\nbreak;\ncase EOF:\n// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n// stop parsing\nbreak;\n}\nreturn true;\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$7:anyOtherEndTag(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\nString name = t.asEndTag().name();\nArrayList<Element> stack = tb.getStack();\nfor (int pos = stack.size() -1; pos >= 0; pos--) {\nElement node = stack.get(pos);\nif (node.nodeName().equals(name)) {\ntb.generateImpliedEndTags(name);\nif (!name.equals(tb.currentElement().nodeName()))\ntb.error(this);\ntb.popStackToClose(name);\nbreak;\n} else {\nif (tb.isSpecial(node)) {\ntb.error(this);\nreturn false;\n}\n}\n}\nreturn true;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$9:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (t.isCharacter()) {\ntb.newPendingTableCharacters();\ntb.markInsertionMode();\ntb.transition(InTableText);\nreturn tb.process(t);\n} else if (t.isComment()) {\ntb.insert(t.asComment());\nreturn true;\n} else if (t.isDoctype()) {\ntb.error(this);\nreturn false;\n} else if (t.isStartTag()) {\nToken.StartTag startTag = t.asStartTag();\nString name = startTag.name();\nif (name.equals(\"caption\")) {\ntb.clearStackToTableContext();\ntb.insertMarkerToFormattingElements();\ntb.insert(startTag);\ntb.transition(InCaption);\n} else if (name.equals(\"colgroup\")) {\ntb.clearStackToTableContext();\ntb.insert(startTag);\ntb.transition(InColumnGroup);\n} else if (name.equals(\"col\")) {\ntb.processStartTag(\"colgroup\");\nreturn tb.process(t);\n} else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\ntb.clearStackToTableContext();\ntb.insert(startTag);\ntb.transition(InTableBody);\n} else if (StringUtil.in(name, \"td\", \"th\", \"tr\")) {\ntb.processStartTag(\"tbody\");\nreturn tb.process(t);\n} else if (name.equals(\"table\")) {\ntb.error(this);\nboolean processed = tb.processEndTag(\"table\");\nif (processed) // only ignored if in fragment\nreturn tb.process(t);\n} else if (StringUtil.in(name, \"style\", \"script\")) {\nreturn tb.process(t, InHead);\n} else if (name.equals(\"input\")) {\nif (!startTag.attributes.get(\"type\").equalsIgnoreCase(\"hidden\")) {\nreturn anythingElse(t, tb);\n} else {\ntb.insertEmpty(startTag);\n}\n} else if (name.equals(\"form\")) {\ntb.error(this);\nif (tb.getFormElement() != null)\nreturn false;\nelse {\ntb.insertForm(startTag, false);\n}\n} else {\nreturn anythingElse(t, tb);\n}\nreturn true; // todo: check if should return processed http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#parsing-main-intable\n} else if (t.isEndTag()) {\nToken.EndTag endTag = t.asEndTag();\nString name = endTag.name();\n\nif (name.equals(\"table\")) {\nif (!tb.inTableScope(name)) {\ntb.error(this);\nreturn false;\n} else {\ntb.popStackToClose(\"table\");\n}\ntb.resetInsertionMode();\n} else if (StringUtil.in(name,\n\"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\nreturn true; // todo: as above todo\n} else if (t.isEOF()) {\nif (tb.currentElement().nodeName().equals(\"html\"))\ntb.error(this);\nreturn true; // stops parsing\n}\nreturn anythingElse(t, tb);\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$9:anythingElse(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean anythingElse(Token t, HtmlTreeBuilder tb) {\ntb.error(this);\nboolean processed;\nif (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\ntb.setFosterInserts(true);\nprocessed = tb.process(t, InBody);\ntb.setFosterInserts(false);\n} else {\nprocessed = tb.process(t, InBody);\n}\nreturn processed;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$10:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nswitch (t.type) {\ncase Character:\nToken.Character c = t.asCharacter();\nif (c.getData().equals(nullString)) {\ntb.error(this);\nreturn false;\n} else {\ntb.getPendingTableCharacters().add(c.getData());\n}\nbreak;\ndefault:\n// todo - don't really like the way these table character data lists are built\nif (tb.getPendingTableCharacters().size() > 0) {\nfor (String character : tb.getPendingTableCharacters()) {\nif (!isWhitespace(character)) {\n// InTable anything else section:\ntb.error(this);\nif (StringUtil.in(tb.currentElement().nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\ntb.setFosterInserts(true);\ntb.process(new Token.Character().data(character), InBody);\ntb.setFosterInserts(false);\n} else {\ntb.process(new Token.Character().data(character), InBody);\n}\n} else\ntb.insert(new Token.Character().data(character));\n}\ntb.newPendingTableCharacters();\n}\ntb.transition(tb.originalState());\nreturn tb.process(t);\n}\nreturn true;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$13:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nswitch (t.type) {\ncase StartTag:\nToken.StartTag startTag = t.asStartTag();\nString name = startTag.name();\nif (name.equals(\"tr\")) {\ntb.clearStackToTableBodyContext();\ntb.insert(startTag);\ntb.transition(InRow);\n} else if (StringUtil.in(name, \"th\", \"td\")) {\ntb.error(this);\ntb.processStartTag(\"tr\");\nreturn tb.process(startTag);\n} else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\")) {\nreturn exitTableBody(t, tb);\n} else\nreturn anythingElse(t, tb);\nbreak;\ncase EndTag:\nToken.EndTag endTag = t.asEndTag();\nname = endTag.name();\nif (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\nif (!tb.inTableScope(name)) {\ntb.error(this);\nreturn false;\n} else {\ntb.clearStackToTableBodyContext();\ntb.pop();\ntb.transition(InTable);\n}\n} else if (name.equals(\"table\")) {\nreturn exitTableBody(t, tb);\n} else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\", \"tr\")) {\ntb.error(this);\nreturn false;\n} else\nreturn anythingElse(t, tb);\nbreak;\ndefault:\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$13:exitTableBody(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "private boolean exitTableBody(Token t, HtmlTreeBuilder tb) {\nif (!(tb.inTableScope(\"tbody\") || tb.inTableScope(\"thead\") || tb.inScope(\"tfoot\"))) {\n// frag case\ntb.error(this);\nreturn false;\n}\ntb.clearStackToTableBodyContext();\ntb.processEndTag(tb.currentElement().nodeName()); // tbody, tfoot, thead\nreturn tb.process(t);\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$14:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (t.isStartTag()) {\nToken.StartTag startTag = t.asStartTag();\nString name = startTag.name();\n\nif (StringUtil.in(name, \"th\", \"td\")) {\ntb.clearStackToTableRowContext();\ntb.insert(startTag);\ntb.transition(InCell);\ntb.insertMarkerToFormattingElements();\n} else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\nreturn handleMissingTr(t, tb);\n} else {\nreturn anythingElse(t, tb);\n}\n} else if (t.isEndTag()) {\nToken.EndTag endTag = t.asEndTag();\nString name = endTag.name();\n\nif (name.equals(\"tr\")) {\nif (!tb.inTableScope(name)) {\ntb.error(this); // frag\nreturn false;\n}\ntb.clearStackToTableRowContext();\ntb.pop(); // tr\ntb.transition(InTableBody);\n} else if (name.equals(\"table\")) {\nreturn handleMissingTr(t, tb);\n} else if (StringUtil.in(name, \"tbody\", \"tfoot\", \"thead\")) {\nif (!tb.inTableScope(name)) {\ntb.error(this);\nreturn false;\n}\ntb.processEndTag(\"tr\");\nreturn tb.process(t);\n} else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\", \"td\", \"th\")) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\n} else {\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$14:anythingElse(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\nreturn tb.process(t, InTable);\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$14:handleMissingTr(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/TreeBuilder;)Z",
            "method_body": "private boolean handleMissingTr(Token t, TreeBuilder tb) {\nboolean processed = tb.processEndTag(\"tr\");\nif (processed)\nreturn tb.process(t);\nelse\nreturn false;\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$15:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (t.isEndTag()) {\nToken.EndTag endTag = t.asEndTag();\nString name = endTag.name();\n\nif (StringUtil.in(name, \"td\", \"th\")) {\nif (!tb.inTableScope(name)) {\ntb.error(this);\ntb.transition(InRow); // might not be in scope if empty: <td /> and processing fake end tag\nreturn false;\n}\ntb.generateImpliedEndTags();\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(name);\ntb.clearFormattingElementsToLastMarker();\ntb.transition(InRow);\n} else if (StringUtil.in(name, \"body\", \"caption\", \"col\", \"colgroup\", \"html\")) {\ntb.error(this);\nreturn false;\n} else if (StringUtil.in(name, \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) {\nif (!tb.inTableScope(name)) {\ntb.error(this);\nreturn false;\n}\ncloseCell(tb);\nreturn tb.process(t);\n} else {\nreturn anythingElse(t, tb);\n}\n} else if (t.isStartTag() &&\nStringUtil.in(t.asStartTag().name(),\n\"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) {\nif (!(tb.inTableScope(\"td\") || tb.inTableScope(\"th\"))) {\ntb.error(this);\nreturn false;\n}\ncloseCell(tb);\nreturn tb.process(t);\n} else {\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$15:anythingElse(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "private boolean anythingElse(Token t, HtmlTreeBuilder tb) {\nreturn tb.process(t, InBody);\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$18:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\nreturn tb.process(t, InBody);\n} else if (t.isComment()) {\ntb.insert(t.asComment()); // into html node\n} else if (t.isDoctype()) {\ntb.error(this);\nreturn false;\n} else if (t.isStartTag() && t.asStartTag().name().equals(\"html\")) {\nreturn tb.process(t, InBody);\n} else if (t.isEndTag() && t.asEndTag().name().equals(\"html\")) {\nif (tb.isFragmentParsing()) {\ntb.error(this);\nreturn false;\n} else {\ntb.transition(AfterAfterBody);\n}\n} else if (t.isEOF()) {\n// chillax! we're done\n} else {\ntb.error(this);\ntb.transition(InBody);\nreturn tb.process(t);\n}\nreturn true;\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notNull(Ljava/lang/Object;)V",
            "method_body": "public static void notNull(Object obj) {\nif (obj == null)\nthrow new IllegalArgumentException(\"Object must not be null\");\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notNull(Ljava/lang/Object;Ljava/lang/String;)V",
            "method_body": "public static void notNull(Object obj, String msg) {\nif (obj == null)\nthrow new IllegalArgumentException(msg);\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isFalse(Z)V",
            "method_body": "public static void isFalse(boolean val) {\nif (val)\nthrow new IllegalArgumentException(\"Must be false\");\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isFalse(ZLjava/lang/String;)V",
            "method_body": "public static void isFalse(boolean val, String msg) {\nif (val)\nthrow new IllegalArgumentException(msg);\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notEmpty(Ljava/lang/String;)V",
            "method_body": "public static void notEmpty(String string) {\nif (string == null || string.length() == 0)\nthrow new IllegalArgumentException(\"String must not be empty\");\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.jsoup.nodes.Node:<init>(Ljava/lang/String;Lorg/jsoup/nodes/Attributes;)V",
            "method_body": "protected Node(String baseUri, Attributes attributes) {\nValidate.notNull(baseUri);\nValidate.notNull(attributes);\n\nchildNodes = new ArrayList<Node>(4);\nthis.baseUri = baseUri.trim();\nthis.attributes = attributes;\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.jsoup.nodes.Node:<init>()V",
            "method_body": "protected Node() {\nchildNodes = Collections.emptyList();\nattributes = null;\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.jsoup.nodes.Node:setParentNode(Lorg/jsoup/nodes/Node;)V",
            "method_body": "protected void setParentNode(Node parentNode) {\nif (this.parentNode != null)\nthis.parentNode.removeChild(this);\nthis.parentNode = parentNode;\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.jsoup.nodes.Node:reparentChild(Lorg/jsoup/nodes/Node;)V",
            "method_body": "protected void reparentChild(Node child) {\nif (child.parentNode != null)\nchild.parentNode.removeChild(child);\nchild.setParentNode(this);\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.jsoup.nodes.Node:setSiblingIndex(I)V",
            "method_body": "protected void setSiblingIndex(int siblingIndex) {\nthis.siblingIndex = siblingIndex;\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<init>(Lorg/jsoup/parser/Tag;Ljava/lang/String;Lorg/jsoup/nodes/Attributes;)V",
            "method_body": "public Element(Tag tag, String baseUri, Attributes attributes) {\nsuper(baseUri, attributes);\n\nValidate.notNull(tag);\nthis.tag = tag;\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<init>(Lorg/jsoup/parser/Tag;Ljava/lang/String;)V",
            "method_body": "public Element(Tag tag, String baseUri) {\nthis(tag, baseUri, new Attributes());\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<clinit>()V",
            "method_body": "private Tag tag;\n\nprivate static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\n\n/**\n* Create a new, standalone Element. (Standalone in that is has no parent.)\n*\n* @param tag tag of this element\n* @param baseUri the base URI\n* @param attributes initial attributes\n* @see #appendChild(Node)\n* @see #appendElement(String)\n*/\npublic Element(Tag tag, String baseUri, Attributes attributes) {\nsuper(baseUri, attributes);\n\nValidate.notNull(tag);\nthis.tag = tag;\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.jsoup.nodes.Element:nodeName()Ljava/lang/String;",
            "method_body": "public String nodeName() {\nreturn tag.getName();\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.jsoup.nodes.Element:tagName()Ljava/lang/String;",
            "method_body": "public String tagName() {\nreturn tag.getName();\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.jsoup.nodes.Element:tag()Lorg/jsoup/parser/Tag;",
            "method_body": "public Tag tag() {\nreturn tag;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.jsoup.nodes.Element:children()Lorg/jsoup/select/Elements;",
            "method_body": "public Elements children() {\n// create on the fly rather than maintaining two lists. if gets slow, memoize, and mark dirty on change\nList<Element> elements = new ArrayList<Element>(childNodes.size());\nfor (Node node : childNodes) {\nif (node instanceof Element)\nelements.add((Element) node);\n}\nreturn new Elements(elements);\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.jsoup.nodes.Element:appendChild(Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Element;",
            "method_body": "public Element appendChild(Node child) {\nValidate.notNull(child);\n\n// was - Node#addChildren(child). short-circuits an array create and a loop.\nreparentChild(child);\nchildNodes.add(child);\nchild.setSiblingIndex(childNodes.size() - 1);\nreturn this;\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.jsoup.nodes.Document:<init>(Ljava/lang/String;)V",
            "method_body": "public Document(String baseUri) {\nsuper(Tag.valueOf(\"#root\"), baseUri);\nthis.location = baseUri;\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.jsoup.nodes.Document:body()Lorg/jsoup/nodes/Element;",
            "method_body": "public Element body() {\nreturn findFirstElementByTagName(\"body\", this);\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.jsoup.nodes.Document:findFirstElementByTagName(Ljava/lang/String;Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Element;",
            "method_body": "private Element findFirstElementByTagName(String tag, Node node) {\nif (node.nodeName().equals(tag))\nreturn (Element) node;\nelse {\nfor (Node child: node.childNodes) {\nElement found = findFirstElementByTagName(tag, child);\nif (found != null)\nreturn found;\n}\n}\nreturn null;\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.jsoup.nodes.Document:nodeName()Ljava/lang/String;",
            "method_body": "public String nodeName() {\nreturn \"#document\";\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.jsoup.nodes.Document:quirksMode()Lorg/jsoup/nodes/Document$QuirksMode;",
            "method_body": "public QuirksMode quirksMode() {\nreturn quirksMode;\n}",
            "method_id": 119
        },
        {
            "method_signature": "org.jsoup.parser.Tag:<init>(Ljava/lang/String;)V",
            "method_body": "private static final Map<String, Tag> tags = new HashMap<String, Tag>(); // map of known tags\n\nprivate String tagName;\nprivate boolean isBlock = true; // block or inline\nprivate boolean formatAsBlock = true; // should be formatted as a block\nprivate boolean canContainBlock = true; // Can this tag hold block level tags?\nprivate boolean canContainInline = true; // only pcdata if not\nprivate boolean empty = false; // can hold nothing; e.g. img\nprivate boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.\nprivate boolean preserveWhitespace = false; // for pre, textarea, script etc\nprivate boolean formList = false; // a control that appears in forms: input, textarea, output etc\nprivate boolean formSubmit = false; // a control that can be submitted in a form: input etc\n\nprivate Tag(String tagName) {\nthis.tagName = tagName.toLowerCase();\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.jsoup.parser.Tag:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn tagName;\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.jsoup.parser.Tag:valueOf(Ljava/lang/String;)Lorg/jsoup/parser/Tag;",
            "method_body": "public static Tag valueOf(String tagName) {\nValidate.notNull(tagName);\nTag tag = tags.get(tagName);\n\nif (tag == null) {\ntagName = tagName.trim().toLowerCase();\nValidate.notEmpty(tagName);\ntag = tags.get(tagName);\n\nif (tag == null) {\n// not defined: create default; go anywhere, do anything! (incl be inside a <p>)\ntag = new Tag(tagName);\ntag.isBlock = false;\ntag.canContainBlock = true;\n}\n}\nreturn tag;\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.jsoup.parser.Tag:isFormListed()Z",
            "method_body": "public boolean isFormListed() {\nreturn formList;\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.jsoup.parser.Tag:register(Lorg/jsoup/parser/Tag;)V",
            "method_body": "private static void register(Tag tag) {\ntags.put(tag.tagName, tag);\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:<init>()V",
            "method_body": "private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;\nprivate Charset charset = Charset.forName(\"UTF-8\");\nprivate CharsetEncoder charsetEncoder = charset.newEncoder();\nprivate boolean prettyPrint = true;\nprivate boolean outline = false;\nprivate int indentAmount = 1;\nprivate Syntax syntax = Syntax.html;\n\npublic OutputSettings() {}",
            "method_id": 125
        },
        {
            "method_signature": "org.jsoup.nodes.Entities$EscapeMode:<init>(Ljava/lang/String;ILjava/util/Map;)V",
            "method_body": "EscapeMode(Map<Character, String> map) {\nthis.map = map;\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:loadEntities(Ljava/lang/String;)Ljava/util/Map;",
            "method_body": "private static Map<String, Character> loadEntities(String filename) {\nProperties properties = new Properties();\nMap<String, Character> entities = new HashMap<String, Character>();\ntry {\nInputStream in = Entities.class.getResourceAsStream(filename);\nproperties.load(in);\nin.close();\n} catch (IOException e) {\nthrow new MissingResourceException(\"Error loading entities resource: \" + e.getMessage(), \"Entities\", filename);\n}\n\nfor (Map.Entry entry: properties.entrySet()) {\nCharacter val = Character.valueOf((char) Integer.parseInt((String) entry.getValue(), 16));\nString name = (String) entry.getKey();\nentities.put(name, val);\n}\nreturn entities;\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:toCharacterKey(Ljava/util/Map;)Ljava/util/Map;",
            "method_body": "private static Map<Character, String> toCharacterKey(Map<String, Character> inMap) {\nMap<Character, String> outMap = new HashMap<Character, String>();\nfor (Map.Entry<String, Character> entry: inMap.entrySet()) {\nCharacter character = entry.getValue();\nString name = entry.getKey();\n\nif (outMap.containsKey(character)) {\n// dupe, prefer the lower case version\nif (name.toLowerCase().equals(name))\noutMap.put(character, name);\n} else {\noutMap.put(character, name);\n}\n}\nreturn outMap;\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/lang/String;)V",
            "method_body": "static final char EOF = (char) -1;\nprivate static final int maxCacheLen = 12;\n\nprivate final char[] input;\nprivate final int length;\nprivate int pos = 0;\nprivate int mark = 0;\nprivate final String[] stringCache = new String[512]; // holds reused strings in this doc, to lessen garbage\n\nCharacterReader(String input) {\nValidate.notNull(input);\nthis.input = input.toCharArray();\nthis.length = this.input.length;\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:isEmpty()Z",
            "method_body": "boolean isEmpty() {\nreturn pos >= length;\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:current()C",
            "method_body": "char current() {\nreturn pos >= length ? EOF : input[pos];\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consume()C",
            "method_body": "char consume() {\nchar val = pos >= length ? EOF : input[pos];\npos++;\nreturn val;\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:advance()V",
            "method_body": "void advance() {\npos++;\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeData()Ljava/lang/String;",
            "method_body": "String consumeData() {\n// &, <, null\nfinal int start = pos;\nfinal int remaining = length;\nfinal char[] val = input;\n\nwhile (pos < remaining) {\nfinal char c = val[pos];\nif (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\nbreak;\npos++;\n}\n\nreturn pos > start ? cacheString(start, pos-start) : \"\";\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeTagName()Ljava/lang/String;",
            "method_body": "String consumeTagName() {\n// '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\nfinal int start = pos;\nfinal int remaining = length;\nfinal char[] val = input;\n\nwhile (pos < remaining) {\nfinal char c = val[pos];\nif (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\nbreak;\npos++;\n}\n\nreturn pos > start ? cacheString(start, pos-start) : \"\";\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matchesLetter()Z",
            "method_body": "boolean matchesLetter() {\nif (isEmpty())\nreturn false;\nchar c = input[pos];\nreturn (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}",
            "method_id": 136
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:cacheString(II)Ljava/lang/String;",
            "method_body": "private String cacheString(final int start, final int count) {\nfinal char[] val = input;\nfinal String[] cache = stringCache;\n\n// limit (no cache):\nif (count > maxCacheLen)\nreturn new String(val, start, count);\n\n// calculate hash:\nint hash = 0;\nint offset = start;\nfor (int i = 0; i < count; i++) {\nhash = 31 * hash + val[offset++];\n}\n\n// get from cache\nfinal int index = hash & cache.length - 1;\nString cached = cache[index];\n\nif (cached == null) { // miss, add\ncached = new String(val, start, count);\ncache[index] = cached;\n} else { // hashcode hit, check equality\nif (rangeEquals(start, count, cached)) {\n// hit\nreturn cached;\n} else { // hashcode conflict\ncached = new String(val, start, count);\n}\n}\nreturn cached;\n}",
            "method_id": 137
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:rangeEquals(IILjava/lang/String;)Z",
            "method_body": "boolean rangeEquals(final int start, int count, final String cached) {\nif (count == cached.length()) {\nchar one[] = input;\nint i = start;\nint j = 0;\nwhile (count-- != 0) {\nif (one[i++] != cached.charAt(j++))\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}",
            "method_id": 138
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:<init>(Lorg/jsoup/parser/CharacterReader;Lorg/jsoup/parser/ParseErrorList;)V",
            "method_body": "private CharacterReader reader; // html input\nprivate ParseErrorList errors; // errors found while tokenising\n\nprivate TokeniserState state = TokeniserState.Data; // current tokenisation state\nprivate Token emitPending; // the token we are about to emit on next read\nprivate boolean isEmitPending = false;\nprivate String charsString = null; // characters pending an emit. Will fall to charsBuilder if more than one\nprivate StringBuilder charsBuilder = new StringBuilder(1024); // buffers characters to output as one token, if more than one emit per read\nStringBuilder dataBuffer = new StringBuilder(1024); // buffers data looking for </script>\n\nToken.Tag tagPending; // tag we are building up\nToken.StartTag startPending = new Token.StartTag();\nToken.EndTag endPending = new Token.EndTag();\nToken.Character charPending = new Token.Character();\nToken.Doctype doctypePending = new Token.Doctype(); // doctype building up\nToken.Comment commentPending = new Token.Comment(); // comment building up\nprivate String lastStartTag; // the last start tag emitted, to test appropriate end tag\nprivate boolean selfClosingFlagAcknowledged = true;\n\nTokeniser(CharacterReader reader, ParseErrorList errors) {\nthis.reader = reader;\nthis.errors = errors;\n}",
            "method_id": 139
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:read()Lorg/jsoup/parser/Token;",
            "method_body": "Token read() {\nif (!selfClosingFlagAcknowledged) {\nerror(\"Self closing flag not acknowledged\");\nselfClosingFlagAcknowledged = true;\n}\n\nwhile (!isEmitPending)\nstate.read(this, reader);\n\n// if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\nif (charsBuilder.length() > 0) {\nString str = charsBuilder.toString();\ncharsBuilder.delete(0, charsBuilder.length());\ncharsString = null;\nreturn charPending.data(str);\n} else if (charsString != null) {\nToken token = charPending.data(charsString);\ncharsString = null;\nreturn token;\n} else {\nisEmitPending = false;\nreturn emitPending;\n}\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Lorg/jsoup/parser/Token;)V",
            "method_body": "void emit(Token token) {\nValidate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\nemitPending = token;\nisEmitPending = true;\n\nif (token.type == Token.TokenType.StartTag) {\nToken.StartTag startTag = (Token.StartTag) token;\nlastStartTag = startTag.tagName;\nif (startTag.selfClosing)\nselfClosingFlagAcknowledged = false;\n} else if (token.type == Token.TokenType.EndTag) {\nToken.EndTag endTag = (Token.EndTag) token;\nif (endTag.attributes != null)\nerror(\"Attributes incorrectly present on end tag\");\n}\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Ljava/lang/String;)V",
            "method_body": "void emit(final String str) {\n// buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n// does not set isEmitPending; read checks that\nif (charsString == null) {\ncharsString = str;\n}\nelse {\nif (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read\ncharsBuilder.append(charsString);\n}\ncharsBuilder.append(str);\n}\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:transition(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void transition(TokeniserState state) {\nthis.state = state;\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:advanceTransition(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void advanceTransition(TokeniserState state) {\nreader.advance();\nthis.state = state;\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:createTagPending(Z)Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Token.Tag createTagPending(boolean start) {\ntagPending = start ? startPending.reset() : endPending.reset();\nreturn tagPending;\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emitTagPending()V",
            "method_body": "void emitTagPending() {\ntagPending.finaliseTag();\nemit(tagPending);\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$1:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\ncase '&':\nt.advanceTransition(CharacterReferenceInData);\nbreak;\ncase '<':\nt.advanceTransition(TagOpen);\nbreak;\ncase nullChar:\nt.error(this); // NOT replacement character (oddly?)\nt.emit(r.consume());\nbreak;\ncase eof:\nt.emit(new Token.EOF());\nbreak;\ndefault:\nString data = r.consumeData();\nt.emit(data);\nbreak;\n}\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$8:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\ncase '!':\nt.advanceTransition(MarkupDeclarationOpen);\nbreak;\ncase '/':\nt.advanceTransition(EndTagOpen);\nbreak;\ncase '?':\nt.advanceTransition(BogusComment);\nbreak;\ndefault:\nif (r.matchesLetter()) {\nt.createTagPending(true);\nt.transition(TagName);\n} else {\nt.error(this);\nt.emit('<'); // char that got us here\nt.transition(Data);\n}\nbreak;\n}\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$9:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.isEmpty()) {\nt.eofError(this);\nt.emit(\"</\");\nt.transition(Data);\n} else if (r.matchesLetter()) {\nt.createTagPending(false);\nt.transition(TagName);\n} else if (r.matches('>')) {\nt.error(this);\nt.advanceTransition(Data);\n} else {\nt.error(this);\nt.advanceTransition(BogusComment);\n}\n}",
            "method_id": 149
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$10:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\n// previous TagOpen state did NOT consume, will have a letter char in current\n//String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\nString tagName = r.consumeTagName().toLowerCase();\nt.tagPending.appendTagName(tagName);\n\nswitch (r.consume()) {\ncase '\\t':\ncase '\\n':\ncase '\\r':\ncase '\\f':\ncase ' ':\nt.transition(BeforeAttributeName);\nbreak;\ncase '/':\nt.transition(SelfClosingStartTag);\nbreak;\ncase '>':\nt.emitTagPending();\nt.transition(Data);\nbreak;\ncase nullChar: // replacement\nt.tagPending.appendTagName(replacementStr);\nbreak;\ncase eof: // should emit pending tag?\nt.eofError(this);\nt.transition(Data);\n// no default, as covered with above consumeToAny\n}\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:<init>()V",
            "method_body": "Character() {\nsuper();\ntype = TokenType.Character;\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:reset()Lorg/jsoup/parser/Token;",
            "method_body": "Token reset() {\ndata = null;\nreturn this;\n}",
            "method_id": 152
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:data(Ljava/lang/String;)Lorg/jsoup/parser/Token$Character;",
            "method_body": "Character data(String data) {\nthis.data = data;\nreturn this;\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:getData()Ljava/lang/String;",
            "method_body": "String getData() {\nreturn data;\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.jsoup.parser.Token$Doctype:<init>()V",
            "method_body": "final StringBuilder name = new StringBuilder();\nfinal StringBuilder publicIdentifier = new StringBuilder();\nfinal StringBuilder systemIdentifier = new StringBuilder();\nboolean forceQuirks = false;\n\nDoctype() {\ntype = TokenType.Doctype;\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.jsoup.parser.Token$Comment:<init>()V",
            "method_body": "Comment() {\ntype = TokenType.Comment;\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$24:<clinit>()V",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\ntb.insert(t.asCharacter());\nreturn true;\n}\nswitch (t.type) {\ncase Comment:\ntb.insert(t.asComment());\nbreak;\ncase Doctype:\ntb.error(this);\nreturn false;\ncase StartTag:\nToken.StartTag start = t.asStartTag();\nString name = start.name();\nif (name.equals(\"html\")) {\nreturn InBody.process(t, tb);\n} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\nElement el = tb.insertEmpty(start);\n// jsoup special: update base the frist time it is seen\nif (name.equals(\"base\") && el.hasAttr(\"href\"))\ntb.maybeSetBaseUri(el);\n} else if (name.equals(\"meta\")) {\nElement meta = tb.insertEmpty(start);\n// todo: charset switches\n} else if (name.equals(\"title\")) {\nhandleRcData(start, tb);\n} else if (StringUtil.in(name, \"noframes\", \"style\")) {\nhandleRawtext(start, tb);\n} else if (name.equals(\"noscript\")) {\n// else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)\ntb.insert(start);\ntb.transition(InHeadNoscript);\n} else if (name.equals(\"script\")) {\n// skips some script rules as won't execute them\n\ntb.tokeniser.transition(TokeniserState.ScriptData);\ntb.markInsertionMode();\ntb.transition(Text);\ntb.insert(start);\n} else if (name.equals(\"head\")) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\nbreak;\ncase EndTag:\nToken.EndTag end = t.asEndTag();\nname = end.name();\nif (name.equals(\"head\")) {\ntb.pop();\ntb.transition(AfterHead);\n} else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\nreturn anythingElse(t, tb);\n} else {\ntb.error(this);\nreturn false;\n}\nbreak;\ndefault:\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 157
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:<clinit>()V",
            "method_body": "private static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \", \"         \", \"          \"};\nprivate static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \", \"         \", \"          \"};",
            "method_id": 158
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:isWhitespace(I)Z",
            "method_body": "public static boolean isWhitespace(int c){\nreturn c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r';\n}",
            "method_id": 159
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:in(Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "public static boolean in(String needle, String... haystack) {\nfor (String hay : haystack) {\nif (hay.equals(needle))\nreturn true;\n}\nreturn false;\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$Constants:<clinit>()V",
            "method_body": "private static final String[] InBodyStartLiBreakers = new String[]{\"address\", \"div\", \"p\"};\nprivate static final String[] InBodyStartLiBreakers = new String[]{\"address\", \"div\", \"p\"};",
            "method_id": 161
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:<init>(Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "public TextNode(String text, String baseUri) {\nthis.baseUri = baseUri;\nthis.text = text;\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.jsoup.parser.Token$EOF:<init>()V",
            "method_body": "EOF() {\ntype = Token.TokenType.EOF;\n}",
            "method_id": 163
        },
        {
            "method_signature": "org.jsoup.parser.Token$EOF:reset()Lorg/jsoup/parser/Token;",
            "method_body": "Token reset() {\nreturn this;\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.jsoup.select.Elements:<init>(Ljava/util/List;)V",
            "method_body": "public Elements(List<Element> elements) {\nsuper(elements);\n}",
            "method_id": 165
        }
    ]
}