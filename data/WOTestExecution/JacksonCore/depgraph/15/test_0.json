{
    "bug_id": 15,
    "test_id": 0,
    "test_name": "com.fasterxml.jackson.core.filter.BasicParserFilteringTest.testNotAllowMultipleMatches",
    "test_body": "public void testNotAllowMultipleMatches() throws Exception\n{\nString jsonString = aposToQuotes(\"{'a':123,'array':[1,2],'ob':{'value0':2,'value':3,'value2':4},'value':4,'b':true}\");\nJsonParser p0 = JSON_F.createParser(jsonString);\nJsonParser p = new FilteringParserDelegate(p0,\nnew NameMatchFilter(\"value\"),\nfalse, // includePath\nfalse // multipleMatches -false\n);\nString result = readAndWrite(JSON_F, p);\nassertEquals(aposToQuotes(\"3\"), result);\n}\n",
    "stack_trace": "junit.framework.ComparisonFailure: expected:<3[]> but was:<3[ 4]>\nat junit.framework.Assert.assertEquals(Assert.java:100)\nat junit.framework.Assert.assertEquals(Assert.java:107)\nat junit.framework.TestCase.assertEquals(TestCase.java:269)\nat com.fasterxml.jackson.core.filter.BasicParserFilteringTest.testNotAllowMultipleMatches(BasicParserFilteringTest.java:118)",
    "covered_methods": [
        {
            "method_signature": "com.fasterxml.jackson.core.filter.FilteringParserDelegate:_nextToken2()Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "public JsonToken nextToken() throws IOException\n{\n//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n// check for no buffered context _exposedContext - null\n//If all the conditions matches then check for scalar / non-scalar property\n//if not scalar and ended successfully, then return null\n//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n// then return null\n// Anything buffered?\nTokenFilterContext ctxt = _exposedContext;\n\nif (ctxt != null) {\nwhile (true) {\nJsonToken t = ctxt.nextTokenToRead();\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n// all done with buffered stuff?\nif (ctxt == _headContext) {\n_exposedContext = null;\nif (ctxt.inArray()) {\nt = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n_currToken = t;\nreturn t;\n}\n\n// Almost! Most likely still have the current token;\n// with the sole exception of\n/*\nt = delegate.getCurrentToken();\nif (t != JsonToken.FIELD_NAME) {\n_currToken = t;\nreturn t;\n}\n*/\nbreak;\n}\n// If not, traverse down the context chain\nctxt = _headContext.findChildOf(ctxt);\n_exposedContext = ctxt;\nif (ctxt == null) { // should never occur\nthrow _constructError(\"Unexpected problem: chain of filtered context broken\");\n}\n}\n}\n\n// If not, need to read more. If we got any:\nJsonToken t = delegate.nextToken();\nif (t == null) {\n// no strict need to close, since we have no state here\nreturn (_currToken = t);\n}\n\n// otherwise... to include or not?\nTokenFilter f;\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\nbreak;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\nbreak;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\n\n// Also: only need buffering if parent path to be included\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\nbreak;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\nbreak;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\nbreak;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\n// Also: only need buffering if parent path to be included\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\n// note: inclusion of surrounding Object handled separately via\n// FIELD_NAME\nbreak;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\nboolean returnEnd = _headContext.isStartHandled();\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\nif (returnEnd) {\nreturn (_currToken = t);\n}\n}\nbreak;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\n// note: this will also set 'needToHandleName'\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nif (!_includePath) {\n// Minor twist here: if parent NOT included, may need to induce output of\n// surrounding START_OBJECT/END_OBJECT\nif (_includeImmediateParent && !_headContext.isStartHandled()) {\nt = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n_exposedContext = _headContext;\n}\n}\nreturn (_currToken = t);\n}\nif (f == null) {\ndelegate.nextToken();\ndelegate.skipChildren();\nbreak;\n}\nf = f.includeProperty(name);\nif (f == null) {\ndelegate.nextToken();\ndelegate.skipChildren();\nbreak;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nif (_includePath) {\nreturn (_currToken = t);\n}\n}\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\nbreak;\n}\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn (_currToken = t);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn (_currToken = t);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\nbreak;\n}\n\n// We get here if token was not yet found; offlined handling\nreturn _nextToken2();\n}\n\n/**\n* Offlined handling for cases where there was no buffered token to\n* return, and the token read next could not be returned as-is,\n* at least not yet, but where we have not yet established that\n* buffering is needed.\n*/\nprotected final JsonToken _nextToken2() throws IOException\n{\nmain_loop:\nwhile (true) {\nJsonToken t = delegate.nextToken();\nif (t == null) { // is this even legal?\nreturn (_currToken = t);\n}\nTokenFilter f;\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\n// but if we didn't figure it out yet, need to buffer possible events\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\ncontinue main_loop;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\ncontinue main_loop;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\nboolean returnEnd = _headContext.isStartHandled();\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\nif (returnEnd) {\nreturn (_currToken = t);\n}\n}\ncontinue main_loop;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nreturn (_currToken = t);\n}\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\nf = f.includeProperty(name);\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nif (_includePath) {\nreturn (_currToken = t);\n}\n//                        if (_includeImmediateParent) { ...\ncontinue main_loop;\n}\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\n}\ncontinue main_loop;\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn (_currToken = t);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn (_currToken = t);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\nbreak;\n}\n}\n}\n\n/**\n* Method called when a new potentially included context is found.\n*/\nprotected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\nthrows IOException\n{\nmain_loop:\nwhile (true) {\nJsonToken t = delegate.nextToken();\nif (t == null) { // is this even legal?\nreturn t;\n}\nTokenFilter f;\n\n// One simplification here: we know for a fact that the item filter is\n// neither null nor 'include all', for most cases; the only exception\n// being FIELD_NAME handling\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _headContext.checkValue(_itemFilter);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn _nextBuffered(buffRoot);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\ncontinue main_loop;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn t;\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn _nextBuffered(buffRoot);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\ncontinue main_loop;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\n// Unlike with other loops, here we know that content was NOT\n// included (won't get this far otherwise)\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\nboolean gotEnd = (_headContext == buffRoot);\nboolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\n\nif (returnEnd) {\nreturn t;\n}\n// Hmmh. Do we need both checks, or should above suffice?\nif (gotEnd || (_headContext == buffRoot)) {\nreturn null;\n}\n}\ncontinue main_loop;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nreturn _nextBuffered(buffRoot);\n}\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\nf = f.includeProperty(name);\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn _nextBuffered(buffRoot);\n}\n}\ncontinue main_loop;\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn _nextBuffered(buffRoot);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn _nextBuffered(buffRoot);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\ncontinue main_loop;\n}\n}\n}\n\nprivate JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n{\n_exposedContext = buffRoot;\nTokenFilterContext ctxt = buffRoot;\nJsonToken t = ctxt.nextTokenToRead();\nif (t != null) {\nreturn t;\n}\nwhile (true) {\n// all done with buffered stuff?\nif (ctxt == _headContext) {\nthrow _constructError(\"Internal error: failed to locate expected buffered tokens\");\n/*\n_exposedContext = null;\nbreak;\n*/\n}\n// If not, traverse down the context chain\nctxt = _exposedContext.findChildOf(ctxt);\n_exposedContext = ctxt;\nif (ctxt == null) { // should never occur\nthrow _constructError(\"Unexpected problem: chain of filtered context broken\");\n}\nt = _exposedContext.nextTokenToRead();\nif (t != null) {\nreturn t;\n}\n}\n}\n\n@Override\npublic JsonToken nextValue() throws IOException {\n// Re-implemented same as ParserMinimalBase:\nJsonToken t = nextToken();\nif (t == JsonToken.FIELD_NAME) {\nt = nextToken();\n}\nreturn t;\n}\n\n/**\n* Need to override, re-implement similar to how method defined in\n* {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n* state correct here.\n*/\n@Override\npublic JsonParser skipChildren() throws IOException\n{\nif ((_currToken != JsonToken.START_OBJECT)\n&& (_currToken != JsonToken.START_ARRAY)) {\nreturn this;\n}\nint open = 1;\n\n// Since proper matching of start/end markers is handled\n// by nextToken(), we'll just count nesting levels here\nwhile (true) {\nJsonToken t = nextToken();\nif (t == null) { // not ideal but for now, just return\nreturn this;\n}\nif (t.isStructStart()) {\n++open;\n} else if (t.isStructEnd()) {\nif (--open == 0) {\nreturn this;\n}\n}\n}\n}\n\n/*\n/**********************************************************\n/* Public API, access to token information, text\n/**********************************************************\n*/\n\n@Override public String getText() throws IOException { return delegate.getText();  }\n@Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n@Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n@Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n@Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n/*\n/**********************************************************\n/* Public API, access to token information, numeric\n/**********************************************************\n*/\n\n@Override\npublic BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n@Override\npublic boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n\n@Override\npublic byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n@Override\npublic short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n@Override\npublic BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n@Override\npublic double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n@Override\npublic float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n@Override\npublic int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n@Override\npublic long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n@Override\npublic NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n@Override\npublic Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n/*\n/**********************************************************\n/* Public API, access to token information, coercion/conversion\n/**********************************************************\n*/\n\n@Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n@Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n@Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n@Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n@Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n@Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n@Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n@Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n@Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n@Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n\n/*\n/**********************************************************\n/* Public API, access to token values, other\n/**********************************************************\n*/\n\n@Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n@Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n@Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n@Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n/*\n/**********************************************************\n/* Internal helper methods\n/**********************************************************\n*/\n\nprotected JsonStreamContext _filterContext() {\nif (_exposedContext != null) {\nreturn _exposedContext;\n}\nreturn _headContext;\n}\n\n}\n}",
            "method_id": 0
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.FilteringParserDelegate:nextToken()Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "public JsonToken nextToken() throws IOException\n{\n//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n// check for no buffered context _exposedContext - null\n//If all the conditions matches then check for scalar / non-scalar property\n//if not scalar and ended successfully, then return null\n//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n// then return null\n// Anything buffered?\nTokenFilterContext ctxt = _exposedContext;\n\nif (ctxt != null) {\nwhile (true) {\nJsonToken t = ctxt.nextTokenToRead();\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n// all done with buffered stuff?\nif (ctxt == _headContext) {\n_exposedContext = null;\nif (ctxt.inArray()) {\nt = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n_currToken = t;\nreturn t;\n}\n\n// Almost! Most likely still have the current token;\n// with the sole exception of\n/*\nt = delegate.getCurrentToken();\nif (t != JsonToken.FIELD_NAME) {\n_currToken = t;\nreturn t;\n}\n*/\nbreak;\n}\n// If not, traverse down the context chain\nctxt = _headContext.findChildOf(ctxt);\n_exposedContext = ctxt;\nif (ctxt == null) { // should never occur\nthrow _constructError(\"Unexpected problem: chain of filtered context broken\");\n}\n}\n}\n\n// If not, need to read more. If we got any:\nJsonToken t = delegate.nextToken();\nif (t == null) {\n// no strict need to close, since we have no state here\nreturn (_currToken = t);\n}\n\n// otherwise... to include or not?\nTokenFilter f;\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\nbreak;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\nbreak;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\n\n// Also: only need buffering if parent path to be included\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\nbreak;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\nbreak;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\nbreak;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\n// Also: only need buffering if parent path to be included\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\n// note: inclusion of surrounding Object handled separately via\n// FIELD_NAME\nbreak;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\nboolean returnEnd = _headContext.isStartHandled();\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\nif (returnEnd) {\nreturn (_currToken = t);\n}\n}\nbreak;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\n// note: this will also set 'needToHandleName'\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nif (!_includePath) {\n// Minor twist here: if parent NOT included, may need to induce output of\n// surrounding START_OBJECT/END_OBJECT\nif (_includeImmediateParent && !_headContext.isStartHandled()) {\nt = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n_exposedContext = _headContext;\n}\n}\nreturn (_currToken = t);\n}\nif (f == null) {\ndelegate.nextToken();\ndelegate.skipChildren();\nbreak;\n}\nf = f.includeProperty(name);\nif (f == null) {\ndelegate.nextToken();\ndelegate.skipChildren();\nbreak;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nif (_includePath) {\nreturn (_currToken = t);\n}\n}\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\nbreak;\n}\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn (_currToken = t);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn (_currToken = t);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\nbreak;\n}\n\n// We get here if token was not yet found; offlined handling\nreturn _nextToken2();\n}\n\n/**\n* Offlined handling for cases where there was no buffered token to\n* return, and the token read next could not be returned as-is,\n* at least not yet, but where we have not yet established that\n* buffering is needed.\n*/\nprotected final JsonToken _nextToken2() throws IOException\n{\nmain_loop:\nwhile (true) {\nJsonToken t = delegate.nextToken();\nif (t == null) { // is this even legal?\nreturn (_currToken = t);\n}\nTokenFilter f;\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\n// but if we didn't figure it out yet, need to buffer possible events\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\ncontinue main_loop;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\ncontinue main_loop;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\nboolean returnEnd = _headContext.isStartHandled();\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\nif (returnEnd) {\nreturn (_currToken = t);\n}\n}\ncontinue main_loop;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nreturn (_currToken = t);\n}\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\nf = f.includeProperty(name);\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nif (_includePath) {\nreturn (_currToken = t);\n}\n//                        if (_includeImmediateParent) { ...\ncontinue main_loop;\n}\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\n}\ncontinue main_loop;\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn (_currToken = t);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn (_currToken = t);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\nbreak;\n}\n}\n}\n\n/**\n* Method called when a new potentially included context is found.\n*/\nprotected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\nthrows IOException\n{\nmain_loop:\nwhile (true) {\nJsonToken t = delegate.nextToken();\nif (t == null) { // is this even legal?\nreturn t;\n}\nTokenFilter f;\n\n// One simplification here: we know for a fact that the item filter is\n// neither null nor 'include all', for most cases; the only exception\n// being FIELD_NAME handling\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _headContext.checkValue(_itemFilter);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn _nextBuffered(buffRoot);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\ncontinue main_loop;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn t;\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn _nextBuffered(buffRoot);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\ncontinue main_loop;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\n// Unlike with other loops, here we know that content was NOT\n// included (won't get this far otherwise)\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\nboolean gotEnd = (_headContext == buffRoot);\nboolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\n\nif (returnEnd) {\nreturn t;\n}\n// Hmmh. Do we need both checks, or should above suffice?\nif (gotEnd || (_headContext == buffRoot)) {\nreturn null;\n}\n}\ncontinue main_loop;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nreturn _nextBuffered(buffRoot);\n}\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\nf = f.includeProperty(name);\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn _nextBuffered(buffRoot);\n}\n}\ncontinue main_loop;\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn _nextBuffered(buffRoot);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn _nextBuffered(buffRoot);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\ncontinue main_loop;\n}\n}\n}\n\nprivate JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n{\n_exposedContext = buffRoot;\nTokenFilterContext ctxt = buffRoot;\nJsonToken t = ctxt.nextTokenToRead();\nif (t != null) {\nreturn t;\n}\nwhile (true) {\n// all done with buffered stuff?\nif (ctxt == _headContext) {\nthrow _constructError(\"Internal error: failed to locate expected buffered tokens\");\n/*\n_exposedContext = null;\nbreak;\n*/\n}\n// If not, traverse down the context chain\nctxt = _exposedContext.findChildOf(ctxt);\n_exposedContext = ctxt;\nif (ctxt == null) { // should never occur\nthrow _constructError(\"Unexpected problem: chain of filtered context broken\");\n}\nt = _exposedContext.nextTokenToRead();\nif (t != null) {\nreturn t;\n}\n}\n}\n\n@Override\npublic JsonToken nextValue() throws IOException {\n// Re-implemented same as ParserMinimalBase:\nJsonToken t = nextToken();\nif (t == JsonToken.FIELD_NAME) {\nt = nextToken();\n}\nreturn t;\n}\n\n/**\n* Need to override, re-implement similar to how method defined in\n* {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n* state correct here.\n*/\n@Override\npublic JsonParser skipChildren() throws IOException\n{\nif ((_currToken != JsonToken.START_OBJECT)\n&& (_currToken != JsonToken.START_ARRAY)) {\nreturn this;\n}\nint open = 1;\n\n// Since proper matching of start/end markers is handled\n// by nextToken(), we'll just count nesting levels here\nwhile (true) {\nJsonToken t = nextToken();\nif (t == null) { // not ideal but for now, just return\nreturn this;\n}\nif (t.isStructStart()) {\n++open;\n} else if (t.isStructEnd()) {\nif (--open == 0) {\nreturn this;\n}\n}\n}\n}\n\n/*\n/**********************************************************\n/* Public API, access to token information, text\n/**********************************************************\n*/\n\n@Override public String getText() throws IOException { return delegate.getText();  }\n@Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n@Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n@Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n@Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n/*\n/**********************************************************\n/* Public API, access to token information, numeric\n/**********************************************************\n*/\n\n@Override\npublic BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n@Override\npublic boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n\n@Override\npublic byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n@Override\npublic short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n@Override\npublic BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n@Override\npublic double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n@Override\npublic float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n@Override\npublic int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n@Override\npublic long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n@Override\npublic NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n@Override\npublic Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n/*\n/**********************************************************\n/* Public API, access to token information, coercion/conversion\n/**********************************************************\n*/\n\n@Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n@Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n@Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n@Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n@Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n@Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n@Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n@Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n@Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n@Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n\n/*\n/**********************************************************\n/* Public API, access to token values, other\n/**********************************************************\n*/\n\n@Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n@Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n@Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n@Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n/*\n/**********************************************************\n/* Internal helper methods\n/**********************************************************\n*/\n\nprotected JsonStreamContext _filterContext() {\nif (_exposedContext != null) {\nreturn _exposedContext;\n}\nreturn _headContext;\n}\n\n}\n}",
            "method_id": 1
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.FilteringParserDelegate:<init>(Lcom/fasterxml/jackson/core/JsonParser;Lcom/fasterxml/jackson/core/filter/TokenFilter;ZZ)V",
            "method_body": "public FilteringParserDelegate(JsonParser p, TokenFilter f,\nboolean includePath, boolean allowMultipleMatches)\n{\nsuper(p);\nrootFilter = f;\n// and this is the currently active filter for root values\n_itemFilter = f;\n_headContext = TokenFilterContext.createRootContext(f);\n_includePath = includePath;\n_allowMultipleMatches = allowMultipleMatches;\n}",
            "method_id": 2
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:createParser(Ljava/lang/String;)Lcom/fasterxml/jackson/core/JsonParser;",
            "method_body": "public JsonParser createParser(String content) throws IOException, JsonParseException {\nfinal int strLen = content.length();\n// Actually, let's use this for medium-sized content, up to 64kB chunk (32kb char)\nif (_inputDecorator != null || strLen > 0x8000 || !canUseCharArrays()) {\n// easier to just wrap in a Reader than extend InputDecorator; or, if content\n// is too long for us to copy it over\nreturn createParser(new StringReader(content));\n}\nIOContext ctxt = _createContext(content, true);\nchar[] buf = ctxt.allocTokenBuffer(strLen);\ncontent.getChars(0, strLen, buf, 0);\nreturn _createParser(buf, 0, strLen, ctxt, true);\n}",
            "method_id": 3
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:<init>(Lcom/fasterxml/jackson/core/io/IOContext;ILjava/io/Reader;Lcom/fasterxml/jackson/core/ObjectCodec;Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;[CIIZ)V",
            "method_body": "public ReaderBasedJsonParser(IOContext ctxt, int features, Reader r,\nObjectCodec codec, CharsToNameCanonicalizer st,\nchar[] inputBuffer, int start, int end,\nboolean bufferRecyclable)\n{\nsuper(ctxt, features);\n_reader = r;\n_inputBuffer = inputBuffer;\n_inputPtr = start;\n_inputEnd = end;\n_objectCodec = codec;\n_symbols = st;\n_hashSeed = st.hashSeed();\n_bufferRecyclable = bufferRecyclable;\n}",
            "method_id": 4
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:_createParser([CIILcom/fasterxml/jackson/core/io/IOContext;Z)Lcom/fasterxml/jackson/core/JsonParser;",
            "method_body": "protected JsonParser _createParser(char[] data, int offset, int len, IOContext ctxt,\nboolean recyclable) throws IOException {\nreturn new ReaderBasedJsonParser(ctxt, _parserFeatures, null, _objectCodec,\n_rootCharSymbols.makeChild(_factoryFeatures),\ndata, offset, offset+len, recyclable);\n}",
            "method_id": 5
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:allocCharBuffer(II)[C",
            "method_body": "public char[] allocCharBuffer(int ix, int minSize) {\nfinal int DEF_SIZE = charBufferLength(ix);\nif (minSize < DEF_SIZE) {\nminSize = DEF_SIZE;\n}\nchar[] buffer = _charBuffers[ix];\nif (buffer == null || buffer.length < minSize) {\nbuffer = calloc(minSize);\n} else {\n_charBuffers[ix] = null;\n}\nreturn buffer;\n}",
            "method_id": 6
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:<init>(Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;I[Ljava/lang/String;[Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer$Bucket;III)V",
            "method_body": "private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, int flags,\nString[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl) {\n_parent = parent;\n\n_flags = flags;\n_canonicalize = JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(flags);\n\n_symbols = symbols;\n_buckets = buckets;\n_size = size;\n_hashSeed = hashSeed;\n// Hard-coded fill factor, 75%\nint arrayLen = (symbols.length);\n_sizeThreshold = _thresholdSize(arrayLen);\n_indexMask =  (arrayLen - 1);\n_longestCollisionList = longestColl;\n\n// Need to make copies of arrays, if/when adding new entries\n_dirty = false;\n}",
            "method_id": 7
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:_getBufferRecycler()Lcom/fasterxml/jackson/core/util/BufferRecycler;",
            "method_body": "public BufferRecycler _getBufferRecycler()\n{\nBufferRecycler br;\n\n/* 23-Apr-2015, tatu: Let's allow disabling of buffer recycling\n*   scheme, for cases where it is considered harmful (possibly\n*   on Android, for example)\n*/\nif (isEnabled(Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING)) {\nSoftReference<BufferRecycler> ref = _recyclerRef.get();\nbr = (ref == null) ? null : ref.get();\n\nif (br == null) {\nbr = new BufferRecycler();\n_recyclerRef.set(new SoftReference<BufferRecycler>(br));\n}\n} else {\nbr = new BufferRecycler();\n}\nreturn br;\n}",
            "method_id": 8
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:allocTokenBuffer(I)[C",
            "method_body": "public char[] allocTokenBuffer(int minSize) {\n_verifyAlloc(_tokenCBuffer);\nreturn (_tokenCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER, minSize));\n}",
            "method_id": 9
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:makeChild(I)Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;",
            "method_body": "public CharsToNameCanonicalizer makeChild(int flags) {\n/* 24-Jul-2012, tatu: Trying to reduce scope of synchronization, assuming\n*   that synchronizing construction is the (potentially) expensive part,\n*   and not so much short copy-the-variables thing.\n*/\nfinal String[] symbols;\nfinal Bucket[] buckets;\nfinal int size;\nfinal int hashSeed;\nfinal int longestCollisionList;\n\nsynchronized (this) {\nsymbols = _symbols;\nbuckets = _buckets;\nsize = _size;\nhashSeed = _hashSeed;\nlongestCollisionList = _longestCollisionList;\n}\nreturn new CharsToNameCanonicalizer(this, flags,\nsymbols, buckets, size, hashSeed, longestCollisionList);\n}",
            "method_id": 10
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:<init>(IZIZ)V",
            "method_body": "private ByteQuadsCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n_parent = null;\n_seed = seed;\n_intern = intern;\n_failOnDoS = failOnDoS;\n// Sanity check: let's now allow hash sizes below certain minimum value\nif (sz < MIN_HASH_SIZE) {\nsz = MIN_HASH_SIZE;\n} else {\n// Also; size must be 2^N; otherwise hash algorithm won't\n// work... so let's just pad it up, if so\nif ((sz & (sz - 1)) != 0) { // only true if it's 2^N\nint curr = MIN_HASH_SIZE;\nwhile (curr < sz) {\ncurr += curr;\n}\nsz = curr;\n}\n}\n_tableInfo = new AtomicReference<TableInfo>(TableInfo.createInitial(sz));\n}",
            "method_id": 11
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:_decorate(Ljava/io/Writer;Lcom/fasterxml/jackson/core/io/IOContext;)Ljava/io/Writer;",
            "method_body": "protected final Writer _decorate(Writer out, IOContext ctxt) throws IOException {\nif (_outputDecorator != null) {\nWriter out2 = _outputDecorator.decorate(ctxt, out);\nif (out2 != null) {\nreturn out2;\n}\n}\nreturn out;\n}",
            "method_id": 12
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:<init>()V",
            "method_body": "private CharsToNameCanonicalizer() {\n// these settings don't really matter for the bootstrap instance\n_canonicalize = true;\n_flags = -1;\n// And we'll also set flags so no copying of buckets is needed:\n_dirty = true;\n_hashSeed = 0;\n_longestCollisionList = 0;\ninitTables(DEFAULT_T_SIZE);\n}",
            "method_id": 13
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:allocCharBuffer(I)[C",
            "method_body": "public final char[] allocCharBuffer(int ix) {\nreturn allocCharBuffer(ix, 0);\n}",
            "method_id": 14
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:charBufferLength(I)I",
            "method_body": "protected int charBufferLength(int ix) {\nreturn CHAR_BUFFER_LENGTHS[ix];\n}",
            "method_id": 15
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:_createContext(Ljava/lang/Object;Z)Lcom/fasterxml/jackson/core/io/IOContext;",
            "method_body": "protected IOContext _createContext(Object srcRef, boolean resourceManaged) {\nreturn new IOContext(_getBufferRecycler(), srcRef, resourceManaged);\n}",
            "method_id": 16
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:isEnabled(Lcom/fasterxml/jackson/core/JsonFactory$Feature;)Z",
            "method_body": "public final boolean isEnabled(JsonFactory.Feature f) {\nreturn (_factoryFeatures & f.getMask()) != 0;\n}",
            "method_id": 17
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:getMask()I",
            "method_body": "public int getMask() { return _mask; }\npublic int getMask() { return _mask; }",
            "method_id": 18
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:_verifyAlloc(Ljava/lang/Object;)V",
            "method_body": "protected final void _verifyAlloc(Object buffer) {\nif (buffer != null) { throw new IllegalStateException(\"Trying to call same allocXxx() method second time\"); }\n}",
            "method_id": 19
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:<init>(Lcom/fasterxml/jackson/core/util/BufferRecycler;Ljava/lang/Object;Z)V",
            "method_body": "public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource)\n{\n_bufferRecycler = br;\n_sourceRef = sourceRef;\n_managedResource = managedResource;\n}",
            "method_id": 20
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:<init>(II)V",
            "method_body": "protected BufferRecycler(int bbCount, int cbCount) {\n_byteBuffers = new byte[bbCount][];\n_charBuffers = new char[cbCount][];\n}",
            "method_id": 21
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:<init>()V",
            "method_body": "public BufferRecycler() {\nthis(4, 4);\n}",
            "method_id": 22
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:getMask()I",
            "method_body": "public int getMask() { return (1 << ordinal()); }\npublic int getMask() { return (1 << ordinal()); }",
            "method_id": 23
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator$Feature:getMask()I",
            "method_body": "public int getMask() { return _mask; }\npublic int getMask() { return _mask; }",
            "method_id": 24
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:enabledIn(I)Z",
            "method_body": "public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\npublic boolean enabledIn(int flags) { return (flags & getMask()) != 0; }",
            "method_id": 25
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:calloc(I)[C",
            "method_body": "protected char[] calloc(int size) { return new char[size]; }\nprotected char[] calloc(int size) { return new char[size]; }",
            "method_id": 26
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.FilteringParserDelegate:getCurrentToken()Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "@Override public JsonToken getCurrentToken() { return _currToken; }\n@Override public JsonToken getCurrentToken() { return _currToken; }",
            "method_id": 27
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.FilteringParserDelegate:getIntValue()I",
            "method_body": "public JsonToken nextToken() throws IOException\n{\n//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n// check for no buffered context _exposedContext - null\n//If all the conditions matches then check for scalar / non-scalar property\n//if not scalar and ended successfully, then return null\n//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n// then return null\n// Anything buffered?\nTokenFilterContext ctxt = _exposedContext;\n\nif (ctxt != null) {\nwhile (true) {\nJsonToken t = ctxt.nextTokenToRead();\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n// all done with buffered stuff?\nif (ctxt == _headContext) {\n_exposedContext = null;\nif (ctxt.inArray()) {\nt = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n_currToken = t;\nreturn t;\n}\n\n// Almost! Most likely still have the current token;\n// with the sole exception of\n/*\nt = delegate.getCurrentToken();\nif (t != JsonToken.FIELD_NAME) {\n_currToken = t;\nreturn t;\n}\n*/\nbreak;\n}\n// If not, traverse down the context chain\nctxt = _headContext.findChildOf(ctxt);\n_exposedContext = ctxt;\nif (ctxt == null) { // should never occur\nthrow _constructError(\"Unexpected problem: chain of filtered context broken\");\n}\n}\n}\n\n// If not, need to read more. If we got any:\nJsonToken t = delegate.nextToken();\nif (t == null) {\n// no strict need to close, since we have no state here\nreturn (_currToken = t);\n}\n\n// otherwise... to include or not?\nTokenFilter f;\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\nbreak;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\nbreak;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\n\n// Also: only need buffering if parent path to be included\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\nbreak;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\nbreak;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\nbreak;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\n// Also: only need buffering if parent path to be included\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\n// note: inclusion of surrounding Object handled separately via\n// FIELD_NAME\nbreak;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\nboolean returnEnd = _headContext.isStartHandled();\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\nif (returnEnd) {\nreturn (_currToken = t);\n}\n}\nbreak;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\n// note: this will also set 'needToHandleName'\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nif (!_includePath) {\n// Minor twist here: if parent NOT included, may need to induce output of\n// surrounding START_OBJECT/END_OBJECT\nif (_includeImmediateParent && !_headContext.isStartHandled()) {\nt = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n_exposedContext = _headContext;\n}\n}\nreturn (_currToken = t);\n}\nif (f == null) {\ndelegate.nextToken();\ndelegate.skipChildren();\nbreak;\n}\nf = f.includeProperty(name);\nif (f == null) {\ndelegate.nextToken();\ndelegate.skipChildren();\nbreak;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nif (_includePath) {\nreturn (_currToken = t);\n}\n}\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\nbreak;\n}\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn (_currToken = t);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn (_currToken = t);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\nbreak;\n}\n\n// We get here if token was not yet found; offlined handling\nreturn _nextToken2();\n}\n\n/**\n* Offlined handling for cases where there was no buffered token to\n* return, and the token read next could not be returned as-is,\n* at least not yet, but where we have not yet established that\n* buffering is needed.\n*/\nprotected final JsonToken _nextToken2() throws IOException\n{\nmain_loop:\nwhile (true) {\nJsonToken t = delegate.nextToken();\nif (t == null) { // is this even legal?\nreturn (_currToken = t);\n}\nTokenFilter f;\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\n// but if we didn't figure it out yet, need to buffer possible events\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\ncontinue main_loop;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\ncontinue main_loop;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\nboolean returnEnd = _headContext.isStartHandled();\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\nif (returnEnd) {\nreturn (_currToken = t);\n}\n}\ncontinue main_loop;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nreturn (_currToken = t);\n}\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\nf = f.includeProperty(name);\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nif (_includePath) {\nreturn (_currToken = t);\n}\n//                        if (_includeImmediateParent) { ...\ncontinue main_loop;\n}\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\n}\ncontinue main_loop;\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn (_currToken = t);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn (_currToken = t);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\nbreak;\n}\n}\n}\n\n/**\n* Method called when a new potentially included context is found.\n*/\nprotected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\nthrows IOException\n{\nmain_loop:\nwhile (true) {\nJsonToken t = delegate.nextToken();\nif (t == null) { // is this even legal?\nreturn t;\n}\nTokenFilter f;\n\n// One simplification here: we know for a fact that the item filter is\n// neither null nor 'include all', for most cases; the only exception\n// being FIELD_NAME handling\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _headContext.checkValue(_itemFilter);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn _nextBuffered(buffRoot);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\ncontinue main_loop;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn t;\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn _nextBuffered(buffRoot);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\ncontinue main_loop;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\n// Unlike with other loops, here we know that content was NOT\n// included (won't get this far otherwise)\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\nboolean gotEnd = (_headContext == buffRoot);\nboolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\n\nif (returnEnd) {\nreturn t;\n}\n// Hmmh. Do we need both checks, or should above suffice?\nif (gotEnd || (_headContext == buffRoot)) {\nreturn null;\n}\n}\ncontinue main_loop;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nreturn _nextBuffered(buffRoot);\n}\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\nf = f.includeProperty(name);\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn _nextBuffered(buffRoot);\n}\n}\ncontinue main_loop;\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn _nextBuffered(buffRoot);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn _nextBuffered(buffRoot);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\ncontinue main_loop;\n}\n}\n}\n\nprivate JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n{\n_exposedContext = buffRoot;\nTokenFilterContext ctxt = buffRoot;\nJsonToken t = ctxt.nextTokenToRead();\nif (t != null) {\nreturn t;\n}\nwhile (true) {\n// all done with buffered stuff?\nif (ctxt == _headContext) {\nthrow _constructError(\"Internal error: failed to locate expected buffered tokens\");\n/*\n_exposedContext = null;\nbreak;\n*/\n}\n// If not, traverse down the context chain\nctxt = _exposedContext.findChildOf(ctxt);\n_exposedContext = ctxt;\nif (ctxt == null) { // should never occur\nthrow _constructError(\"Unexpected problem: chain of filtered context broken\");\n}\nt = _exposedContext.nextTokenToRead();\nif (t != null) {\nreturn t;\n}\n}\n}\n\n@Override\npublic JsonToken nextValue() throws IOException {\n// Re-implemented same as ParserMinimalBase:\nJsonToken t = nextToken();\nif (t == JsonToken.FIELD_NAME) {\nt = nextToken();\n}\nreturn t;\n}\n\n/**\n* Need to override, re-implement similar to how method defined in\n* {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n* state correct here.\n*/\n@Override\npublic JsonParser skipChildren() throws IOException\n{\nif ((_currToken != JsonToken.START_OBJECT)\n&& (_currToken != JsonToken.START_ARRAY)) {\nreturn this;\n}\nint open = 1;\n\n// Since proper matching of start/end markers is handled\n// by nextToken(), we'll just count nesting levels here\nwhile (true) {\nJsonToken t = nextToken();\nif (t == null) { // not ideal but for now, just return\nreturn this;\n}\nif (t.isStructStart()) {\n++open;\n} else if (t.isStructEnd()) {\nif (--open == 0) {\nreturn this;\n}\n}\n}\n}\n\n/*\n/**********************************************************\n/* Public API, access to token information, text\n/**********************************************************\n*/\n\n@Override public String getText() throws IOException { return delegate.getText();  }\n@Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n@Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n@Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n@Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n/*\n/**********************************************************\n/* Public API, access to token information, numeric\n/**********************************************************\n*/\n\n@Override\npublic BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n@Override\npublic boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n\n@Override\npublic byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n@Override\npublic short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n@Override\npublic BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n@Override\npublic double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n@Override\npublic float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n@Override\npublic int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n@Override\npublic long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n@Override\npublic NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n@Override\npublic Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n/*\n/**********************************************************\n/* Public API, access to token information, coercion/conversion\n/**********************************************************\n*/\n\n@Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n@Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n@Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n@Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n@Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n@Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n@Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n@Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n@Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n@Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n\n/*\n/**********************************************************\n/* Public API, access to token values, other\n/**********************************************************\n*/\n\n@Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n@Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n@Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n@Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n/*\n/**********************************************************\n/* Internal helper methods\n/**********************************************************\n*/\n\nprotected JsonStreamContext _filterContext() {\nif (_exposedContext != null) {\nreturn _exposedContext;\n}\nreturn _headContext;\n}\n\n}\n}",
            "method_id": 28
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.FilteringParserDelegate:getNumberType()Lcom/fasterxml/jackson/core/JsonParser$NumberType;",
            "method_body": "public JsonToken nextToken() throws IOException\n{\n//Check for _allowMultipleMatches - false and atleast there is one token - which is _currToken\n// check for no buffered context _exposedContext - null\n//If all the conditions matches then check for scalar / non-scalar property\n//if not scalar and ended successfully, then return null\n//else if scalar, and scalar not present in obj/array and !includePath and INCLUDE_ALL matched once\n// then return null\n// Anything buffered?\nTokenFilterContext ctxt = _exposedContext;\n\nif (ctxt != null) {\nwhile (true) {\nJsonToken t = ctxt.nextTokenToRead();\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n// all done with buffered stuff?\nif (ctxt == _headContext) {\n_exposedContext = null;\nif (ctxt.inArray()) {\nt = delegate.getCurrentToken();\n// Is this guaranteed to work without further checks?\n//                        if (t != JsonToken.START_ARRAY) {\n_currToken = t;\nreturn t;\n}\n\n// Almost! Most likely still have the current token;\n// with the sole exception of\n/*\nt = delegate.getCurrentToken();\nif (t != JsonToken.FIELD_NAME) {\n_currToken = t;\nreturn t;\n}\n*/\nbreak;\n}\n// If not, traverse down the context chain\nctxt = _headContext.findChildOf(ctxt);\n_exposedContext = ctxt;\nif (ctxt == null) { // should never occur\nthrow _constructError(\"Unexpected problem: chain of filtered context broken\");\n}\n}\n}\n\n// If not, need to read more. If we got any:\nJsonToken t = delegate.nextToken();\nif (t == null) {\n// no strict need to close, since we have no state here\nreturn (_currToken = t);\n}\n\n// otherwise... to include or not?\nTokenFilter f;\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\nbreak;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\nbreak;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\n\n// Also: only need buffering if parent path to be included\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\nbreak;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\nbreak;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\nbreak;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\n// Also: only need buffering if parent path to be included\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\n// note: inclusion of surrounding Object handled separately via\n// FIELD_NAME\nbreak;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\nboolean returnEnd = _headContext.isStartHandled();\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\nif (returnEnd) {\nreturn (_currToken = t);\n}\n}\nbreak;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\n// note: this will also set 'needToHandleName'\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nif (!_includePath) {\n// Minor twist here: if parent NOT included, may need to induce output of\n// surrounding START_OBJECT/END_OBJECT\nif (_includeImmediateParent && !_headContext.isStartHandled()) {\nt = _headContext.nextTokenToRead(); // returns START_OBJECT but also marks it handled\n_exposedContext = _headContext;\n}\n}\nreturn (_currToken = t);\n}\nif (f == null) {\ndelegate.nextToken();\ndelegate.skipChildren();\nbreak;\n}\nf = f.includeProperty(name);\nif (f == null) {\ndelegate.nextToken();\ndelegate.skipChildren();\nbreak;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nif (_includePath) {\nreturn (_currToken = t);\n}\n}\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\nbreak;\n}\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn (_currToken = t);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn (_currToken = t);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\nbreak;\n}\n\n// We get here if token was not yet found; offlined handling\nreturn _nextToken2();\n}\n\n/**\n* Offlined handling for cases where there was no buffered token to\n* return, and the token read next could not be returned as-is,\n* at least not yet, but where we have not yet established that\n* buffering is needed.\n*/\nprotected final JsonToken _nextToken2() throws IOException\n{\nmain_loop:\nwhile (true) {\nJsonToken t = delegate.nextToken();\nif (t == null) { // is this even legal?\nreturn (_currToken = t);\n}\nTokenFilter f;\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\n// but if we didn't figure it out yet, need to buffer possible events\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\ncontinue main_loop;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn (_currToken = t);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\ncontinue main_loop;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\nboolean returnEnd = _headContext.isStartHandled();\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\nif (returnEnd) {\nreturn (_currToken = t);\n}\n}\ncontinue main_loop;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nreturn (_currToken = t);\n}\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\nf = f.includeProperty(name);\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nif (_includePath) {\nreturn (_currToken = t);\n}\n//                        if (_includeImmediateParent) { ...\ncontinue main_loop;\n}\nif (_includePath) {\nt = _nextTokenWithBuffering(_headContext);\nif (t != null) {\n_currToken = t;\nreturn t;\n}\n}\n}\ncontinue main_loop;\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn (_currToken = t);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn (_currToken = t);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\nbreak;\n}\n}\n}\n\n/**\n* Method called when a new potentially included context is found.\n*/\nprotected final JsonToken _nextTokenWithBuffering(final TokenFilterContext buffRoot)\nthrows IOException\n{\nmain_loop:\nwhile (true) {\nJsonToken t = delegate.nextToken();\nif (t == null) { // is this even legal?\nreturn t;\n}\nTokenFilter f;\n\n// One simplification here: we know for a fact that the item filter is\n// neither null nor 'include all', for most cases; the only exception\n// being FIELD_NAME handling\n\nswitch (t.id()) {\ncase ID_START_ARRAY:\nf = _headContext.checkValue(_itemFilter);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartArray();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildArrayContext(f, true);\nreturn _nextBuffered(buffRoot);\n}\n_headContext = _headContext.createChildArrayContext(f, false);\ncontinue main_loop;\n\ncase ID_START_OBJECT:\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn t;\n}\nif (f == null) { // does this occur?\ndelegate.skipChildren();\ncontinue main_loop;\n}\n// Otherwise still iffy, need to check\nf = _headContext.checkValue(f);\nif (f == null) {\ndelegate.skipChildren();\ncontinue main_loop;\n}\nif (f != TokenFilter.INCLUDE_ALL) {\nf = f.filterStartObject();\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\n_headContext = _headContext.createChildObjectContext(f, true);\nreturn _nextBuffered(buffRoot);\n}\n_headContext = _headContext.createChildObjectContext(f, false);\ncontinue main_loop;\n\ncase ID_END_ARRAY:\ncase ID_END_OBJECT:\n{\n// Unlike with other loops, here we know that content was NOT\n// included (won't get this far otherwise)\nf = _headContext.getFilter();\nif ((f != null) && (f != TokenFilter.INCLUDE_ALL)) {\nf.filterFinishArray();\n}\nboolean gotEnd = (_headContext == buffRoot);\nboolean returnEnd = gotEnd && _headContext.isStartHandled();\n\n_headContext = _headContext.getParent();\n_itemFilter = _headContext.getFilter();\n\nif (returnEnd) {\nreturn t;\n}\n// Hmmh. Do we need both checks, or should above suffice?\nif (gotEnd || (_headContext == buffRoot)) {\nreturn null;\n}\n}\ncontinue main_loop;\n\ncase ID_FIELD_NAME:\n{\nfinal String name = delegate.getCurrentName();\nf = _headContext.setFieldName(name);\nif (f == TokenFilter.INCLUDE_ALL) {\n_itemFilter = f;\nreturn _nextBuffered(buffRoot);\n}\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\nf = f.includeProperty(name);\nif (f == null) { // filter out the value\ndelegate.nextToken();\ndelegate.skipChildren();\ncontinue main_loop;\n}\n_itemFilter = f;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn _nextBuffered(buffRoot);\n}\n}\ncontinue main_loop;\n\ndefault: // scalar value\nf = _itemFilter;\nif (f == TokenFilter.INCLUDE_ALL) {\nreturn _nextBuffered(buffRoot);\n}\nif (f != null) {\nf = _headContext.checkValue(f);\nif ((f == TokenFilter.INCLUDE_ALL)\n|| ((f != null) && f.includeValue(delegate))) {\nreturn _nextBuffered(buffRoot);\n}\n}\n// Otherwise not included (leaves must be explicitly included)\ncontinue main_loop;\n}\n}\n}\n\nprivate JsonToken _nextBuffered(TokenFilterContext buffRoot) throws IOException\n{\n_exposedContext = buffRoot;\nTokenFilterContext ctxt = buffRoot;\nJsonToken t = ctxt.nextTokenToRead();\nif (t != null) {\nreturn t;\n}\nwhile (true) {\n// all done with buffered stuff?\nif (ctxt == _headContext) {\nthrow _constructError(\"Internal error: failed to locate expected buffered tokens\");\n/*\n_exposedContext = null;\nbreak;\n*/\n}\n// If not, traverse down the context chain\nctxt = _exposedContext.findChildOf(ctxt);\n_exposedContext = ctxt;\nif (ctxt == null) { // should never occur\nthrow _constructError(\"Unexpected problem: chain of filtered context broken\");\n}\nt = _exposedContext.nextTokenToRead();\nif (t != null) {\nreturn t;\n}\n}\n}\n\n@Override\npublic JsonToken nextValue() throws IOException {\n// Re-implemented same as ParserMinimalBase:\nJsonToken t = nextToken();\nif (t == JsonToken.FIELD_NAME) {\nt = nextToken();\n}\nreturn t;\n}\n\n/**\n* Need to override, re-implement similar to how method defined in\n* {@link com.fasterxml.jackson.core.base.ParserMinimalBase}, to keep\n* state correct here.\n*/\n@Override\npublic JsonParser skipChildren() throws IOException\n{\nif ((_currToken != JsonToken.START_OBJECT)\n&& (_currToken != JsonToken.START_ARRAY)) {\nreturn this;\n}\nint open = 1;\n\n// Since proper matching of start/end markers is handled\n// by nextToken(), we'll just count nesting levels here\nwhile (true) {\nJsonToken t = nextToken();\nif (t == null) { // not ideal but for now, just return\nreturn this;\n}\nif (t.isStructStart()) {\n++open;\n} else if (t.isStructEnd()) {\nif (--open == 0) {\nreturn this;\n}\n}\n}\n}\n\n/*\n/**********************************************************\n/* Public API, access to token information, text\n/**********************************************************\n*/\n\n@Override public String getText() throws IOException { return delegate.getText();  }\n@Override public boolean hasTextCharacters() { return delegate.hasTextCharacters(); }\n@Override public char[] getTextCharacters() throws IOException { return delegate.getTextCharacters(); }\n@Override public int getTextLength() throws IOException { return delegate.getTextLength(); }\n@Override public int getTextOffset() throws IOException { return delegate.getTextOffset(); }\n\n/*\n/**********************************************************\n/* Public API, access to token information, numeric\n/**********************************************************\n*/\n\n@Override\npublic BigInteger getBigIntegerValue() throws IOException { return delegate.getBigIntegerValue(); }\n\n@Override\npublic boolean getBooleanValue() throws IOException { return delegate.getBooleanValue(); }\n\n@Override\npublic byte getByteValue() throws IOException { return delegate.getByteValue(); }\n\n@Override\npublic short getShortValue() throws IOException { return delegate.getShortValue(); }\n\n@Override\npublic BigDecimal getDecimalValue() throws IOException { return delegate.getDecimalValue(); }\n\n@Override\npublic double getDoubleValue() throws IOException { return delegate.getDoubleValue(); }\n\n@Override\npublic float getFloatValue() throws IOException { return delegate.getFloatValue(); }\n\n@Override\npublic int getIntValue() throws IOException { return delegate.getIntValue(); }\n\n@Override\npublic long getLongValue() throws IOException { return delegate.getLongValue(); }\n\n@Override\npublic NumberType getNumberType() throws IOException { return delegate.getNumberType(); }\n\n@Override\npublic Number getNumberValue() throws IOException { return delegate.getNumberValue(); }\n\n/*\n/**********************************************************\n/* Public API, access to token information, coercion/conversion\n/**********************************************************\n*/\n\n@Override public int getValueAsInt() throws IOException { return delegate.getValueAsInt(); }\n@Override public int getValueAsInt(int defaultValue) throws IOException { return delegate.getValueAsInt(defaultValue); }\n@Override public long getValueAsLong() throws IOException { return delegate.getValueAsLong(); }\n@Override public long getValueAsLong(long defaultValue) throws IOException { return delegate.getValueAsLong(defaultValue); }\n@Override public double getValueAsDouble() throws IOException { return delegate.getValueAsDouble(); }\n@Override public double getValueAsDouble(double defaultValue) throws IOException { return delegate.getValueAsDouble(defaultValue); }\n@Override public boolean getValueAsBoolean() throws IOException { return delegate.getValueAsBoolean(); }\n@Override public boolean getValueAsBoolean(boolean defaultValue) throws IOException { return delegate.getValueAsBoolean(defaultValue); }\n@Override public String getValueAsString() throws IOException { return delegate.getValueAsString(); }\n@Override public String getValueAsString(String defaultValue) throws IOException { return delegate.getValueAsString(defaultValue); }\n\n/*\n/**********************************************************\n/* Public API, access to token values, other\n/**********************************************************\n*/\n\n@Override public Object getEmbeddedObject() throws IOException { return delegate.getEmbeddedObject(); }\n@Override public byte[] getBinaryValue(Base64Variant b64variant) throws IOException { return delegate.getBinaryValue(b64variant); }\n@Override public int readBinaryValue(Base64Variant b64variant, OutputStream out) throws IOException { return delegate.readBinaryValue(b64variant, out); }\n@Override public JsonLocation getTokenLocation() { return delegate.getTokenLocation(); }\n\n/*\n/**********************************************************\n/* Internal helper methods\n/**********************************************************\n*/\n\nprotected JsonStreamContext _filterContext() {\nif (_exposedContext != null) {\nreturn _exposedContext;\n}\nreturn _headContext;\n}\n\n}\n}",
            "method_id": 29
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:canUseCharArrays()Z",
            "method_body": "public boolean canUseCharArrays() { return true; }\npublic boolean canUseCharArrays() { return true; }",
            "method_id": 30
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilter:includeValue(Lcom/fasterxml/jackson/core/JsonParser;)Z",
            "method_body": "public boolean includeValue(JsonParser p) throws IOException {\nreturn _includeScalar();\n}",
            "method_id": 31
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilterContext:getParent()Lcom/fasterxml/jackson/core/filter/TokenFilterContext;",
            "method_body": "@Override public final TokenFilterContext getParent() { return _parent; }\n@Override public final TokenFilterContext getParent() { return _parent; }",
            "method_id": 32
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilterContext:isStartHandled()Z",
            "method_body": "public boolean isStartHandled() { return _startHandled; }\npublic boolean isStartHandled() { return _startHandled; }",
            "method_id": 33
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.GeneratorBase:getOutputContext()Lcom/fasterxml/jackson/core/json/JsonWriteContext;",
            "method_body": "@Override public final JsonWriteContext getOutputContext() { return _writeContext; }\n@Override public final JsonWriteContext getOutputContext() { return _writeContext; }",
            "method_id": 34
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonWriteContext:writeValue()I",
            "method_body": "public int writeValue() {\n// Most likely, object:\nif (_type == TYPE_OBJECT) {\nif (!_gotName) {\nreturn STATUS_EXPECT_NAME;\n}\n_gotName = false;\n++_index;\nreturn STATUS_OK_AFTER_COLON;\n}\n\n// Ok, array?\nif (_type == TYPE_ARRAY) {\nint ix = _index;\n++_index;\nreturn (ix < 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_COMMA;\n}\n\n// Nope, root context\n// No commas within root context, but need space\n++_index;\nreturn (_index == 0) ? STATUS_OK_AS_IS : STATUS_OK_AFTER_SPACE;\n}",
            "method_id": 35
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.GeneratorBase:close()V",
            "method_body": "@Override public abstract void flush() throws IOException;\n@Override public void close() throws IOException { _closed = true; }",
            "method_id": 36
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:releaseConcatBuffer([C)V",
            "method_body": "public void releaseConcatBuffer(char[] buf) {\nif (buf != null) {\n// 14-Jan-2014, tatu: Let's actually allow upgrade of the original buffer.\n_verifyRelease(buf, _concatCBuffer);\n_concatCBuffer = null;\n_bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_CONCAT_BUFFER, buf);\n}\n}",
            "method_id": 37
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.GeneratorBase:isEnabled(Lcom/fasterxml/jackson/core/JsonGenerator$Feature;)Z",
            "method_body": "@Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; }\n@Override public final boolean isEnabled(Feature f) { return (_features & f.getMask()) != 0; }",
            "method_id": 38
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator$Feature:enabledIn(I)Z",
            "method_body": "public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\npublic boolean enabledIn(int flags) { return (flags & _mask) != 0; }",
            "method_id": 39
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator:<init>()V",
            "method_body": "protected JsonGenerator() { }\nprotected JsonGenerator() { }",
            "method_id": 40
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.GeneratorBase:<init>(ILcom/fasterxml/jackson/core/ObjectCodec;)V",
            "method_body": "protected GeneratorBase(int features, ObjectCodec codec) {\nsuper();\n_features = features;\n_objectCodec = codec;\nDupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n? DupDetector.rootDetector(this) : null;\n_writeContext = JsonWriteContext.createRootContext(dups);\n_cfgNumbersAsStrings = Feature.WRITE_NUMBERS_AS_STRINGS.enabledIn(features);\n}",
            "method_id": 41
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.GeneratorBase:<clinit>()V",
            "method_body": "public final static int SURR1_FIRST = 0xD800;\npublic final static int SURR1_LAST = 0xDBFF;\npublic final static int SURR2_FIRST = 0xDC00;\npublic final static int SURR2_LAST = 0xDFFF;\n\n/**\n* Set of feature masks related to features that need updates of other\n* local configuration or state.\n*\n* @since 2.5\n*/\nprotected final static int DERIVED_FEATURES_MASK =\nFeature.WRITE_NUMBERS_AS_STRINGS.getMask()\n| Feature.ESCAPE_NON_ASCII.getMask()\n| Feature.STRICT_DUPLICATE_DETECTION.getMask()\n;\n\n// // // Constants for validation messages (since 2.6)\n\nprotected final String WRITE_BINARY = \"write a binary value\";\nprotected final String WRITE_BOOLEAN = \"write a boolean value\";\nprotected final String WRITE_NULL = \"write a null\";\nprotected final String WRITE_NUMBER = \"write a number\";\nprotected final String WRITE_RAW = \"write a raw (unencoded) value\";\nprotected final String WRITE_STRING = \"write a string\";\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\nprotected ObjectCodec _objectCodec;\n\n/**\n* Bit flag composed of bits that indicate which\n* {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s",
            "method_id": 42
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonGeneratorImpl:<init>(Lcom/fasterxml/jackson/core/io/IOContext;ILcom/fasterxml/jackson/core/ObjectCodec;)V",
            "method_body": "public JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec)\n{\nsuper(features, codec);\n_ioContext = ctxt;\nif (Feature.ESCAPE_NON_ASCII.enabledIn(features)) {\n// inlined `setHighestNonEscapedChar()`\n_maximumNonEscapedChar = 127;\n}\n_cfgUnqNames = !Feature.QUOTE_FIELD_NAMES.enabledIn(features);\n}",
            "method_id": 43
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonGeneratorImpl:<clinit>()V",
            "method_body": "protected final static int[] sOutputEscapes = CharTypes.get7BitOutputEscapes();\n\n/*\n/**********************************************************\n/* Configuration, basic I/O\n/**********************************************************\n*/\n\nfinal protected IOContext _ioContext;\n\n/*\n/**********************************************************\n/* Configuration, output escaping\n/**********************************************************\n*/\n\n/**\n* Currently active set of output escape code definitions (whether\n* and how to escape or not) for 7-bit ASCII range (first 128\n* character codes). Defined separately to make potentially\n* customizable\n*/\nprotected int[] _outputEscapes = sOutputEscapes;\n\n/**\n* Value between 128 (0x80) and 65535 (0xFFFF) that indicates highest\n* Unicode code point that will not need escaping; or 0 to indicate\n* that all characters can be represented without escaping.\n* Typically used to force escaping of some portion of character set;\n* for example to always escape non-ASCII characters (if value was 127).\n*<p>\n* NOTE: not all sub-classes make use of this setting.\n*/\nprotected int _maximumNonEscapedChar;\n\n/**\n* Definition of custom character escapes to use for generators created\n* by this factory, if any. If null, standard data format specific\n* escapes are used.\n*/\nprotected CharacterEscapes _characterEscapes;\n\n/*\n/**********************************************************\n/* Configuration, other\n/**********************************************************\n*/\n\n/**\n* Separator to use, if any, between root-level values.\n*\n* @since 2.1\n*/\nprotected SerializableString _rootValueSeparator\n= DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;\n\n/**\n* Flag that is set if quoting is not to be added around\n* JSON Object property names.\n*\n* @since 2.7\n*/\nprotected boolean _cfgUnqNames;\n\n/*\n/**********************************************************\n/* Life-cycle\n/**********************************************************\n*/\n\npublic JsonGeneratorImpl(IOContext ctxt, int features, ObjectCodec codec)\n{\nsuper(features, codec);\n_ioContext = ctxt;\nif (Feature.ESCAPE_NON_ASCII.enabledIn(features)) {\n// inlined `setHighestNonEscapedChar()`\n_maximumNonEscapedChar = 127;\n}\n_cfgUnqNames = !Feature.QUOTE_FIELD_NAMES.enabledIn(features);\n}",
            "method_id": 44
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonWriteContext:<init>(ILcom/fasterxml/jackson/core/json/JsonWriteContext;Lcom/fasterxml/jackson/core/json/DupDetector;)V",
            "method_body": "protected JsonWriteContext(int type, JsonWriteContext parent, DupDetector dups) {\nsuper();\n_type = type;\n_parent = parent;\n_dups = dups;\n_index = -1;\n}",
            "method_id": 45
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonWriteContext:createRootContext(Lcom/fasterxml/jackson/core/json/DupDetector;)Lcom/fasterxml/jackson/core/json/JsonWriteContext;",
            "method_body": "public static JsonWriteContext createRootContext(DupDetector dd) {\nreturn new JsonWriteContext(TYPE_ROOT, null, dd);\n}",
            "method_id": 46
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:allocConcatBuffer()[C",
            "method_body": "public char[] allocConcatBuffer() {\n_verifyAlloc(_concatCBuffer);\nreturn (_concatCBuffer = _bufferRecycler.allocCharBuffer(BufferRecycler.CHAR_CONCAT_BUFFER));\n}",
            "method_id": 47
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilter:filterStartArray()Lcom/fasterxml/jackson/core/filter/TokenFilter;",
            "method_body": "public TokenFilter filterStartArray() {\nreturn this;\n}",
            "method_id": 48
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.JsonParserDelegate:close()V",
            "method_body": "@Override public void close() throws IOException { delegate.close(); }\n@Override public void close() throws IOException { delegate.close(); }",
            "method_id": 49
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.CharTypes:get7BitOutputEscapes()[I",
            "method_body": "public static int[] get7BitOutputEscapes() { return sOutputEscapes128; }\npublic static int[] get7BitOutputEscapes() { return sOutputEscapes128; }",
            "method_id": 50
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser:<init>()V",
            "method_body": "protected JsonParser() { }\nprotected JsonParser() { }",
            "method_id": 51
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.JsonParserDelegate:<init>(Lcom/fasterxml/jackson/core/JsonParser;)V",
            "method_body": "public JsonParserDelegate(JsonParser d) {\ndelegate = d;\n}",
            "method_id": 52
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilter:filterStartObject()Lcom/fasterxml/jackson/core/filter/TokenFilter;",
            "method_body": "public TokenFilter filterStartObject() {\nreturn this;\n}",
            "method_id": 53
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonStreamContext:inArray()Z",
            "method_body": "public abstract JsonStreamContext getParent();\n\n/**\n* Method that returns true if this context is an Array context;\n* that is, content is being read from or written to a Json Array.\n*/\npublic final boolean inArray() { return _type == TYPE_ARRAY; }",
            "method_id": 54
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilterContext:reset(ILcom/fasterxml/jackson/core/filter/TokenFilter;Z)Lcom/fasterxml/jackson/core/filter/TokenFilterContext;",
            "method_body": "protected TokenFilterContext reset(int type,\nTokenFilter filter, boolean startWritten)\n{\n_type = type;\n_filter = filter;\n_index = -1;\n_currentName = null;\n_startHandled = startWritten;\n_needToHandleName = false;\nreturn this;\n}",
            "method_id": 55
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.SerializedString:getValue()Ljava/lang/String;",
            "method_body": "public final String getValue() { return _value; }\npublic final String getValue() { return _value; }",
            "method_id": 56
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilterContext:createChildArrayContext(Lcom/fasterxml/jackson/core/filter/TokenFilter;Z)Lcom/fasterxml/jackson/core/filter/TokenFilterContext;",
            "method_body": "public TokenFilterContext createChildArrayContext(TokenFilter filter, boolean writeStart) {\nTokenFilterContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new TokenFilterContext(TYPE_ARRAY, this, filter, writeStart);\nreturn ctxt;\n}\nreturn ctxt.reset(TYPE_ARRAY, filter, writeStart);\n}",
            "method_id": 57
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilter:filterFinishArray()V",
            "method_body": "public void filterFinishArray() { }\npublic void filterFinishArray() { }",
            "method_id": 58
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:_verifyRelease([C[C)V",
            "method_body": "protected final void _verifyRelease(char[] toRelease, char[] src) {\nif ((toRelease != src) && (toRelease.length <= src.length)) { throw wrongBuf(); }\n}",
            "method_id": 59
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:isResourceManaged()Z",
            "method_body": "public boolean isResourceManaged() { return _managedResource; }\npublic boolean isResourceManaged() { return _managedResource; }",
            "method_id": 60
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator:_verifyValueWrite(Ljava/lang/String;)V",
            "method_body": "protected void _verifyValueWrite(String typeMsg) throws IOException\n{\nif (_cfgPrettyPrinter != null) {\n// Otherwise, pretty printer knows what to do...\n_verifyPrettyValueWrite(typeMsg);\nreturn;\n}\nchar c;\nfinal int status = _writeContext.writeValue();\nif (status == JsonWriteContext.STATUS_EXPECT_NAME) {\n_reportError(\"Can not \"+typeMsg+\", expecting field name\");\n}\nswitch (status) {\ncase JsonWriteContext.STATUS_OK_AFTER_COMMA:\nc = ',';\nbreak;\ncase JsonWriteContext.STATUS_OK_AFTER_COLON:\nc = ':';\nbreak;\ncase JsonWriteContext.STATUS_OK_AFTER_SPACE: // root-value separator\nif (_rootValueSeparator != null) {\nwriteRaw(_rootValueSeparator.getValue());\n}\nreturn;\ncase JsonWriteContext.STATUS_OK_AS_IS:\ndefault:\nreturn;\n}\nif (_outputTail >= _outputEnd) {\n_flushBuffer();\n}\n_outputBuffer[_outputTail] = c;\n++_outputTail;\n}",
            "method_id": 61
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:createGenerator(Ljava/io/Writer;)Lcom/fasterxml/jackson/core/JsonGenerator;",
            "method_body": "public JsonGenerator createGenerator(Writer w) throws IOException {\nIOContext ctxt = _createContext(w, false);\nreturn _createGenerator(_decorate(w, ctxt), ctxt);\n}",
            "method_id": 62
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:_createGenerator(Ljava/io/Writer;Lcom/fasterxml/jackson/core/io/IOContext;)Lcom/fasterxml/jackson/core/JsonGenerator;",
            "method_body": "protected JsonGenerator _createGenerator(Writer out, IOContext ctxt) throws IOException\n{\nWriterBasedJsonGenerator gen = new WriterBasedJsonGenerator(ctxt,\n_generatorFeatures, _objectCodec, out);\nif (_characterEscapes != null) {\ngen.setCharacterEscapes(_characterEscapes);\n}\nSerializableString rootSep = _rootValueSeparator;\nif (rootSep != DEFAULT_ROOT_VALUE_SEPARATOR) {\ngen.setRootValueSeparator(rootSep);\n}\nreturn gen;\n}",
            "method_id": 63
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator:close()V",
            "method_body": "public void close() throws IOException\n{\nsuper.close();\n\n/* 05-Dec-2008, tatu: To add [JACKSON-27], need to close open\n*   scopes.\n*/\n// First: let's see that we still have buffers...\nif (_outputBuffer != null\n&& isEnabled(Feature.AUTO_CLOSE_JSON_CONTENT)) {\nwhile (true) {\nJsonStreamContext ctxt = getOutputContext();\nif (ctxt.inArray()) {\nwriteEndArray();\n} else if (ctxt.inObject()) {\nwriteEndObject();\n} else {\nbreak;\n}\n}\n}\n_flushBuffer();\n_outputHead = 0;\n_outputTail = 0;\n\n/* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n*   on the underlying Reader, unless we \"own\" it, or auto-closing\n*   feature is enabled.\n*   One downside: when using UTF8Writer, underlying buffer(s)\n*   may not be properly recycled if we don't close the writer.\n*/\nif (_writer != null) {\nif (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_TARGET)) {\n_writer.close();\n} else  if (isEnabled(Feature.FLUSH_PASSED_TO_STREAM)) {\n// If we can't close it, we should at least flush\n_writer.flush();\n}\n}\n// Internal buffer(s) generator has can now be released as well\n_releaseBuffers();\n}",
            "method_id": 64
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator:_releaseBuffers()V",
            "method_body": "protected void _releaseBuffers()\n{\nchar[] buf = _outputBuffer;\nif (buf != null) {\n_outputBuffer = null;\n_ioContext.releaseConcatBuffer(buf);\n}\n}",
            "method_id": 65
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator:_flushBuffer()V",
            "method_body": "protected void _flushBuffer() throws IOException\n{\nint len = _outputTail - _outputHead;\nif (len > 0) {\nint offset = _outputHead;\n_outputTail = _outputHead = 0;\n_writer.write(_outputBuffer, offset, len);\n}\n}",
            "method_id": 66
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator:<init>(Lcom/fasterxml/jackson/core/io/IOContext;ILcom/fasterxml/jackson/core/ObjectCodec;Ljava/io/Writer;)V",
            "method_body": "public WriterBasedJsonGenerator(IOContext ctxt, int features,\nObjectCodec codec, Writer w)\n{\nsuper(ctxt, features, codec);\n_writer = w;\n_outputBuffer = ctxt.allocConcatBuffer();\n_outputEnd = _outputBuffer.length;\n}",
            "method_id": 67
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator:<clinit>()V",
            "method_body": "final protected static int SHORT_WRITE = 32;\n\nfinal protected static char[] HEX_CHARS = CharTypes.copyHexChars();\n\n/*\n/**********************************************************\n/* Output buffering\n/**********************************************************\n*/\n\nfinal protected Writer _writer;\n\n/**\n* Intermediate buffer in which contents are buffered before\n* being written using {@link #_writer}.",
            "method_id": 68
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilter:<init>()V",
            "method_body": "protected TokenFilter() { }\nprotected TokenFilter() { }",
            "method_id": 69
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilter:<clinit>()V",
            "method_body": "public final static TokenFilter INCLUDE_ALL = new TokenFilter();\n\n// Life-cycle\n\nprotected TokenFilter() { }",
            "method_id": 70
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilter:includeRootValue(I)Lcom/fasterxml/jackson/core/filter/TokenFilter;",
            "method_body": "public TokenFilter includeRootValue(int index) {\nreturn this;\n}",
            "method_id": 71
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilterContext:<init>(ILcom/fasterxml/jackson/core/filter/TokenFilterContext;Lcom/fasterxml/jackson/core/filter/TokenFilter;Z)V",
            "method_body": "protected TokenFilterContext(int type, TokenFilterContext parent,\nTokenFilter filter, boolean startHandled)\n{\nsuper();\n_type = type;\n_parent = parent;\n_filter = filter;\n_index = -1;\n_startHandled = startHandled;\n_needToHandleName = false;\n}",
            "method_id": 72
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilterContext:createRootContext(Lcom/fasterxml/jackson/core/filter/TokenFilter;)Lcom/fasterxml/jackson/core/filter/TokenFilterContext;",
            "method_body": "public static TokenFilterContext createRootContext(TokenFilter filter) {\n// true -> since we have no start/end marker, consider start handled\nreturn new TokenFilterContext(TYPE_ROOT, null, filter, true);\n}",
            "method_id": 73
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilterContext:createChildObjectContext(Lcom/fasterxml/jackson/core/filter/TokenFilter;Z)Lcom/fasterxml/jackson/core/filter/TokenFilterContext;",
            "method_body": "public TokenFilterContext createChildObjectContext(TokenFilter filter, boolean writeStart) {\nTokenFilterContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new TokenFilterContext(TYPE_OBJECT, this, filter, writeStart);\nreturn ctxt;\n}\nreturn ctxt.reset(TYPE_OBJECT, filter, writeStart);\n}",
            "method_id": 74
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilterContext:setFieldName(Ljava/lang/String;)Lcom/fasterxml/jackson/core/filter/TokenFilter;",
            "method_body": "public TokenFilter setFieldName(String name) throws JsonProcessingException {\n_currentName = name;\n_needToHandleName = true;\nreturn _filter;\n}",
            "method_id": 75
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilterContext:checkValue(Lcom/fasterxml/jackson/core/filter/TokenFilter;)Lcom/fasterxml/jackson/core/filter/TokenFilter;",
            "method_body": "public TokenFilter checkValue(TokenFilter filter) {\n// First, checks for Object properties have been made earlier:\nif (_type == TYPE_OBJECT) {\nreturn filter;\n}\n// We increase it first because at the beginning of array, value is -1\nint ix = ++_index;\nif (_type == TYPE_ARRAY) {\nreturn filter.includeElement(ix);\n}\nreturn filter.includeRootValue(ix);\n}",
            "method_id": 76
        },
        {
            "method_signature": "com.fasterxml.jackson.core.filter.TokenFilterContext:getFilter()Lcom/fasterxml/jackson/core/filter/TokenFilter;",
            "method_body": "public TokenFilter getFilter() { return _filter; }\npublic TokenFilter getFilter() { return _filter; }",
            "method_id": 77
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:releaseCharBuffer(I[C)V",
            "method_body": "public void releaseCharBuffer(int ix, char[] buffer) {\n_charBuffers[ix] = buffer;\n}",
            "method_id": 78
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonStreamContext:inObject()Z",
            "method_body": "public final boolean inObject() { return _type == TYPE_OBJECT; }\npublic final boolean inObject() { return _type == TYPE_OBJECT; }",
            "method_id": 79
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonStreamContext:<init>()V",
            "method_body": "protected JsonStreamContext() { }\nprotected JsonStreamContext() { }",
            "method_id": 80
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:createChildArrayContext(II)Lcom/fasterxml/jackson/core/json/JsonReadContext;",
            "method_body": "public JsonReadContext createChildArrayContext(int lineNr, int colNr) {\nJsonReadContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new JsonReadContext(this,\n(_dups == null) ? null : _dups.child(), TYPE_ARRAY, lineNr, colNr);\n} else {\nctxt.reset(TYPE_ARRAY, lineNr, colNr);\n}\nreturn ctxt;\n}",
            "method_id": 81
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:<init>()V",
            "method_body": "public JsonFactory() { this(null); }\npublic JsonFactory() { this(null); }",
            "method_id": 82
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;)V",
            "method_body": "public JsonFactory(ObjectCodec oc) { _objectCodec = oc; }\npublic JsonFactory(ObjectCodec oc) { _objectCodec = oc; }",
            "method_id": 83
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:<clinit>()V",
            "method_body": "public final static String FORMAT_NAME_JSON = \"JSON\";\n\n/**\n* Bitfield (set of flags) of all factory features that are enabled by default.\n*/\nprotected final static int DEFAULT_FACTORY_FEATURE_FLAGS = JsonFactory.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all parser features that are enabled\n* by default.\n*/\nprotected final static int DEFAULT_PARSER_FEATURE_FLAGS = JsonParser.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all generator features that are enabled\n* by default.\n*/\nprotected final static int DEFAULT_GENERATOR_FEATURE_FLAGS = JsonGenerator.Feature.collectDefaults();\n\nprivate final static SerializableString DEFAULT_ROOT_VALUE_SEPARATOR = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;\n\n/*\n/**********************************************************\n/* Buffer, symbol table management\n/**********************************************************\n*/\n\n/**\n* This <code>ThreadLocal</code> contains a {@link java.lang.ref.SoftReference}",
            "method_id": 84
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:<init>(Ljava/lang/String;IZ)V",
            "method_body": "private Feature(boolean defaultState) {\n_mask = (1 << ordinal());\n_defaultState = defaultState;\n}",
            "method_id": 85
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}",
            "method_id": 86
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:enabledByDefault()Z",
            "method_body": "public boolean enabledByDefault() { return _defaultState; }\npublic boolean enabledByDefault() { return _defaultState; }",
            "method_id": 87
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
            "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}",
            "method_id": 88
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}",
            "method_id": 89
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator$Feature:enabledByDefault()Z",
            "method_body": "public boolean enabledByDefault() { return _defaultState; }\npublic boolean enabledByDefault() { return _defaultState; }",
            "method_id": 90
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:createRoot()Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;",
            "method_body": "public static CharsToNameCanonicalizer createRoot() {\n/* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n* based attacks.\n*/\nlong now = System.currentTimeMillis();\n// ensure it's not 0; and might as well require to be odd so:\nint seed = (((int) now) + ((int) (now >>> 32))) | 1;\nreturn createRoot(seed);\n}",
            "method_id": 91
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:createRoot()Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer;",
            "method_body": "public static ByteQuadsCanonicalizer createRoot() {\n/* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n* based attacks.\n*/\nlong now = System.currentTimeMillis();\n// ensure it's not 0; and might as well require to be odd so:\nint seed = (((int) now) + ((int) (now >>> 32))) | 1;\nreturn createRoot(seed);\n}",
            "method_id": 92
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter:<clinit>()V",
            "method_body": "private static final long serialVersionUID = 1;\n\n/**\n* Constant that specifies default \"root-level\" separator to use between\n* root values: a single space character.\n*\n* @since 2.1\n*/\npublic final static SerializedString DEFAULT_ROOT_VALUE_SEPARATOR = new SerializedString(\" \");\n\n/**\n* Interface that defines objects that can produce indentation used\n* to separate object entries and array values. Indentation in this\n* context just means insertion of white space, independent of whether\n* linefeeds are output.\n*/\npublic interface Indenter\n{\nvoid writeIndentation(JsonGenerator jg, int level) throws IOException;\n\n/**\n* @return True if indenter is considered inline (does not add linefeeds),\n*   false otherwise\n*/\nboolean isInline();\n}",
            "method_id": 93
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.CharTypes:copyHexChars()[C",
            "method_body": "public static char[] copyHexChars() {\nreturn (char[]) HC.clone();\n}",
            "method_id": 94
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.CharTypes:<clinit>()V",
            "method_body": "private final static char[] HC = \"0123456789ABCDEF\".toCharArray();\nprivate final static byte[] HB;\nstatic {\nint len = HC.length;\nHB = new byte[len];\nfor (int i = 0; i < len; ++i) {\nHB[i] = (byte) HC[i];\n}\n}",
            "method_id": 95
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.SerializedString:<init>(Ljava/lang/String;)V",
            "method_body": "public SerializedString(String v) {\nif (v == null) {\nthrow new IllegalStateException(\"Null String illegal for SerializedString\");\n}\n_value = v;\n}",
            "method_id": 96
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:<clinit>()V",
            "method_body": "public final static int BYTE_READ_IO_BUFFER = 0;\n\n/**\n* Buffer used for temporarily storing encoded content; used\n* for example by UTF-8 encoding writer\n*/\npublic final static int BYTE_WRITE_ENCODING_BUFFER = 1;\n\n/**\n* Buffer used for temporarily concatenating output; used for\n* example when requesting output as byte array.\n*/\npublic final static int BYTE_WRITE_CONCAT_BUFFER = 2;\n\n/**\n* Buffer used for concatenating binary data that is either being\n* encoded as base64 output, or decoded from base64 input.\n*\n* @since 2.1\n*/\npublic final static int BYTE_BASE64_CODEC_BUFFER = 3;\n\npublic final static int CHAR_TOKEN_BUFFER = 0;  // Tokenizable input\npublic final static int CHAR_CONCAT_BUFFER = 1; // concatenated output\npublic final static int CHAR_TEXT_BUFFER = 2; // Text content from input\npublic final static int CHAR_NAME_COPY_BUFFER = 3; // Temporary buffer for getting name characters\n\n// Buffer lengths, defined in 2.4 (smaller before that)\n\nprivate final static int[] BYTE_BUFFER_LENGTHS = new int[] { 8000, 8000, 2000, 2000 };",
            "method_id": 97
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:<clinit>()V",
            "method_body": "public final static int HASH_MULT = 33;\n\n/**\n* Default initial table size. Shouldn't be miniscule (as there's\n* cost to both array realloc and rehashing), but let's keep\n* it reasonably small. For systems that properly\n* reuse factories it doesn't matter either way; but when\n* recreating factories often, initial overhead may dominate.\n*/\nprotected static final int DEFAULT_T_SIZE = 64;\n\n/**\n* Let's not expand symbol tables past some maximum size;\n* this should protected against OOMEs caused by large documents\n* with unique (~= random) names.\n*/\nprotected static final int MAX_T_SIZE = 0x10000; // 64k entries == 256k mem\n\n/**\n* Let's only share reasonably sized symbol tables. Max size set to 3/4 of 16k;\n* this corresponds to 64k main hash index. This should allow for enough distinct\n* names for almost any case.\n*/\nfinal static int MAX_ENTRIES_FOR_REUSE = 12000;\n\n/**\n* Also: to thwart attacks based on hash collisions (which may or may not\n* be cheap to calculate), we will need to detect \"too long\"\n* collision chains. Let's start with static value of 255 entries\n* for the longest legal chain.\n*<p>\n* Note: longest chain we have been able to produce without malicious\n* intent has been 38 (with \"com.fasterxml.jackson.core.main.TestWithTonsaSymbols\");\n* our setting should be reasonable here.\n*<p>\n* Also note that value was lowered from 255 (2.3 and earlier) to 100 for 2.4\n*\n* @since 2.1\n*/\nfinal static int MAX_COLL_CHAIN_LENGTH = 100;\n\nfinal static CharsToNameCanonicalizer sBootstrapSymbolTable = new CharsToNameCanonicalizer();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* Sharing of learnt symbols is done by optional linking of symbol\n* table instances with their parents. When parent linkage is\n* defined, and child instance is released (call to <code>release</code>),\n* parent's shared tables may be updated from the child instance.\n*/\nprotected CharsToNameCanonicalizer _parent;\n\n/**\n* Seed value we use as the base to make hash codes non-static between\n* different runs, but still stable for lifetime of a single symbol table\n* instance.\n* This is done for security reasons, to avoid potential DoS attack via\n* hash collisions.\n*\n* @since 2.1\n*/\nfinal private int _hashSeed;\n\nfinal protected int _flags;\n\n/**\n* Whether any canonicalization should be attempted (whether using\n* intern or not)\n*/\nprotected boolean _canonicalize;\n\n/*\n/**********************************************************\n/* Actual symbol table data\n/**********************************************************\n*/\n\n/**\n* Primary matching symbols; it's expected most match occur from\n* here.\n*/\nprotected String[] _symbols;\n\n/**\n* Overflow buckets; if primary doesn't match, lookup is done\n* from here.\n*<p>\n* Note: Number of buckets is half of number of symbol entries, on\n* assumption there's less need for buckets.\n*/\nprotected Bucket[] _buckets;\n\n/**\n* Current size (number of entries); needed to know if and when\n* rehash.\n*/\nprotected int _size;\n\n/**\n* Limit that indicates maximum size this instance can hold before\n* it needs to be expanded and rehashed. Calculated using fill\n* factor passed in to constructor.\n*/\nprotected int _sizeThreshold;\n\n/**\n* Mask used to get index from hash values; equal to\n* <code>_buckets.length - 1</code>, when _buckets.length is\n* a power of two.\n*/\nprotected int _indexMask;\n\n/**\n* We need to keep track of the longest collision list; this is needed\n* both to indicate problems with attacks and to allow flushing for\n* other cases.\n*\n* @since 2.1\n*/\nprotected int _longestCollisionList;\n\n/*\n/**********************************************************\n/* State regarding shared arrays\n/**********************************************************\n*/\n\n/**\n* Flag that indicates if any changes have been made to the data;\n* used to both determine if bucket array needs to be copied when\n* (first) change is made, and potentially if updated bucket list\n* is to be resync'ed back to master instance.\n*/\nprotected boolean _dirty;\n\n/*\n/**********************************************************\n/* Bit of DoS detection goodness\n/**********************************************************\n*/\n\n/**\n* Lazily constructed structure that is used to keep track of\n* collision buckets that have overflowed once: this is used\n* to detect likely attempts at denial-of-service attacks that\n* uses hash collisions.\n*\n* @since 2.4\n*/\nprotected BitSet _overflows;\n\n/*\n/**********************************************************\n/* Life-cycle\n/**********************************************************\n*/\n\n/**\n* Method called to create root canonicalizer for a {@link com.fasterxml.jackson.core.JsonFactory}",
            "method_id": 98
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:createRoot(I)Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;",
            "method_body": "protected static CharsToNameCanonicalizer createRoot(int hashSeed) {\nreturn sBootstrapSymbolTable.makeOrphan(hashSeed);\n}",
            "method_id": 99
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:initTables(I)V",
            "method_body": "private void initTables(int initialSize)\n{\n_symbols = new String[initialSize];\n_buckets = new Bucket[initialSize >> 1];\n// Mask is easy to calc for powers of two.\n_indexMask = initialSize - 1;\n_size = 0;\n_longestCollisionList = 0;\n// Hard-coded fill factor is 75%\n_sizeThreshold = _thresholdSize(initialSize);\n}",
            "method_id": 100
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:_thresholdSize(I)I",
            "method_body": "private static int _thresholdSize(int hashAreaSize) { return hashAreaSize - (hashAreaSize >> 2); }\nprivate static int _thresholdSize(int hashAreaSize) { return hashAreaSize - (hashAreaSize >> 2); }",
            "method_id": 101
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:makeOrphan(I)Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;",
            "method_body": "private CharsToNameCanonicalizer makeOrphan(int seed) {\nreturn new CharsToNameCanonicalizer(null, -1, _symbols, _buckets, _size, seed, _longestCollisionList);\n}",
            "method_id": 102
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:createRoot(I)Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer;",
            "method_body": "protected static ByteQuadsCanonicalizer createRoot(int seed) {\nreturn new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n}",
            "method_id": 103
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:_calcTertiaryShift(I)I",
            "method_body": "static int _calcTertiaryShift(int primarySlots)\n{\n// first: we only get 1/4 of slots of primary, to divide\nint tertSlots = (primarySlots) >> 2;\n\n// default is for buckets of 4 slots (each 4 ints, i.e. 1 << 4)\nif (tertSlots < 64) {\nreturn 4;\n}\nif (tertSlots <= 256) { // buckets of 8 slots (up to 256 == 32 x 8)\nreturn 5;\n}\nif (tertSlots <= 1024) { // buckets of 16 slots (up to 1024 == 64 x 16)\nreturn 6;\n}\n// and biggest buckets have 32 slots\nreturn 7;\n}",
            "method_id": 104
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer$TableInfo:<init>(III[I[Ljava/lang/String;II)V",
            "method_body": "public TableInfo(int size, int count, int tertiaryShift,\nint[] mainHash, String[] names, int spilloverEnd, int longNameOffset)\n{\nthis.size = size;\nthis.count = count;\nthis.tertiaryShift = tertiaryShift;\nthis.mainHash = mainHash;\nthis.names = names;\nthis.spilloverEnd = spilloverEnd;\nthis.longNameOffset = longNameOffset;\n}",
            "method_id": 105
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer$TableInfo:createInitial(I)Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer$TableInfo;",
            "method_body": "public static TableInfo createInitial(int sz) {\nint hashAreaSize = sz << 3;\nint tertShift = _calcTertiaryShift(sz);\n\nreturn new TableInfo(sz, // hashSize\n0, // count\ntertShift,\nnew int[hashAreaSize], // mainHash, 2x slots, 4 ints per slot\nnew String[sz << 1], // names == 2x slots\nhashAreaSize - sz, // at 7/8 of the total area\nhashAreaSize // longNameOffset, immediately after main hashes\n);\n}",
            "method_id": 106
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults() {\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) { flags |= f.getMask(); }\n}\nreturn flags;\n}",
            "method_id": 107
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:enabledByDefault()Z",
            "method_body": "public boolean enabledByDefault() { return _defaultState; }\npublic boolean enabledByDefault() { return _defaultState; }",
            "method_id": 108
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:<init>(Ljava/lang/String;IZ)V",
            "method_body": "private Feature(boolean defaultState) { _defaultState = defaultState; }\nprivate Feature(boolean defaultState) { _defaultState = defaultState; }",
            "method_id": 109
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator:copyCurrentEvent(Lcom/fasterxml/jackson/core/JsonParser;)V",
            "method_body": "public void copyCurrentEvent(JsonParser p) throws IOException\n{\nJsonToken t = p.getCurrentToken();\n// sanity check; what to do?\nif (t == null) {\n_reportError(\"No current event to copy\");\n}\nswitch (t.id()) {\ncase ID_NOT_AVAILABLE:\n_reportError(\"No current event to copy\");\ncase ID_START_OBJECT:\nwriteStartObject();\nbreak;\ncase ID_END_OBJECT:\nwriteEndObject();\nbreak;\ncase ID_START_ARRAY:\nwriteStartArray();\nbreak;\ncase ID_END_ARRAY:\nwriteEndArray();\nbreak;\ncase ID_FIELD_NAME:\nwriteFieldName(p.getCurrentName());\nbreak;\ncase ID_STRING:\nif (p.hasTextCharacters()) {\nwriteString(p.getTextCharacters(), p.getTextOffset(), p.getTextLength());\n} else {\nwriteString(p.getText());\n}\nbreak;\ncase ID_NUMBER_INT:\n{\nNumberType n = p.getNumberType();\nif (n == NumberType.INT) {\nwriteNumber(p.getIntValue());\n} else if (n == NumberType.BIG_INTEGER) {\nwriteNumber(p.getBigIntegerValue());\n} else {\nwriteNumber(p.getLongValue());\n}\nbreak;\n}\ncase ID_NUMBER_FLOAT:\n{\nNumberType n = p.getNumberType();\nif (n == NumberType.BIG_DECIMAL) {\nwriteNumber(p.getDecimalValue());\n} else if (n == NumberType.FLOAT) {\nwriteNumber(p.getFloatValue());\n} else {\nwriteNumber(p.getDoubleValue());\n}\nbreak;\n}\ncase ID_TRUE:\nwriteBoolean(true);\nbreak;\ncase ID_FALSE:\nwriteBoolean(false);\nbreak;\ncase ID_NULL:\nwriteNull();\nbreak;\ncase ID_EMBEDDED_OBJECT:\nwriteObject(p.getEmbeddedObject());\nbreak;\ndefault:\n_throwInternal();\n}\n}",
            "method_id": 110
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator:writeRaw(Ljava/lang/String;)V",
            "method_body": "public void writeRaw(String text) throws IOException\n{\n// Nothing to check, can just output as is\nint len = text.length();\nint room = _outputEnd - _outputTail;\n\nif (room == 0) {\n_flushBuffer();\nroom = _outputEnd - _outputTail;\n}\n// But would it nicely fit in? If yes, it's easy\nif (room >= len) {\ntext.getChars(0, len, _outputBuffer, _outputTail);\n_outputTail += len;\n} else {\nwriteRawLong(text);\n}\n}",
            "method_id": 111
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:clearAndGetParent()Lcom/fasterxml/jackson/core/json/JsonReadContext;",
            "method_body": "public JsonReadContext clearAndGetParent() {\n_currentValue = null;\n// could also clear the current name, but seems cheap enough to leave?\nreturn _parent;\n}",
            "method_id": 112
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:getNumberType()Lcom/fasterxml/jackson/core/JsonParser$NumberType;",
            "method_body": "public NumberType getNumberType() throws IOException\n{\nif (_numTypesValid == NR_UNKNOWN) {\n_parseNumericValue(NR_UNKNOWN); // will also check event type\n}\nif (_currToken == JsonToken.VALUE_NUMBER_INT) {\nif ((_numTypesValid & NR_INT) != 0) {\nreturn NumberType.INT;\n}\nif ((_numTypesValid & NR_LONG) != 0) {\nreturn NumberType.LONG;\n}\nreturn NumberType.BIG_INTEGER;\n}\n\n/* And then floating point types. Here optimal type\n* needs to be big decimal, to avoid losing any data?\n* However... using BD is slow, so let's allow returning\n* double as type if no explicit call has been made to access\n* data as BD?\n*/\nif ((_numTypesValid & NR_BIGDECIMAL) != 0) {\nreturn NumberType.BIG_DECIMAL;\n}\nreturn NumberType.DOUBLE;\n}",
            "method_id": 113
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$NumberType:<clinit>()V",
            "method_body": "private final static int MIN_BYTE_I = (int) Byte.MIN_VALUE;\n// as per [JACKSON-804], allow range up to and including 255\nprivate final static int MAX_BYTE_I = (int) 255;\n\nprivate final static int MIN_SHORT_I = (int) Short.MIN_VALUE;\nprivate final static int MAX_SHORT_I = (int) Short.MAX_VALUE;\n\n/**\n* Enumeration of possible \"native\" (optimal) types that can be\n* used for numbers.\n*/\npublic enum NumberType {\nINT, LONG, BIG_INTEGER, FLOAT, DOUBLE, BIG_DECIMAL\n};",
            "method_id": 114
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:releaseTokenBuffer([C)V",
            "method_body": "public void releaseTokenBuffer(char[] buf) {\nif (buf != null) {\n_verifyRelease(buf, _tokenCBuffer);\n_tokenCBuffer = null;\n_bufferRecycler.releaseCharBuffer(BufferRecycler.CHAR_TOKEN_BUFFER, buf);\n}\n}",
            "method_id": 115
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:_releaseBuffers()V",
            "method_body": "protected void _releaseBuffers() throws IOException {\nsuper._releaseBuffers();\n// merge new symbols, if any\n_symbols.release();\n// and release buffers, if they are recyclable ones\nif (_bufferRecyclable) {\nchar[] buf = _inputBuffer;\nif (buf != null) {\n_inputBuffer = null;\n_ioContext.releaseTokenBuffer(buf);\n}\n}\n}",
            "method_id": 116
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:_skipWSOrEnd()I",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n_updateLocation();\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleOddValue(i);\n}\n\nprotected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n{\n// // // and this is back to standard nextToken()\nString name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n_parsingContext.setCurrentName(name);\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n_updateLocation();\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn nameToMatch.equals(name);\n}\n// Ok: we must have a value... what is it?\nJsonToken t;\nswitch (i) {\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ncase 'f':\n_matchFalse();\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchNull();\nt = JsonToken.VALUE_NULL;\nbreak;\ncase 't':\n_matchTrue();\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ndefault:\nt = _handleOddValue(i);\nbreak;\n}\n_nextToken = t;\nreturn nameToMatch.equals(name);\n}\n\nprivate final JsonToken _nextTokenNotInObject(int i) throws IOException\n{\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\nreturn (_currToken = JsonToken.VALUE_STRING);\n}\nswitch (i) {\ncase '[':\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_ARRAY);\ncase '{':\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_OBJECT);\ncase 't':\n_matchToken(\"true\", 1);\nreturn (_currToken = JsonToken.VALUE_TRUE);\ncase 'f':\n_matchToken(\"false\", 1);\nreturn (_currToken = JsonToken.VALUE_FALSE);\ncase 'n':\n_matchToken(\"null\", 1);\nreturn (_currToken = JsonToken.VALUE_NULL);\ncase '-':\nreturn (_currToken = _parseNegNumber());\n/* Should we have separate handling for plus? Although\n* it is not allowed per se, it may be erroneously used,\n* and could be indicated by a more specific error message.\n*/\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn (_currToken = _parsePosNumber(i));\n}\nreturn (_currToken = _handleOddValue(i));\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final String nextTextValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\n_finishString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final int nextIntValue(int defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) {\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final long nextLongValue(long defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final Boolean nextBooleanValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\nJsonToken t = nextToken();\nif (t != null) {\nint id = t.id();\nif (id == ID_TRUE) return Boolean.TRUE;\nif (id == ID_FALSE) return Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected final JsonToken _parsePosNumber(int ch) throws IOException\n{\n/* Although we will always be complete with respect to textual\n* representation (that is, all characters will be parsed),\n* actual conversion to a number is deferred. Thus, need to\n* note that no representations are valid yet\n*/\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include digit already read\nfinal int inputLen = _inputEnd;\n\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(false, startPtr);\n}\n\n/* First, let's see if the whole number is contained within\n* the input buffer unsplit. This should be the common case;\n* and to simplify processing, we will just reparse contents\n* in the alternative case (number split on buffer boundary)\n*/\n\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(false, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, false, intLen);\n}\n// Got it all: let's add to text buffer for parsing, access\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(false, intLen);\n}\n\nprivate final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\nthrows IOException\n{\nfinal int inputLen = _inputEnd;\nint fractLen = 0;\n\n// And then see if we get other parts\nif (ch == '.') { // yes, fraction\nfract_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n}\n}\nint expLen = 0;\nif (ch == 'e' || ch == 'E') { // and/or exponent\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\n// Sign indicator?\nch = (int) _inputBuffer[ptr++];\nif (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\nwhile (ch <= INT_9 && ch >= INT_0) {\n++expLen;\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n}\n}\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n// And there we have it!\nreturn resetFloat(neg, intLen, fractLen, expLen);\n}\n\nprotected final JsonToken _parseNegNumber() throws IOException\n{\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include sign/digit already read\nfinal int inputLen = _inputEnd;\n\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nint ch = _inputBuffer[ptr++];\n// First check: must have a digit to follow minus sign\nif (ch > INT_9 || ch < INT_0) {\n_inputPtr = ptr;\nreturn _handleInvalidNumberStart(ch, true);\n}\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(true, startPtr);\n}\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\n\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, true, intLen);\n}\n--ptr;\n_inputPtr = ptr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to parse a number, when the primary parse\n* method has failed to parse it, due to it being split on\n* buffer boundary. As a result code is very similar, except\n* that it has to explicitly copy contents to the text buffer\n* instead of just sharing the main input buffer.\n*/\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n{\n_inputPtr = neg ? (startPtr+1) : startPtr;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\nif (neg) {\noutBuf[outPtr++] = '-';\n}\n\n// This is the place to do leading-zero check(s) too:\nint intLen = 0;\nchar c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\nif (c == '0') {\nc = _verifyNoLeadingZeroes();\n}\nboolean eof = false;\n\n// Ok, first the obligatory integer part:\nint_loop:\nwhile (c >= '0' && c <= '9') {\n++intLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\n// EOF is legal for main level int values\nc = CHAR_NULL;\neof = true;\nbreak int_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// Also, integer part is not optional\nif (intLen == 0) {\nreturn _handleInvalidNumberStart(c, neg);\n}\n\nint fractLen = 0;\n// And then see if we get other parts\nif (c == '.') { // yes, fraction\noutBuf[outPtr++] = c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = _inputBuffer[_inputPtr++];\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == 'e' || c == 'E') { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Not optional, can require that we get one more char\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Likewise, non optional:\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n// And there we have it!\nreturn reset(neg, intLen, fractLen, expLen);\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final char _verifyNoLeadingZeroes() throws IOException\n{\n// Fast case first:\nif (_inputPtr < _inputEnd) {\nchar ch = _inputBuffer[_inputPtr];\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\n}\n// and offline the less common case\nreturn _verifyNLZ2();\n}\n\nprivate char _verifyNLZ2() throws IOException\n{\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn '0';\n}\nchar ch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') { // followed by non-number; retain one zero\nreturn '0';\n}\n++_inputPtr; // skip previous zero\nif (ch != '0') { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n{\nif (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { _reportInvalidEOFInValue(); }\n}\nch = _inputBuffer[_inputPtr++];\nif (ch == 'N') {\nString match = negative ? \"-INF\" :\"+INF\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n} else if (ch == 'n') {\nString match = negative ? \"-Infinity\" :\"+Infinity\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName() throws IOException\n{\n// First: let's try to see if we have a simple name: one that does\n// not cross input buffer boundary, and does not contain escape sequences.\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int[] codes = _icLatin1;\n\nwhile (ptr < _inputEnd) {\nint ch = _inputBuffer[ptr];\nif (ch < codes.length && codes[ch] != 0) {\nif (ch == '\"') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n}\nint start = _inputPtr;\n_inputPtr = ptr;\nreturn _parseName2(start, hash, INT_QUOTE);\n}\n\nprivate String _parseName2(int startPtr, int hash, int endChar) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n/* Output pointers; calls will also ensure that the buffer is\n* not shared and has room for at least one more char.\n*/\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= endChar) {\nif (i == endChar) {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"name\");\n}\n}\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int i) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n_reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n}\nfinal int[] codes = CharTypes.getInputCodeLatin1JsNames();\nfinal int maxCode = codes.length;\n\n// Also: first char must be a valid name char, but NOT be number\nboolean firstOk;\n\nif (i < maxCode) { // identifier, or a number ([Issue#102])\nfirstOk = (codes[i] == 0);\n} else {\nfirstOk = Character.isJavaIdentifierPart((char) i);\n}\nif (!firstOk) {\n_reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode) {\nif (codes[ch] != 0) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\n} else if (!Character.isJavaIdentifierPart((char) ch)) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\nint start = _inputPtr-1;\n_inputPtr = ptr;\nreturn _handleOddName2(start, hash, codes);\n}\n\nprotected String _parseAposName() throws IOException\n{\n// Note: mostly copy of_parseFieldName\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch == '\\'') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nif (ch < maxCode && codes[ch] != 0) {\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\n\nint start = _inputPtr;\n_inputPtr = ptr;\n\nreturn _parseName2(start, hash, '\\'');\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleOddValue(int i) throws IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (i) {\ncase '\\'':\n/* [JACKSON-173]: allow single quotes. Unlike with regular\n* Strings, we'll eagerly parse contents; this so that there's\n* no need to store information on quote char used.\n*\n* Also, no separation to fast/slow parsing; we'll just do\n* one regular (~= slowish) parsing, to keep code simple\n*/\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(i)) {\n_reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= '\\\\') {\nif (i == '\\\\') {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= '\\'') {\nif (i == '\\'') {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\nreturn JsonToken.VALUE_STRING;\n}\n\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // acceptable for now (will error out later)\nbreak;\n}\n}\nchar c = _inputBuffer[_inputPtr];\nint i = (int) c;\nif (i <= maxCode) {\nif (codes[i] != 0) {\nbreak;\n}\n} else if (!Character.isJavaIdentifierPart(c)) {\nbreak;\n}\n++_inputPtr;\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\n\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n@Override\nprotected final void _finishString() throws IOException\n{\n/* First: let's try to see if we have simple String value: one\n* that does not cross input buffer boundary, and does not\n* contain escape sequences.\n*/\nint ptr = _inputPtr;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode && codes[ch] != 0) {\nif (ch == '\"') {\n_textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr+1;\n// Yes, we got it all\nreturn;\n}\nbreak;\n}\n++ptr;\n} while (ptr < inputLen);\n}\n\n/* Either ran out of input, or bumped into an escape\n* sequence...\n*/\n_textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr;\n_finishString2();\n}\n\nprotected void _finishString2() throws IOException\n{\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i < maxCode && codes[i] != 0) {\nif (i == INT_QUOTE) {\nbreak;\n} else if (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n} // anything else?\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected final void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\nint inPtr = _inputPtr;\nint inLen = _inputEnd;\nchar[] inBuf = _inputBuffer;\n\nwhile (true) {\nif (inPtr >= inLen) {\n_inputPtr = inPtr;\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\ninPtr = _inputPtr;\ninLen = _inputEnd;\n}\nchar c = inBuf[inPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\n_inputPtr = inPtr;\nc = _decodeEscaped();\ninPtr = _inputPtr;\ninLen = _inputEnd;\n} else if (i <= INT_QUOTE) {\nif (i == INT_QUOTE) {\n_inputPtr = inPtr;\nbreak;\n}\nif (i < INT_SPACE) {\n_inputPtr = inPtr;\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n}\n}\n\n/*\n/**********************************************************\n/* Internal methods, other parsing\n/**********************************************************\n*/\n\n/**\n* We actually need to check the character value here\n* (to see if we have \\n following \\r).\n*/\nprotected final void _skipCR() throws IOException {\nif (_inputPtr < _inputEnd || loadMore()) {\nif (_inputBuffer[_inputPtr] == '\\n') {\n++_inputPtr;\n}\n}\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n}\n\nprivate final int _skipColon() throws IOException\n{\nif ((_inputPtr + 4) >= _inputEnd) {\nreturn _skipColon2(false);\n}\nchar c = _inputBuffer[_inputPtr];\nif (c == ':') { // common case, no leading space\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) { // nor trailing\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (c == ' ' || c == '\\t') {\nc = _inputBuffer[++_inputPtr];\n}\nif (c == ':') {\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true);\n}\nreturn _skipColon2(false);\n}\n\nprivate final int _skipColon2(boolean gotColon) throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nif (gotColon) {\nreturn i;\n}\nif (i != INT_COLON) {\nif (i < INT_SPACE) {\n_throwInvalidSpace(i);\n}\n_reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n}\ngotColon = true;\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n// Variant called when we know there's at least 4 more bytes available\nprivate final int _skipColonFast(int ptr) throws IOException\n{\nint i = (int) _inputBuffer[ptr++];\nif (i == INT_COLON) { // common case, no leading space\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) { // nor trailing\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = _inputBuffer[ptr++];\n}\nboolean gotColon = (i == INT_COLON);\nif (gotColon) {\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(gotColon);\n}\n\n// Primary loop: no reloading, comment handling\nprivate final int _skipComma(int i) throws IOException\n{\nif (i != INT_COMMA) {\n_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n}\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipAfterComma2();\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipAfterComma2();\n}\n\nprivate final int _skipAfterComma2() throws IOException\n{\nwhile (_inputPtr < _inputEnd || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nthrow _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n}\n\nprivate final int _skipWSOrEnd() throws IOException\n{\n// Let's handle first character separately since it is likely that\n// it is either non-whitespace; or we have longer run of white space\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\nreturn _eofAsNextChar();\n}\n}\nint i = _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipWSOrEnd2();\n}\n\nprivate int _skipWSOrEnd2() throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // We ran out of input...\nreturn _eofAsNextChar();\n}\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n} else if (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\nprivate void _skipComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_COMMENTS)) {\n_reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n}\n// First: check which comment (if either) it is:\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_reportInvalidEOF(\" in a comment\");\n}\nchar c = _inputBuffer[_inputPtr++];\nif (c == '/') {\n_skipLine();\n} else if (c == '*') {\n_skipCComment();\n} else {\n_reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n}\n}\n\nprivate void _skipCComment() throws IOException\n{\n// Ok: need the matching '*/'\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i <= '*') {\nif (i == '*') { // end?\nif ((_inputPtr >= _inputEnd) && !loadMore()) {\nbreak;\n}\nif (_inputBuffer[_inputPtr] == INT_SLASH) {\n++_inputPtr;\nreturn;\n}\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n_reportInvalidEOF(\" in a comment\");\n}\n\nprivate boolean _skipYAMLComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\nreturn false;\n}\n_skipLine();\nreturn true;\n}\n\nprivate void _skipLine() throws IOException\n{\n// Ok: need to find EOF or linefeed\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nbreak;\n} else if (i == INT_CR) {\n_skipCR();\nbreak;\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n@Override\nprotected char _decodeEscaped() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\n\nswitch ((int) c) {\n// First, ones that are mapped\ncase 'b':\nreturn '\\b';\ncase 't':\nreturn '\\t';\ncase 'n':\nreturn '\\n';\ncase 'f':\nreturn '\\f';\ncase 'r':\nreturn '\\r';\n\n// And these are to be returned as they are\ncase '\"':\ncase '/':\ncase '\\\\':\nreturn c;\n\ncase 'u': // and finally hex-escaped\nbreak;\n\ndefault:\nreturn _handleUnrecognizedCharacterEscape(c);\n}\n\n// Ok, a hex escape. Need 4 characters\nint value = 0;\nfor (int i = 0; i < 4; ++i) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nint ch = (int) _inputBuffer[_inputPtr++];\nint digit = CharTypes.charToHex(ch);\nif (digit < 0) {\n_reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n}\nvalue = (value << 4) | digit;\n}\nreturn (char) value;\n}\n\nprivate final void _matchTrue() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"true\", 1);\n}\n\nprivate final void _matchFalse() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 4) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"false\", 1);\n}\n\nprivate final void _matchNull() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"null\", 1);\n}",
            "method_id": 117
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:_updateLocation()V",
            "method_body": "private final void _updateLocation()\n{\nint ptr = _inputPtr;\n_tokenInputTotal = _currInputProcessed + ptr;\n_tokenInputRow = _currInputRow;\n_tokenInputCol = ptr - _currInputRowStart;\n}",
            "method_id": 118
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:release()V",
            "method_body": "public void release(){\n// If nothing has been added, nothing to do\nif (!maybeDirty()) { return; }\nif (_parent != null && _canonicalize) { // canonicalize set to false if max size was reached\n_parent.mergeChild(this);\n/* Let's also mark this instance as dirty, so that just in\n* case release was too early, there's no corruption\n* of possibly shared data.\n*/\n_dirty = false;\n}\n}",
            "method_id": 119
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:maybeDirty()Z",
            "method_body": "public boolean maybeDirty() { return _dirty; }\npublic boolean maybeDirty() { return _dirty; }",
            "method_id": 120
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:reset(III)V",
            "method_body": "protected void reset(int type, int lineNr, int colNr) {\n_type = type;\n_index = -1;\n_lineNr = lineNr;\n_columnNr = colNr;\n_currentName = null;\n_currentValue = null;\nif (_dups != null) {\n_dups.reset();\n}\n}",
            "method_id": 121
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:_closeInput()V",
            "method_body": "protected void _closeInput() throws IOException {\n/* 25-Nov-2008, tatus: As per [JACKSON-16] we are not to call close()\n*   on the underlying Reader, unless we \"own\" it, or auto-closing\n*   feature is enabled.\n*   One downside is that when using our optimized\n*   Reader (granted, we only do that for UTF-32...) this\n*   means that buffer recycling won't work correctly.\n*/\nif (_reader != null) {\nif (_ioContext.isResourceManaged() || isEnabled(Feature.AUTO_CLOSE_SOURCE)) {\n_reader.close();\n}\n_reader = null;\n}\n}",
            "method_id": 122
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:hashSeed()I",
            "method_body": "public int hashSeed() { return _hashSeed; }\npublic int hashSeed() { return _hashSeed; }",
            "method_id": 123
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:<clinit>()V",
            "method_body": "protected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n/*\n/**********************************************************\n/* Input configuration\n/**********************************************************\n*/\n\n/**\n* Reader that can be used for reading more content, if one\n* buffer from input source, but in some cases pre-loaded buffer\n* is handed to the parser.\n*/\nprotected Reader _reader;\n\n/**\n* Current buffer from which data is read; generally data is read into\n* buffer from input source.\n*/\nprotected char[] _inputBuffer;\n\n/**\n* Flag that indicates whether the input buffer is recycable (and\n* needs to be returned to recycler once we are done) or not.\n*<p>\n* If it is not, it also means that parser can NOT modify underlying\n* buffer.\n*/\nprotected boolean _bufferRecyclable;\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\nprotected ObjectCodec _objectCodec;\n\nfinal protected CharsToNameCanonicalizer _symbols;\n\nfinal protected int _hashSeed;\n\n/*\n/**********************************************************\n/* Parsing state\n/**********************************************************\n*/\n\n/**\n* Flag that indicates that the current token has not yet\n* been fully processed, and needs to be finished for\n* some access (or skipped to obtain the next token)\n*/\nprotected boolean _tokenIncomplete;\n\n/**\n* Value of {@link #_inputPtr} at the time when the first character of",
            "method_id": 124
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:_matchTrue()V",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n_updateLocation();\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleOddValue(i);\n}\n\nprotected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n{\n// // // and this is back to standard nextToken()\nString name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n_parsingContext.setCurrentName(name);\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n_updateLocation();\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn nameToMatch.equals(name);\n}\n// Ok: we must have a value... what is it?\nJsonToken t;\nswitch (i) {\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ncase 'f':\n_matchFalse();\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchNull();\nt = JsonToken.VALUE_NULL;\nbreak;\ncase 't':\n_matchTrue();\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ndefault:\nt = _handleOddValue(i);\nbreak;\n}\n_nextToken = t;\nreturn nameToMatch.equals(name);\n}\n\nprivate final JsonToken _nextTokenNotInObject(int i) throws IOException\n{\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\nreturn (_currToken = JsonToken.VALUE_STRING);\n}\nswitch (i) {\ncase '[':\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_ARRAY);\ncase '{':\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_OBJECT);\ncase 't':\n_matchToken(\"true\", 1);\nreturn (_currToken = JsonToken.VALUE_TRUE);\ncase 'f':\n_matchToken(\"false\", 1);\nreturn (_currToken = JsonToken.VALUE_FALSE);\ncase 'n':\n_matchToken(\"null\", 1);\nreturn (_currToken = JsonToken.VALUE_NULL);\ncase '-':\nreturn (_currToken = _parseNegNumber());\n/* Should we have separate handling for plus? Although\n* it is not allowed per se, it may be erroneously used,\n* and could be indicated by a more specific error message.\n*/\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn (_currToken = _parsePosNumber(i));\n}\nreturn (_currToken = _handleOddValue(i));\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final String nextTextValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\n_finishString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final int nextIntValue(int defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) {\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final long nextLongValue(long defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final Boolean nextBooleanValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\nJsonToken t = nextToken();\nif (t != null) {\nint id = t.id();\nif (id == ID_TRUE) return Boolean.TRUE;\nif (id == ID_FALSE) return Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected final JsonToken _parsePosNumber(int ch) throws IOException\n{\n/* Although we will always be complete with respect to textual\n* representation (that is, all characters will be parsed),\n* actual conversion to a number is deferred. Thus, need to\n* note that no representations are valid yet\n*/\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include digit already read\nfinal int inputLen = _inputEnd;\n\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(false, startPtr);\n}\n\n/* First, let's see if the whole number is contained within\n* the input buffer unsplit. This should be the common case;\n* and to simplify processing, we will just reparse contents\n* in the alternative case (number split on buffer boundary)\n*/\n\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(false, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, false, intLen);\n}\n// Got it all: let's add to text buffer for parsing, access\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(false, intLen);\n}\n\nprivate final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\nthrows IOException\n{\nfinal int inputLen = _inputEnd;\nint fractLen = 0;\n\n// And then see if we get other parts\nif (ch == '.') { // yes, fraction\nfract_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n}\n}\nint expLen = 0;\nif (ch == 'e' || ch == 'E') { // and/or exponent\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\n// Sign indicator?\nch = (int) _inputBuffer[ptr++];\nif (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\nwhile (ch <= INT_9 && ch >= INT_0) {\n++expLen;\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n}\n}\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n// And there we have it!\nreturn resetFloat(neg, intLen, fractLen, expLen);\n}\n\nprotected final JsonToken _parseNegNumber() throws IOException\n{\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include sign/digit already read\nfinal int inputLen = _inputEnd;\n\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nint ch = _inputBuffer[ptr++];\n// First check: must have a digit to follow minus sign\nif (ch > INT_9 || ch < INT_0) {\n_inputPtr = ptr;\nreturn _handleInvalidNumberStart(ch, true);\n}\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(true, startPtr);\n}\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\n\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, true, intLen);\n}\n--ptr;\n_inputPtr = ptr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to parse a number, when the primary parse\n* method has failed to parse it, due to it being split on\n* buffer boundary. As a result code is very similar, except\n* that it has to explicitly copy contents to the text buffer\n* instead of just sharing the main input buffer.\n*/\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n{\n_inputPtr = neg ? (startPtr+1) : startPtr;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\nif (neg) {\noutBuf[outPtr++] = '-';\n}\n\n// This is the place to do leading-zero check(s) too:\nint intLen = 0;\nchar c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\nif (c == '0') {\nc = _verifyNoLeadingZeroes();\n}\nboolean eof = false;\n\n// Ok, first the obligatory integer part:\nint_loop:\nwhile (c >= '0' && c <= '9') {\n++intLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\n// EOF is legal for main level int values\nc = CHAR_NULL;\neof = true;\nbreak int_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// Also, integer part is not optional\nif (intLen == 0) {\nreturn _handleInvalidNumberStart(c, neg);\n}\n\nint fractLen = 0;\n// And then see if we get other parts\nif (c == '.') { // yes, fraction\noutBuf[outPtr++] = c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = _inputBuffer[_inputPtr++];\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == 'e' || c == 'E') { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Not optional, can require that we get one more char\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Likewise, non optional:\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n// And there we have it!\nreturn reset(neg, intLen, fractLen, expLen);\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final char _verifyNoLeadingZeroes() throws IOException\n{\n// Fast case first:\nif (_inputPtr < _inputEnd) {\nchar ch = _inputBuffer[_inputPtr];\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\n}\n// and offline the less common case\nreturn _verifyNLZ2();\n}\n\nprivate char _verifyNLZ2() throws IOException\n{\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn '0';\n}\nchar ch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') { // followed by non-number; retain one zero\nreturn '0';\n}\n++_inputPtr; // skip previous zero\nif (ch != '0') { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n{\nif (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { _reportInvalidEOFInValue(); }\n}\nch = _inputBuffer[_inputPtr++];\nif (ch == 'N') {\nString match = negative ? \"-INF\" :\"+INF\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n} else if (ch == 'n') {\nString match = negative ? \"-Infinity\" :\"+Infinity\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName() throws IOException\n{\n// First: let's try to see if we have a simple name: one that does\n// not cross input buffer boundary, and does not contain escape sequences.\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int[] codes = _icLatin1;\n\nwhile (ptr < _inputEnd) {\nint ch = _inputBuffer[ptr];\nif (ch < codes.length && codes[ch] != 0) {\nif (ch == '\"') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n}\nint start = _inputPtr;\n_inputPtr = ptr;\nreturn _parseName2(start, hash, INT_QUOTE);\n}\n\nprivate String _parseName2(int startPtr, int hash, int endChar) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n/* Output pointers; calls will also ensure that the buffer is\n* not shared and has room for at least one more char.\n*/\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= endChar) {\nif (i == endChar) {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"name\");\n}\n}\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int i) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n_reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n}\nfinal int[] codes = CharTypes.getInputCodeLatin1JsNames();\nfinal int maxCode = codes.length;\n\n// Also: first char must be a valid name char, but NOT be number\nboolean firstOk;\n\nif (i < maxCode) { // identifier, or a number ([Issue#102])\nfirstOk = (codes[i] == 0);\n} else {\nfirstOk = Character.isJavaIdentifierPart((char) i);\n}\nif (!firstOk) {\n_reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode) {\nif (codes[ch] != 0) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\n} else if (!Character.isJavaIdentifierPart((char) ch)) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\nint start = _inputPtr-1;\n_inputPtr = ptr;\nreturn _handleOddName2(start, hash, codes);\n}\n\nprotected String _parseAposName() throws IOException\n{\n// Note: mostly copy of_parseFieldName\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch == '\\'') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nif (ch < maxCode && codes[ch] != 0) {\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\n\nint start = _inputPtr;\n_inputPtr = ptr;\n\nreturn _parseName2(start, hash, '\\'');\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleOddValue(int i) throws IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (i) {\ncase '\\'':\n/* [JACKSON-173]: allow single quotes. Unlike with regular\n* Strings, we'll eagerly parse contents; this so that there's\n* no need to store information on quote char used.\n*\n* Also, no separation to fast/slow parsing; we'll just do\n* one regular (~= slowish) parsing, to keep code simple\n*/\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(i)) {\n_reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= '\\\\') {\nif (i == '\\\\') {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= '\\'') {\nif (i == '\\'') {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\nreturn JsonToken.VALUE_STRING;\n}\n\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // acceptable for now (will error out later)\nbreak;\n}\n}\nchar c = _inputBuffer[_inputPtr];\nint i = (int) c;\nif (i <= maxCode) {\nif (codes[i] != 0) {\nbreak;\n}\n} else if (!Character.isJavaIdentifierPart(c)) {\nbreak;\n}\n++_inputPtr;\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\n\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n@Override\nprotected final void _finishString() throws IOException\n{\n/* First: let's try to see if we have simple String value: one\n* that does not cross input buffer boundary, and does not\n* contain escape sequences.\n*/\nint ptr = _inputPtr;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode && codes[ch] != 0) {\nif (ch == '\"') {\n_textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr+1;\n// Yes, we got it all\nreturn;\n}\nbreak;\n}\n++ptr;\n} while (ptr < inputLen);\n}\n\n/* Either ran out of input, or bumped into an escape\n* sequence...\n*/\n_textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr;\n_finishString2();\n}\n\nprotected void _finishString2() throws IOException\n{\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i < maxCode && codes[i] != 0) {\nif (i == INT_QUOTE) {\nbreak;\n} else if (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n} // anything else?\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected final void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\nint inPtr = _inputPtr;\nint inLen = _inputEnd;\nchar[] inBuf = _inputBuffer;\n\nwhile (true) {\nif (inPtr >= inLen) {\n_inputPtr = inPtr;\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\ninPtr = _inputPtr;\ninLen = _inputEnd;\n}\nchar c = inBuf[inPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\n_inputPtr = inPtr;\nc = _decodeEscaped();\ninPtr = _inputPtr;\ninLen = _inputEnd;\n} else if (i <= INT_QUOTE) {\nif (i == INT_QUOTE) {\n_inputPtr = inPtr;\nbreak;\n}\nif (i < INT_SPACE) {\n_inputPtr = inPtr;\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n}\n}\n\n/*\n/**********************************************************\n/* Internal methods, other parsing\n/**********************************************************\n*/\n\n/**\n* We actually need to check the character value here\n* (to see if we have \\n following \\r).\n*/\nprotected final void _skipCR() throws IOException {\nif (_inputPtr < _inputEnd || loadMore()) {\nif (_inputBuffer[_inputPtr] == '\\n') {\n++_inputPtr;\n}\n}\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n}\n\nprivate final int _skipColon() throws IOException\n{\nif ((_inputPtr + 4) >= _inputEnd) {\nreturn _skipColon2(false);\n}\nchar c = _inputBuffer[_inputPtr];\nif (c == ':') { // common case, no leading space\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) { // nor trailing\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (c == ' ' || c == '\\t') {\nc = _inputBuffer[++_inputPtr];\n}\nif (c == ':') {\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true);\n}\nreturn _skipColon2(false);\n}\n\nprivate final int _skipColon2(boolean gotColon) throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nif (gotColon) {\nreturn i;\n}\nif (i != INT_COLON) {\nif (i < INT_SPACE) {\n_throwInvalidSpace(i);\n}\n_reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n}\ngotColon = true;\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n// Variant called when we know there's at least 4 more bytes available\nprivate final int _skipColonFast(int ptr) throws IOException\n{\nint i = (int) _inputBuffer[ptr++];\nif (i == INT_COLON) { // common case, no leading space\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) { // nor trailing\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = _inputBuffer[ptr++];\n}\nboolean gotColon = (i == INT_COLON);\nif (gotColon) {\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(gotColon);\n}\n\n// Primary loop: no reloading, comment handling\nprivate final int _skipComma(int i) throws IOException\n{\nif (i != INT_COMMA) {\n_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n}\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipAfterComma2();\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipAfterComma2();\n}\n\nprivate final int _skipAfterComma2() throws IOException\n{\nwhile (_inputPtr < _inputEnd || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nthrow _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n}\n\nprivate final int _skipWSOrEnd() throws IOException\n{\n// Let's handle first character separately since it is likely that\n// it is either non-whitespace; or we have longer run of white space\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\nreturn _eofAsNextChar();\n}\n}\nint i = _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipWSOrEnd2();\n}\n\nprivate int _skipWSOrEnd2() throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // We ran out of input...\nreturn _eofAsNextChar();\n}\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n} else if (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\nprivate void _skipComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_COMMENTS)) {\n_reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n}\n// First: check which comment (if either) it is:\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_reportInvalidEOF(\" in a comment\");\n}\nchar c = _inputBuffer[_inputPtr++];\nif (c == '/') {\n_skipLine();\n} else if (c == '*') {\n_skipCComment();\n} else {\n_reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n}\n}\n\nprivate void _skipCComment() throws IOException\n{\n// Ok: need the matching '*/'\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i <= '*') {\nif (i == '*') { // end?\nif ((_inputPtr >= _inputEnd) && !loadMore()) {\nbreak;\n}\nif (_inputBuffer[_inputPtr] == INT_SLASH) {\n++_inputPtr;\nreturn;\n}\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n_reportInvalidEOF(\" in a comment\");\n}\n\nprivate boolean _skipYAMLComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\nreturn false;\n}\n_skipLine();\nreturn true;\n}\n\nprivate void _skipLine() throws IOException\n{\n// Ok: need to find EOF or linefeed\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nbreak;\n} else if (i == INT_CR) {\n_skipCR();\nbreak;\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n@Override\nprotected char _decodeEscaped() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\n\nswitch ((int) c) {\n// First, ones that are mapped\ncase 'b':\nreturn '\\b';\ncase 't':\nreturn '\\t';\ncase 'n':\nreturn '\\n';\ncase 'f':\nreturn '\\f';\ncase 'r':\nreturn '\\r';\n\n// And these are to be returned as they are\ncase '\"':\ncase '/':\ncase '\\\\':\nreturn c;\n\ncase 'u': // and finally hex-escaped\nbreak;\n\ndefault:\nreturn _handleUnrecognizedCharacterEscape(c);\n}\n\n// Ok, a hex escape. Need 4 characters\nint value = 0;\nfor (int i = 0; i < 4; ++i) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nint ch = (int) _inputBuffer[_inputPtr++];\nint digit = CharTypes.charToHex(ch);\nif (digit < 0) {\n_reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n}\nvalue = (value << 4) | digit;\n}\nreturn (char) value;\n}\n\nprivate final void _matchTrue() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"true\", 1);\n}\n\nprivate final void _matchFalse() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 4) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"false\", 1);\n}\n\nprivate final void _matchNull() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"null\", 1);\n}",
            "method_id": 125
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:close()V",
            "method_body": "@Override public void close() throws IOException {\nif (!_closed) {\n_closed = true;\ntry {\n_closeInput();\n} finally {\n// as per [JACKSON-324], do in finally block\n// Also, internal buffer(s) can now be released as well\n_releaseBuffers();\n}\n}\n}",
            "method_id": 126
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:_releaseBuffers()V",
            "method_body": "protected void _releaseBuffers() throws IOException {\n_textBuffer.releaseBuffers();\nchar[] buf = _nameCopyBuffer;\nif (buf != null) {\n_nameCopyBuffer = null;\n_ioContext.releaseNameCopyBuffer(buf);\n}\n}",
            "method_id": 127
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:expectComma()Z",
            "method_body": "public boolean expectComma() {\n/* Assumption here is that we will be getting a value (at least\n* before calling this method again), and\n* so will auto-increment index to avoid having to do another call\n*/\nint ix = ++_index; // starts from -1\nreturn (_type != TYPE_ROOT && ix > 0);\n}",
            "method_id": 128
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonToken:<init>(Ljava/lang/String;ILjava/lang/String;I)V",
            "method_body": "JsonToken(String token, int id)\n{\nif (token == null) {\n_serialized = null;\n_serializedChars = null;\n_serializedBytes = null;\n} else {\n_serialized = token;\n_serializedChars = token.toCharArray();\n// It's all in ascii, can just case...\nint len = _serializedChars.length;\n_serializedBytes = new byte[len];\nfor (int i = 0; i < len; ++i) {\n_serializedBytes[i] = (byte) _serializedChars[i];\n}\n}\n_id = id;\n\n_isBoolean = (id == JsonTokenId.ID_FALSE || id == JsonTokenId.ID_TRUE);\n_isNumber = (id == JsonTokenId.ID_NUMBER_INT || id == JsonTokenId.ID_NUMBER_FLOAT);\n\n_isStructStart = (id == JsonTokenId.ID_START_OBJECT || id == JsonTokenId.ID_START_ARRAY);\n_isStructEnd = (id == JsonTokenId.ID_END_OBJECT || id == JsonTokenId.ID_END_ARRAY);\n\n_isScalar = !_isStructStart && !_isStructEnd\n&& (id != JsonTokenId.ID_FIELD_NAME)\n&& (id != JsonTokenId.ID_NOT_AVAILABLE);\n}",
            "method_id": 129
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:releaseBuffers()V",
            "method_body": "public void releaseBuffers()\n{\nif (_allocator == null) {\nresetWithEmpty();\n} else {\nif (_currentSegment != null) {\n// First, let's get rid of all but the largest char array\nresetWithEmpty();\n// And then return that array\nchar[] buf = _currentSegment;\n_currentSegment = null;\n_allocator.releaseCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, buf);\n}\n}\n}",
            "method_id": 130
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:_parseNumericValue(I)V",
            "method_body": "protected void _parseNumericValue(int expType) throws IOException\n{\n// Int or float?\nif (_currToken == JsonToken.VALUE_NUMBER_INT) {\nchar[] buf = _textBuffer.getTextBuffer();\nint offset = _textBuffer.getTextOffset();\nint len = _intLength;\nif (_numberNegative) {\n++offset;\n}\nif (len <= 9) { // definitely fits in int\nint i = NumberInput.parseInt(buf, offset, len);\n_numberInt = _numberNegative ? -i : i;\n_numTypesValid = NR_INT;\nreturn;\n}\nif (len <= 18) { // definitely fits AND is easy to parse using 2 int parse calls\nlong l = NumberInput.parseLong(buf, offset, len);\nif (_numberNegative) {\nl = -l;\n}\n// [JACKSON-230] Could still fit in int, need to check\nif (len == 10) {\nif (_numberNegative) {\nif (l >= MIN_INT_L) {\n_numberInt = (int) l;\n_numTypesValid = NR_INT;\nreturn;\n}\n} else {\nif (l <= MAX_INT_L) {\n_numberInt = (int) l;\n_numTypesValid = NR_INT;\nreturn;\n}\n}\n}\n_numberLong = l;\n_numTypesValid = NR_LONG;\nreturn;\n}\n_parseSlowInt(expType, buf, offset, len);\nreturn;\n}\nif (_currToken == JsonToken.VALUE_NUMBER_FLOAT) {\n_parseSlowFloat(expType);\nreturn;\n}\n_reportError(\"Current token (\"+_currToken+\") not numeric, can not use numeric value accessors\");\n}",
            "method_id": 131
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:enabledIn(I)Z",
            "method_body": "public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\npublic boolean enabledIn(int flags) { return (flags & _mask) != 0; }",
            "method_id": 132
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:constructTextBuffer()Lcom/fasterxml/jackson/core/util/TextBuffer;",
            "method_body": "public TextBuffer constructTextBuffer() {\nreturn new TextBuffer(_bufferRecycler);\n}",
            "method_id": 133
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser:<init>(I)V",
            "method_body": "protected JsonParser(int features) { _features = features; }\nprotected JsonParser(int features) { _features = features; }",
            "method_id": 134
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserMinimalBase:<init>(I)V",
            "method_body": "protected ParserMinimalBase(int features) { super(features); }\nprotected ParserMinimalBase(int features) { super(features); }",
            "method_id": 135
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:<init>(Lcom/fasterxml/jackson/core/io/IOContext;I)V",
            "method_body": "protected ParserBase(IOContext ctxt, int features) {\nsuper(features);\n_ioContext = ctxt;\n_textBuffer = ctxt.constructTextBuffer();\nDupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n? DupDetector.rootDetector(this) : null;\n_parsingContext = JsonReadContext.createRootContext(dups);\n}",
            "method_id": 136
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:<clinit>()V",
            "method_body": "protected byte[] _binaryValue;\n\n/*\n/**********************************************************\n/* Constants and fields of former 'JsonNumericParserBase'\n/**********************************************************\n*/\n\nfinal protected static int NR_UNKNOWN = 0;\n\n// First, integer types\n\nfinal protected static int NR_INT = 0x0001;\nfinal protected static int NR_LONG = 0x0002;\nfinal protected static int NR_BIGINT = 0x0004;\n\n// And then floating point types\n\nfinal protected static int NR_DOUBLE = 0x008;\nfinal protected static int NR_BIGDECIMAL = 0x0010;\n\n// Also, we need some numeric constants\n\nfinal static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE);\nfinal static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE);\n\nfinal static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);\nfinal static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);\n\nfinal static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG);\nfinal static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG);\n\nfinal static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT);\nfinal static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT);\n\nfinal static long MIN_INT_L = (long) Integer.MIN_VALUE;\nfinal static long MAX_INT_L = (long) Integer.MAX_VALUE;\n\n// These are not very accurate, but have to do... (for bounds checks)\n\nfinal static double MIN_LONG_D = (double) Long.MIN_VALUE;\nfinal static double MAX_LONG_D = (double) Long.MAX_VALUE;\n\nfinal static double MIN_INT_D = (double) Integer.MIN_VALUE;\nfinal static double MAX_INT_D = (double) Integer.MAX_VALUE;\n\n// Digits, numeric\nfinal protected static int INT_0 = '0';\nfinal protected static int INT_9 = '9';\n\nfinal protected static int INT_MINUS = '-';\nfinal protected static int INT_PLUS = '+';\n\nfinal protected static char CHAR_NULL = '\\0';\n\n// Numeric value holders: multiple fields used for\n// for efficiency\n\n/**\n* Bitfield that indicates which numeric representations\n* have been calculated for the current type\n*/\nprotected int _numTypesValid = NR_UNKNOWN;\n\n// First primitives\n\nprotected int _numberInt;\n\nprotected long _numberLong;\n\nprotected double _numberDouble;\n\n// And then object types\n\nprotected BigInteger _numberBigInt;\n\nprotected BigDecimal _numberBigDecimal;\n\n// And then other information about value itself\n\n/**\n* Flag that indicates whether numeric value has a negative\n* value. That is, whether its textual representation starts\n* with minus character.\n*/\nprotected boolean _numberNegative;\n\n/**\n* Length of integer part of the number, in characters\n*/\nprotected int _intLength;\n\n/**\n* Length of the fractional part (not including decimal\n* point or exponent), in characters.\n* Not used for  pure integer values.\n*/\nprotected int _fractLength;\n\n/**\n* Length of the exponent part of the number, if any, not\n* including 'e' marker or sign, just digits.\n* Not used for  pure integer values.\n*/\nprotected int _expLength;\n\n/*\n/**********************************************************\n/* Life-cycle\n/**********************************************************\n*/\n\nprotected ParserBase(IOContext ctxt, int features) {\nsuper(features);\n_ioContext = ctxt;\n_textBuffer = ctxt.constructTextBuffer();\nDupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n? DupDetector.rootDetector(this) : null;\n_parsingContext = JsonReadContext.createRootContext(dups);\n}",
            "method_id": 137
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.CharTypes:getInputCodeLatin1()[I",
            "method_body": "public static int[] getInputCodeLatin1() { return sInputCodes; }\npublic static int[] getInputCodeLatin1() { return sInputCodes; }",
            "method_id": 138
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:<init>(Lcom/fasterxml/jackson/core/json/JsonReadContext;Lcom/fasterxml/jackson/core/json/DupDetector;III)V",
            "method_body": "public JsonReadContext(JsonReadContext parent, DupDetector dups, int type, int lineNr, int colNr) {\nsuper();\n_parent = parent;\n_dups = dups;\n_type = type;\n_lineNr = lineNr;\n_columnNr = colNr;\n_index = -1;\n}",
            "method_id": 139
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:createRootContext(Lcom/fasterxml/jackson/core/json/DupDetector;)Lcom/fasterxml/jackson/core/json/JsonReadContext;",
            "method_body": "public static JsonReadContext createRootContext(DupDetector dups) {\nreturn new JsonReadContext(null, dups, TYPE_ROOT, 1, 0);\n}",
            "method_id": 140
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.WriterBasedJsonGenerator:writeNumber(I)V",
            "method_body": "public void writeNumber(int i) throws IOException\n{\n_verifyValueWrite(WRITE_NUMBER);\nif (_cfgNumbersAsStrings) {\n_writeQuotedInt(i);\nreturn;\n}\n// up to 10 digits and possible minus sign\nif ((_outputTail + 11) >= _outputEnd) {\n_flushBuffer();\n}\n_outputTail = NumberOutput.outputInt(i, _outputBuffer, _outputTail);\n}",
            "method_id": 141
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:<init>(Lcom/fasterxml/jackson/core/util/BufferRecycler;)V",
            "method_body": "public TextBuffer(BufferRecycler allocator) {\n_allocator = allocator;\n}",
            "method_id": 142
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:<clinit>()V",
            "method_body": "final static char[] NO_CHARS = new char[0];\n\n/**\n* Let's start with sizable but not huge buffer, will grow as necessary\n*/\nfinal static int MIN_SEGMENT_LEN = 1000;\n\n/**\n* Let's limit maximum segment length to something sensible\n* like 256k\n*/\nfinal static int MAX_SEGMENT_LEN = 0x40000;\n\n/*\n/**********************************************************\n/* Configuration:\n/**********************************************************\n*/\n\nprivate final BufferRecycler _allocator;\n\n/*\n/**********************************************************\n/* Shared input buffers\n/**********************************************************\n*/\n\n/**\n* Shared input buffer; stored here in case some input can be returned\n* as is, without being copied to collector's own buffers. Note that\n* this is read-only for this Object.\n*/\nprivate char[] _inputBuffer;\n\n/**\n* Character offset of first char in input buffer; -1 to indicate\n* that input buffer currently does not contain any useful char data\n*/\nprivate int _inputStart;\n\nprivate int _inputLen;\n\n/*\n/**********************************************************\n/* Aggregation segments (when not using input buf)\n/**********************************************************\n*/\n\n/**\n* List of segments prior to currently active segment.\n*/\nprivate ArrayList<char[]> _segments;\n\n/**\n* Flag that indicates whether _seqments is non-empty\n*/\nprivate boolean _hasSegments;\n\n// // // Currently used segment; not (yet) contained in _seqments\n\n/**\n* Amount of characters in segments in {@link _segments}",
            "method_id": 143
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.NumberOutput:outputInt(I[CI)I",
            "method_body": "public static int outputInt(int v, char[] b, int off)\n{\nif (v < 0) {\nif (v == Integer.MIN_VALUE) {\n/* Special case: no matching positive value within range;\n* let's then \"upgrade\" to long and output as such.\n*/\nreturn outputLong((long) v, b, off);\n}\nb[off++] = '-';\nv = -v;\n}\n\nif (v < MILLION) { // at most 2 triplets...\nif (v < 1000) {\nif (v < 10) {\nb[off++] = (char) ('0' + v);\n} else {\noff = leading3(v, b, off);\n}\n} else {\nint thousands = v / 1000;\nv -= (thousands * 1000); // == value % 1000\noff = leading3(thousands, b, off);\noff = full3(v, b, off);\n}\nreturn off;\n}\n\n// ok, all 3 triplets included\n/* Let's first hand possible billions separately before\n* handling 3 triplets. This is possible since we know we\n* can have at most '2' as billion count.\n*/\nboolean hasBillions = (v >= BILLION);\nif (hasBillions) {\nv -= BILLION;\nif (v >= BILLION) {\nv -= BILLION;\nb[off++] = '2';\n} else {\nb[off++] = '1';\n}\n}\nint newValue = v / 1000;\nint ones = (v - (newValue * 1000)); // == value % 1000\nv = newValue;\nnewValue /= 1000;\nint thousands = (v - (newValue * 1000));\n\n// value now has millions, which have 1, 2 or 3 digits\nif (hasBillions) {\noff = full3(newValue, b, off);\n} else {\noff = leading3(newValue, b, off);\n}\noff = full3(thousands, b, off);\noff = full3(ones, b, off);\nreturn off;\n}",
            "method_id": 144
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.NumberOutput:<clinit>()V",
            "method_body": "private final static char NC = (char) 0;\n\nprivate static int MILLION = 1000000;\nprivate static int BILLION = 1000000000;\nprivate static long TEN_BILLION_L = 10000000000L;\nprivate static long THOUSAND_L = 1000L;\n\nprivate static long MIN_INT_AS_LONG = (long) Integer.MIN_VALUE;\nprivate static long MAX_INT_AS_LONG = (long) Integer.MAX_VALUE;\n\nfinal static String SMALLEST_LONG = String.valueOf(Long.MIN_VALUE);\n\nprivate final static char[] LEAD_3 = new char[4000];\nprivate final static char[] FULL_3 = new char[4000];\nstatic {\n/* Let's fill it with NULLs for ignorable leading digits,\n* and digit chars for others\n*/\nint ix = 0;\nfor (int i1 = 0; i1 < 10; ++i1) {\nchar f1 = (char) ('0' + i1);\nchar l1 = (i1 == 0) ? NC : f1;\nfor (int i2 = 0; i2 < 10; ++i2) {\nchar f2 = (char) ('0' + i2);\nchar l2 = (i1 == 0 && i2 == 0) ? NC : f2;\nfor (int i3 = 0; i3 < 10; ++i3) {\n// Last is never to be empty\nchar f3 = (char) ('0' + i3);\nLEAD_3[ix] = l1;\nLEAD_3[ix+1] = l2;\nLEAD_3[ix+2] = f3;\nFULL_3[ix] = f1;\nFULL_3[ix+1] = f2;\nFULL_3[ix+2] = f3;\nix += 4;\n}\n}\n}\n}",
            "method_id": 145
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:getCurrentName()Ljava/lang/String;",
            "method_body": "@Override public String getCurrentName() throws IOException {\n// [JACKSON-395]: start markers require information from parent\nif (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\nJsonReadContext parent = _parsingContext.getParent();\nif (parent != null) {\nreturn parent.getCurrentName();\n}\n}\nreturn _parsingContext.getCurrentName();\n}",
            "method_id": 146
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonToken:id()I",
            "method_body": "public final int id() { return _id; }\npublic final int id() { return _id; }",
            "method_id": 147
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:_nextAfterName()Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "private final JsonToken _nextAfterName()\n{\n_nameCopied = false; // need to invalidate if it was copied\nJsonToken t = _nextToken;\n_nextToken = null;\n\n// !!! 16-Nov-2015, tatu: TODO: fix [databind#37], copy next location to current here\n\n// Also: may need to start new context?\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn (_currToken = t);\n}",
            "method_id": 148
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:_parseName()Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n_updateLocation();\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleOddValue(i);\n}\n\nprotected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n{\n// // // and this is back to standard nextToken()\nString name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n_parsingContext.setCurrentName(name);\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n_updateLocation();\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn nameToMatch.equals(name);\n}\n// Ok: we must have a value... what is it?\nJsonToken t;\nswitch (i) {\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ncase 'f':\n_matchFalse();\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchNull();\nt = JsonToken.VALUE_NULL;\nbreak;\ncase 't':\n_matchTrue();\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ndefault:\nt = _handleOddValue(i);\nbreak;\n}\n_nextToken = t;\nreturn nameToMatch.equals(name);\n}\n\nprivate final JsonToken _nextTokenNotInObject(int i) throws IOException\n{\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\nreturn (_currToken = JsonToken.VALUE_STRING);\n}\nswitch (i) {\ncase '[':\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_ARRAY);\ncase '{':\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_OBJECT);\ncase 't':\n_matchToken(\"true\", 1);\nreturn (_currToken = JsonToken.VALUE_TRUE);\ncase 'f':\n_matchToken(\"false\", 1);\nreturn (_currToken = JsonToken.VALUE_FALSE);\ncase 'n':\n_matchToken(\"null\", 1);\nreturn (_currToken = JsonToken.VALUE_NULL);\ncase '-':\nreturn (_currToken = _parseNegNumber());\n/* Should we have separate handling for plus? Although\n* it is not allowed per se, it may be erroneously used,\n* and could be indicated by a more specific error message.\n*/\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn (_currToken = _parsePosNumber(i));\n}\nreturn (_currToken = _handleOddValue(i));\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final String nextTextValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\n_finishString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final int nextIntValue(int defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) {\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final long nextLongValue(long defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final Boolean nextBooleanValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\nJsonToken t = nextToken();\nif (t != null) {\nint id = t.id();\nif (id == ID_TRUE) return Boolean.TRUE;\nif (id == ID_FALSE) return Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected final JsonToken _parsePosNumber(int ch) throws IOException\n{\n/* Although we will always be complete with respect to textual\n* representation (that is, all characters will be parsed),\n* actual conversion to a number is deferred. Thus, need to\n* note that no representations are valid yet\n*/\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include digit already read\nfinal int inputLen = _inputEnd;\n\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(false, startPtr);\n}\n\n/* First, let's see if the whole number is contained within\n* the input buffer unsplit. This should be the common case;\n* and to simplify processing, we will just reparse contents\n* in the alternative case (number split on buffer boundary)\n*/\n\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(false, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, false, intLen);\n}\n// Got it all: let's add to text buffer for parsing, access\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(false, intLen);\n}\n\nprivate final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\nthrows IOException\n{\nfinal int inputLen = _inputEnd;\nint fractLen = 0;\n\n// And then see if we get other parts\nif (ch == '.') { // yes, fraction\nfract_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n}\n}\nint expLen = 0;\nif (ch == 'e' || ch == 'E') { // and/or exponent\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\n// Sign indicator?\nch = (int) _inputBuffer[ptr++];\nif (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\nwhile (ch <= INT_9 && ch >= INT_0) {\n++expLen;\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n}\n}\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n// And there we have it!\nreturn resetFloat(neg, intLen, fractLen, expLen);\n}\n\nprotected final JsonToken _parseNegNumber() throws IOException\n{\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include sign/digit already read\nfinal int inputLen = _inputEnd;\n\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nint ch = _inputBuffer[ptr++];\n// First check: must have a digit to follow minus sign\nif (ch > INT_9 || ch < INT_0) {\n_inputPtr = ptr;\nreturn _handleInvalidNumberStart(ch, true);\n}\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(true, startPtr);\n}\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\n\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, true, intLen);\n}\n--ptr;\n_inputPtr = ptr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to parse a number, when the primary parse\n* method has failed to parse it, due to it being split on\n* buffer boundary. As a result code is very similar, except\n* that it has to explicitly copy contents to the text buffer\n* instead of just sharing the main input buffer.\n*/\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n{\n_inputPtr = neg ? (startPtr+1) : startPtr;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\nif (neg) {\noutBuf[outPtr++] = '-';\n}\n\n// This is the place to do leading-zero check(s) too:\nint intLen = 0;\nchar c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\nif (c == '0') {\nc = _verifyNoLeadingZeroes();\n}\nboolean eof = false;\n\n// Ok, first the obligatory integer part:\nint_loop:\nwhile (c >= '0' && c <= '9') {\n++intLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\n// EOF is legal for main level int values\nc = CHAR_NULL;\neof = true;\nbreak int_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// Also, integer part is not optional\nif (intLen == 0) {\nreturn _handleInvalidNumberStart(c, neg);\n}\n\nint fractLen = 0;\n// And then see if we get other parts\nif (c == '.') { // yes, fraction\noutBuf[outPtr++] = c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = _inputBuffer[_inputPtr++];\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == 'e' || c == 'E') { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Not optional, can require that we get one more char\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Likewise, non optional:\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n// And there we have it!\nreturn reset(neg, intLen, fractLen, expLen);\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final char _verifyNoLeadingZeroes() throws IOException\n{\n// Fast case first:\nif (_inputPtr < _inputEnd) {\nchar ch = _inputBuffer[_inputPtr];\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\n}\n// and offline the less common case\nreturn _verifyNLZ2();\n}\n\nprivate char _verifyNLZ2() throws IOException\n{\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn '0';\n}\nchar ch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') { // followed by non-number; retain one zero\nreturn '0';\n}\n++_inputPtr; // skip previous zero\nif (ch != '0') { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n{\nif (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { _reportInvalidEOFInValue(); }\n}\nch = _inputBuffer[_inputPtr++];\nif (ch == 'N') {\nString match = negative ? \"-INF\" :\"+INF\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n} else if (ch == 'n') {\nString match = negative ? \"-Infinity\" :\"+Infinity\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName() throws IOException\n{\n// First: let's try to see if we have a simple name: one that does\n// not cross input buffer boundary, and does not contain escape sequences.\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int[] codes = _icLatin1;\n\nwhile (ptr < _inputEnd) {\nint ch = _inputBuffer[ptr];\nif (ch < codes.length && codes[ch] != 0) {\nif (ch == '\"') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n}\nint start = _inputPtr;\n_inputPtr = ptr;\nreturn _parseName2(start, hash, INT_QUOTE);\n}\n\nprivate String _parseName2(int startPtr, int hash, int endChar) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n/* Output pointers; calls will also ensure that the buffer is\n* not shared and has room for at least one more char.\n*/\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= endChar) {\nif (i == endChar) {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"name\");\n}\n}\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int i) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n_reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n}\nfinal int[] codes = CharTypes.getInputCodeLatin1JsNames();\nfinal int maxCode = codes.length;\n\n// Also: first char must be a valid name char, but NOT be number\nboolean firstOk;\n\nif (i < maxCode) { // identifier, or a number ([Issue#102])\nfirstOk = (codes[i] == 0);\n} else {\nfirstOk = Character.isJavaIdentifierPart((char) i);\n}\nif (!firstOk) {\n_reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode) {\nif (codes[ch] != 0) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\n} else if (!Character.isJavaIdentifierPart((char) ch)) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\nint start = _inputPtr-1;\n_inputPtr = ptr;\nreturn _handleOddName2(start, hash, codes);\n}\n\nprotected String _parseAposName() throws IOException\n{\n// Note: mostly copy of_parseFieldName\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch == '\\'') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nif (ch < maxCode && codes[ch] != 0) {\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\n\nint start = _inputPtr;\n_inputPtr = ptr;\n\nreturn _parseName2(start, hash, '\\'');\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleOddValue(int i) throws IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (i) {\ncase '\\'':\n/* [JACKSON-173]: allow single quotes. Unlike with regular\n* Strings, we'll eagerly parse contents; this so that there's\n* no need to store information on quote char used.\n*\n* Also, no separation to fast/slow parsing; we'll just do\n* one regular (~= slowish) parsing, to keep code simple\n*/\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(i)) {\n_reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= '\\\\') {\nif (i == '\\\\') {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= '\\'') {\nif (i == '\\'') {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\nreturn JsonToken.VALUE_STRING;\n}\n\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // acceptable for now (will error out later)\nbreak;\n}\n}\nchar c = _inputBuffer[_inputPtr];\nint i = (int) c;\nif (i <= maxCode) {\nif (codes[i] != 0) {\nbreak;\n}\n} else if (!Character.isJavaIdentifierPart(c)) {\nbreak;\n}\n++_inputPtr;\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\n\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n@Override\nprotected final void _finishString() throws IOException\n{\n/* First: let's try to see if we have simple String value: one\n* that does not cross input buffer boundary, and does not\n* contain escape sequences.\n*/\nint ptr = _inputPtr;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode && codes[ch] != 0) {\nif (ch == '\"') {\n_textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr+1;\n// Yes, we got it all\nreturn;\n}\nbreak;\n}\n++ptr;\n} while (ptr < inputLen);\n}\n\n/* Either ran out of input, or bumped into an escape\n* sequence...\n*/\n_textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr;\n_finishString2();\n}\n\nprotected void _finishString2() throws IOException\n{\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i < maxCode && codes[i] != 0) {\nif (i == INT_QUOTE) {\nbreak;\n} else if (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n} // anything else?\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected final void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\nint inPtr = _inputPtr;\nint inLen = _inputEnd;\nchar[] inBuf = _inputBuffer;\n\nwhile (true) {\nif (inPtr >= inLen) {\n_inputPtr = inPtr;\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\ninPtr = _inputPtr;\ninLen = _inputEnd;\n}\nchar c = inBuf[inPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\n_inputPtr = inPtr;\nc = _decodeEscaped();\ninPtr = _inputPtr;\ninLen = _inputEnd;\n} else if (i <= INT_QUOTE) {\nif (i == INT_QUOTE) {\n_inputPtr = inPtr;\nbreak;\n}\nif (i < INT_SPACE) {\n_inputPtr = inPtr;\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n}\n}\n\n/*\n/**********************************************************\n/* Internal methods, other parsing\n/**********************************************************\n*/\n\n/**\n* We actually need to check the character value here\n* (to see if we have \\n following \\r).\n*/\nprotected final void _skipCR() throws IOException {\nif (_inputPtr < _inputEnd || loadMore()) {\nif (_inputBuffer[_inputPtr] == '\\n') {\n++_inputPtr;\n}\n}\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n}\n\nprivate final int _skipColon() throws IOException\n{\nif ((_inputPtr + 4) >= _inputEnd) {\nreturn _skipColon2(false);\n}\nchar c = _inputBuffer[_inputPtr];\nif (c == ':') { // common case, no leading space\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) { // nor trailing\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (c == ' ' || c == '\\t') {\nc = _inputBuffer[++_inputPtr];\n}\nif (c == ':') {\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true);\n}\nreturn _skipColon2(false);\n}\n\nprivate final int _skipColon2(boolean gotColon) throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nif (gotColon) {\nreturn i;\n}\nif (i != INT_COLON) {\nif (i < INT_SPACE) {\n_throwInvalidSpace(i);\n}\n_reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n}\ngotColon = true;\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n// Variant called when we know there's at least 4 more bytes available\nprivate final int _skipColonFast(int ptr) throws IOException\n{\nint i = (int) _inputBuffer[ptr++];\nif (i == INT_COLON) { // common case, no leading space\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) { // nor trailing\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = _inputBuffer[ptr++];\n}\nboolean gotColon = (i == INT_COLON);\nif (gotColon) {\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(gotColon);\n}\n\n// Primary loop: no reloading, comment handling\nprivate final int _skipComma(int i) throws IOException\n{\nif (i != INT_COMMA) {\n_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n}\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipAfterComma2();\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipAfterComma2();\n}\n\nprivate final int _skipAfterComma2() throws IOException\n{\nwhile (_inputPtr < _inputEnd || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nthrow _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n}\n\nprivate final int _skipWSOrEnd() throws IOException\n{\n// Let's handle first character separately since it is likely that\n// it is either non-whitespace; or we have longer run of white space\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\nreturn _eofAsNextChar();\n}\n}\nint i = _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipWSOrEnd2();\n}\n\nprivate int _skipWSOrEnd2() throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // We ran out of input...\nreturn _eofAsNextChar();\n}\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n} else if (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\nprivate void _skipComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_COMMENTS)) {\n_reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n}\n// First: check which comment (if either) it is:\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_reportInvalidEOF(\" in a comment\");\n}\nchar c = _inputBuffer[_inputPtr++];\nif (c == '/') {\n_skipLine();\n} else if (c == '*') {\n_skipCComment();\n} else {\n_reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n}\n}\n\nprivate void _skipCComment() throws IOException\n{\n// Ok: need the matching '*/'\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i <= '*') {\nif (i == '*') { // end?\nif ((_inputPtr >= _inputEnd) && !loadMore()) {\nbreak;\n}\nif (_inputBuffer[_inputPtr] == INT_SLASH) {\n++_inputPtr;\nreturn;\n}\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n_reportInvalidEOF(\" in a comment\");\n}\n\nprivate boolean _skipYAMLComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\nreturn false;\n}\n_skipLine();\nreturn true;\n}\n\nprivate void _skipLine() throws IOException\n{\n// Ok: need to find EOF or linefeed\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nbreak;\n} else if (i == INT_CR) {\n_skipCR();\nbreak;\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n@Override\nprotected char _decodeEscaped() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\n\nswitch ((int) c) {\n// First, ones that are mapped\ncase 'b':\nreturn '\\b';\ncase 't':\nreturn '\\t';\ncase 'n':\nreturn '\\n';\ncase 'f':\nreturn '\\f';\ncase 'r':\nreturn '\\r';\n\n// And these are to be returned as they are\ncase '\"':\ncase '/':\ncase '\\\\':\nreturn c;\n\ncase 'u': // and finally hex-escaped\nbreak;\n\ndefault:\nreturn _handleUnrecognizedCharacterEscape(c);\n}\n\n// Ok, a hex escape. Need 4 characters\nint value = 0;\nfor (int i = 0; i < 4; ++i) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nint ch = (int) _inputBuffer[_inputPtr++];\nint digit = CharTypes.charToHex(ch);\nif (digit < 0) {\n_reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n}\nvalue = (value << 4) | digit;\n}\nreturn (char) value;\n}\n\nprivate final void _matchTrue() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"true\", 1);\n}\n\nprivate final void _matchFalse() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 4) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"false\", 1);\n}\n\nprivate final void _matchNull() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"null\", 1);\n}",
            "method_id": 149
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:mergeChild(Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;)V",
            "method_body": "private void mergeChild(CharsToNameCanonicalizer child) {\n/* One caveat: let's try to avoid problems with\n* degenerate cases of documents with generated \"random\"\n* names: for these, symbol tables would bloat indefinitely.\n* One way to do this is to just purge tables if they grow\n* too large, and that's what we'll do here.\n*/\nif (child.size() > MAX_ENTRIES_FOR_REUSE) {\n// Should there be a way to get notified about this event, to log it or such?\n// (as it's somewhat abnormal thing to happen)\n// At any rate, need to clean up the tables, then:\nsynchronized (this) {\ninitTables(DEFAULT_T_SIZE * 4); // no point in starting from tiny tho\n// Dirty flag... well, let's just clear it. Shouldn't really matter for master tables\n// (which this is, given something is merged to it)\n_dirty = false;\n}\n} else {\n// Otherwise, we'll merge changed stuff in, if there are  more entries (which\n// may not be the case if one of siblings has added symbols first or such)\nif (child.size() <= size()) { // nothing to add\nreturn;\n}\n// Okie dokie, let's get the data in!\nsynchronized (this) {\n_symbols = child._symbols;\n_buckets = child._buckets;\n_size = child._size;\n_sizeThreshold = child._sizeThreshold;\n_indexMask = child._indexMask;\n_longestCollisionList = child._longestCollisionList;\n// Dirty flag... well, let's just clear it. Shouldn't really matter for master tables\n// (which this is, given something is merged to it)\n_dirty = false;\n}\n}\n}",
            "method_id": 150
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:_skipColon()I",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n_updateLocation();\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleOddValue(i);\n}\n\nprotected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n{\n// // // and this is back to standard nextToken()\nString name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n_parsingContext.setCurrentName(name);\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n_updateLocation();\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn nameToMatch.equals(name);\n}\n// Ok: we must have a value... what is it?\nJsonToken t;\nswitch (i) {\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ncase 'f':\n_matchFalse();\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchNull();\nt = JsonToken.VALUE_NULL;\nbreak;\ncase 't':\n_matchTrue();\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ndefault:\nt = _handleOddValue(i);\nbreak;\n}\n_nextToken = t;\nreturn nameToMatch.equals(name);\n}\n\nprivate final JsonToken _nextTokenNotInObject(int i) throws IOException\n{\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\nreturn (_currToken = JsonToken.VALUE_STRING);\n}\nswitch (i) {\ncase '[':\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_ARRAY);\ncase '{':\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_OBJECT);\ncase 't':\n_matchToken(\"true\", 1);\nreturn (_currToken = JsonToken.VALUE_TRUE);\ncase 'f':\n_matchToken(\"false\", 1);\nreturn (_currToken = JsonToken.VALUE_FALSE);\ncase 'n':\n_matchToken(\"null\", 1);\nreturn (_currToken = JsonToken.VALUE_NULL);\ncase '-':\nreturn (_currToken = _parseNegNumber());\n/* Should we have separate handling for plus? Although\n* it is not allowed per se, it may be erroneously used,\n* and could be indicated by a more specific error message.\n*/\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn (_currToken = _parsePosNumber(i));\n}\nreturn (_currToken = _handleOddValue(i));\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final String nextTextValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\n_finishString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final int nextIntValue(int defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) {\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final long nextLongValue(long defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final Boolean nextBooleanValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\nJsonToken t = nextToken();\nif (t != null) {\nint id = t.id();\nif (id == ID_TRUE) return Boolean.TRUE;\nif (id == ID_FALSE) return Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected final JsonToken _parsePosNumber(int ch) throws IOException\n{\n/* Although we will always be complete with respect to textual\n* representation (that is, all characters will be parsed),\n* actual conversion to a number is deferred. Thus, need to\n* note that no representations are valid yet\n*/\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include digit already read\nfinal int inputLen = _inputEnd;\n\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(false, startPtr);\n}\n\n/* First, let's see if the whole number is contained within\n* the input buffer unsplit. This should be the common case;\n* and to simplify processing, we will just reparse contents\n* in the alternative case (number split on buffer boundary)\n*/\n\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(false, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, false, intLen);\n}\n// Got it all: let's add to text buffer for parsing, access\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(false, intLen);\n}\n\nprivate final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\nthrows IOException\n{\nfinal int inputLen = _inputEnd;\nint fractLen = 0;\n\n// And then see if we get other parts\nif (ch == '.') { // yes, fraction\nfract_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n}\n}\nint expLen = 0;\nif (ch == 'e' || ch == 'E') { // and/or exponent\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\n// Sign indicator?\nch = (int) _inputBuffer[ptr++];\nif (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\nwhile (ch <= INT_9 && ch >= INT_0) {\n++expLen;\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n}\n}\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n// And there we have it!\nreturn resetFloat(neg, intLen, fractLen, expLen);\n}\n\nprotected final JsonToken _parseNegNumber() throws IOException\n{\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include sign/digit already read\nfinal int inputLen = _inputEnd;\n\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nint ch = _inputBuffer[ptr++];\n// First check: must have a digit to follow minus sign\nif (ch > INT_9 || ch < INT_0) {\n_inputPtr = ptr;\nreturn _handleInvalidNumberStart(ch, true);\n}\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(true, startPtr);\n}\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\n\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, true, intLen);\n}\n--ptr;\n_inputPtr = ptr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to parse a number, when the primary parse\n* method has failed to parse it, due to it being split on\n* buffer boundary. As a result code is very similar, except\n* that it has to explicitly copy contents to the text buffer\n* instead of just sharing the main input buffer.\n*/\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n{\n_inputPtr = neg ? (startPtr+1) : startPtr;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\nif (neg) {\noutBuf[outPtr++] = '-';\n}\n\n// This is the place to do leading-zero check(s) too:\nint intLen = 0;\nchar c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\nif (c == '0') {\nc = _verifyNoLeadingZeroes();\n}\nboolean eof = false;\n\n// Ok, first the obligatory integer part:\nint_loop:\nwhile (c >= '0' && c <= '9') {\n++intLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\n// EOF is legal for main level int values\nc = CHAR_NULL;\neof = true;\nbreak int_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// Also, integer part is not optional\nif (intLen == 0) {\nreturn _handleInvalidNumberStart(c, neg);\n}\n\nint fractLen = 0;\n// And then see if we get other parts\nif (c == '.') { // yes, fraction\noutBuf[outPtr++] = c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = _inputBuffer[_inputPtr++];\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == 'e' || c == 'E') { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Not optional, can require that we get one more char\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Likewise, non optional:\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n// And there we have it!\nreturn reset(neg, intLen, fractLen, expLen);\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final char _verifyNoLeadingZeroes() throws IOException\n{\n// Fast case first:\nif (_inputPtr < _inputEnd) {\nchar ch = _inputBuffer[_inputPtr];\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\n}\n// and offline the less common case\nreturn _verifyNLZ2();\n}\n\nprivate char _verifyNLZ2() throws IOException\n{\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn '0';\n}\nchar ch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') { // followed by non-number; retain one zero\nreturn '0';\n}\n++_inputPtr; // skip previous zero\nif (ch != '0') { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n{\nif (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { _reportInvalidEOFInValue(); }\n}\nch = _inputBuffer[_inputPtr++];\nif (ch == 'N') {\nString match = negative ? \"-INF\" :\"+INF\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n} else if (ch == 'n') {\nString match = negative ? \"-Infinity\" :\"+Infinity\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName() throws IOException\n{\n// First: let's try to see if we have a simple name: one that does\n// not cross input buffer boundary, and does not contain escape sequences.\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int[] codes = _icLatin1;\n\nwhile (ptr < _inputEnd) {\nint ch = _inputBuffer[ptr];\nif (ch < codes.length && codes[ch] != 0) {\nif (ch == '\"') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n}\nint start = _inputPtr;\n_inputPtr = ptr;\nreturn _parseName2(start, hash, INT_QUOTE);\n}\n\nprivate String _parseName2(int startPtr, int hash, int endChar) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n/* Output pointers; calls will also ensure that the buffer is\n* not shared and has room for at least one more char.\n*/\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= endChar) {\nif (i == endChar) {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"name\");\n}\n}\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int i) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n_reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n}\nfinal int[] codes = CharTypes.getInputCodeLatin1JsNames();\nfinal int maxCode = codes.length;\n\n// Also: first char must be a valid name char, but NOT be number\nboolean firstOk;\n\nif (i < maxCode) { // identifier, or a number ([Issue#102])\nfirstOk = (codes[i] == 0);\n} else {\nfirstOk = Character.isJavaIdentifierPart((char) i);\n}\nif (!firstOk) {\n_reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode) {\nif (codes[ch] != 0) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\n} else if (!Character.isJavaIdentifierPart((char) ch)) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\nint start = _inputPtr-1;\n_inputPtr = ptr;\nreturn _handleOddName2(start, hash, codes);\n}\n\nprotected String _parseAposName() throws IOException\n{\n// Note: mostly copy of_parseFieldName\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch == '\\'') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nif (ch < maxCode && codes[ch] != 0) {\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\n\nint start = _inputPtr;\n_inputPtr = ptr;\n\nreturn _parseName2(start, hash, '\\'');\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleOddValue(int i) throws IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (i) {\ncase '\\'':\n/* [JACKSON-173]: allow single quotes. Unlike with regular\n* Strings, we'll eagerly parse contents; this so that there's\n* no need to store information on quote char used.\n*\n* Also, no separation to fast/slow parsing; we'll just do\n* one regular (~= slowish) parsing, to keep code simple\n*/\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(i)) {\n_reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= '\\\\') {\nif (i == '\\\\') {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= '\\'') {\nif (i == '\\'') {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\nreturn JsonToken.VALUE_STRING;\n}\n\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // acceptable for now (will error out later)\nbreak;\n}\n}\nchar c = _inputBuffer[_inputPtr];\nint i = (int) c;\nif (i <= maxCode) {\nif (codes[i] != 0) {\nbreak;\n}\n} else if (!Character.isJavaIdentifierPart(c)) {\nbreak;\n}\n++_inputPtr;\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\n\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n@Override\nprotected final void _finishString() throws IOException\n{\n/* First: let's try to see if we have simple String value: one\n* that does not cross input buffer boundary, and does not\n* contain escape sequences.\n*/\nint ptr = _inputPtr;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode && codes[ch] != 0) {\nif (ch == '\"') {\n_textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr+1;\n// Yes, we got it all\nreturn;\n}\nbreak;\n}\n++ptr;\n} while (ptr < inputLen);\n}\n\n/* Either ran out of input, or bumped into an escape\n* sequence...\n*/\n_textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr;\n_finishString2();\n}\n\nprotected void _finishString2() throws IOException\n{\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i < maxCode && codes[i] != 0) {\nif (i == INT_QUOTE) {\nbreak;\n} else if (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n} // anything else?\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected final void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\nint inPtr = _inputPtr;\nint inLen = _inputEnd;\nchar[] inBuf = _inputBuffer;\n\nwhile (true) {\nif (inPtr >= inLen) {\n_inputPtr = inPtr;\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\ninPtr = _inputPtr;\ninLen = _inputEnd;\n}\nchar c = inBuf[inPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\n_inputPtr = inPtr;\nc = _decodeEscaped();\ninPtr = _inputPtr;\ninLen = _inputEnd;\n} else if (i <= INT_QUOTE) {\nif (i == INT_QUOTE) {\n_inputPtr = inPtr;\nbreak;\n}\nif (i < INT_SPACE) {\n_inputPtr = inPtr;\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n}\n}\n\n/*\n/**********************************************************\n/* Internal methods, other parsing\n/**********************************************************\n*/\n\n/**\n* We actually need to check the character value here\n* (to see if we have \\n following \\r).\n*/\nprotected final void _skipCR() throws IOException {\nif (_inputPtr < _inputEnd || loadMore()) {\nif (_inputBuffer[_inputPtr] == '\\n') {\n++_inputPtr;\n}\n}\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n}\n\nprivate final int _skipColon() throws IOException\n{\nif ((_inputPtr + 4) >= _inputEnd) {\nreturn _skipColon2(false);\n}\nchar c = _inputBuffer[_inputPtr];\nif (c == ':') { // common case, no leading space\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) { // nor trailing\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (c == ' ' || c == '\\t') {\nc = _inputBuffer[++_inputPtr];\n}\nif (c == ':') {\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true);\n}\nreturn _skipColon2(false);\n}\n\nprivate final int _skipColon2(boolean gotColon) throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nif (gotColon) {\nreturn i;\n}\nif (i != INT_COLON) {\nif (i < INT_SPACE) {\n_throwInvalidSpace(i);\n}\n_reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n}\ngotColon = true;\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n// Variant called when we know there's at least 4 more bytes available\nprivate final int _skipColonFast(int ptr) throws IOException\n{\nint i = (int) _inputBuffer[ptr++];\nif (i == INT_COLON) { // common case, no leading space\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) { // nor trailing\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = _inputBuffer[ptr++];\n}\nboolean gotColon = (i == INT_COLON);\nif (gotColon) {\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(gotColon);\n}\n\n// Primary loop: no reloading, comment handling\nprivate final int _skipComma(int i) throws IOException\n{\nif (i != INT_COMMA) {\n_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n}\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipAfterComma2();\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipAfterComma2();\n}\n\nprivate final int _skipAfterComma2() throws IOException\n{\nwhile (_inputPtr < _inputEnd || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nthrow _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n}\n\nprivate final int _skipWSOrEnd() throws IOException\n{\n// Let's handle first character separately since it is likely that\n// it is either non-whitespace; or we have longer run of white space\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\nreturn _eofAsNextChar();\n}\n}\nint i = _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipWSOrEnd2();\n}\n\nprivate int _skipWSOrEnd2() throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // We ran out of input...\nreturn _eofAsNextChar();\n}\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n} else if (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\nprivate void _skipComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_COMMENTS)) {\n_reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n}\n// First: check which comment (if either) it is:\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_reportInvalidEOF(\" in a comment\");\n}\nchar c = _inputBuffer[_inputPtr++];\nif (c == '/') {\n_skipLine();\n} else if (c == '*') {\n_skipCComment();\n} else {\n_reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n}\n}\n\nprivate void _skipCComment() throws IOException\n{\n// Ok: need the matching '*/'\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i <= '*') {\nif (i == '*') { // end?\nif ((_inputPtr >= _inputEnd) && !loadMore()) {\nbreak;\n}\nif (_inputBuffer[_inputPtr] == INT_SLASH) {\n++_inputPtr;\nreturn;\n}\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n_reportInvalidEOF(\" in a comment\");\n}\n\nprivate boolean _skipYAMLComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\nreturn false;\n}\n_skipLine();\nreturn true;\n}\n\nprivate void _skipLine() throws IOException\n{\n// Ok: need to find EOF or linefeed\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nbreak;\n} else if (i == INT_CR) {\n_skipCR();\nbreak;\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n@Override\nprotected char _decodeEscaped() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\n\nswitch ((int) c) {\n// First, ones that are mapped\ncase 'b':\nreturn '\\b';\ncase 't':\nreturn '\\t';\ncase 'n':\nreturn '\\n';\ncase 'f':\nreturn '\\f';\ncase 'r':\nreturn '\\r';\n\n// And these are to be returned as they are\ncase '\"':\ncase '/':\ncase '\\\\':\nreturn c;\n\ncase 'u': // and finally hex-escaped\nbreak;\n\ndefault:\nreturn _handleUnrecognizedCharacterEscape(c);\n}\n\n// Ok, a hex escape. Need 4 characters\nint value = 0;\nfor (int i = 0; i < 4; ++i) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nint ch = (int) _inputBuffer[_inputPtr++];\nint digit = CharTypes.charToHex(ch);\nif (digit < 0) {\n_reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n}\nvalue = (value << 4) | digit;\n}\nreturn (char) value;\n}\n\nprivate final void _matchTrue() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"true\", 1);\n}\n\nprivate final void _matchFalse() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 4) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"false\", 1);\n}\n\nprivate final void _matchNull() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"null\", 1);\n}",
            "method_id": 151
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:getCurrentName()Ljava/lang/String;",
            "method_body": "@Override public String getCurrentName() { return _currentName; }\n@Override public String getCurrentName() { return _currentName; }",
            "method_id": 152
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:getIntValue()I",
            "method_body": "public int getIntValue() throws IOException\n{\nif ((_numTypesValid & NR_INT) == 0) {\nif (_numTypesValid == NR_UNKNOWN) { // not parsed at all\nreturn _parseIntValue();\n}\nif ((_numTypesValid & NR_INT) == 0) { // wasn't an int natively?\nconvertNumberToInt(); // let's make it so, if possible\n}\n}\nreturn _numberInt;\n}",
            "method_id": 153
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:size()I",
            "method_body": "public int size() { return _size; }\npublic int size() { return _size; }",
            "method_id": 154
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:findSymbol([CIII)Ljava/lang/String;",
            "method_body": "public String findSymbol(char[] buffer, int start, int len, int h)\n{\nif (len < 1) { // empty Strings are simplest to handle up front\nreturn \"\";\n}\nif (!_canonicalize) { // [JACKSON-259]\nreturn new String(buffer, start, len);\n}\n\n/* Related to problems with sub-standard hashing (somewhat\n* relevant for collision attacks too), let's try little\n* bit of shuffling to improve hash codes.\n* (note, however, that this can't help with full collisions)\n*/\nint index = _hashToIndex(h);\nString sym = _symbols[index];\n\n// Optimal case; checking existing primary symbol for hash index:\nif (sym != null) {\n// Let's inline primary String equality checking:\nif (sym.length() == len) {\nint i = 0;\nwhile (sym.charAt(i) == buffer[start+i]) {\n// Optimal case; primary match found\nif (++i == len) {\nreturn sym;\n}\n}\n}\nBucket b = _buckets[index>>1];\nif (b != null) {\nsym = b.has(buffer, start, len);\nif (sym != null) {\nreturn sym;\n}\nsym = _findSymbol2(buffer, start, len, b.next);\nif (sym != null) {\nreturn sym;\n}\n}\n}\nreturn _addSymbol(buffer, start, len, h, index);\n}",
            "method_id": 155
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:_addSymbol([CIIII)Ljava/lang/String;",
            "method_body": "private String _addSymbol(char[] buffer, int start, int len, int h, int index)\n{\nif (!_dirty) { //need to do copy-on-write?\ncopyArrays();\n_dirty = true;\n} else if (_size >= _sizeThreshold) { // Need to expand?\nrehash();\n/* Need to recalc hash; rare occurence (index mask has been\n* recalculated as part of rehash)\n*/\nindex = _hashToIndex(calcHash(buffer, start, len));\n}\n\nString newSymbol = new String(buffer, start, len);\nif (JsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(_flags)) {\nnewSymbol = InternCache.instance.intern(newSymbol);\n}\n++_size;\n// Ok; do we need to add primary entry, or a bucket?\nif (_symbols[index] == null) {\n_symbols[index] = newSymbol;\n} else {\nfinal int bix = (index >> 1);\nBucket newB = new Bucket(newSymbol, _buckets[bix]);\nint collLen = newB.length;\nif (collLen > MAX_COLL_CHAIN_LENGTH) {\n/* 23-May-2014, tatu: Instead of throwing an exception right away, let's handle\n*   in bit smarter way.\n*/\n_handleSpillOverflow(bix, newB);\n} else {\n_buckets[bix] = newB;\n_longestCollisionList = Math.max(collLen, _longestCollisionList);\n}\n}\n\nreturn newSymbol;\n}",
            "method_id": 156
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:_hashToIndex(I)I",
            "method_body": "public int _hashToIndex(int rawHash) {\n// doing these seems to help a bit\nrawHash += (rawHash >>> 15);\nrawHash ^= (rawHash << 7);\nrawHash += (rawHash >>> 3);\nreturn (rawHash & _indexMask);\n}",
            "method_id": 157
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:copyArrays()V",
            "method_body": "private void copyArrays() {\nfinal String[] oldSyms = _symbols;\n_symbols = Arrays.copyOf(oldSyms, oldSyms.length);\nfinal Bucket[] oldBuckets = _buckets;\n_buckets = Arrays.copyOf(oldBuckets, oldBuckets.length);\n}",
            "method_id": 158
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:_updateNameLocation()V",
            "method_body": "private final void _updateNameLocation()\n{\nint ptr = _inputPtr;\n_nameStartOffset = ptr;\n_nameStartRow = _currInputRow;\n_nameStartCol = ptr - _currInputRowStart;\n}",
            "method_id": 159
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.NumberInput:parseInt([CII)I",
            "method_body": "public static int parseInt(char[] ch, int off, int len)\n{\nint num = ch[off] - '0';\n\nif (len > 4) {\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nlen -= 4;\nif (len > 4) {\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nreturn num;\n}\n}\nif (len > 1) {\nnum = (num * 10) + (ch[++off] - '0');\nif (len > 2) {\nnum = (num * 10) + (ch[++off] - '0');\nif (len > 3) {\nnum = (num * 10) + (ch[++off] - '0');\n}\n}\n}\nreturn num;\n}",
            "method_id": 160
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:_skipComma(I)I",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n_updateLocation();\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleOddValue(i);\n}\n\nprotected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n{\n// // // and this is back to standard nextToken()\nString name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n_parsingContext.setCurrentName(name);\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n_updateLocation();\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn nameToMatch.equals(name);\n}\n// Ok: we must have a value... what is it?\nJsonToken t;\nswitch (i) {\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ncase 'f':\n_matchFalse();\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchNull();\nt = JsonToken.VALUE_NULL;\nbreak;\ncase 't':\n_matchTrue();\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ndefault:\nt = _handleOddValue(i);\nbreak;\n}\n_nextToken = t;\nreturn nameToMatch.equals(name);\n}\n\nprivate final JsonToken _nextTokenNotInObject(int i) throws IOException\n{\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\nreturn (_currToken = JsonToken.VALUE_STRING);\n}\nswitch (i) {\ncase '[':\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_ARRAY);\ncase '{':\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_OBJECT);\ncase 't':\n_matchToken(\"true\", 1);\nreturn (_currToken = JsonToken.VALUE_TRUE);\ncase 'f':\n_matchToken(\"false\", 1);\nreturn (_currToken = JsonToken.VALUE_FALSE);\ncase 'n':\n_matchToken(\"null\", 1);\nreturn (_currToken = JsonToken.VALUE_NULL);\ncase '-':\nreturn (_currToken = _parseNegNumber());\n/* Should we have separate handling for plus? Although\n* it is not allowed per se, it may be erroneously used,\n* and could be indicated by a more specific error message.\n*/\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn (_currToken = _parsePosNumber(i));\n}\nreturn (_currToken = _handleOddValue(i));\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final String nextTextValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\n_finishString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final int nextIntValue(int defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) {\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final long nextLongValue(long defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final Boolean nextBooleanValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\nJsonToken t = nextToken();\nif (t != null) {\nint id = t.id();\nif (id == ID_TRUE) return Boolean.TRUE;\nif (id == ID_FALSE) return Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected final JsonToken _parsePosNumber(int ch) throws IOException\n{\n/* Although we will always be complete with respect to textual\n* representation (that is, all characters will be parsed),\n* actual conversion to a number is deferred. Thus, need to\n* note that no representations are valid yet\n*/\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include digit already read\nfinal int inputLen = _inputEnd;\n\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(false, startPtr);\n}\n\n/* First, let's see if the whole number is contained within\n* the input buffer unsplit. This should be the common case;\n* and to simplify processing, we will just reparse contents\n* in the alternative case (number split on buffer boundary)\n*/\n\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(false, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, false, intLen);\n}\n// Got it all: let's add to text buffer for parsing, access\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(false, intLen);\n}\n\nprivate final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\nthrows IOException\n{\nfinal int inputLen = _inputEnd;\nint fractLen = 0;\n\n// And then see if we get other parts\nif (ch == '.') { // yes, fraction\nfract_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n}\n}\nint expLen = 0;\nif (ch == 'e' || ch == 'E') { // and/or exponent\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\n// Sign indicator?\nch = (int) _inputBuffer[ptr++];\nif (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\nwhile (ch <= INT_9 && ch >= INT_0) {\n++expLen;\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n}\n}\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n// And there we have it!\nreturn resetFloat(neg, intLen, fractLen, expLen);\n}\n\nprotected final JsonToken _parseNegNumber() throws IOException\n{\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include sign/digit already read\nfinal int inputLen = _inputEnd;\n\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nint ch = _inputBuffer[ptr++];\n// First check: must have a digit to follow minus sign\nif (ch > INT_9 || ch < INT_0) {\n_inputPtr = ptr;\nreturn _handleInvalidNumberStart(ch, true);\n}\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(true, startPtr);\n}\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\n\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, true, intLen);\n}\n--ptr;\n_inputPtr = ptr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to parse a number, when the primary parse\n* method has failed to parse it, due to it being split on\n* buffer boundary. As a result code is very similar, except\n* that it has to explicitly copy contents to the text buffer\n* instead of just sharing the main input buffer.\n*/\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n{\n_inputPtr = neg ? (startPtr+1) : startPtr;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\nif (neg) {\noutBuf[outPtr++] = '-';\n}\n\n// This is the place to do leading-zero check(s) too:\nint intLen = 0;\nchar c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\nif (c == '0') {\nc = _verifyNoLeadingZeroes();\n}\nboolean eof = false;\n\n// Ok, first the obligatory integer part:\nint_loop:\nwhile (c >= '0' && c <= '9') {\n++intLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\n// EOF is legal for main level int values\nc = CHAR_NULL;\neof = true;\nbreak int_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// Also, integer part is not optional\nif (intLen == 0) {\nreturn _handleInvalidNumberStart(c, neg);\n}\n\nint fractLen = 0;\n// And then see if we get other parts\nif (c == '.') { // yes, fraction\noutBuf[outPtr++] = c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = _inputBuffer[_inputPtr++];\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == 'e' || c == 'E') { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Not optional, can require that we get one more char\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Likewise, non optional:\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n// And there we have it!\nreturn reset(neg, intLen, fractLen, expLen);\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final char _verifyNoLeadingZeroes() throws IOException\n{\n// Fast case first:\nif (_inputPtr < _inputEnd) {\nchar ch = _inputBuffer[_inputPtr];\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\n}\n// and offline the less common case\nreturn _verifyNLZ2();\n}\n\nprivate char _verifyNLZ2() throws IOException\n{\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn '0';\n}\nchar ch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') { // followed by non-number; retain one zero\nreturn '0';\n}\n++_inputPtr; // skip previous zero\nif (ch != '0') { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n{\nif (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { _reportInvalidEOFInValue(); }\n}\nch = _inputBuffer[_inputPtr++];\nif (ch == 'N') {\nString match = negative ? \"-INF\" :\"+INF\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n} else if (ch == 'n') {\nString match = negative ? \"-Infinity\" :\"+Infinity\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName() throws IOException\n{\n// First: let's try to see if we have a simple name: one that does\n// not cross input buffer boundary, and does not contain escape sequences.\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int[] codes = _icLatin1;\n\nwhile (ptr < _inputEnd) {\nint ch = _inputBuffer[ptr];\nif (ch < codes.length && codes[ch] != 0) {\nif (ch == '\"') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n}\nint start = _inputPtr;\n_inputPtr = ptr;\nreturn _parseName2(start, hash, INT_QUOTE);\n}\n\nprivate String _parseName2(int startPtr, int hash, int endChar) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n/* Output pointers; calls will also ensure that the buffer is\n* not shared and has room for at least one more char.\n*/\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= endChar) {\nif (i == endChar) {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"name\");\n}\n}\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int i) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n_reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n}\nfinal int[] codes = CharTypes.getInputCodeLatin1JsNames();\nfinal int maxCode = codes.length;\n\n// Also: first char must be a valid name char, but NOT be number\nboolean firstOk;\n\nif (i < maxCode) { // identifier, or a number ([Issue#102])\nfirstOk = (codes[i] == 0);\n} else {\nfirstOk = Character.isJavaIdentifierPart((char) i);\n}\nif (!firstOk) {\n_reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode) {\nif (codes[ch] != 0) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\n} else if (!Character.isJavaIdentifierPart((char) ch)) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\nint start = _inputPtr-1;\n_inputPtr = ptr;\nreturn _handleOddName2(start, hash, codes);\n}\n\nprotected String _parseAposName() throws IOException\n{\n// Note: mostly copy of_parseFieldName\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch == '\\'') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nif (ch < maxCode && codes[ch] != 0) {\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\n\nint start = _inputPtr;\n_inputPtr = ptr;\n\nreturn _parseName2(start, hash, '\\'');\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleOddValue(int i) throws IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (i) {\ncase '\\'':\n/* [JACKSON-173]: allow single quotes. Unlike with regular\n* Strings, we'll eagerly parse contents; this so that there's\n* no need to store information on quote char used.\n*\n* Also, no separation to fast/slow parsing; we'll just do\n* one regular (~= slowish) parsing, to keep code simple\n*/\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(i)) {\n_reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= '\\\\') {\nif (i == '\\\\') {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= '\\'') {\nif (i == '\\'') {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\nreturn JsonToken.VALUE_STRING;\n}\n\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // acceptable for now (will error out later)\nbreak;\n}\n}\nchar c = _inputBuffer[_inputPtr];\nint i = (int) c;\nif (i <= maxCode) {\nif (codes[i] != 0) {\nbreak;\n}\n} else if (!Character.isJavaIdentifierPart(c)) {\nbreak;\n}\n++_inputPtr;\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\n\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n@Override\nprotected final void _finishString() throws IOException\n{\n/* First: let's try to see if we have simple String value: one\n* that does not cross input buffer boundary, and does not\n* contain escape sequences.\n*/\nint ptr = _inputPtr;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode && codes[ch] != 0) {\nif (ch == '\"') {\n_textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr+1;\n// Yes, we got it all\nreturn;\n}\nbreak;\n}\n++ptr;\n} while (ptr < inputLen);\n}\n\n/* Either ran out of input, or bumped into an escape\n* sequence...\n*/\n_textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr;\n_finishString2();\n}\n\nprotected void _finishString2() throws IOException\n{\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i < maxCode && codes[i] != 0) {\nif (i == INT_QUOTE) {\nbreak;\n} else if (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n} // anything else?\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected final void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\nint inPtr = _inputPtr;\nint inLen = _inputEnd;\nchar[] inBuf = _inputBuffer;\n\nwhile (true) {\nif (inPtr >= inLen) {\n_inputPtr = inPtr;\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\ninPtr = _inputPtr;\ninLen = _inputEnd;\n}\nchar c = inBuf[inPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\n_inputPtr = inPtr;\nc = _decodeEscaped();\ninPtr = _inputPtr;\ninLen = _inputEnd;\n} else if (i <= INT_QUOTE) {\nif (i == INT_QUOTE) {\n_inputPtr = inPtr;\nbreak;\n}\nif (i < INT_SPACE) {\n_inputPtr = inPtr;\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n}\n}\n\n/*\n/**********************************************************\n/* Internal methods, other parsing\n/**********************************************************\n*/\n\n/**\n* We actually need to check the character value here\n* (to see if we have \\n following \\r).\n*/\nprotected final void _skipCR() throws IOException {\nif (_inputPtr < _inputEnd || loadMore()) {\nif (_inputBuffer[_inputPtr] == '\\n') {\n++_inputPtr;\n}\n}\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n}\n\nprivate final int _skipColon() throws IOException\n{\nif ((_inputPtr + 4) >= _inputEnd) {\nreturn _skipColon2(false);\n}\nchar c = _inputBuffer[_inputPtr];\nif (c == ':') { // common case, no leading space\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) { // nor trailing\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (c == ' ' || c == '\\t') {\nc = _inputBuffer[++_inputPtr];\n}\nif (c == ':') {\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true);\n}\nreturn _skipColon2(false);\n}\n\nprivate final int _skipColon2(boolean gotColon) throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nif (gotColon) {\nreturn i;\n}\nif (i != INT_COLON) {\nif (i < INT_SPACE) {\n_throwInvalidSpace(i);\n}\n_reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n}\ngotColon = true;\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n// Variant called when we know there's at least 4 more bytes available\nprivate final int _skipColonFast(int ptr) throws IOException\n{\nint i = (int) _inputBuffer[ptr++];\nif (i == INT_COLON) { // common case, no leading space\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) { // nor trailing\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = _inputBuffer[ptr++];\n}\nboolean gotColon = (i == INT_COLON);\nif (gotColon) {\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(gotColon);\n}\n\n// Primary loop: no reloading, comment handling\nprivate final int _skipComma(int i) throws IOException\n{\nif (i != INT_COMMA) {\n_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n}\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipAfterComma2();\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipAfterComma2();\n}\n\nprivate final int _skipAfterComma2() throws IOException\n{\nwhile (_inputPtr < _inputEnd || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nthrow _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n}\n\nprivate final int _skipWSOrEnd() throws IOException\n{\n// Let's handle first character separately since it is likely that\n// it is either non-whitespace; or we have longer run of white space\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\nreturn _eofAsNextChar();\n}\n}\nint i = _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipWSOrEnd2();\n}\n\nprivate int _skipWSOrEnd2() throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // We ran out of input...\nreturn _eofAsNextChar();\n}\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n} else if (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\nprivate void _skipComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_COMMENTS)) {\n_reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n}\n// First: check which comment (if either) it is:\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_reportInvalidEOF(\" in a comment\");\n}\nchar c = _inputBuffer[_inputPtr++];\nif (c == '/') {\n_skipLine();\n} else if (c == '*') {\n_skipCComment();\n} else {\n_reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n}\n}\n\nprivate void _skipCComment() throws IOException\n{\n// Ok: need the matching '*/'\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i <= '*') {\nif (i == '*') { // end?\nif ((_inputPtr >= _inputEnd) && !loadMore()) {\nbreak;\n}\nif (_inputBuffer[_inputPtr] == INT_SLASH) {\n++_inputPtr;\nreturn;\n}\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n_reportInvalidEOF(\" in a comment\");\n}\n\nprivate boolean _skipYAMLComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\nreturn false;\n}\n_skipLine();\nreturn true;\n}\n\nprivate void _skipLine() throws IOException\n{\n// Ok: need to find EOF or linefeed\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nbreak;\n} else if (i == INT_CR) {\n_skipCR();\nbreak;\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n@Override\nprotected char _decodeEscaped() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\n\nswitch ((int) c) {\n// First, ones that are mapped\ncase 'b':\nreturn '\\b';\ncase 't':\nreturn '\\t';\ncase 'n':\nreturn '\\n';\ncase 'f':\nreturn '\\f';\ncase 'r':\nreturn '\\r';\n\n// And these are to be returned as they are\ncase '\"':\ncase '/':\ncase '\\\\':\nreturn c;\n\ncase 'u': // and finally hex-escaped\nbreak;\n\ndefault:\nreturn _handleUnrecognizedCharacterEscape(c);\n}\n\n// Ok, a hex escape. Need 4 characters\nint value = 0;\nfor (int i = 0; i < 4; ++i) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nint ch = (int) _inputBuffer[_inputPtr++];\nint digit = CharTypes.charToHex(ch);\nif (digit < 0) {\n_reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n}\nvalue = (value << 4) | digit;\n}\nreturn (char) value;\n}\n\nprivate final void _matchTrue() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"true\", 1);\n}\n\nprivate final void _matchFalse() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 4) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"false\", 1);\n}\n\nprivate final void _matchNull() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"null\", 1);\n}",
            "method_id": 161
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:_handleEOF()V",
            "method_body": "protected void _handleEOF() throws JsonParseException {\nif (!_parsingContext.inRoot()) {\n_reportInvalidEOF(\": expected close marker for \"+_parsingContext.getTypeDesc()+\" (from \"+_parsingContext.getStartLocation(_ioContext.getSourceReference())+\")\");\n}\n}",
            "method_id": 162
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:_eofAsNextChar()I",
            "method_body": "protected final int _eofAsNextChar() throws JsonParseException {\n_handleEOF();\nreturn -1;\n}",
            "method_id": 163
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:getTextOffset()I",
            "method_body": "public int getTextOffset() {\n/* Only shared input buffer can have non-zero offset; buffer\n* segments start at 0, and if we have to create a combo buffer,\n* that too will start from beginning of the buffer\n*/\nreturn (_inputStart >= 0) ? _inputStart : 0;\n}",
            "method_id": 164
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:getTextBuffer()[C",
            "method_body": "public char[] getTextBuffer()\n{\n// Are we just using shared input buffer?\nif (_inputStart >= 0) return _inputBuffer;\nif (_resultArray != null)  return _resultArray;\nif (_resultString != null) {\nreturn (_resultArray = _resultString.toCharArray());\n}\n// Nope; but does it fit in just one segment?\nif (!_hasSegments) {\nreturn (_currentSegment == null) ? NO_CHARS : _currentSegment;\n}\n// Nope, need to have/create a non-segmented array and return it\nreturn contentsAsArray();\n}",
            "method_id": 165
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:_parsePosNumber(I)Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n_updateLocation();\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleOddValue(i);\n}\n\nprotected boolean _isNextTokenNameMaybe(int i, String nameToMatch) throws IOException\n{\n// // // and this is back to standard nextToken()\nString name = (i == INT_QUOTE) ? _parseName() : _handleOddName(i);\n_parsingContext.setCurrentName(name);\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n_updateLocation();\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn nameToMatch.equals(name);\n}\n// Ok: we must have a value... what is it?\nJsonToken t;\nswitch (i) {\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ncase 'f':\n_matchFalse();\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchNull();\nt = JsonToken.VALUE_NULL;\nbreak;\ncase 't':\n_matchTrue();\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ndefault:\nt = _handleOddValue(i);\nbreak;\n}\n_nextToken = t;\nreturn nameToMatch.equals(name);\n}\n\nprivate final JsonToken _nextTokenNotInObject(int i) throws IOException\n{\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\nreturn (_currToken = JsonToken.VALUE_STRING);\n}\nswitch (i) {\ncase '[':\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_ARRAY);\ncase '{':\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_OBJECT);\ncase 't':\n_matchToken(\"true\", 1);\nreturn (_currToken = JsonToken.VALUE_TRUE);\ncase 'f':\n_matchToken(\"false\", 1);\nreturn (_currToken = JsonToken.VALUE_FALSE);\ncase 'n':\n_matchToken(\"null\", 1);\nreturn (_currToken = JsonToken.VALUE_NULL);\ncase '-':\nreturn (_currToken = _parseNegNumber());\n/* Should we have separate handling for plus? Although\n* it is not allowed per se, it may be erroneously used,\n* and could be indicated by a more specific error message.\n*/\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn (_currToken = _parsePosNumber(i));\n}\nreturn (_currToken = _handleOddValue(i));\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final String nextTextValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\n_finishString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final int nextIntValue(int defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) {\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n// note: identical to one in Utf8StreamParser\n@Override\npublic final long nextLongValue(long defaultValue) throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n// note: identical to one in UTF8StreamJsonParser\n@Override\npublic final Boolean nextBooleanValue() throws IOException\n{\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\nJsonToken t = nextToken();\nif (t != null) {\nint id = t.id();\nif (id == ID_TRUE) return Boolean.TRUE;\nif (id == ID_FALSE) return Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected final JsonToken _parsePosNumber(int ch) throws IOException\n{\n/* Although we will always be complete with respect to textual\n* representation (that is, all characters will be parsed),\n* actual conversion to a number is deferred. Thus, need to\n* note that no representations are valid yet\n*/\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include digit already read\nfinal int inputLen = _inputEnd;\n\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(false, startPtr);\n}\n\n/* First, let's see if the whole number is contained within\n* the input buffer unsplit. This should be the common case;\n* and to simplify processing, we will just reparse contents\n* in the alternative case (number split on buffer boundary)\n*/\n\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(false, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, false, intLen);\n}\n// Got it all: let's add to text buffer for parsing, access\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(false, intLen);\n}\n\nprivate final JsonToken _parseFloat(int ch, int startPtr, int ptr, boolean neg, int intLen)\nthrows IOException\n{\nfinal int inputLen = _inputEnd;\nint fractLen = 0;\n\n// And then see if we get other parts\nif (ch == '.') { // yes, fraction\nfract_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(ch, \"Decimal point not followed by a digit\");\n}\n}\nint expLen = 0;\nif (ch == 'e' || ch == 'E') { // and/or exponent\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\n// Sign indicator?\nch = (int) _inputBuffer[ptr++];\nif (ch == INT_MINUS || ch == INT_PLUS) { // yup, skip for now\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\nwhile (ch <= INT_9 && ch >= INT_0) {\n++expLen;\nif (ptr >= inputLen) {\n_inputPtr = startPtr;\nreturn _parseNumber2(neg, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(ch, \"Exponent indicator not followed by a digit\");\n}\n}\n--ptr; // need to push back following separator\n_inputPtr = ptr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\n// And there we have it!\nreturn resetFloat(neg, intLen, fractLen, expLen);\n}\n\nprotected final JsonToken _parseNegNumber() throws IOException\n{\nint ptr = _inputPtr;\nint startPtr = ptr-1; // to include sign/digit already read\nfinal int inputLen = _inputEnd;\n\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nint ch = _inputBuffer[ptr++];\n// First check: must have a digit to follow minus sign\nif (ch > INT_9 || ch < INT_0) {\n_inputPtr = ptr;\nreturn _handleInvalidNumberStart(ch, true);\n}\n// One special case, leading zero(es):\nif (ch == INT_0) {\nreturn _parseNumber2(true, startPtr);\n}\nint intLen = 1; // already got one\n\n// First let's get the obligatory integer part:\nint_loop:\nwhile (true) {\nif (ptr >= inputLen) {\nreturn _parseNumber2(true, startPtr);\n}\nch = (int) _inputBuffer[ptr++];\nif (ch < INT_0 || ch > INT_9) {\nbreak int_loop;\n}\n++intLen;\n}\n\nif (ch == INT_PERIOD || ch == INT_e || ch == INT_E) {\n_inputPtr = ptr;\nreturn _parseFloat(ch, startPtr, ptr, true, intLen);\n}\n--ptr;\n_inputPtr = ptr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(ch);\n}\nint len = ptr-startPtr;\n_textBuffer.resetWithShared(_inputBuffer, startPtr, len);\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to parse a number, when the primary parse\n* method has failed to parse it, due to it being split on\n* buffer boundary. As a result code is very similar, except\n* that it has to explicitly copy contents to the text buffer\n* instead of just sharing the main input buffer.\n*/\nprivate final JsonToken _parseNumber2(boolean neg, int startPtr) throws IOException\n{\n_inputPtr = neg ? (startPtr+1) : startPtr;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\nif (neg) {\noutBuf[outPtr++] = '-';\n}\n\n// This is the place to do leading-zero check(s) too:\nint intLen = 0;\nchar c = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++] : getNextChar(\"No digit following minus sign\");\nif (c == '0') {\nc = _verifyNoLeadingZeroes();\n}\nboolean eof = false;\n\n// Ok, first the obligatory integer part:\nint_loop:\nwhile (c >= '0' && c <= '9') {\n++intLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\n// EOF is legal for main level int values\nc = CHAR_NULL;\neof = true;\nbreak int_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// Also, integer part is not optional\nif (intLen == 0) {\nreturn _handleInvalidNumberStart(c, neg);\n}\n\nint fractLen = 0;\n// And then see if we get other parts\nif (c == '.') { // yes, fraction\noutBuf[outPtr++] = c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = _inputBuffer[_inputPtr++];\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == 'e' || c == 'E') { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Not optional, can require that we get one more char\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\n// Likewise, non optional:\nc = (_inputPtr < _inputEnd) ? _inputBuffer[_inputPtr++]\n: getNextChar(\"expected a digit for number exponent\");\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = _inputBuffer[_inputPtr++];\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n// And there we have it!\nreturn reset(neg, intLen, fractLen, expLen);\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final char _verifyNoLeadingZeroes() throws IOException\n{\n// Fast case first:\nif (_inputPtr < _inputEnd) {\nchar ch = _inputBuffer[_inputPtr];\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\n}\n// and offline the less common case\nreturn _verifyNLZ2();\n}\n\nprivate char _verifyNLZ2() throws IOException\n{\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn '0';\n}\nchar ch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') {\nreturn '0';\n}\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr];\nif (ch < '0' || ch > '9') { // followed by non-number; retain one zero\nreturn '0';\n}\n++_inputPtr; // skip previous zero\nif (ch != '0') { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean negative) throws IOException\n{\nif (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { _reportInvalidEOFInValue(); }\n}\nch = _inputBuffer[_inputPtr++];\nif (ch == 'N') {\nString match = negative ? \"-INF\" :\"+INF\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n} else if (ch == 'n') {\nString match = negative ? \"-Infinity\" :\"+Infinity\";\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, negative ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName() throws IOException\n{\n// First: let's try to see if we have a simple name: one that does\n// not cross input buffer boundary, and does not contain escape sequences.\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int[] codes = _icLatin1;\n\nwhile (ptr < _inputEnd) {\nint ch = _inputBuffer[ptr];\nif (ch < codes.length && codes[ch] != 0) {\nif (ch == '\"') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n}\nint start = _inputPtr;\n_inputPtr = ptr;\nreturn _parseName2(start, hash, INT_QUOTE);\n}\n\nprivate String _parseName2(int startPtr, int hash, int endChar) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n\n/* Output pointers; calls will also ensure that the buffer is\n* not shared and has room for at least one more char.\n*/\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\"+((char) endChar)+\"' for name\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= endChar) {\nif (i == endChar) {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"name\");\n}\n}\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + c;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int i) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (i == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\n_reportUnexpectedChar(i, \"was expecting double-quote to start field name\");\n}\nfinal int[] codes = CharTypes.getInputCodeLatin1JsNames();\nfinal int maxCode = codes.length;\n\n// Also: first char must be a valid name char, but NOT be number\nboolean firstOk;\n\nif (i < maxCode) { // identifier, or a number ([Issue#102])\nfirstOk = (codes[i] == 0);\n} else {\nfirstOk = Character.isJavaIdentifierPart((char) i);\n}\nif (!firstOk) {\n_reportUnexpectedChar(i, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode) {\nif (codes[ch] != 0) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\n} else if (!Character.isJavaIdentifierPart((char) ch)) {\nint start = _inputPtr-1; // -1 to bring back first char\n_inputPtr = ptr;\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\nint start = _inputPtr-1;\n_inputPtr = ptr;\nreturn _handleOddName2(start, hash, codes);\n}\n\nprotected String _parseAposName() throws IOException\n{\n// Note: mostly copy of_parseFieldName\nint ptr = _inputPtr;\nint hash = _hashSeed;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch == '\\'') {\nint start = _inputPtr;\n_inputPtr = ptr+1; // to skip the quote\nreturn _symbols.findSymbol(_inputBuffer, start, ptr - start, hash);\n}\nif (ch < maxCode && codes[ch] != 0) {\nbreak;\n}\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + ch;\n++ptr;\n} while (ptr < inputLen);\n}\n\nint start = _inputPtr;\n_inputPtr = ptr;\n\nreturn _parseName2(start, hash, '\\'');\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleOddValue(int i) throws IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (i) {\ncase '\\'':\n/* [JACKSON-173]: allow single quotes. Unlike with regular\n* Strings, we'll eagerly parse contents; this so that there's\n* no need to store information on quote char used.\n*\n* Also, no separation to fast/slow parsing; we'll just do\n* one regular (~= slowish) parsing, to keep code simple\n*/\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++], false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(i)) {\n_reportInvalidToken(\"\"+((char) i), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(i, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i <= '\\\\') {\nif (i == '\\\\') {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i <= '\\'') {\nif (i == '\\'') {\nbreak;\n}\nif (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\nreturn JsonToken.VALUE_STRING;\n}\n\nprivate String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n_textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // acceptable for now (will error out later)\nbreak;\n}\n}\nchar c = _inputBuffer[_inputPtr];\nint i = (int) c;\nif (i <= maxCode) {\nif (codes[i] != 0) {\nbreak;\n}\n} else if (!Character.isJavaIdentifierPart(c)) {\nbreak;\n}\n++_inputPtr;\nhash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i;\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n{\nTextBuffer tb = _textBuffer;\nchar[] buf = tb.getTextBuffer();\nint start = tb.getTextOffset();\nint len = tb.size();\n\nreturn _symbols.findSymbol(buf, start, len, hash);\n}\n}\n\n@Override\nprotected final void _finishString() throws IOException\n{\n/* First: let's try to see if we have simple String value: one\n* that does not cross input buffer boundary, and does not\n* contain escape sequences.\n*/\nint ptr = _inputPtr;\nfinal int inputLen = _inputEnd;\n\nif (ptr < inputLen) {\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\ndo {\nint ch = _inputBuffer[ptr];\nif (ch < maxCode && codes[ch] != 0) {\nif (ch == '\"') {\n_textBuffer.resetWithShared(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr+1;\n// Yes, we got it all\nreturn;\n}\nbreak;\n}\n++ptr;\n} while (ptr < inputLen);\n}\n\n/* Either ran out of input, or bumped into an escape\n* sequence...\n*/\n_textBuffer.resetWithCopy(_inputBuffer, _inputPtr, (ptr-_inputPtr));\n_inputPtr = ptr;\n_finishString2();\n}\n\nprotected void _finishString2() throws IOException\n{\nchar[] outBuf = _textBuffer.getCurrentSegment();\nint outPtr = _textBuffer.getCurrentSegmentSize();\nfinal int[] codes = _icLatin1;\nfinal int maxCode = codes.length;\n\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\nint i = (int) c;\nif (i < maxCode && codes[i] != 0) {\nif (i == INT_QUOTE) {\nbreak;\n} else if (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\nc = _decodeEscaped();\n} else if (i < INT_SPACE) {\n_throwUnquotedSpace(i, \"string value\");\n} // anything else?\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected final void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\nint inPtr = _inputPtr;\nint inLen = _inputEnd;\nchar[] inBuf = _inputBuffer;\n\nwhile (true) {\nif (inPtr >= inLen) {\n_inputPtr = inPtr;\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing quote for a string value\");\n}\ninPtr = _inputPtr;\ninLen = _inputEnd;\n}\nchar c = inBuf[inPtr++];\nint i = (int) c;\nif (i <= INT_BACKSLASH) {\nif (i == INT_BACKSLASH) {\n/* Although chars outside of BMP are to be escaped as\n* an UTF-16 surrogate pair, does that affect decoding?\n* For now let's assume it does not.\n*/\n_inputPtr = inPtr;\nc = _decodeEscaped();\ninPtr = _inputPtr;\ninLen = _inputEnd;\n} else if (i <= INT_QUOTE) {\nif (i == INT_QUOTE) {\n_inputPtr = inPtr;\nbreak;\n}\nif (i < INT_SPACE) {\n_inputPtr = inPtr;\n_throwUnquotedSpace(i, \"string value\");\n}\n}\n}\n}\n}\n\n/*\n/**********************************************************\n/* Internal methods, other parsing\n/**********************************************************\n*/\n\n/**\n* We actually need to check the character value here\n* (to see if we have \\n following \\r).\n*/\nprotected final void _skipCR() throws IOException {\nif (_inputPtr < _inputEnd || loadMore()) {\nif (_inputBuffer[_inputPtr] == '\\n') {\n++_inputPtr;\n}\n}\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n}\n\nprivate final int _skipColon() throws IOException\n{\nif ((_inputPtr + 4) >= _inputEnd) {\nreturn _skipColon2(false);\n}\nchar c = _inputBuffer[_inputPtr];\nif (c == ':') { // common case, no leading space\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) { // nor trailing\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (c == ' ' || c == '\\t') {\nc = _inputBuffer[++_inputPtr];\n}\nif (c == ':') {\nint i = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true);\n}\nreturn _skipColon2(false);\n}\n\nprivate final int _skipColon2(boolean gotColon) throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nif (gotColon) {\nreturn i;\n}\nif (i != INT_COLON) {\nif (i < INT_SPACE) {\n_throwInvalidSpace(i);\n}\n_reportUnexpectedChar(i, \"was expecting a colon to separate field name and value\");\n}\ngotColon = true;\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n// Variant called when we know there's at least 4 more bytes available\nprivate final int _skipColonFast(int ptr) throws IOException\n{\nint i = (int) _inputBuffer[ptr++];\nif (i == INT_COLON) { // common case, no leading space\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) { // nor trailing\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = _inputBuffer[ptr++];\n}\nboolean gotColon = (i == INT_COLON);\nif (gotColon) {\ni = _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n} else if (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[ptr++];\nif (i > INT_SPACE) {\nif (i != INT_SLASH && i != INT_HASH) {\n_inputPtr = ptr;\nreturn i;\n}\n}\n}\n}\n_inputPtr = ptr-1;\nreturn _skipColon2(gotColon);\n}\n\n// Primary loop: no reloading, comment handling\nprivate final int _skipComma(int i) throws IOException\n{\nif (i != INT_COMMA) {\n_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n}\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipAfterComma2();\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipAfterComma2();\n}\n\nprivate final int _skipAfterComma2() throws IOException\n{\nwhile (_inputPtr < _inputEnd || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nthrow _constructError(\"Unexpected end-of-input within/between \"+_parsingContext.getTypeDesc()+\" entries\");\n}\n\nprivate final int _skipWSOrEnd() throws IOException\n{\n// Let's handle first character separately since it is likely that\n// it is either non-whitespace; or we have longer run of white space\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\nreturn _eofAsNextChar();\n}\n}\nint i = _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n\nwhile (_inputPtr < _inputEnd) {\ni = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipWSOrEnd2();\n}\n\nprivate int _skipWSOrEnd2() throws IOException\n{\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) { // We ran out of input...\nreturn _eofAsNextChar();\n}\n}\nint i = (int) _inputBuffer[_inputPtr++];\nif (i > INT_SPACE) {\nif (i == INT_SLASH) {\n_skipComment();\ncontinue;\n}\nif (i == INT_HASH) {\nif (_skipYAMLComment()) {\ncontinue;\n}\n}\nreturn i;\n} else if (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\nprivate void _skipComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_COMMENTS)) {\n_reportUnexpectedChar('/', \"maybe a (non-standard) comment? (not recognized as one since Feature 'ALLOW_COMMENTS' not enabled for parser)\");\n}\n// First: check which comment (if either) it is:\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_reportInvalidEOF(\" in a comment\");\n}\nchar c = _inputBuffer[_inputPtr++];\nif (c == '/') {\n_skipLine();\n} else if (c == '*') {\n_skipCComment();\n} else {\n_reportUnexpectedChar(c, \"was expecting either '*' or '/' for a comment\");\n}\n}\n\nprivate void _skipCComment() throws IOException\n{\n// Ok: need the matching '*/'\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i <= '*') {\nif (i == '*') { // end?\nif ((_inputPtr >= _inputEnd) && !loadMore()) {\nbreak;\n}\nif (_inputBuffer[_inputPtr] == INT_SLASH) {\n++_inputPtr;\nreturn;\n}\ncontinue;\n}\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n_reportInvalidEOF(\" in a comment\");\n}\n\nprivate boolean _skipYAMLComment() throws IOException\n{\nif (!isEnabled(Feature.ALLOW_YAML_COMMENTS)) {\nreturn false;\n}\n_skipLine();\nreturn true;\n}\n\nprivate void _skipLine() throws IOException\n{\n// Ok: need to find EOF or linefeed\nwhile ((_inputPtr < _inputEnd) || loadMore()) {\nint i = (int) _inputBuffer[_inputPtr++];\nif (i < INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nbreak;\n} else if (i == INT_CR) {\n_skipCR();\nbreak;\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\n}\n\n@Override\nprotected char _decodeEscaped() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nchar c = _inputBuffer[_inputPtr++];\n\nswitch ((int) c) {\n// First, ones that are mapped\ncase 'b':\nreturn '\\b';\ncase 't':\nreturn '\\t';\ncase 'n':\nreturn '\\n';\ncase 'f':\nreturn '\\f';\ncase 'r':\nreturn '\\r';\n\n// And these are to be returned as they are\ncase '\"':\ncase '/':\ncase '\\\\':\nreturn c;\n\ncase 'u': // and finally hex-escaped\nbreak;\n\ndefault:\nreturn _handleUnrecognizedCharacterEscape(c);\n}\n\n// Ok, a hex escape. Need 4 characters\nint value = 0;\nfor (int i = 0; i < 4; ++i) {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in character escape sequence\");\n}\n}\nint ch = (int) _inputBuffer[_inputPtr++];\nint digit = CharTypes.charToHex(ch);\nif (digit < 0) {\n_reportUnexpectedChar(ch, \"expected a hex-digit for character escape sequence\");\n}\nvalue = (value << 4) | digit;\n}\nreturn (char) value;\n}\n\nprivate final void _matchTrue() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'r' && b[++ptr] == 'u' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"true\", 1);\n}\n\nprivate final void _matchFalse() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 4) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'a' && b[++ptr] == 'l' && b[++ptr] == 's' && b[++ptr] == 'e') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"false\", 1);\n}\n\nprivate final void _matchNull() throws IOException {\nint ptr = _inputPtr;\nif ((ptr + 3) < _inputEnd) {\nfinal char[] b = _inputBuffer;\nif (b[ptr] == 'u' && b[++ptr] == 'l' && b[++ptr] == 'l') {\nchar c = b[++ptr];\nif (c < '0' || c == ']' || c == '}') { // expected/allowed chars\n_inputPtr = ptr;\nreturn;\n}\n}\n}\n// buffer boundary, or problem, offline\n_matchToken(\"null\", 1);\n}",
            "method_id": 166
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.NumberInput:<clinit>()V",
            "method_body": "public final static String NASTY_SMALL_DOUBLE = \"2.2250738585072012e-308\";\n\n/**\n* Constants needed for parsing longs from basic int parsing methods\n*/\nfinal static long L_BILLION = 1000000000;\n\nfinal static String MIN_LONG_STR_NO_SIGN = String.valueOf(Long.MIN_VALUE).substring(1);\nfinal static String MAX_LONG_STR = String.valueOf(Long.MAX_VALUE);\n\n/**\n* Fast method for parsing integers that are known to fit into\n* regular 32-bit signed int type. This means that length is\n* between 1 and 9 digits (inclusive)\n*<p>\n* Note: public to let unit tests call it\n*/\npublic static int parseInt(char[] ch, int off, int len)\n{\nint num = ch[off] - '0';\n\nif (len > 4) {\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nlen -= 4;\nif (len > 4) {\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nreturn num;\n}\n}\nif (len > 1) {\nnum = (num * 10) + (ch[++off] - '0');\nif (len > 2) {\nnum = (num * 10) + (ch[++off] - '0');\nif (len > 3) {\nnum = (num * 10) + (ch[++off] - '0');\n}\n}\n}\nreturn num;\n}",
            "method_id": 167
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:resetWithShared([CII)V",
            "method_body": "public void resetWithShared(char[] buf, int start, int len)\n{\n// First, let's clear intermediate values, if any:\n_resultString = null;\n_resultArray = null;\n\n// Then let's mark things we need about input buffer\n_inputBuffer = buf;\n_inputStart = start;\n_inputLen = len;\n\n// And then reset internal input buffers, if necessary:\nif (_hasSegments) {\nclearSegments();\n}\n}",
            "method_id": 168
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:setCurrentName(Ljava/lang/String;)V",
            "method_body": "public void setCurrentName(String name) throws JsonProcessingException {\n_currentName = name;\nif (_dups != null) { _checkDup(_dups, name); }\n}",
            "method_id": 169
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.InternCache:<init>()V",
            "method_body": "private InternCache() { super(MAX_ENTRIES, 0.8f, 4); }\nprivate InternCache() { super(MAX_ENTRIES, 0.8f, 4); }",
            "method_id": 170
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.InternCache:<clinit>()V",
            "method_body": "private final static int MAX_ENTRIES = 180;\n\npublic final static InternCache instance = new InternCache();\n\n/**\n* As minor optimization let's try to avoid \"flush storms\",\n* cases where multiple threads might try to concurrently\n* flush the map.\n*/\nprivate final Object lock = new Object();\n\nprivate InternCache() { super(MAX_ENTRIES, 0.8f, 4); }",
            "method_id": 171
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.InternCache:intern(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "public String intern(String input) {\nString result = get(input);\nif (result != null) { return result; }\n\n/* 18-Sep-2013, tatu: We used to use LinkedHashMap, which has simple LRU\n*   method. No such functionality exists with CHM; and let's use simplest\n*   possible limitation: just clear all contents. This because otherwise\n*   we are simply likely to keep on clearing same, commonly used entries.\n*/\nif (size() >= MAX_ENTRIES) {\n/* Not incorrect wrt well-known double-locking anti-pattern because underlying\n* storage gives close enough answer to real one here; and we are\n* more concerned with flooding than starvation.\n*/\nsynchronized (lock) {\nif (size() >= MAX_ENTRIES) {\nclear();\n}\n}\n}\nresult = input.intern();\nput(result, result);\nreturn result;\n}",
            "method_id": 172
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:createChildObjectContext(II)Lcom/fasterxml/jackson/core/json/JsonReadContext;",
            "method_body": "public JsonReadContext createChildObjectContext(int lineNr, int colNr) {\nJsonReadContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new JsonReadContext(this,\n(_dups == null) ? null : _dups.child(), TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}\nctxt.reset(TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}",
            "method_id": 173
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:resetInt(ZI)Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "protected final JsonToken resetInt(boolean negative, int intLen)\n{\n_numberNegative = negative;\n_intLength = intLen;\n_fractLength = 0;\n_expLength = 0;\n_numTypesValid = NR_UNKNOWN; // to force parsing\nreturn JsonToken.VALUE_NUMBER_INT;\n}",
            "method_id": 174
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ReaderBasedJsonParser:loadMore()Z",
            "method_body": "protected boolean loadMore() throws IOException\n{\nfinal int bufSize = _inputEnd;\n\n_currInputProcessed += bufSize;\n_currInputRowStart -= bufSize;\n\n// 26-Nov-2015, tatu: Since name-offset requires it too, must offset\n//   this increase to avoid \"moving\" name-offset, resulting most likely\n//   in negative value, which is fine as combine value remains unchanged.\n_nameStartOffset -= bufSize;\n\nif (_reader != null) {\nint count = _reader.read(_inputBuffer, 0, _inputBuffer.length);\nif (count > 0) {\n_inputPtr = 0;\n_inputEnd = count;\nreturn true;\n}\n// End of input\n_closeInput();\n// Should never return 0, so let's fail\nif (count == 0) {\nthrow new IOException(\"Reader returned 0 characters when trying to read \"+_inputEnd);\n}\n}\nreturn false;\n}",
            "method_id": 175
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonStreamContext:inRoot()Z",
            "method_body": "public final boolean inRoot() { return _type == TYPE_ROOT; }\npublic final boolean inRoot() { return _type == TYPE_ROOT; }",
            "method_id": 176
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:<init>(Lcom/fasterxml/jackson/core/JsonFactory;Lcom/fasterxml/jackson/core/ObjectCodec;)V",
            "method_body": "final protected static ThreadLocal<SoftReference<BufferRecycler>> _recyclerRef\nprotected final transient CharsToNameCanonicalizer _rootCharSymbols = CharsToNameCanonicalizer.createRoot();\nprotected final transient ByteQuadsCanonicalizer _byteSymbolCanonicalizer = ByteQuadsCanonicalizer.createRoot();\nprotected int _factoryFeatures = DEFAULT_FACTORY_FEATURE_FLAGS;\nprotected int _parserFeatures = DEFAULT_PARSER_FEATURE_FLAGS;\nprotected int _generatorFeatures = DEFAULT_GENERATOR_FEATURE_FLAGS;\nprotected SerializableString _rootValueSeparator = DEFAULT_ROOT_VALUE_SEPARATOR;\npublic JsonFactory() { this(null); }",
            "method_id": 177
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.GeneratorBase:<init>(ILcom/fasterxml/jackson/core/ObjectCodec;Lcom/fasterxml/jackson/core/json/JsonWriteContext;)V",
            "method_body": "public final static int SURR1_FIRST = 0xD800;\nprotected final static int DERIVED_FEATURES_MASK =\nprotected final String WRITE_BINARY = \"write a binary value\";\nprotected final String WRITE_BOOLEAN = \"write a boolean value\";\nprotected final String WRITE_NULL = \"write a null\";\nprotected final String WRITE_NUMBER = \"write a number\";\nprotected final String WRITE_RAW = \"write a raw (unencoded) value\";\nprotected final String WRITE_STRING = \"write a string\";\n* {@link com.fasterxml.jackson.core.JsonGenerator.Feature}s",
            "method_id": 178
        }
    ]
}