{
    "bug_id": 5,
    "test_id": 0,
    "test_name": "com.fasterxml.jackson.core.TestJsonPointer.testWonkyNumber173",
    "test_body": "public void testWonkyNumber173() throws Exception\n{\nJsonPointer ptr = JsonPointer.compile(\"/1e0\");\nassertFalse(ptr.matches());\n}\n",
    "stack_trace": "java.lang.NumberFormatException: For input string: \"1e0\"\nat java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\nat java.lang.Integer.parseInt(Integer.java:580)\nat java.lang.Integer.parseInt(Integer.java:615)\nat com.fasterxml.jackson.core.io.NumberInput.parseInt(NumberInput.java:91)\nat com.fasterxml.jackson.core.JsonPointer._parseIndex(JsonPointer.java:204)\nat com.fasterxml.jackson.core.JsonPointer.<init>(JsonPointer.java:70)\nat com.fasterxml.jackson.core.JsonPointer._parseTail(JsonPointer.java:225)\nat com.fasterxml.jackson.core.JsonPointer.compile(JsonPointer.java:98)\nat com.fasterxml.jackson.core.TestJsonPointer.testWonkyNumber173(TestJsonPointer.java:41)",
    "covered_methods": [
        {
            "method_signature": "com.fasterxml.jackson.core.JsonPointer:<clinit>()V",
            "method_body": "protected final static JsonPointer EMPTY = new JsonPointer();\n\n/**\n* Reference to rest of the pointer beyond currently matching\n* segment (if any); null if this pointer refers to a matching\n* segment.\n*/\nprotected final JsonPointer _nextSegment;\n\n/**\n* We will retain representation of the pointer, as a String,\n* so that {@link #toString} should be as efficient as possible.",
            "method_id": 0
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonPointer:<init>(Ljava/lang/String;Ljava/lang/String;Lcom/fasterxml/jackson/core/JsonPointer;)V",
            "method_body": "protected JsonPointer(String fullString, String segment, JsonPointer next) {\n_asString = fullString;\n_nextSegment = next;\n// Ok; may always be a property\n_matchingPropertyName = segment;\n_matchingElementIndex = _parseIndex(segment);\n}",
            "method_id": 1
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonPointer:<init>()V",
            "method_body": "protected JsonPointer() {\n_nextSegment = null;\n_matchingPropertyName = \"\";\n_matchingElementIndex = -1;\n_asString = \"\";\n}",
            "method_id": 2
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.NumberInput:<clinit>()V",
            "method_body": "public final static String NASTY_SMALL_DOUBLE = \"2.2250738585072012e-308\";\n\n/**\n* Constants needed for parsing longs from basic int parsing methods\n*/\nfinal static long L_BILLION = 1000000000;\n\nfinal static String MIN_LONG_STR_NO_SIGN = String.valueOf(Long.MIN_VALUE).substring(1);\nfinal static String MAX_LONG_STR = String.valueOf(Long.MAX_VALUE);\n\n/**\n* Fast method for parsing integers that are known to fit into\n* regular 32-bit signed int type. This means that length is\n* between 1 and 9 digits (inclusive)\n*<p>\n* Note: public to let unit tests call it\n*/\npublic static int parseInt(char[] ch, int off, int len)\n{\nint num = ch[off] - '0';\n\nif (len > 4) {\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nlen -= 4;\nif (len > 4) {\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nnum = (num * 10) + (ch[++off] - '0');\nreturn num;\n}\n}\nif (len > 1) {\nnum = (num * 10) + (ch[++off] - '0');\nif (len > 2) {\nnum = (num * 10) + (ch[++off] - '0');\nif (len > 3) {\nnum = (num * 10) + (ch[++off] - '0');\n}\n}\n}\nreturn num;\n}",
            "method_id": 3
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.NumberInput:parseInt(Ljava/lang/String;)I",
            "method_body": "public static int parseInt(String s)\n{\n/* Ok: let's keep strategy simple: ignoring optional minus sign,\n* we'll accept 1 - 9 digits and parse things efficiently;\n* otherwise just defer to JDK parse functionality.\n*/\nchar c = s.charAt(0);\nint len = s.length();\nboolean neg = (c == '-');\nint offset = 1;\n// must have 1 - 9 digits after optional sign:\n// negative?\nif (neg) {\nif (len == 1 || len > 10) {\nreturn Integer.parseInt(s);\n}\nc = s.charAt(offset++);\n} else {\nif (len > 9) {\nreturn Integer.parseInt(s);\n}\n}\nif (c > '9' || c < '0') {\nreturn Integer.parseInt(s);\n}\nint num = c - '0';\nif (offset < len) {\nc = s.charAt(offset++);\nif (c > '9' || c < '0') {\nreturn Integer.parseInt(s);\n}\nnum = (num * 10) + (c - '0');\nif (offset < len) {\nc = s.charAt(offset++);\nif (c > '9' || c < '0') {\nreturn Integer.parseInt(s);\n}\nnum = (num * 10) + (c - '0');\n// Let's just loop if we have more than 3 digits:\nif (offset < len) {\ndo {\nc = s.charAt(offset++);\nif (c > '9' || c < '0') {\nreturn Integer.parseInt(s);\n}\nnum = (num * 10) + (c - '0');\n} while (offset < len);\n}\n}\n}\nreturn neg ? -num : num;\n}",
            "method_id": 4
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonPointer:_parseTail(Ljava/lang/String;)Lcom/fasterxml/jackson/core/JsonPointer;",
            "method_body": "protected static JsonPointer _parseTail(String input) {\nfinal int end = input.length();\n\n// first char is the contextual slash, skip\nfor (int i = 1; i < end; ) {\nchar c = input.charAt(i);\nif (c == '/') { // common case, got a segment\nreturn new JsonPointer(input, input.substring(1, i),\n_parseTail(input.substring(i)));\n}\n++i;\n// quoting is different; offline this case\nif (c == '~' && i < end) { // possibly, quote\nreturn _parseQuotedTail(input, i);\n}\n// otherwise, loop on\n}\n// end of the road, no escapes\nreturn new JsonPointer(input, input.substring(1), EMPTY);\n}",
            "method_id": 5
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonPointer:compile(Ljava/lang/String;)Lcom/fasterxml/jackson/core/JsonPointer;",
            "method_body": "public static JsonPointer compile(String input) throws IllegalArgumentException\n{\n// First quick checks for well-known 'empty' pointer\nif ((input == null) || input.length() == 0) {\nreturn EMPTY;\n}\n// And then quick validity check:\nif (input.charAt(0) != '/') {\nthrow new IllegalArgumentException(\"Invalid input: JSON Pointer expression must start with '/': \"+\"\\\"\"+input+\"\\\"\");\n}\nreturn _parseTail(input);\n}",
            "method_id": 6
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonPointer:_parseIndex(Ljava/lang/String;)I",
            "method_body": "private final static int _parseIndex(String str) {\nfinal int len = str.length();\n// [Issue#133]: beware of super long indexes; assume we never\n// have arrays over 2 billion entries so ints are fine.\nif (len == 0 || len > 10) {\nreturn -1;\n}\nfor (int i = 0; i < len; ++i) {\nchar c = str.charAt(i++);\nif (c > '9' || c < '0') {\nreturn -1;\n}\n}\nif (len == 10) {\nlong l = NumberInput.parseLong(str);\nif (l > Integer.MAX_VALUE) {\nreturn -1;\n}\n}\nreturn NumberInput.parseInt(str);\n}",
            "method_id": 7
        }
    ]
}