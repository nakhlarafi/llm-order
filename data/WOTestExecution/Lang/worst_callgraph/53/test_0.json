{
    "bug_id": 53,
    "test_id": 0,
    "test_name": "org.apache.commons.lang.time.DateUtilsTest.testRoundLang346",
    "test_body": "public void testRoundLang346() throws Exception\n{\nTimeZone.setDefault(defaultZone);\ndateTimeParser.setTimeZone(defaultZone);\nCalendar testCalendar = Calendar.getInstance();\ntestCalendar.set(2007, 6, 2, 8, 8, 50);\nDate date = testCalendar.getTime();\nassertEquals(\"Minute Round Up Failed\",\ndateTimeParser.parse(\"July 2, 2007 08:09:00.000\"),\nDateUtils.round(date, Calendar.MINUTE));\ntestCalendar.set(2007, 6, 2, 8, 8, 20);\ndate = testCalendar.getTime();\nassertEquals(\"Minute No Round Failed\",\ndateTimeParser.parse(\"July 2, 2007 08:08:00.000\"),\nDateUtils.round(date, Calendar.MINUTE));\ntestCalendar.set(2007, 6, 2, 8, 8, 50);\ntestCalendar.set(Calendar.MILLISECOND, 600);\ndate = testCalendar.getTime();\nassertEquals(\"Second Round Up with 600 Milli Seconds Failed\",\ndateTimeParser.parse(\"July 2, 2007 08:08:51.000\"),\nDateUtils.round(date, Calendar.SECOND));\ntestCalendar.set(2007, 6, 2, 8, 8, 50);\ntestCalendar.set(Calendar.MILLISECOND, 200);\ndate = testCalendar.getTime();\nassertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\ndateTimeParser.parse(\"July 2, 2007 08:08:50.000\"),\nDateUtils.round(date, Calendar.SECOND));\ntestCalendar.set(2007, 6, 2, 8, 8, 20);\ntestCalendar.set(Calendar.MILLISECOND, 600);\ndate = testCalendar.getTime();\nassertEquals(\"Second Round Up with 200 Milli Seconds Failed\",\ndateTimeParser.parse(\"July 2, 2007 08:08:21.000\"),\nDateUtils.round(date, Calendar.SECOND));\ntestCalendar.set(2007, 6, 2, 8, 8, 20);\ntestCalendar.set(Calendar.MILLISECOND, 200);\ndate = testCalendar.getTime();\nassertEquals(\"Second Round Down with 200 Milli Seconds Failed\",\ndateTimeParser.parse(\"July 2, 2007 08:08:20.000\"),\nDateUtils.round(date, Calendar.SECOND));\ntestCalendar.set(2007, 6, 2, 8, 8, 50);\ndate = testCalendar.getTime();\nassertEquals(\"Hour Round Down Failed\",\ndateTimeParser.parse(\"July 2, 2007 08:00:00.000\"),\nDateUtils.round(date, Calendar.HOUR));\ntestCalendar.set(2007, 6, 2, 8, 31, 50);\ndate = testCalendar.getTime();\nassertEquals(\"Hour Round Up Failed\",\ndateTimeParser.parse(\"July 2, 2007 09:00:00.000\"),\nDateUtils.round(date, Calendar.HOUR));\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: Minute Round Up Failed expected:<Mon Jul 02 08:09:00 PDT 2007> but was:<Mon Jul 02 08:01:00 PDT 2007>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:78)\nat junit.framework.TestCase.assertEquals(TestCase.java:244)\nat org.apache.commons.lang.time.DateUtilsTest.testRoundLang346(DateUtilsTest.java:712)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.lang.time.DateUtils:round(Ljava/util/Date;I)Ljava/util/Date;",
            "method_body": "public static Date round(Date date, int field) {\nif (date == null) {\nthrow new IllegalArgumentException(\"The date must not be null\");\n}\nCalendar gval = Calendar.getInstance();\ngval.setTime(date);\nmodify(gval, field, true);\nreturn gval.getTime();\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.lang.time.DateUtils:modify(Ljava/util/Calendar;IZ)V",
            "method_body": "private static void modify(Calendar val, int field, boolean round) {\nif (val.get(Calendar.YEAR) > 280000000) {\nthrow new ArithmeticException(\"Calendar value too large for accurate calculations\");\n}\n\nif (field == Calendar.MILLISECOND) {\nreturn;\n}\n\n// ----------------- Fix for LANG-59 ---------------------- START ---------------\n// see http://issues.apache.org/jira/browse/LANG-59\n//\n// Manually truncate milliseconds, seconds and minutes, rather than using\n// Calendar methods.\n\nDate date = val.getTime();\nlong time = date.getTime();\nboolean done = false;\n\n// truncate milliseconds\nint millisecs = val.get(Calendar.MILLISECOND);\nif (!round || millisecs < 500) {\ntime = time - millisecs;\nif (field == Calendar.SECOND) {\ndone = true;\n}\n}\n\n// truncate seconds\nint seconds = val.get(Calendar.SECOND);\nif (!done && (!round || seconds < 30)) {\ntime = time - (seconds * 1000L);\nif (field == Calendar.MINUTE) {\ndone = true;\n}\n}\n\n// truncate minutes\nint minutes = val.get(Calendar.MINUTE);\nif (!done && (!round || minutes < 30)) {\ntime = time - (minutes * 60000L);\n}\n\n// reset time\nif (date.getTime() != time) {\ndate.setTime(time);\nval.setTime(date);\n}\n// ----------------- Fix for LANG-59 ----------------------- END ----------------\n\nboolean roundUp = false;\nfor (int i = 0; i < fields.length; i++) {\nfor (int j = 0; j < fields[i].length; j++) {\nif (fields[i][j] == field) {\n//This is our field... we stop looping\nif (round && roundUp) {\nif (field == DateUtils.SEMI_MONTH) {\n//This is a special case that's hard to generalize\n//If the date is 1, we round up to 16, otherwise\n//  we subtract 15 days and add 1 month\nif (val.get(Calendar.DATE) == 1) {\nval.add(Calendar.DATE, 15);\n} else {\nval.add(Calendar.DATE, -15);\nval.add(Calendar.MONTH, 1);\n}\n} else {\n//We need at add one to this field since the\n//  last number causes us to round up\nval.add(fields[i][0], 1);\n}\n}\nreturn;\n}\n}\n//We have various fields that are not easy roundings\nint offset = 0;\nboolean offsetSet = false;\n//These are special types of fields that require different rounding rules\nswitch (field) {\ncase DateUtils.SEMI_MONTH:\nif (fields[i][0] == Calendar.DATE) {\n//If we're going to drop the DATE field's value,\n//  we want to do this our own way.\n//We need to subtrace 1 since the date has a minimum of 1\noffset = val.get(Calendar.DATE) - 1;\n//If we're above 15 days adjustment, that means we're in the\n//  bottom half of the month and should stay accordingly.\nif (offset >= 15) {\noffset -= 15;\n}\n//Record whether we're in the top or bottom half of that range\nroundUp = offset > 7;\noffsetSet = true;\n}\nbreak;\ncase Calendar.AM_PM:\nif (fields[i][0] == Calendar.HOUR_OF_DAY) {\n//If we're going to drop the HOUR field's value,\n//  we want to do this our own way.\noffset = val.get(Calendar.HOUR_OF_DAY);\nif (offset >= 12) {\noffset -= 12;\n}\nroundUp = offset > 6;\noffsetSet = true;\n}\nbreak;\n}\nif (!offsetSet) {\nint min = val.getActualMinimum(fields[i][0]);\nint max = val.getActualMaximum(fields[i][0]);\n//Calculate the offset from the minimum allowed value\noffset = val.get(fields[i][0]) - min;\n//Set roundUp if this is more than half way between the minimum and maximum\nroundUp = offset > ((max - min) / 2);\n}\n//We need to remove this field\nif (offset != 0) {\nval.set(fields[i][0], val.get(fields[i][0]) - offset);\n}\n}\nthrow new IllegalArgumentException(\"The field \" + field + \" is not supported\");\n\n}",
            "method_id": 1
        }
    ]
}