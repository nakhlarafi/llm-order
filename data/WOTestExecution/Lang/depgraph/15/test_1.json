{
    "bug_id": 15,
    "test_id": 1,
    "test_name": "org.apache.commons.lang3.reflect.TypeUtilsTest.testGetTypeArguments",
    "test_body": "public void testGetTypeArguments() {\nMap<TypeVariable<?>, Type> typeVarAssigns;\nTypeVariable<?> treeSetTypeVar;\nType typeArg;\ntypeVarAssigns = TypeUtils.getTypeArguments(Integer.class, Comparable.class);\ntreeSetTypeVar = Comparable.class.getTypeParameters()[0];\nAssert.assertTrue(\"Type var assigns for Comparable from Integer: \" + typeVarAssigns,\ntypeVarAssigns.containsKey(treeSetTypeVar));\ntypeArg = typeVarAssigns.get(treeSetTypeVar);\nAssert.assertEquals(\"Type argument of Comparable from Integer: \" + typeArg, Integer.class,\ntypeVarAssigns.get(treeSetTypeVar));\ntypeVarAssigns = TypeUtils.getTypeArguments(int.class, Comparable.class);\ntreeSetTypeVar = Comparable.class.getTypeParameters()[0];\nAssert.assertTrue(\"Type var assigns for Comparable from int: \" + typeVarAssigns,\ntypeVarAssigns.containsKey(treeSetTypeVar));\ntypeArg = typeVarAssigns.get(treeSetTypeVar);\nAssert.assertEquals(\"Type argument of Comparable from int: \" + typeArg, Integer.class,\ntypeVarAssigns.get(treeSetTypeVar));\nCollection<Integer> col = Arrays.asList(new Integer[0]);\ntypeVarAssigns = TypeUtils.getTypeArguments(List.class, Collection.class);\ntreeSetTypeVar = Comparable.class.getTypeParameters()[0];\nAssert.assertFalse(\"Type var assigns for Collection from List: \" + typeVarAssigns,\ntypeVarAssigns.containsKey(treeSetTypeVar));\ntypeVarAssigns = TypeUtils.getTypeArguments(AAAClass.BBBClass.class, AAClass.BBClass.class);\nAssert.assertTrue(typeVarAssigns.size() == 2);\nAssert.assertEquals(String.class, typeVarAssigns.get(AAClass.class.getTypeParameters()[0]));\nAssert.assertEquals(String.class, typeVarAssigns.get(AAClass.BBClass.class.getTypeParameters()[0]));\ntypeVarAssigns = TypeUtils.getTypeArguments(Other.class, This.class);\nAssert.assertEquals(2, typeVarAssigns.size());\nAssert.assertEquals(String.class, typeVarAssigns.get(This.class.getTypeParameters()[0]));\nAssert.assertEquals(Other.class.getTypeParameters()[0], typeVarAssigns.get(This.class.getTypeParameters()[1]));\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<2> but was:<0>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:118)\nat org.junit.Assert.assertEquals(Assert.java:555)\nat org.junit.Assert.assertEquals(Assert.java:542)\nat org.apache.commons.lang3.reflect.TypeUtilsTest.testGetTypeArguments(TypeUtilsTest.java:505)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/reflect/ParameterizedType;Ljava/lang/Class;Ljava/util/Map;)Ljava/util/Map;",
            "method_body": "private static Map<TypeVariable<?>, Type> getTypeArguments(\nParameterizedType parameterizedType, Class<?> toClass,\nMap<TypeVariable<?>, Type> subtypeVarAssigns) {\nClass<?> cls = getRawType(parameterizedType);\n\n// make sure they're assignable\nif (!isAssignable(cls, toClass)) {\nreturn null;\n}\n\nType ownerType = parameterizedType.getOwnerType();\nMap<TypeVariable<?>, Type> typeVarAssigns;\n\nif (ownerType instanceof ParameterizedType) {\n// get the owner type arguments first\nParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType;\ntypeVarAssigns = getTypeArguments(parameterizedOwnerType,\ngetRawType(parameterizedOwnerType), subtypeVarAssigns);\n} else {\n// no owner, prep the type variable assignments map\ntypeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n: new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n}\n\n// get the subject parameterized type's arguments\nType[] typeArgs = parameterizedType.getActualTypeArguments();\n// and get the corresponding type variables from the raw class\nTypeVariable<?>[] typeParams = cls.getTypeParameters();\n\n// map the arguments to their respective type variables\nfor (int i = 0; i < typeParams.length; i++) {\nType typeArg = typeArgs[i];\ntypeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns\n.get(typeArg) : typeArg);\n}\n\nif (toClass.equals(cls)) {\n// target class has been reached. Done.\nreturn typeVarAssigns;\n}\n\n// walk the inheritance hierarchy until the target class is reached\nreturn getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/Class;Ljava/lang/Class;Ljava/util/Map;)Ljava/util/Map;",
            "method_body": "private static Map<TypeVariable<?>, Type> getTypeArguments(Class<?> cls, Class<?> toClass,\nMap<TypeVariable<?>, Type> subtypeVarAssigns) {\n// make sure they're assignable\nif (!isAssignable(cls, toClass)) {\nreturn null;\n}\n\n// can't work with primitives\nif (cls.isPrimitive()) {\n// both classes are primitives?\nif (toClass.isPrimitive()) {\n// dealing with widening here. No type arguments to be\n// harvested with these two types.\nreturn new HashMap<TypeVariable<?>, Type>();\n}\n\n// work with wrapper the wrapper class instead of the primitive\ncls = ClassUtils.primitiveToWrapper(cls);\n}\n\n// create a copy of the incoming map, or an empty one if it's null\nHashMap<TypeVariable<?>, Type> typeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n: new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n\n// has target class been reached?\nif (cls.getTypeParameters().length > 0 || toClass.equals(cls)) {\nreturn typeVarAssigns;\n}\n\n// walk the inheritance hierarchy until the target class is reached\nreturn getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getClosestParentType(Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
            "method_body": "private static Type getClosestParentType(Class<?> cls, Class<?> superClass) {\n// only look at the interfaces if the super class is also an interface\nif (superClass.isInterface()) {\n// get the generic interfaces of the subject class\nType[] interfaceTypes = cls.getGenericInterfaces();\n// will hold the best generic interface match found\nType genericInterface = null;\n\n// find the interface closest to the super class\nfor (Type midType : interfaceTypes) {\nClass<?> midClass = null;\n\nif (midType instanceof ParameterizedType) {\nmidClass = getRawType((ParameterizedType) midType);\n} else if (midType instanceof Class<?>) {\nmidClass = (Class<?>) midType;\n} else {\nthrow new IllegalStateException(\"Unexpected generic\"\n+ \" interface type found: \" + midType);\n}\n\n// check if this interface is further up the inheritance chain\n// than the previously found match\nif (isAssignable(midClass, superClass)\n&& isAssignable(genericInterface, (Type) midClass)) {\ngenericInterface = midType;\n}\n}\n\n// found a match?\nif (genericInterface != null) {\nreturn genericInterface;\n}\n}\n\n// none of the interfaces were descendants of the target class, so the\n// super class has to be one, instead\nreturn cls.getGenericSuperclass();\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/Class;)Z",
            "method_body": "private static boolean isAssignable(Type type, Class<?> toClass) {\nif (type == null) {\n// consistency with ClassUtils.isAssignable() behavior\nreturn toClass == null || !toClass.isPrimitive();\n}\n\n// only a null type can be assigned to null type which\n// would have cause the previous to return true\nif (toClass == null) {\nreturn false;\n}\n\n// all types are assignable to themselves\nif (toClass.equals(type)) {\nreturn true;\n}\n\nif (type instanceof Class<?>) {\n// just comparing two classes\nreturn ClassUtils.isAssignable((Class<?>) type, toClass);\n}\n\nif (type instanceof ParameterizedType) {\n// only have to compare the raw type to the class\nreturn isAssignable(getRawType((ParameterizedType) type), toClass);\n}\n\n// *\nif (type instanceof TypeVariable<?>) {\n// if any of the bounds are assignable to the class, then the\n// type is assignable to the class.\nfor (Type bound : ((TypeVariable<?>) type).getBounds()) {\nif (isAssignable(bound, toClass)) {\nreturn true;\n}\n}\n\nreturn false;\n}\n\n// the only classes to which a generic array type can be assigned\n// are class Object and array classes\nif (type instanceof GenericArrayType) {\nreturn toClass.equals(Object.class)\n|| toClass.isArray()\n&& isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass\n.getComponentType());\n}\n\n// wildcard types are not assignable to a class (though one would think\n// \"? super Object\" would be assignable to Object)\nif (type instanceof WildcardType) {\nreturn false;\n}\n\nthrow new IllegalStateException(\"found an unhandled type: \" + type);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.lang3.ClassUtils:isAssignable(Ljava/lang/Class;Ljava/lang/Class;Z)Z",
            "method_body": "public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\nif (toClass == null) {\nreturn false;\n}\n// have to check for null, as isAssignableFrom doesn't\nif (cls == null) {\nreturn !toClass.isPrimitive();\n}\n//autoboxing:\nif (autoboxing) {\nif (cls.isPrimitive() && !toClass.isPrimitive()) {\ncls = primitiveToWrapper(cls);\nif (cls == null) {\nreturn false;\n}\n}\nif (toClass.isPrimitive() && !cls.isPrimitive()) {\ncls = wrapperToPrimitive(cls);\nif (cls == null) {\nreturn false;\n}\n}\n}\nif (cls.equals(toClass)) {\nreturn true;\n}\nif (cls.isPrimitive()) {\nif (toClass.isPrimitive() == false) {\nreturn false;\n}\nif (Integer.TYPE.equals(cls)) {\nreturn Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Long.TYPE.equals(cls)) {\nreturn Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Boolean.TYPE.equals(cls)) {\nreturn false;\n}\nif (Double.TYPE.equals(cls)) {\nreturn false;\n}\nif (Float.TYPE.equals(cls)) {\nreturn Double.TYPE.equals(toClass);\n}\nif (Character.TYPE.equals(cls)) {\nreturn Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Short.TYPE.equals(cls)) {\nreturn Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Byte.TYPE.equals(cls)) {\nreturn Short.TYPE.equals(toClass)\n|| Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\n// should never get here\nreturn false;\n}\nreturn toClass.isAssignableFrom(cls);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.lang3.ClassUtils:primitiveToWrapper(Ljava/lang/Class;)Ljava/lang/Class;",
            "method_body": "public static Class<?> primitiveToWrapper(Class<?> cls) {\nClass<?> convertedClass = cls;\nif (cls != null && cls.isPrimitive()) {\nconvertedClass = primitiveWrapperMap.get(cls);\n}\nreturn convertedClass;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getRawType(Ljava/lang/reflect/ParameterizedType;)Ljava/lang/Class;",
            "method_body": "private static Class<?> getRawType(ParameterizedType parameterizedType) {\nType rawType = parameterizedType.getRawType();\n\n// check if raw type is a Class object\n// not currently necessary, but since the return type is Type instead of\n// Class, there's enough reason to believe that future versions of Java\n// may return other Type implementations. And type-safety checking is\n// rarely a bad idea.\nif (!(rawType instanceof Class<?>)) {\nthrow new IllegalStateException(\"Wait... What!? Type of rawType: \" + rawType);\n}\n\nreturn (Class<?>) rawType;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/util/Map;)Ljava/util/Map;",
            "method_body": "private static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass,\nMap<TypeVariable<?>, Type> subtypeVarAssigns) {\nif (type instanceof Class<?>) {\nreturn getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns);\n}\n\nif (type instanceof ParameterizedType) {\nreturn getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns);\n}\n\nif (type instanceof GenericArrayType) {\nreturn getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass\n.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns);\n}\n\n// since wildcard types are not assignable to classes, should this just\n// return null?\nif (type instanceof WildcardType) {\nfor (Type bound : getImplicitUpperBounds((WildcardType) type)) {\n// find the first bound that is assignable to the target class\nif (isAssignable(bound, toClass)) {\nreturn getTypeArguments(bound, toClass, subtypeVarAssigns);\n}\n}\n\nreturn null;\n}\n\n// *\nif (type instanceof TypeVariable<?>) {\nfor (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n// find the first bound that is assignable to the target class\nif (isAssignable(bound, toClass)) {\nreturn getTypeArguments(bound, toClass, subtypeVarAssigns);\n}\n}\n\nreturn null;\n}\n// */\n\nthrow new IllegalStateException(\"found an unhandled type: \" + type);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionAtLeast(Lorg/apache/commons/lang3/JavaVersion;)Z",
            "method_body": "public static boolean isJavaVersionAtLeast(JavaVersion requiredVersion) {\nreturn JAVA_SPECIFICATION_VERSION_AS_ENUM.atLeast(requiredVersion);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.lang3.ClassUtils:isAssignable(Ljava/lang/Class;Ljava/lang/Class;)Z",
            "method_body": "public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\nreturn isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5));\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
            "method_body": "public static boolean isAssignable(Type type, Type toType) {\nreturn isAssignable(type, toType, null);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/reflect/Type;Ljava/lang/Class;)Ljava/util/Map;",
            "method_body": "public static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass) {\nreturn getTypeArguments(type, toClass, null);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.lang3.JavaVersion:atLeast(Lorg/apache/commons/lang3/JavaVersion;)Z",
            "method_body": "public boolean atLeast(JavaVersion requiredVersion) {\nreturn this.value >= requiredVersion.value;\n}",
            "method_id": 12
        }
    ]
}