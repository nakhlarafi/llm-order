{
    "bug_id": 15,
    "test_id": 0,
    "test_name": "org.apache.commons.lang3.reflect.TypeUtilsTest.testIsAssignable",
    "test_body": "public void testIsAssignable() throws SecurityException, NoSuchMethodException,\nNoSuchFieldException {\nList list0 = null;\nList<Object> list1 = null;\nList<?> list2 = null;\nList<? super Object> list3 = null;\nList<String> list4 = null;\nList<? extends String> list5 = null;\nList<? super String> list6 = null;\nList[] list7 = null;\nList<Object>[] list8 = null;\nList<?>[] list9 = null;\nList<? super Object>[] list10 = null;\nList<String>[] list11 = null;\nList<? extends String>[] list12 = null;\nList<? super String>[] list13;\nClass<?> clazz = getClass();\nMethod method = clazz.getMethod(\"dummyMethod\", List.class, List.class, List.class,\nList.class, List.class, List.class, List.class, List[].class, List[].class,\nList[].class, List[].class, List[].class, List[].class, List[].class);\nType[] types = method.getGenericParameterTypes();\n//        list0 = list0;\ndelegateBooleanAssertion(types, 0, 0, true);\nlist1 = list0;\ndelegateBooleanAssertion(types, 0, 1, true);\nlist0 = list1;\ndelegateBooleanAssertion(types, 1, 0, true);\nlist2 = list0;\ndelegateBooleanAssertion(types, 0, 2, true);\nlist0 = list2;\ndelegateBooleanAssertion(types, 2, 0, true);\nlist3 = list0;\ndelegateBooleanAssertion(types, 0, 3, true);\nlist0 = list3;\ndelegateBooleanAssertion(types, 3, 0, true);\nlist4 = list0;\ndelegateBooleanAssertion(types, 0, 4, true);\nlist0 = list4;\ndelegateBooleanAssertion(types, 4, 0, true);\nlist5 = list0;\ndelegateBooleanAssertion(types, 0, 5, true);\nlist0 = list5;\ndelegateBooleanAssertion(types, 5, 0, true);\nlist6 = list0;\ndelegateBooleanAssertion(types, 0, 6, true);\nlist0 = list6;\ndelegateBooleanAssertion(types, 6, 0, true);\n//        list1 = list1;\ndelegateBooleanAssertion(types, 1, 1, true);\nlist2 = list1;\ndelegateBooleanAssertion(types, 1, 2, true);\nlist1 = (List<Object>) list2;\ndelegateBooleanAssertion(types, 2, 1, false);\nlist3 = list1;\ndelegateBooleanAssertion(types, 1, 3, true);\nlist1 = (List<Object>) list3;\ndelegateBooleanAssertion(types, 3, 1, false);\n// list4 = list1;\ndelegateBooleanAssertion(types, 1, 4, false);\n// list1 = list4;\ndelegateBooleanAssertion(types, 4, 1, false);\n// list5 = list1;\ndelegateBooleanAssertion(types, 1, 5, false);\n// list1 = list5;\ndelegateBooleanAssertion(types, 5, 1, false);\nlist6 = list1;\ndelegateBooleanAssertion(types, 1, 6, true);\nlist1 = (List<Object>) list6;\ndelegateBooleanAssertion(types, 6, 1, false);\n//        list2 = list2;\ndelegateBooleanAssertion(types, 2, 2, true);\nlist2 = list3;\ndelegateBooleanAssertion(types, 2, 3, false);\nlist2 = list4;\ndelegateBooleanAssertion(types, 3, 2, true);\nlist3 = (List<? super Object>) list2;\ndelegateBooleanAssertion(types, 2, 4, false);\nlist2 = list5;\ndelegateBooleanAssertion(types, 4, 2, true);\nlist4 = (List<String>) list2;\ndelegateBooleanAssertion(types, 2, 5, false);\nlist2 = list6;\ndelegateBooleanAssertion(types, 5, 2, true);\nlist5 = (List<? extends String>) list2;\ndelegateBooleanAssertion(types, 2, 6, false);\n//        list3 = list3;\ndelegateBooleanAssertion(types, 6, 2, true);\nlist6 = (List<? super String>) list2;\ndelegateBooleanAssertion(types, 3, 3, true);\n// list4 = list3;\ndelegateBooleanAssertion(types, 3, 4, false);\n// list3 = list4;\ndelegateBooleanAssertion(types, 4, 3, false);\n// list5 = list3;\ndelegateBooleanAssertion(types, 3, 5, false);\n// list3 = list5;\ndelegateBooleanAssertion(types, 5, 3, false);\nlist6 = list3;\ndelegateBooleanAssertion(types, 3, 6, true);\nlist3 = (List<? super Object>) list6;\ndelegateBooleanAssertion(types, 6, 3, false);\n//        list4 = list4;\ndelegateBooleanAssertion(types, 4, 4, true);\nlist5 = list4;\ndelegateBooleanAssertion(types, 4, 5, true);\nlist4 = (List<String>) list5;\ndelegateBooleanAssertion(types, 5, 4, false);\nlist6 = list4;\ndelegateBooleanAssertion(types, 4, 6, true);\nlist4 = (List<String>) list6;\ndelegateBooleanAssertion(types, 6, 4, false);\n//        list5 = list5;\ndelegateBooleanAssertion(types, 5, 5, true);\nlist6 = (List<? super String>) list5;\ndelegateBooleanAssertion(types, 5, 6, false);\nlist5 = (List<? extends String>) list6;\ndelegateBooleanAssertion(types, 6, 5, false);\n//        list6 = list6;\ndelegateBooleanAssertion(types, 6, 6, true);\n//        list7 = list7;\ndelegateBooleanAssertion(types, 7, 7, true);\nlist8 = list7;\ndelegateBooleanAssertion(types, 7, 8, true);\nlist7 = list8;\ndelegateBooleanAssertion(types, 8, 7, true);\nlist9 = list7;\ndelegateBooleanAssertion(types, 7, 9, true);\nlist7 = list9;\ndelegateBooleanAssertion(types, 9, 7, true);\nlist10 = list7;\ndelegateBooleanAssertion(types, 7, 10, true);\nlist7 = list10;\ndelegateBooleanAssertion(types, 10, 7, true);\nlist11 = list7;\ndelegateBooleanAssertion(types, 7, 11, true);\nlist7 = list11;\ndelegateBooleanAssertion(types, 11, 7, true);\nlist12 = list7;\ndelegateBooleanAssertion(types, 7, 12, true);\nlist7 = list12;\ndelegateBooleanAssertion(types, 12, 7, true);\nlist13 = list7;\ndelegateBooleanAssertion(types, 7, 13, true);\nlist7 = list13;\ndelegateBooleanAssertion(types, 13, 7, true);\n//        list8 = list8;\ndelegateBooleanAssertion(types, 8, 8, true);\nlist9 = list8;\ndelegateBooleanAssertion(types, 8, 9, true);\nlist8 = (List<Object>[]) list9;\ndelegateBooleanAssertion(types, 9, 8, false);\nlist10 = list8;\ndelegateBooleanAssertion(types, 8, 10, true);\nlist8 = (List<Object>[]) list10; // NOTE cast is required by Sun Java, but not by Eclipse\ndelegateBooleanAssertion(types, 10, 8, false);\n// list11 = list8;\ndelegateBooleanAssertion(types, 8, 11, false);\n// list8 = list11;\ndelegateBooleanAssertion(types, 11, 8, false);\n// list12 = list8;\ndelegateBooleanAssertion(types, 8, 12, false);\n// list8 = list12;\ndelegateBooleanAssertion(types, 12, 8, false);\nlist13 = list8;\ndelegateBooleanAssertion(types, 8, 13, true);\nlist8 = (List<Object>[]) list13;\ndelegateBooleanAssertion(types, 13, 8, false);\n//        list9 = list9;\ndelegateBooleanAssertion(types, 9, 9, true);\nlist10 = (List<? super Object>[]) list9;\ndelegateBooleanAssertion(types, 9, 10, false);\nlist9 = list10;\ndelegateBooleanAssertion(types, 10, 9, true);\nlist11 = (List<String>[]) list9;\ndelegateBooleanAssertion(types, 9, 11, false);\nlist9 = list11;\ndelegateBooleanAssertion(types, 11, 9, true);\nlist12 = (List<? extends String>[]) list9;\ndelegateBooleanAssertion(types, 9, 12, false);\nlist9 = list12;\ndelegateBooleanAssertion(types, 12, 9, true);\nlist13 = (List<? super String>[]) list9;\ndelegateBooleanAssertion(types, 9, 13, false);\nlist9 = list13;\ndelegateBooleanAssertion(types, 13, 9, true);\n//        list10 = list10;\ndelegateBooleanAssertion(types, 10, 10, true);\n// list11 = list10;\ndelegateBooleanAssertion(types, 10, 11, false);\n// list10 = list11;\ndelegateBooleanAssertion(types, 11, 10, false);\n// list12 = list10;\ndelegateBooleanAssertion(types, 10, 12, false);\n// list10 = list12;\ndelegateBooleanAssertion(types, 12, 10, false);\nlist13 = list10;\ndelegateBooleanAssertion(types, 10, 13, true);\nlist10 = (List<? super Object>[]) list13;\ndelegateBooleanAssertion(types, 13, 10, false);\n//        list11 = list11;\ndelegateBooleanAssertion(types, 11, 11, true);\nlist12 = list11;\ndelegateBooleanAssertion(types, 11, 12, true);\nlist11 = (List<String>[]) list12;\ndelegateBooleanAssertion(types, 12, 11, false);\nlist13 = list11;\ndelegateBooleanAssertion(types, 11, 13, true);\nlist11 = (List<String>[]) list13;\ndelegateBooleanAssertion(types, 13, 11, false);\n//        list12 = list12;\ndelegateBooleanAssertion(types, 12, 12, true);\nlist13 = (List<? super String>[]) list12;\ndelegateBooleanAssertion(types, 12, 13, false);\nlist12 = (List<? extends String>[]) list13;\ndelegateBooleanAssertion(types, 13, 12, false);\n//        list13 = list13;\ndelegateBooleanAssertion(types, 13, 13, true);\nType disType = getClass().getField(\"dis\").getGenericType();\n// Reporter.log( ( ( ParameterizedType ) disType\n// ).getOwnerType().getClass().toString() );\nType datType = getClass().getField(\"dat\").getGenericType();\nType daType = getClass().getField(\"da\").getGenericType();\nType uhderType = getClass().getField(\"uhder\").getGenericType();\nType dingType = getClass().getField(\"ding\").getGenericType();\nType testerType = getClass().getField(\"tester\").getGenericType();\nType tester2Type = getClass().getField(\"tester2\").getGenericType();\nType dat2Type = getClass().getField(\"dat2\").getGenericType();\nType dat3Type = getClass().getField(\"dat3\").getGenericType();\ndis = dat;\nAssert.assertTrue(TypeUtils.isAssignable(datType, disType));\n// dis = da;\nAssert.assertFalse(TypeUtils.isAssignable(daType, disType));\ndis = uhder;\nAssert.assertTrue(TypeUtils.isAssignable(uhderType, disType));\ndis = ding;\nAssert.assertFalse(String.format(\"type %s not assignable to %s!\", dingType, disType),\nTypeUtils.isAssignable(dingType, disType));\ndis = tester;\nAssert.assertTrue(TypeUtils.isAssignable(testerType, disType));\n// dis = tester2;\nAssert.assertFalse(TypeUtils.isAssignable(tester2Type, disType));\n// dat = dat2;\nAssert.assertFalse(TypeUtils.isAssignable(dat2Type, datType));\n// dat2 = dat;\nAssert.assertFalse(TypeUtils.isAssignable(datType, dat2Type));\n// dat = dat3;\nAssert.assertFalse(TypeUtils.isAssignable(dat3Type, datType));\nchar ch = 0;\nboolean bo = false;\nbyte by = 0;\nshort sh = 0;\nint in = 0;\nlong lo = 0;\nfloat fl = 0;\ndouble du = 0;\ndu = ch;\nAssert.assertTrue(TypeUtils.isAssignable(char.class, double.class));\ndu = by;\nAssert.assertTrue(TypeUtils.isAssignable(byte.class, double.class));\ndu = sh;\nAssert.assertTrue(TypeUtils.isAssignable(short.class, double.class));\ndu = in;\nAssert.assertTrue(TypeUtils.isAssignable(int.class, double.class));\ndu = lo;\nAssert.assertTrue(TypeUtils.isAssignable(long.class, double.class));\ndu = fl;\nAssert.assertTrue(TypeUtils.isAssignable(float.class, double.class));\nlo = in;\nAssert.assertTrue(TypeUtils.isAssignable(int.class, long.class));\nlo = Integer.valueOf(0);\nAssert.assertTrue(TypeUtils.isAssignable(Integer.class, long.class));\n// Long lngW = 1;\nAssert.assertFalse(TypeUtils.isAssignable(int.class, Long.class));\n// lngW = Integer.valueOf( 0 );\nAssert.assertFalse(TypeUtils.isAssignable(Integer.class, Long.class));\nin = Integer.valueOf(0);\nAssert.assertTrue(TypeUtils.isAssignable(Integer.class, int.class));\nInteger inte = in;\nAssert.assertTrue(TypeUtils.isAssignable(int.class, Integer.class));\nAssert.assertTrue(TypeUtils.isAssignable(int.class, Number.class));\nAssert.assertTrue(TypeUtils.isAssignable(int.class, Object.class));\nType intComparableType = getClass().getField(\"intComparable\").getGenericType();\nintComparable = 1;\nAssert.assertTrue(TypeUtils.isAssignable(int.class, intComparableType));\nAssert.assertTrue(TypeUtils.isAssignable(int.class, Comparable.class));\nSerializable ser = 1;\nAssert.assertTrue(TypeUtils.isAssignable(int.class, Serializable.class));\nType longComparableType = getClass().getField(\"longComparable\").getGenericType();\n// longComparable = 1;\nAssert.assertFalse(TypeUtils.isAssignable(int.class, longComparableType));\n// longComparable = Integer.valueOf( 0 );\nAssert.assertFalse(TypeUtils.isAssignable(Integer.class, longComparableType));\n// int[] ia;\n// long[] la = ia;\nAssert.assertFalse(TypeUtils.isAssignable(int[].class, long[].class));\nInteger[] ia = null;\nType caType = getClass().getField(\"intWildcardComparable\").getGenericType();\nintWildcardComparable = ia;\nAssert.assertTrue(TypeUtils.isAssignable(Integer[].class, caType));\n// int[] ina = ia;\nAssert.assertFalse(TypeUtils.isAssignable(Integer[].class, int[].class));\nint[] ina = null;\nObject[] oa;\n// oa = ina;\nAssert.assertFalse(TypeUtils.isAssignable(int[].class, Object[].class));\noa = new Integer[0];\nAssert.assertTrue(TypeUtils.isAssignable(Integer[].class, Object[].class));\nType bClassType = AClass.class.getField(\"bClass\").getGenericType();\nType cClassType = AClass.class.getField(\"cClass\").getGenericType();\nType dClassType = AClass.class.getField(\"dClass\").getGenericType();\nType eClassType = AClass.class.getField(\"eClass\").getGenericType();\nType fClassType = AClass.class.getField(\"fClass\").getGenericType();\nAClass aClass = new AClass(new AAClass<String>());\naClass.bClass = aClass.cClass;\nAssert.assertTrue(TypeUtils.isAssignable(cClassType, bClassType));\naClass.bClass = aClass.dClass;\nAssert.assertTrue(TypeUtils.isAssignable(dClassType, bClassType));\naClass.bClass = aClass.eClass;\nAssert.assertTrue(TypeUtils.isAssignable(eClassType, bClassType));\naClass.bClass = aClass.fClass;\nAssert.assertTrue(TypeUtils.isAssignable(fClassType, bClassType));\naClass.cClass = aClass.dClass;\nAssert.assertTrue(TypeUtils.isAssignable(dClassType, cClassType));\naClass.cClass = aClass.eClass;\nAssert.assertTrue(TypeUtils.isAssignable(eClassType, cClassType));\naClass.cClass = aClass.fClass;\nAssert.assertTrue(TypeUtils.isAssignable(fClassType, cClassType));\naClass.dClass = aClass.eClass;\nAssert.assertTrue(TypeUtils.isAssignable(eClassType, dClassType));\naClass.dClass = aClass.fClass;\nAssert.assertTrue(TypeUtils.isAssignable(fClassType, dClassType));\naClass.eClass = aClass.fClass;\nAssert.assertTrue(TypeUtils.isAssignable(fClassType, eClassType));\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: type class org.apache.commons.lang3.reflect.TypeUtilsTest$Thing not assignable to org.apache.commons.lang3.reflect.TypeUtilsTest$This<java.lang.String, java.lang.String>!\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertFalse(Assert.java:64)\nat org.apache.commons.lang3.reflect.TypeUtilsTest.testIsAssignable(TypeUtilsTest.java:344)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/WildcardType;Ljava/util/Map;)Z",
            "method_body": "private static boolean isAssignable(Type type, WildcardType toWildcardType,\nMap<TypeVariable<?>, Type> typeVarAssigns) {\nif (type == null) {\nreturn true;\n}\n\n// only a null type can be assigned to null type which\n// would have cause the previous to return true\nif (toWildcardType == null) {\nreturn false;\n}\n\n// all types are assignable to themselves\nif (toWildcardType.equals(type)) {\nreturn true;\n}\n\nType[] toUpperBounds = getImplicitUpperBounds(toWildcardType);\nType[] toLowerBounds = getImplicitLowerBounds(toWildcardType);\n\nif (type instanceof WildcardType) {\nWildcardType wildcardType = (WildcardType) type;\nType[] upperBounds = getImplicitUpperBounds(wildcardType);\nType[] lowerBounds = getImplicitLowerBounds(wildcardType);\n\nfor (Type toBound : toUpperBounds) {\n// if there are assignments for unresolved type variables,\n// now's the time to substitute them.\ntoBound = substituteTypeVariables(toBound, typeVarAssigns);\n\n// each upper bound of the subject type has to be assignable to\n// each\n// upper bound of the target type\nfor (Type bound : upperBounds) {\nif (!isAssignable(bound, toBound, typeVarAssigns)) {\nreturn false;\n}\n}\n}\n\nfor (Type toBound : toLowerBounds) {\n// if there are assignments for unresolved type variables,\n// now's the time to substitute them.\ntoBound = substituteTypeVariables(toBound, typeVarAssigns);\n\n// each lower bound of the target type has to be assignable to\n// each\n// lower bound of the subject type\nfor (Type bound : lowerBounds) {\nif (!isAssignable(toBound, bound, typeVarAssigns)) {\nreturn false;\n}\n}\n}\n\nreturn true;\n}\n\nfor (Type toBound : toUpperBounds) {\n// if there are assignments for unresolved type variables,\n// now's the time to substitute them.\nif (!isAssignable(type, substituteTypeVariables(toBound, typeVarAssigns),\ntypeVarAssigns)) {\nreturn false;\n}\n}\n\nfor (Type toBound : toLowerBounds) {\n// if there are assignments for unresolved type variables,\n// now's the time to substitute them.\nif (!isAssignable(substituteTypeVariables(toBound, typeVarAssigns), type,\ntypeVarAssigns)) {\nreturn false;\n}\n}\n\nreturn true;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/GenericArrayType;Ljava/util/Map;)Z",
            "method_body": "private static boolean isAssignable(Type type, GenericArrayType toGenericArrayType,\nMap<TypeVariable<?>, Type> typeVarAssigns) {\nif (type == null) {\nreturn true;\n}\n\n// only a null type can be assigned to null type which\n// would have cause the previous to return true\nif (toGenericArrayType == null) {\nreturn false;\n}\n\n// all types are assignable to themselves\nif (toGenericArrayType.equals(type)) {\nreturn true;\n}\n\nType toComponentType = toGenericArrayType.getGenericComponentType();\n\nif (type instanceof Class<?>) {\nClass<?> cls = (Class<?>) type;\n\n// compare the component types\nreturn cls.isArray()\n&& isAssignable(cls.getComponentType(), toComponentType, typeVarAssigns);\n}\n\nif (type instanceof GenericArrayType) {\n// compare the component types\nreturn isAssignable(((GenericArrayType) type).getGenericComponentType(),\ntoComponentType, typeVarAssigns);\n}\n\nif (type instanceof WildcardType) {\n// so long as one of the upper bounds is assignable, it's good\nfor (Type bound : getImplicitUpperBounds((WildcardType) type)) {\nif (isAssignable(bound, toGenericArrayType)) {\nreturn true;\n}\n}\n\nreturn false;\n}\n\nif (type instanceof TypeVariable<?>) {\n// probably should remove the following logic and just return false.\n// type variables cannot specify arrays as bounds.\nfor (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\nif (isAssignable(bound, toGenericArrayType)) {\nreturn true;\n}\n}\n\nreturn false;\n}\n\nif (type instanceof ParameterizedType) {\n// the raw type of a parameterized type is never an array or\n// generic array, otherwise the declaration would look like this:\n// Collection[]< ? extends String > collection;\nreturn false;\n}\n\nthrow new IllegalStateException(\"found an unhandled type: \" + type);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/reflect/ParameterizedType;Ljava/lang/Class;Ljava/util/Map;)Ljava/util/Map;",
            "method_body": "private static Map<TypeVariable<?>, Type> getTypeArguments(\nParameterizedType parameterizedType, Class<?> toClass,\nMap<TypeVariable<?>, Type> subtypeVarAssigns) {\nClass<?> cls = getRawType(parameterizedType);\n\n// make sure they're assignable\nif (!isAssignable(cls, toClass)) {\nreturn null;\n}\n\nType ownerType = parameterizedType.getOwnerType();\nMap<TypeVariable<?>, Type> typeVarAssigns;\n\nif (ownerType instanceof ParameterizedType) {\n// get the owner type arguments first\nParameterizedType parameterizedOwnerType = (ParameterizedType) ownerType;\ntypeVarAssigns = getTypeArguments(parameterizedOwnerType,\ngetRawType(parameterizedOwnerType), subtypeVarAssigns);\n} else {\n// no owner, prep the type variable assignments map\ntypeVarAssigns = subtypeVarAssigns == null ? new HashMap<TypeVariable<?>, Type>()\n: new HashMap<TypeVariable<?>, Type>(subtypeVarAssigns);\n}\n\n// get the subject parameterized type's arguments\nType[] typeArgs = parameterizedType.getActualTypeArguments();\n// and get the corresponding type variables from the raw class\nTypeVariable<?>[] typeParams = cls.getTypeParameters();\n\n// map the arguments to their respective type variables\nfor (int i = 0; i < typeParams.length; i++) {\nType typeArg = typeArgs[i];\ntypeVarAssigns.put(typeParams[i], typeVarAssigns.containsKey(typeArg) ? typeVarAssigns\n.get(typeArg) : typeArg);\n}\n\nif (toClass.equals(cls)) {\n// target class has been reached. Done.\nreturn typeVarAssigns;\n}\n\n// walk the inheritance hierarchy until the target class is reached\nreturn getTypeArguments(getClosestParentType(cls, toClass), toClass, typeVarAssigns);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/ParameterizedType;Ljava/util/Map;)Z",
            "method_body": "private static boolean isAssignable(Type type, ParameterizedType toParameterizedType,\nMap<TypeVariable<?>, Type> typeVarAssigns) {\nif (type == null) {\nreturn true;\n}\n\n// only a null type can be assigned to null type which\n// would have cause the previous to return true\nif (toParameterizedType == null) {\nreturn false;\n}\n\n// all types are assignable to themselves\nif (toParameterizedType.equals(type)) {\nreturn true;\n}\n\n// get the target type's raw type\nClass<?> toClass = getRawType(toParameterizedType);\n// get the subject type's type arguments including owner type arguments\n// and supertype arguments up to and including the target class.\nMap<TypeVariable<?>, Type> fromTypeVarAssigns = getTypeArguments(type, toClass, null);\n\n// null means the two types are not compatible\nif (fromTypeVarAssigns == null) {\nreturn false;\n}\n\n// compatible types, but there's no type arguments. this is equivalent\n// to comparing Map< ?, ? > to Map, and raw types are always assignable\n// to parameterized types.\nif (fromTypeVarAssigns.isEmpty()) {\nreturn true;\n}\n\n// get the target type's type arguments including owner type arguments\nMap<TypeVariable<?>, Type> toTypeVarAssigns = getTypeArguments(toParameterizedType,\ntoClass, typeVarAssigns);\n\n// now to check each type argument\nfor (Map.Entry<TypeVariable<?>, Type> entry : toTypeVarAssigns.entrySet()) {\nType toTypeArg = entry.getValue();\nType fromTypeArg = fromTypeVarAssigns.get(entry.getKey());\n\n// parameters must either be absent from the subject type, within\n// the bounds of the wildcard type, or be an exact match to the\n// parameters of the target type.\nif (fromTypeArg != null\n&& !toTypeArg.equals(fromTypeArg)\n&& !(toTypeArg instanceof WildcardType && isAssignable(fromTypeArg, toTypeArg,\ntypeVarAssigns))) {\nreturn false;\n}\n}\n\nreturn true;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getClosestParentType(Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
            "method_body": "private static Type getClosestParentType(Class<?> cls, Class<?> superClass) {\n// only look at the interfaces if the super class is also an interface\nif (superClass.isInterface()) {\n// get the generic interfaces of the subject class\nType[] interfaceTypes = cls.getGenericInterfaces();\n// will hold the best generic interface match found\nType genericInterface = null;\n\n// find the interface closest to the super class\nfor (Type midType : interfaceTypes) {\nClass<?> midClass = null;\n\nif (midType instanceof ParameterizedType) {\nmidClass = getRawType((ParameterizedType) midType);\n} else if (midType instanceof Class<?>) {\nmidClass = (Class<?>) midType;\n} else {\nthrow new IllegalStateException(\"Unexpected generic\"\n+ \" interface type found: \" + midType);\n}\n\n// check if this interface is further up the inheritance chain\n// than the previously found match\nif (isAssignable(midClass, superClass)\n&& isAssignable(genericInterface, (Type) midClass)) {\ngenericInterface = midType;\n}\n}\n\n// found a match?\nif (genericInterface != null) {\nreturn genericInterface;\n}\n}\n\n// none of the interfaces were descendants of the target class, so the\n// super class has to be one, instead\nreturn cls.getGenericSuperclass();\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/Class;)Z",
            "method_body": "private static boolean isAssignable(Type type, Class<?> toClass) {\nif (type == null) {\n// consistency with ClassUtils.isAssignable() behavior\nreturn toClass == null || !toClass.isPrimitive();\n}\n\n// only a null type can be assigned to null type which\n// would have cause the previous to return true\nif (toClass == null) {\nreturn false;\n}\n\n// all types are assignable to themselves\nif (toClass.equals(type)) {\nreturn true;\n}\n\nif (type instanceof Class<?>) {\n// just comparing two classes\nreturn ClassUtils.isAssignable((Class<?>) type, toClass);\n}\n\nif (type instanceof ParameterizedType) {\n// only have to compare the raw type to the class\nreturn isAssignable(getRawType((ParameterizedType) type), toClass);\n}\n\n// *\nif (type instanceof TypeVariable<?>) {\n// if any of the bounds are assignable to the class, then the\n// type is assignable to the class.\nfor (Type bound : ((TypeVariable<?>) type).getBounds()) {\nif (isAssignable(bound, toClass)) {\nreturn true;\n}\n}\n\nreturn false;\n}\n\n// the only classes to which a generic array type can be assigned\n// are class Object and array classes\nif (type instanceof GenericArrayType) {\nreturn toClass.equals(Object.class)\n|| toClass.isArray()\n&& isAssignable(((GenericArrayType) type).getGenericComponentType(), toClass\n.getComponentType());\n}\n\n// wildcard types are not assignable to a class (though one would think\n// \"? super Object\" would be assignable to Object)\nif (type instanceof WildcardType) {\nreturn false;\n}\n\nthrow new IllegalStateException(\"found an unhandled type: \" + type);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.lang3.ClassUtils:isAssignable(Ljava/lang/Class;Ljava/lang/Class;Z)Z",
            "method_body": "public static boolean isAssignable(Class<?> cls, Class<?> toClass, boolean autoboxing) {\nif (toClass == null) {\nreturn false;\n}\n// have to check for null, as isAssignableFrom doesn't\nif (cls == null) {\nreturn !toClass.isPrimitive();\n}\n//autoboxing:\nif (autoboxing) {\nif (cls.isPrimitive() && !toClass.isPrimitive()) {\ncls = primitiveToWrapper(cls);\nif (cls == null) {\nreturn false;\n}\n}\nif (toClass.isPrimitive() && !cls.isPrimitive()) {\ncls = wrapperToPrimitive(cls);\nif (cls == null) {\nreturn false;\n}\n}\n}\nif (cls.equals(toClass)) {\nreturn true;\n}\nif (cls.isPrimitive()) {\nif (toClass.isPrimitive() == false) {\nreturn false;\n}\nif (Integer.TYPE.equals(cls)) {\nreturn Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Long.TYPE.equals(cls)) {\nreturn Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Boolean.TYPE.equals(cls)) {\nreturn false;\n}\nif (Double.TYPE.equals(cls)) {\nreturn false;\n}\nif (Float.TYPE.equals(cls)) {\nreturn Double.TYPE.equals(toClass);\n}\nif (Character.TYPE.equals(cls)) {\nreturn Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Short.TYPE.equals(cls)) {\nreturn Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\nif (Byte.TYPE.equals(cls)) {\nreturn Short.TYPE.equals(toClass)\n|| Integer.TYPE.equals(toClass)\n|| Long.TYPE.equals(toClass)\n|| Float.TYPE.equals(toClass)\n|| Double.TYPE.equals(toClass);\n}\n// should never get here\nreturn false;\n}\nreturn toClass.isAssignableFrom(cls);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;Ljava/util/Map;)Z",
            "method_body": "private static boolean isAssignable(Type type, Type toType,\nMap<TypeVariable<?>, Type> typeVarAssigns) {\nif (toType == null || toType instanceof Class<?>) {\nreturn isAssignable(type, (Class<?>) toType);\n}\n\nif (toType instanceof ParameterizedType) {\nreturn isAssignable(type, (ParameterizedType) toType, typeVarAssigns);\n}\n\nif (toType instanceof GenericArrayType) {\nreturn isAssignable(type, (GenericArrayType) toType, typeVarAssigns);\n}\n\nif (toType instanceof WildcardType) {\nreturn isAssignable(type, (WildcardType) toType, typeVarAssigns);\n}\n\n// *\nif (toType instanceof TypeVariable<?>) {\nreturn isAssignable(type, (TypeVariable<?>) toType, typeVarAssigns);\n}\n// */\n\nthrow new IllegalStateException(\"found an unhandled type: \" + toType);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;Ljava/io/Writer;)V",
            "method_body": "public final void translate(CharSequence input, Writer out) throws IOException {\nif (out == null) {\nthrow new IllegalArgumentException(\"The Writer must not be null\");\n}\nif (input == null) {\nreturn;\n}\nint pos = 0;\nint len = input.length();\nwhile (pos < len) {\nint consumed = translate(input, pos, out);\nif (consumed == 0) {\nchar[] c = Character.toChars(Character.codePointAt(input, pos));\nout.write(c);\npos+= c.length;\ncontinue;\n}\n//          // contract with translators is that they have to understand codepoints\n//          // and they just took care of a surrogate pair\nfor (int pt = 0; pt < consumed; pt++) {\npos += Character.charCount(Character.codePointAt(input, pos));\n}\n}\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getRawType(Ljava/lang/reflect/ParameterizedType;)Ljava/lang/Class;",
            "method_body": "private static Class<?> getRawType(ParameterizedType parameterizedType) {\nType rawType = parameterizedType.getRawType();\n\n// check if raw type is a Class object\n// not currently necessary, but since the return type is Type instead of\n// Class, there's enough reason to believe that future versions of Java\n// may return other Type implementations. And type-safety checking is\n// rarely a bad idea.\nif (!(rawType instanceof Class<?>)) {\nthrow new IllegalStateException(\"Wait... What!? Type of rawType: \" + rawType);\n}\n\nreturn (Class<?>) rawType;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:normalizeUpperBounds([Ljava/lang/reflect/Type;)[Ljava/lang/reflect/Type;",
            "method_body": "public static Type[] normalizeUpperBounds(Type[] bounds) {\n// don't bother if there's only one (or none) type\nif (bounds.length < 2) {\nreturn bounds;\n}\n\nSet<Type> types = new HashSet<Type>(bounds.length);\n\nfor (Type type1 : bounds) {\nboolean subtypeFound = false;\n\nfor (Type type2 : bounds) {\nif (type1 != type2 && isAssignable(type2, type1, null)) {\nsubtypeFound = true;\nbreak;\n}\n}\n\nif (!subtypeFound) {\ntypes.add(type1);\n}\n}\n\nreturn types.toArray(new Type[types.size()]);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:substituteTypeVariables(Ljava/lang/reflect/Type;Ljava/util/Map;)Ljava/lang/reflect/Type;",
            "method_body": "private static Type substituteTypeVariables(Type type, Map<TypeVariable<?>, Type> typeVarAssigns) {\nif (type instanceof TypeVariable<?> && typeVarAssigns != null) {\nType replacementType = typeVarAssigns.get(type);\n\nif (replacementType == null) {\nthrow new IllegalArgumentException(\"missing assignment type for type variable \"\n+ type);\n}\n\nreturn replacementType;\n}\n\nreturn type;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getTypeArguments(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/util/Map;)Ljava/util/Map;",
            "method_body": "private static Map<TypeVariable<?>, Type> getTypeArguments(Type type, Class<?> toClass,\nMap<TypeVariable<?>, Type> subtypeVarAssigns) {\nif (type instanceof Class<?>) {\nreturn getTypeArguments((Class<?>) type, toClass, subtypeVarAssigns);\n}\n\nif (type instanceof ParameterizedType) {\nreturn getTypeArguments((ParameterizedType) type, toClass, subtypeVarAssigns);\n}\n\nif (type instanceof GenericArrayType) {\nreturn getTypeArguments(((GenericArrayType) type).getGenericComponentType(), toClass\n.isArray() ? toClass.getComponentType() : toClass, subtypeVarAssigns);\n}\n\n// since wildcard types are not assignable to classes, should this just\n// return null?\nif (type instanceof WildcardType) {\nfor (Type bound : getImplicitUpperBounds((WildcardType) type)) {\n// find the first bound that is assignable to the target class\nif (isAssignable(bound, toClass)) {\nreturn getTypeArguments(bound, toClass, subtypeVarAssigns);\n}\n}\n\nreturn null;\n}\n\n// *\nif (type instanceof TypeVariable<?>) {\nfor (Type bound : getImplicitBounds((TypeVariable<?>) type)) {\n// find the first bound that is assignable to the target class\nif (isAssignable(bound, toClass)) {\nreturn getTypeArguments(bound, toClass, subtypeVarAssigns);\n}\n}\n\nreturn null;\n}\n// */\n\nthrow new IllegalStateException(\"found an unhandled type: \" + type);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getImplicitUpperBounds(Ljava/lang/reflect/WildcardType;)[Ljava/lang/reflect/Type;",
            "method_body": "public static Type[] getImplicitUpperBounds(WildcardType wildcardType) {\nType[] bounds = wildcardType.getUpperBounds();\n\nreturn bounds.length == 0 ? new Type[] { Object.class } : normalizeUpperBounds(bounds);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:getImplicitLowerBounds(Ljava/lang/reflect/WildcardType;)[Ljava/lang/reflect/Type;",
            "method_body": "public static Type[] getImplicitLowerBounds(WildcardType wildcardType) {\nType[] bounds = wildcardType.getLowerBounds();\n\nreturn bounds.length == 0 ? new Type[] { null } : bounds;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.lang3.text.translate.CharSequenceTranslator:translate(Ljava/lang/CharSequence;)Ljava/lang/String;",
            "method_body": "public abstract int translate(CharSequence input, int index, Writer out) throws IOException;\n\n/**\n* Helper for non-Writer usage.\n* @param input CharSequence to be translated\n* @return String output of translation\n*/\npublic final String translate(CharSequence input) {\nif (input == null) {\nreturn null;\n}\ntry {\nStringWriter writer = new StringWriter(input.length() * 2);\ntranslate(input, writer);\nreturn writer.toString();\n} catch (IOException ioe) {\n// this should never ever happen while writing to a StringWriter\nthrow new RuntimeException(ioe);\n}\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.lang3.SystemUtils:isJavaVersionAtLeast(Lorg/apache/commons/lang3/JavaVersion;)Z",
            "method_body": "public static boolean isJavaVersionAtLeast(JavaVersion requiredVersion) {\nreturn JAVA_SPECIFICATION_VERSION_AS_ENUM.atLeast(requiredVersion);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.lang3.StringEscapeUtils:escapeHtml4(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "public static final String escapeHtml4(String input) {\nreturn ESCAPE_HTML4.translate(input);\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.lang3.ClassUtils:isAssignable(Ljava/lang/Class;Ljava/lang/Class;)Z",
            "method_body": "public static boolean isAssignable(Class<?> cls, Class<?> toClass) {\nreturn isAssignable(cls, toClass, SystemUtils.isJavaVersionAtLeast(JavaVersion.JAVA_1_5));\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.lang3.reflect.TypeUtils:isAssignable(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;)Z",
            "method_body": "public static boolean isAssignable(Type type, Type toType) {\nreturn isAssignable(type, toType, null);\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.lang3.JavaVersion:atLeast(Lorg/apache/commons/lang3/JavaVersion;)Z",
            "method_body": "public boolean atLeast(JavaVersion requiredVersion) {\nreturn this.value >= requiredVersion.value;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.lang3.text.translate.AggregateTranslator:translate(Ljava/lang/CharSequence;ILjava/io/Writer;)I",
            "method_body": "public int translate(CharSequence input, int index, Writer out) throws IOException {\nfor (CharSequenceTranslator translator : translators) {\nint consumed = translator.translate(input, index, out);\nif(consumed != 0) {\nreturn consumed;\n}\n}\nreturn 0;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.lang3.text.translate.LookupTranslator:translate(Ljava/lang/CharSequence;ILjava/io/Writer;)I",
            "method_body": "public int translate(CharSequence input, int index, Writer out) throws IOException {\nint max = longest;\nif (index + longest > input.length()) {\nmax = input.length() - index;\n}\n// descend so as to get a greedy algorithm\nfor (int i = max; i >= shortest; i--) {\nCharSequence subSeq = input.subSequence(index, index + i);\nCharSequence result = lookupMap.get(subSeq);\nif (result != null) {\nout.write(result.toString());\nreturn i;\n}\n}\nreturn 0;\n}",
            "method_id": 22
        }
    ]
}