{
    "projects": [
        {
            "name": "Cli",
            "bugs": [
                {
                    "bug_id": 1,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI13Test.testCLI13",
                            "test_body": "public void testCLI13()\nthrows ParseException\n{\nfinal String debugOpt = \"debug\";\nOption debug = OptionBuilder\n.withArgName( debugOpt )\n.withDescription( \"turn on debugging\" )\n.withLongOpt( debugOpt )\n.hasArg()\n.create( 'd' );\nOptions options = new Options();\noptions.addOption( debug );\nCommandLine commandLine = new PosixParser().parse( options, new String[]{\"-d\", \"true\"} );\nassertEquals(\"true\", commandLine.getOptionValue( debugOpt ));\nassertEquals(\"true\", commandLine.getOptionValue( 'd' ));\nassertTrue(commandLine.hasOption( 'd'));\nassertTrue(commandLine.hasOption( debugOpt));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.hasArg = hasArg;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn (this.valuesep > 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValue(Ljava/lang/String;)V",
                                    "method_body": "void addValue(String value)\n{\nswitch (numberOfArgs)\n{\ncase UNINITIALIZED:\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n\ndefault:\nprocessValue(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == (numberOfArgs - 1))\n{\nbreak;\n}\n\n\n// store\nadd(value.substring(0, index));\n\n\n// parse\nvalue = value.substring(index + 1);\n\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif ((numberOfArgs > 0) && (values.size() > (numberOfArgs - 1)))\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n\n// store value\nthis.values.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues()\n? null : (String[]) this.values.toArray(new String[] {  });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn this.values.size() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hashCode()I",
                                    "method_body": "public int hashCode()\n{\nint result;\nresult = ( opt != null ? opt.hashCode() : 0 );\nresult = 31 * result + ( longOpt != null ? longOpt.hashCode() : 0 );\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withArgName(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withArgName(String name)\n{\nOptionBuilder.argName = name;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withDescription(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withDescription(String newDescription)\n{\nOptionBuilder.description = newDescription;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt)\nthrows IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// initialise members\nthis.options = options;\nrequiredOptions = options.getRequiredOptions();\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(this.options,\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !options.hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "private void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = options.getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValue(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "private void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (requiredOptions.size() > 0)\n{\nIterator iter = requiredOptions.iterator();\nStringBuffer buff = new StringBuffer();\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\n}\n\nthrow new MissingOptionException(buff.toString());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(Option opt, ListIterator iter)\nthrows ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nString str = (String) iter.next();\n\n// found an Option, not an argument\nif (options.hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValue( Util.stripLeadingAndTrailingQuotes(str) );\n}\ncatch (RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif ((opt.getValues() == null) && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(\"Missing argument for option:\"\n+ opt.getKey());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "private void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = options.hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \"\n+ arg);\n}\n\n// get the option represented by arg\nfinal Option opt = options.getOption(arg);\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\nrequiredOptions.remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (options.getOptionGroup(opt) != null)\n{\nOptionGroup group = options.getOptionGroup(opt);\n\nif (group.isRequired())\n{\nrequiredOptions.remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments,\nboolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\nString token = null;\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\ntoken = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1,\ntoken.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nint tokenLength = token.length();\n\nif (tokenLength == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token)) {\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nif (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[] {  });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (this.options.hasOption(token))\n{\ncurrentOption = this.options.getOption(token);\ntokens.add(token);\n}\nelse if (stopAtNonOption)\n{\neatTheRest = true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(C)Z",
                                    "method_body": "public boolean hasOption(char opt)\n{\nreturn hasOption(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(String opt)\n{\nString[] values = getOptionValues(opt);\n\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(C)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(char opt)\n{\nreturn getOptionValue(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Ljava/lang/String;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nString key = opt;\nif (names.containsKey(opt))\n{\nkey = (String) names.get(opt);\n}\nif (options.containsKey(key))\n{\nreturn ((Option) options.get(key)).getValues();\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\nhashcodeMap.put(new Integer(opt.hashCode()), opt);\nString key = opt.getKey();\nif (key == null)\n{\nkey = opt.getLongOpt();\n}\nelse\n{\nnames.put(opt.getLongOpt(), key);\n}\noptions.put(key, opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nif (str.startsWith(\"\\\"\")) {\nstr = str.substring(1, str.length());\n}\nif (str.endsWith(\"\\\"\")) {\nstr = str.substring(0, str.length()-1);\n}\nreturn str;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 1,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI13Test.testCLI13",
                            "test_body": "public void testCLI13()\nthrows ParseException\n{\nfinal String debugOpt = \"debug\";\nOption debug = OptionBuilder\n.withArgName( debugOpt )\n.withDescription( \"turn on debugging\" )\n.withLongOpt( debugOpt )\n.hasArg()\n.create( 'd' );\nOptions options = new Options();\noptions.addOption( debug );\nCommandLine commandLine = new PosixParser().parse( options, new String[]{\"-d\", \"true\"} );\nassertEquals(\"true\", commandLine.getOptionValue( debugOpt ));\nassertEquals(\"true\", commandLine.getOptionValue( 'd' ));\nassertTrue(commandLine.hasOption( 'd'));\nassertTrue(commandLine.hasOption( debugOpt));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.hasArg = hasArg;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn (this.valuesep > 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValue(Ljava/lang/String;)V",
                                    "method_body": "void addValue(String value)\n{\nswitch (numberOfArgs)\n{\ncase UNINITIALIZED:\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n\ndefault:\nprocessValue(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == (numberOfArgs - 1))\n{\nbreak;\n}\n\n\n// store\nadd(value.substring(0, index));\n\n\n// parse\nvalue = value.substring(index + 1);\n\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif ((numberOfArgs > 0) && (values.size() > (numberOfArgs - 1)))\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n\n// store value\nthis.values.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues()\n? null : (String[]) this.values.toArray(new String[] {  });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn this.values.size() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hashCode()I",
                                    "method_body": "public int hashCode()\n{\nint result;\nresult = ( opt != null ? opt.hashCode() : 0 );\nresult = 31 * result + ( longOpt != null ? longOpt.hashCode() : 0 );\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withArgName(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withArgName(String name)\n{\nOptionBuilder.argName = name;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withDescription(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withDescription(String newDescription)\n{\nOptionBuilder.description = newDescription;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt)\nthrows IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// initialise members\nthis.options = options;\nrequiredOptions = options.getRequiredOptions();\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(this.options,\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !options.hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "private void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = options.getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValue(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "private void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (requiredOptions.size() > 0)\n{\nIterator iter = requiredOptions.iterator();\nStringBuffer buff = new StringBuffer();\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\n}\n\nthrow new MissingOptionException(buff.toString());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(Option opt, ListIterator iter)\nthrows ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nString str = (String) iter.next();\n\n// found an Option, not an argument\nif (options.hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValue( Util.stripLeadingAndTrailingQuotes(str) );\n}\ncatch (RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif ((opt.getValues() == null) && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(\"Missing argument for option:\"\n+ opt.getKey());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "private void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = options.hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \"\n+ arg);\n}\n\n// get the option represented by arg\nfinal Option opt = options.getOption(arg);\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\nrequiredOptions.remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (options.getOptionGroup(opt) != null)\n{\nOptionGroup group = options.getOptionGroup(opt);\n\nif (group.isRequired())\n{\nrequiredOptions.remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments,\nboolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\nString token = null;\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\ntoken = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1,\ntoken.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nint tokenLength = token.length();\n\nif (tokenLength == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token)) {\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nif (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[] {  });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (this.options.hasOption(token))\n{\ncurrentOption = this.options.getOption(token);\ntokens.add(token);\n}\nelse if (stopAtNonOption)\n{\neatTheRest = true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(C)Z",
                                    "method_body": "public boolean hasOption(char opt)\n{\nreturn hasOption(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(String opt)\n{\nString[] values = getOptionValues(opt);\n\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(C)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(char opt)\n{\nreturn getOptionValue(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Ljava/lang/String;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nString key = opt;\nif (names.containsKey(opt))\n{\nkey = (String) names.get(opt);\n}\nif (options.containsKey(key))\n{\nreturn ((Option) options.get(key)).getValues();\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\nhashcodeMap.put(new Integer(opt.hashCode()), opt);\nString key = opt.getKey();\nif (key == null)\n{\nkey = opt.getLongOpt();\n}\nelse\n{\nnames.put(opt.getLongOpt(), key);\n}\noptions.put(key, opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nif (str.startsWith(\"\\\"\")) {\nstr = str.substring(1, str.length());\n}\nif (str.endsWith(\"\\\"\")) {\nstr = str.substring(0, str.length()-1);\n}\nreturn str;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 2,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI51Test.test",
                            "test_body": "public void test() throws Exception\n{\nOptions options = buildCommandLineOptions();\nCommandLineParser parser = new PosixParser();\nString[] args = new String[] {\"-t\", \"-something\" };\nCommandLine commandLine;\ncommandLine = parser.parse( options, args );\nassertEquals(\"-something\", commandLine.getOptionValue( 't'));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.hasArg = hasArg;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn (this.valuesep > 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValue(Ljava/lang/String;)V",
                                    "method_body": "void addValue(String value)\n{\nswitch (numberOfArgs)\n{\ncase UNINITIALIZED:\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n\ndefault:\nprocessValue(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == (numberOfArgs - 1))\n{\nbreak;\n}\n\n\n// store\nadd(value.substring(0, index));\n\n\n// parse\nvalue = value.substring(index + 1);\n\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif ((numberOfArgs > 0) && (values.size() > (numberOfArgs - 1)))\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n\n// store value\nthis.values.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues()\n? null : (String[]) this.values.toArray(new String[] {  });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn this.values.size() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hashCode()I",
                                    "method_body": "public int hashCode()\n{\nint result;\nresult = ( opt != null ? opt.hashCode() : 0 );\nresult = 31 * result + ( longOpt != null ? longOpt.hashCode() : 0 );\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withArgName(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withArgName(String name)\n{\nOptionBuilder.argName = name;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt)\nthrows IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// initialise members\nthis.options = options;\nrequiredOptions = options.getRequiredOptions();\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(this.options,\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !options.hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(Option opt, ListIterator iter)\nthrows ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nString str = (String) iter.next();\n\n// found an Option, not an argument\nif (options.hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValue( Util.stripLeadingAndTrailingQuotes(str) );\n}\ncatch (RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif ((opt.getValues() == null) && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(\"Missing argument for option:\"\n+ opt.getKey());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "private void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = options.hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \"\n+ arg);\n}\n\n// get the option represented by arg\nfinal Option opt = options.getOption(arg);\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\nrequiredOptions.remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (options.getOptionGroup(opt) != null)\n{\nOptionGroup group = options.getOptionGroup(opt);\n\nif (group.isRequired())\n{\nrequiredOptions.remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments,\nboolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\nString token;\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\ntoken = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1,\ntoken.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nint tokenLength = token.length();\n\nif (tokenLength == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token)) {\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nif (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[] {  });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (this.options.hasOption(token))\n{\ncurrentOption = this.options.getOption(token);\ntokens.add(token);\n}\nelse if (stopAtNonOption)\n{\neatTheRest = true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:burstToken(Ljava/lang/String;Z)V",
                                    "method_body": "protected void burstToken(String token, boolean stopAtNonOption)\n{\nint tokenLength = token.length();\n\nfor (int i = 1; i < tokenLength; i++)\n{\nString ch = String.valueOf(token.charAt(i));\nboolean hasOption = options.hasOption(ch);\n\nif (hasOption)\n{\ntokens.add(\"-\" + ch);\ncurrentOption = options.getOption(ch);\n\nif (currentOption.hasArg() && (token.length() != (i + 1)))\n{\ntokens.add(token.substring(i + 1));\n\nbreak;\n}\n}\nelse if (stopAtNonOption)\n{\nprocess(token.substring(i));\n}\nelse\n{\ntokens.add(\"-\" + ch);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nif (str.startsWith(\"\\\"\")) {\nstr = str.substring(1, str.length());\n}\nif (str.endsWith(\"\\\"\")) {\nstr = str.substring(0, str.length()-1);\n}\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.UnrecognizedOptionException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public UnrecognizedOptionException(String message)\n{\nsuper(message);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 3,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.PatternOptionBuilderTest.testSimplePattern",
                            "test_body": "public void testSimplePattern()\n{\ntry {\nOptions options = PatternOptionBuilder.parsePattern(\"a:b@cde>f+n%t/\");\nString[] args = new String[] { \"-c\", \"-a\", \"foo\", \"-b\", \"java.util.Vector\", \"-e\", \"build.xml\", \"-f\", \"java.util.Calendar\", \"-n\", \"4.5\", \"-t\", \"http://jakarta.apache.org/\" };\nCommandLineParser parser = new PosixParser();\nCommandLine line = parser.parse(options,args);\n// tests the char methods of CommandLine that delegate to\n// the String methods\nassertEquals(\"flag a\", \"foo\", line.getOptionValue(\"a\"));\nassertEquals(\"flag a\", \"foo\", line.getOptionValue('a'));\nassertEquals(\"string flag a\", \"foo\", line.getOptionObject(\"a\"));\nassertEquals(\"string flag a\", \"foo\", line.getOptionObject('a'));\nassertEquals(\"object flag b\", new java.util.Vector(), line.getOptionObject(\"b\"));\nassertEquals(\"object flag b\", new java.util.Vector(), line.getOptionObject('b'));\nassertEquals(\"boolean true flag c\", true, line.hasOption(\"c\"));\nassertEquals(\"boolean true flag c\", true, line.hasOption('c'));\nassertEquals(\"boolean false flag d\", false, line.hasOption(\"d\"));\nassertEquals(\"boolean false flag d\", false, line.hasOption('d'));\nassertEquals(\"file flag e\", new java.io.File(\"build.xml\"), line.getOptionObject(\"e\"));\nassertEquals(\"file flag e\", new java.io.File(\"build.xml\"), line.getOptionObject('e'));\nassertEquals(\"class flag f\", java.util.Calendar.class, line.getOptionObject(\"f\"));\nassertEquals(\"class flag f\", java.util.Calendar.class, line.getOptionObject('f'));\nassertEquals(\"number flag n\", new Double(4.5), line.getOptionObject(\"n\"));\nassertEquals(\"number flag n\", new Double(4.5), line.getOptionObject('n'));\nassertEquals(\"url flag t\", new java.net.URL(\"http://jakarta.apache.org/\"), line.getOptionObject(\"t\"));\nassertEquals(\"url flag t\", new java.net.URL(\"http://jakarta.apache.org/\"), line.getOptionObject('t'));\n/// DATES NOT SUPPORTED YET.\n//      assertEquals(\"number flag t\", new java.util.Date(1023400137276L), line.getOptionObject('z'));\n//     input is:  \"Thu Jun 06 17:48:57 EDT 2002\"\n}\ncatch( ParseException exp ) {\nfail( exp.getMessage() );\n}\ncatch( java.net.MalformedURLException exp ) {\nfail( exp.getMessage() );\n}\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.hasArg = hasArg;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getType()Ljava/lang/Object;",
                                    "method_body": "public Object getType()\n{\nreturn this.type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn (this.valuesep > 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValue(Ljava/lang/String;)V",
                                    "method_body": "void addValue(String value)\n{\nswitch (numberOfArgs)\n{\ncase UNINITIALIZED:\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n\ndefault:\nprocessValue(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == (numberOfArgs - 1))\n{\nbreak;\n}\n\n\n// store\nadd(value.substring(0, index));\n\n\n// parse\nvalue = value.substring(index + 1);\n\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif ((numberOfArgs > 0) && (values.size() > (numberOfArgs - 1)))\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n\n// store value\nthis.values.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues()\n? null : (String[]) this.values.toArray(new String[] {  });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn this.values.size() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hashCode()I",
                                    "method_body": "public int hashCode()\n{\nint result;\nresult = ( opt != null ? opt.hashCode() : 0 );\nresult = 31 * result + ( longOpt != null ? longOpt.hashCode() : 0 );\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg(Z)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg(boolean hasArg)\n{\nOptionBuilder.numberOfArgs = (hasArg == true) ? 1 : Option.UNINITIALIZED;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:isRequired(Z)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder isRequired(boolean newRequired)\n{\nOptionBuilder.required = newRequired;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withType(Ljava/lang/Object;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withType(Object newType)\n{\nOptionBuilder.type = newType;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt)\nthrows IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nList opts = new ArrayList(shortOpts.values());\n\n// now look through the long opts to see if there are any Long-opt\n// only options\nIterator iter = longOpts.values().iterator();\n\nwhile (iter.hasNext())\n{\nObject item = iter.next();\n\nif (!opts.contains(item))\n{\nopts.add(item);\n}\n}\n\nreturn new ArrayList(opts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// initialise members\nthis.options = options;\n\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\nrequiredOptions = options.getRequiredOptions();\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(this.options,\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !options.hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "private void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = options.getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValue(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "private void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (requiredOptions.size() > 0)\n{\nIterator iter = requiredOptions.iterator();\nStringBuffer buff = new StringBuffer();\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\n}\n\nthrow new MissingOptionException(buff.toString());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(Option opt, ListIterator iter)\nthrows ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nString str = (String) iter.next();\n\n// found an Option, not an argument\nif (options.hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValue( Util.stripLeadingAndTrailingQuotes(str) );\n}\ncatch (RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif ((opt.getValues() == null) && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(\"Missing argument for option:\"\n+ opt.getKey());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "private void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = options.hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \"\n+ arg);\n}\n\n// get the option represented by arg\nfinal Option opt = options.getOption(arg);\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\nrequiredOptions.remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (options.getOptionGroup(opt) != null)\n{\nOptionGroup group = options.getOptionGroup(opt);\n\nif (group.isRequired())\n{\nrequiredOptions.remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments,\nboolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\nString token;\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\ntoken = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1,\ntoken.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nint tokenLength = token.length();\n\nif (tokenLength == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token)) {\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nif (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[] {  });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (this.options.hasOption(token))\n{\ncurrentOption = this.options.getOption(token);\ntokens.add(token);\n}\nelse if (stopAtNonOption)\n{\neatTheRest = true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains( resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(C)Z",
                                    "method_body": "public boolean hasOption(char opt)\n{\nreturn hasOption(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionObject(Ljava/lang/String;)Ljava/lang/Object;",
                                    "method_body": "public Object getOptionObject(String opt)\n{\nString res = getOptionValue(opt);\n\nOption option = resolveOption(opt);\nif (option == null)\n{\nreturn null;\n}\n\nObject type = option.getType();\n\nreturn (res == null)        ? null : TypeHandler.createValue(res, type);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionObject(C)Ljava/lang/Object;",
                                    "method_body": "public Object getOptionObject(char opt)\n{\nreturn getOptionObject(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(String opt)\n{\nString[] values = getOptionValues(opt);\n\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(C)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(char opt)\n{\nreturn getOptionValue(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Ljava/lang/String;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(String opt)\n{\nOption key = resolveOption( opt );\n\nif (options.contains(key))\n{\nreturn key.getValues();\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption( String opt )\n{\nopt = Util.stripLeadingHyphens(opt);\nfor ( Iterator it = options.iterator(); it.hasNext(); )\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\nif (opt.equals( option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nif (str.startsWith(\"\\\"\")) {\nstr = str.substring(1, str.length());\n}\nif (str.endsWith(\"\\\"\")) {\nstr = str.substring(0, str.length()-1);\n}\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:<clinit>()V",
                                    "method_body": "public static final Class STRING_VALUE = java.lang.String.class;\n\n/** Object class */\npublic static final Class OBJECT_VALUE = java.lang.Object.class;\n\n/** Number class */\npublic static final Class NUMBER_VALUE = java.lang.Number.class;\n\n/** Date class */\npublic static final Class DATE_VALUE = java.util.Date.class;\n\n/** Class class */\npublic static final Class CLASS_VALUE = java.lang.Class.class;\n\n/// can we do this one??\n// is meant to check that the file exists, else it errors.\n// ie) it's for reading not writing.\n\n/** FileInputStream class */\npublic static final Class EXISTING_FILE_VALUE =\njava.io.FileInputStream.class;\n\n/** File class */\npublic static final Class FILE_VALUE = java.io.File.class;\n\n/** File array class */\npublic static final Class FILES_VALUE = java.io.File[].class;\n\n/** URL class */\npublic static final Class URL_VALUE = java.net.URL.class;\n\n/**\n* <p>Retrieve the class that <code>ch</code> represents.</p>\n*\n* @param ch the specified character\n* @return The class that <code>ch</code> represents\n*/\npublic static Object getValueClass(char ch)\n{\nif (ch == '@')\n{\nreturn PatternOptionBuilder.OBJECT_VALUE;\n}\nelse if (ch == ':')\n{\nreturn PatternOptionBuilder.STRING_VALUE;\n}\nelse if (ch == '%')\n{\nreturn PatternOptionBuilder.NUMBER_VALUE;\n}\nelse if (ch == '+')\n{\nreturn PatternOptionBuilder.CLASS_VALUE;\n}\nelse if (ch == '#')\n{\nreturn PatternOptionBuilder.DATE_VALUE;\n}\nelse if (ch == '<')\n{\nreturn PatternOptionBuilder.EXISTING_FILE_VALUE;\n}\nelse if (ch == '>')\n{\nreturn PatternOptionBuilder.FILE_VALUE;\n}\nelse if (ch == '*')\n{\nreturn PatternOptionBuilder.FILES_VALUE;\n}\nelse if (ch == '/')\n{\nreturn PatternOptionBuilder.URL_VALUE;\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:getValueClass(C)Ljava/lang/Object;",
                                    "method_body": "public static Object getValueClass(char ch)\n{\nif (ch == '@')\n{\nreturn PatternOptionBuilder.OBJECT_VALUE;\n}\nelse if (ch == ':')\n{\nreturn PatternOptionBuilder.STRING_VALUE;\n}\nelse if (ch == '%')\n{\nreturn PatternOptionBuilder.NUMBER_VALUE;\n}\nelse if (ch == '+')\n{\nreturn PatternOptionBuilder.CLASS_VALUE;\n}\nelse if (ch == '#')\n{\nreturn PatternOptionBuilder.DATE_VALUE;\n}\nelse if (ch == '<')\n{\nreturn PatternOptionBuilder.EXISTING_FILE_VALUE;\n}\nelse if (ch == '>')\n{\nreturn PatternOptionBuilder.FILE_VALUE;\n}\nelse if (ch == '*')\n{\nreturn PatternOptionBuilder.FILES_VALUE;\n}\nelse if (ch == '/')\n{\nreturn PatternOptionBuilder.URL_VALUE;\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:isValueCode(C)Z",
                                    "method_body": "public static boolean isValueCode(char ch)\n{\nif ((ch != '@') && (ch != ':') && (ch != '%') && (ch != '+')\n&& (ch != '#') && (ch != '<') && (ch != '>') && (ch != '*')\n&& (ch != '/') && (ch != '!'))\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:parsePattern(Ljava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public static Options parsePattern(String pattern)\n{\nint sz = pattern.length();\n\nchar opt = ' ';\nchar ch = ' ';\nboolean required = false;\nObject type = null;\n\nOptions options = new Options();\n\nfor (int i = 0; i < sz; i++)\n{\nch = pattern.charAt(i);\n\n// a value code comes after an option and specifies\n// details about it\nif (!isValueCode(ch))\n{\nif (opt != ' ')\n{\nOptionBuilder.hasArg(type != null);\nOptionBuilder.isRequired(required);\nOptionBuilder.withType(type);\n\n// we have a previous one to deal with\noptions.addOption(OptionBuilder.create(opt));\nrequired = false;\ntype = null;\nopt = ' ';\n}\n\nopt = ch;\n}\nelse if (ch == '!')\n{\nrequired = true;\n}\nelse\n{\ntype = getValueClass(ch);\n}\n}\n\nif (opt != ' ')\n{\nOptionBuilder.hasArg(type != null);\nOptionBuilder.isRequired(required);\nOptionBuilder.withType(type);\n\n// we have a final one to deal with\noptions.addOption(OptionBuilder.create(opt));\n}\n\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createValue(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static Object createValue(String str, Object obj)\n{\nreturn createValue(str, (Class) obj);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createValue(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public static Object createValue(String str, Class clazz)\n{\nif (PatternOptionBuilder.STRING_VALUE == clazz)\n{\nreturn str;\n}\nelse if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n{\nreturn createObject(str);\n}\nelse if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n{\nreturn createNumber(str);\n}\nelse if (PatternOptionBuilder.DATE_VALUE == clazz)\n{\nreturn createDate(str);\n}\nelse if (PatternOptionBuilder.CLASS_VALUE == clazz)\n{\nreturn createClass(str);\n}\nelse if (PatternOptionBuilder.FILE_VALUE == clazz)\n{\nreturn createFile(str);\n}\nelse if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n{\nreturn createFile(str);\n}\nelse if (PatternOptionBuilder.FILES_VALUE == clazz)\n{\nreturn createFiles(str);\n}\nelse if (PatternOptionBuilder.URL_VALUE == clazz)\n{\nreturn createURL(str);\n}\nelse\n{\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createObject(Ljava/lang/String;)Ljava/lang/Object;",
                                    "method_body": "public static Object createObject(String str)\n{\nClass cl = null;\n\ntry\n{\ncl = Class.forName(str);\n}\ncatch (ClassNotFoundException cnfe)\n{\nSystem.err.println(\"Unable to find: \" + str);\n\nreturn null;\n}\n\nObject instance = null;\n\ntry\n{\ninstance = cl.newInstance();\n}\ncatch (InstantiationException cnfe)\n{\nSystem.err.println(\"InstantiationException; Unable to create: \"\n+ str);\n\nreturn null;\n}\ncatch (IllegalAccessException cnfe)\n{\nSystem.err.println(\"IllegalAccessException; Unable to create: \"\n+ str);\n\nreturn null;\n}\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(String str)\n{\ntry\n{\nreturn org.apache.commons.lang.math.NumberUtils.createNumber(str);\n}\ncatch (NumberFormatException nfe)\n{\nSystem.err.println(nfe.getMessage());\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createClass(Ljava/lang/String;)Ljava/lang/Class;",
                                    "method_body": "public static Class createClass(String str)\n{\ntry\n{\nreturn Class.forName(str);\n}\ncatch (ClassNotFoundException cnfe)\n{\nSystem.err.println(\"Unable to find: \" + str);\n\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createFile(Ljava/lang/String;)Ljava/io/File;",
                                    "method_body": "public static File createFile(String str)\n{\nreturn new File(str);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 4,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.OptionsTest.testMissingOptionException",
                            "test_body": "public void testMissingOptionException() throws ParseException {\nOptions options = new Options();\noptions.addOption(OptionBuilder.isRequired().create(\"f\"));\ntry {\nnew PosixParser().parse(options, new String[0]);\nfail(\"Expected MissingOptionException to be thrown\");\n} catch (MissingOptionException e) {\nassertEquals(\"Missing required option: f\", e.getMessage());\n}\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.hasArg = hasArg;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:isRequired()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder isRequired()\n{\nOptionBuilder.required = true;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nList opts = new ArrayList(shortOpts.values());\n\n// now look through the long opts to see if there are any Long-opt\n// only options\nIterator iter = longOpts.values().iterator();\n\nwhile (iter.hasNext())\n{\nObject item = iter.next();\n\nif (!opts.contains(item))\n{\nopts.add(item);\n}\n}\n\nreturn new ArrayList(opts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// initialise members\nthis.options = options;\n\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\nrequiredOptions = options.getRequiredOptions();\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(this.options,\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !options.hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "private void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = options.getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValue(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "private void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (requiredOptions.size() > 0)\n{\nIterator iter = requiredOptions.iterator();\nStringBuffer buff = new StringBuffer();\n\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\n}\n\nthrow new MissingOptionException(buff.toString());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments,\nboolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\nString token;\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\ntoken = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1,\ntoken.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nint tokenLength = token.length();\n\nif (tokenLength == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token)) {\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nif (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.MissingOptionException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public MissingOptionException(String message)\n{\nsuper(message);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.OptionsTest.testMissingOptionsException",
                            "test_body": "public void testMissingOptionsException() throws ParseException {\nOptions options = new Options();\noptions.addOption(OptionBuilder.isRequired().create(\"f\"));\noptions.addOption(OptionBuilder.isRequired().create(\"x\"));\ntry {\nnew PosixParser().parse(options, new String[0]);\nfail(\"Expected MissingOptionException to be thrown\");\n} catch (MissingOptionException e) {\nassertEquals(\"Missing required options: fx\", e.getMessage());\n}\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.hasArg = hasArg;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:isRequired()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder isRequired()\n{\nOptionBuilder.required = true;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nList opts = new ArrayList(shortOpts.values());\n\n// now look through the long opts to see if there are any Long-opt\n// only options\nIterator iter = longOpts.values().iterator();\n\nwhile (iter.hasNext())\n{\nObject item = iter.next();\n\nif (!opts.contains(item))\n{\nopts.add(item);\n}\n}\n\nreturn new ArrayList(opts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// initialise members\nthis.options = options;\n\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\nrequiredOptions = options.getRequiredOptions();\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(this.options,\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !options.hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "private void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = options.getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValue(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "private void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (requiredOptions.size() > 0)\n{\nIterator iter = requiredOptions.iterator();\nStringBuffer buff = new StringBuffer();\n\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\n}\n\nthrow new MissingOptionException(buff.toString());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments,\nboolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\nString token;\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\ntoken = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1,\ntoken.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nint tokenLength = token.length();\n\nif (tokenLength == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token)) {\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nif (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.MissingOptionException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public MissingOptionException(String message)\n{\nsuper(message);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 5,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI133Test.testOrder",
                            "test_body": "public void testOrder() throws ParseException {\nOption optionA = new Option(\"a\", \"first\");\nOptions opts = new Options();\nopts.addOption(optionA);\nPosixParser posixParser = new PosixParser();\nCommandLine line = posixParser.parse(opts, null);\nassertFalse(line.hasOption(null));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.hasArg = hasArg;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nList opts = new ArrayList(shortOpts.values());\n\n// now look through the long opts to see if there are any Long-opt\n// only options\nIterator iter = longOpts.values().iterator();\n\nwhile (iter.hasNext())\n{\nObject item = iter.next();\n\nif (!opts.contains(item))\n{\nopts.add(item);\n}\n}\n\nreturn new ArrayList(opts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// initialise members\nthis.options = options;\n\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\nrequiredOptions = options.getRequiredOptions();\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(this.options,\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !options.hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "private void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = options.getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValue(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "private void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (requiredOptions.size() > 0)\n{\nIterator iter = requiredOptions.iterator();\nStringBuffer buff = new StringBuffer(\"Missing required option\");\nbuff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\nbuff.append(\": \");\n\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\n}\n\nthrow new MissingOptionException(buff.toString());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments,\nboolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\nString token;\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\ntoken = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1,\ntoken.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nint tokenLength = token.length();\n\nif (tokenLength == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token)) {\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nif (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains( resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption( String opt )\n{\nopt = Util.stripLeadingHyphens(opt);\nfor ( Iterator it = options.iterator(); it.hasNext(); )\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\nif (opt.equals( option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 8,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.HelpFormatterTest.testPrintWrapped",
                            "test_body": "public void testPrintWrapped()\nthrows Exception\n{\nStringBuffer sb = new StringBuffer();\nHelpFormatter hf = new HelpFormatter();\nString text = \"This is a test.\";\nString expected;\nexpected = \"This is a\" + hf.getNewLine() + \"test.\";\nhf.renderWrappedText(sb, 12, 0, text);\nassertEquals(\"single line text\", expected, sb.toString());\nsb.setLength(0);\nexpected = \"This is a\" + hf.getNewLine() + \"    test.\";\nhf.renderWrappedText(sb, 12, 4, text);\nassertEquals(\"single line padded text\", expected, sb.toString());\ntext = \"  -p,--period <PERIOD>  PERIOD is time duration of form \" +\n\"DATE[-DATE] where DATE has form YYYY[MM[DD]]\";\nsb.setLength(0);\nexpected = \"  -p,--period <PERIOD>  PERIOD is time duration of\" +\nhf.getNewLine() +\n\"                        form DATE[-DATE] where DATE\" +\nhf.getNewLine() +\n\"                        has form YYYY[MM[DD]]\";\nhf.renderWrappedText(sb, 53, 24, text);\nassertEquals(\"single line padded text 2\", expected, sb.toString());\ntext =\n\"aaaa aaaa aaaa\" + hf.getNewLine() +\n\"aaaaaa\" + hf.getNewLine() +\n\"aaaaa\";\nexpected = text;\nsb.setLength(0);\nhf.renderWrappedText(sb, 16, 0, text);\nassertEquals(\"multi line text\", expected, sb.toString());\nexpected =\n\"aaaa aaaa aaaa\" + hf.getNewLine() +\n\"    aaaaaa\" + hf.getNewLine() +\n\"    aaaaa\";\nsb.setLength(0);\nhf.renderWrappedText(sb, 16, 4, text);\nassertEquals(\"multi-line padded text\", expected, sb.toString());\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:getNewLine()Ljava/lang/String;",
                                    "method_body": "public String getNewLine()\n{\nreturn this.defaultNewLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderWrappedText(Ljava/lang/StringBuffer;IILjava/lang/String;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderWrappedText(StringBuffer sb, int width,\nint nextLineTabStop, String text)\n{\nint pos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(rtrim(text));\n\nreturn sb;\n}\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n// all following lines must be padded with nextLineTabStop space\n// characters\nfinal String padding = createPadding(nextLineTabStop);\n\nwhile (true)\n{\ntext = padding + text.substring(pos).trim();\npos = findWrapPos(text, width, nextLineTabStop);\n\nif (pos == -1)\n{\nsb.append(text);\n\nreturn sb;\n}\n\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:findWrapPos(Ljava/lang/String;II)I",
                                    "method_body": "protected int findWrapPos(String text, int width, int startPos)\n{\nint pos = -1;\n\n// the line ends before the max wrap pos or a new line char found\nif (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n|| ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n{\nreturn pos+1;\n}\nelse if ((startPos + width) >= text.length())\n{\nreturn -1;\n}\n\n\n// look for the last whitespace character before startPos+width\npos = startPos + width;\n\nchar c;\n\nwhile ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n--pos;\n}\n\n// if we found it - just return\nif (pos > startPos)\n{\nreturn pos;\n}\n\n// must look for the first whitespace chearacter after startPos\n// + width\npos = startPos + width;\n\nwhile ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n++pos;\n}\n\nreturn (pos == text.length())        ? (-1) : pos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:createPadding(I)Ljava/lang/String;",
                                    "method_body": "protected String createPadding(int len)\n{\nStringBuffer sb = new StringBuffer(len);\n\nfor (int i = 0; i < len; ++i)\n{\nsb.append(' ');\n}\n\nreturn sb.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:rtrim(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "protected String rtrim(String s)\n{\nif ((s == null) || (s.length() == 0))\n{\nreturn s;\n}\n\nint pos = s.length();\n\nwhile ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n{\n--pos;\n}\n\nreturn s.substring(0, pos);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 9,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.OptionsTest.testMissingOptionsException",
                            "test_body": "public void testMissingOptionsException() throws ParseException {\nOptions options = new Options();\noptions.addOption(OptionBuilder.isRequired().create(\"f\"));\noptions.addOption(OptionBuilder.isRequired().create(\"x\"));\ntry {\nnew PosixParser().parse(options, new String[0]);\nfail(\"Expected MissingOptionException to be thrown\");\n} catch (MissingOptionException e) {\nassertEquals(\"Missing required options: f, x\", e.getMessage());\n}\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:isRequired()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder isRequired()\n{\nOptionBuilder.required = true;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nList opts = new ArrayList(shortOpts.values());\n\n// now look through the long opts to see if there are any Long-opt\n// only options\nIterator iter = longOpts.values().iterator();\n\nwhile (iter.hasNext())\n{\nObject item = iter.next();\n\nif (!opts.contains(item))\n{\nopts.add(item);\n}\n}\n\nreturn new ArrayList(opts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options) {\nthis.options = options;\nthis.requiredOptions = options.getRequiredOptions();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions() {\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions() {\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(),\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (getRequiredOptions().size() > 0)\n{\nIterator iter = getRequiredOptions().iterator();\nStringBuffer buff = new StringBuffer(\"Missing required option\");\nbuff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\nbuff.append(\": \");\n\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\n}\n\nthrow new MissingOptionException(buff.toString());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments,\nboolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\nString token;\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\ntoken = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1,\ntoken.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nint tokenLength = token.length();\n\nif (tokenLength == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token)) {\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nif (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.MissingOptionException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public MissingOptionException(String message)\n{\nsuper(message);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.ParseRequiredTest.testMissingRequiredOptions",
                            "test_body": "public void testMissingRequiredOptions()\n{\nString[] args = new String[] { \"-a\" };\n_options.addOption( OptionBuilder.withLongOpt( \"cfile\" )\n.hasArg()\n.isRequired()\n.withDescription( \"set the value of [c]\" )\n.create( 'c' ) );\ntry\n{\nCommandLine cl = parser.parse(_options,args);\nfail( \"exception should have been thrown\" );\n}\ncatch (MissingOptionException e)\n{\nassertEquals( \"Incorrect exception message\", \"Missing required options: b, c\", e.getMessage() );\n}\ncatch (ParseException e)\n{\nfail( \"expected to catch MissingOptionException\" );\n}\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:isRequired()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder isRequired()\n{\nOptionBuilder.required = true;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nList opts = new ArrayList(shortOpts.values());\n\n// now look through the long opts to see if there are any Long-opt\n// only options\nIterator iter = longOpts.values().iterator();\n\nwhile (iter.hasNext())\n{\nObject item = iter.next();\n\nif (!opts.contains(item))\n{\nopts.add(item);\n}\n}\n\nreturn new ArrayList(opts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options) {\nthis.options = options;\nthis.requiredOptions = options.getRequiredOptions();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions() {\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions() {\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(),\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (getRequiredOptions().size() > 0)\n{\nIterator iter = getRequiredOptions().iterator();\nStringBuffer buff = new StringBuffer(\"Missing required option\");\nbuff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\nbuff.append(\": \");\n\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\n}\n\nthrow new MissingOptionException(buff.toString());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments,\nboolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\nString token;\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\ntoken = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1,\ntoken.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nint tokenLength = token.length();\n\nif (tokenLength == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token)) {\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nif (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.MissingOptionException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public MissingOptionException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null) {\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals( Object o )\n{\nif ( this == o )\n{\nreturn true;\n}\nif ( o == null || getClass() != o.getClass() )\n{\nreturn false;\n}\n\nOption option = (Option) o;\n\n\nif ( opt != null ? !opt.equals( option.opt ) : option.opt != null )\n{\nreturn false;\n}\nif ( longOpt != null ? !longOpt.equals( option.longOpt ) : option.longOpt != null )\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hashCode()I",
                                    "method_body": "public int hashCode()\n{\nint result;\nresult = ( opt != null ? opt.hashCode() : 0 );\nresult = 31 * result + ( longOpt != null ? longOpt.hashCode() : 0 );\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withDescription(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withDescription(String newDescription)\n{\nOptionBuilder.description = newDescription;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt)\nthrows IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg,\nString description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \"\n+ arg);\n}\n\n// get the option represented by arg\nfinal Option opt = getOptions().getOption(arg);\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (this.options.hasOption(token))\n{\ncurrentOption = this.options.getOption(token);\ntokens.add(token);\n}\nelse if (stopAtNonOption)\n{\neatTheRest = true;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 10,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.ParseRequiredTest.testReuseOptionsTwice",
                            "test_body": "public void testReuseOptionsTwice() throws Exception\n{\nOptions opts = new Options();\nopts.addOption(OptionBuilder.isRequired().create('v'));\nGnuParser parser = new GnuParser();\n// first parsing\nparser.parse(opts, new String[] { \"-v\" });\ntry\n{\n// second parsing, with the same Options instance and an invalid command line\nparser.parse(opts, new String[0]);\nfail(\"MissingOptionException not thrown\");\n}\ncatch (MissingOptionException e)\n{\n// expected\n}\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null) {\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hashCode()I",
                                    "method_body": "public int hashCode()\n{\nint result;\nresult = ( opt != null ? opt.hashCode() : 0 );\nresult = 31 * result + ( longOpt != null ? longOpt.hashCode() : 0 );\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:isRequired()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder isRequired()\n{\nOptionBuilder.required = true;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withDescription(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withDescription(String newDescription)\n{\nOptionBuilder.description = newDescription;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt)\nthrows IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg,\nString description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nList opts = new ArrayList(shortOpts.values());\n\n// now look through the long opts to see if there are any Long-opt\n// only options\nIterator iter = longOpts.values().iterator();\n\nwhile (iter.hasNext())\n{\nObject item = iter.next();\n\nif (!opts.contains(item))\n{\nopts.add(item);\n}\n}\n\nreturn new ArrayList(opts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options) {\nthis.options = options;\nthis.requiredOptions = options.getRequiredOptions();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions() {\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions() {\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(),\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (getRequiredOptions().size() > 0)\n{\nIterator iter = getRequiredOptions().iterator();\nStringBuffer buff = new StringBuffer(\"Missing required option\");\nbuff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\nbuff.append(\": \");\n\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\nbuff.append(\", \");\n}\n\nthrow new MissingOptionException(buff.substring(0, buff.length() - 2));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \"\n+ arg);\n}\n\n// get the option represented by arg\nfinal Option opt = getOptions().getOption(arg);\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.GnuParser:init()V",
                                    "method_body": "private void init()\n{\ntokens.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.GnuParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments,\nboolean stopAtNonOption)\n{\ninit();\n\nboolean eatTheRest = false;\nOption currentOption = null;\n\nfor (int i = 0; i < arguments.length; i++)\n{\nif (\"--\".equals(arguments[i]))\n{\neatTheRest = true;\ntokens.add(\"--\");\n}\nelse if (\"-\".equals(arguments[i]))\n{\ntokens.add(\"-\");\n}\nelse if (arguments[i].startsWith(\"-\"))\n{\nOption option = options.getOption(arguments[i]);\n\n// this is not an Option\nif (option == null)\n{\n// handle special properties Option\nOption specialOption =\noptions.getOption(arguments[i].substring(0, 2));\n\nif (specialOption != null)\n{\ntokens.add(arguments[i].substring(0, 2));\ntokens.add(arguments[i].substring(2));\n}\nelse if (stopAtNonOption)\n{\neatTheRest = true;\ntokens.add(arguments[i]);\n}\nelse\n{\ntokens.add(arguments[i]);\n}\n}\nelse\n{\n// WARNING: Findbugs reports major problems with the following code.\n//          As option cannot be null, currentOption cannot and\n//          much of the code below is never going to be run.\n\ncurrentOption = option;\n\n// special option\nOption specialOption =\noptions.getOption(arguments[i].substring(0, 2));\n\nif ((specialOption != null) && (option == null))\n{\ntokens.add(arguments[i].substring(0, 2));\ntokens.add(arguments[i].substring(2));\n}\nelse if ((currentOption != null) && currentOption.hasArg())\n{\nif (currentOption.hasArg())\n{\ntokens.add(arguments[i]);\ncurrentOption = null;\n}\nelse if (currentOption.hasArgs())\n{\ntokens.add(arguments[i]);\n}\nelse if (stopAtNonOption)\n{\neatTheRest = true;\ntokens.add(\"--\");\ntokens.add(arguments[i]);\n}\nelse\n{\ntokens.add(arguments[i]);\n}\n}\nelse if (currentOption != null)\n{\ntokens.add(arguments[i]);\n}\nelse if (stopAtNonOption)\n{\neatTheRest = true;\ntokens.add(\"--\");\ntokens.add(arguments[i]);\n}\nelse\n{\ntokens.add(arguments[i]);\n}\n}\n}\nelse\n{\ntokens.add(arguments[i]);\n}\n\nif (eatTheRest)\n{\nfor (i++; i < arguments.length; i++)\n{\ntokens.add(arguments[i]);\n}\n}\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 11,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.HelpFormatterTest.testPrintOptionWithEmptyArgNameUsage",
                            "test_body": "public void testPrintOptionWithEmptyArgNameUsage() {\nOption option = new Option(\"f\", true, null);\noption.setArgName(\"\");\noption.setRequired(true);\nOptions options = new Options();\noptions.addOption(option);\nStringWriter out = new StringWriter();\nHelpFormatter formatter = new HelpFormatter();\nformatter.printUsage(new PrintWriter(out), 80, \"app\", options);\nassertEquals(\"usage: app -f\" + EOL, out.toString());\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\nreturn Collections.unmodifiableCollection(helpOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nList opts = new ArrayList(shortOpts.values());\n\n// now look through the long opts to see if there are any Long-opt\n// only options\nIterator iter = longOpts.values().iterator();\n\nwhile (iter.hasNext())\n{\nObject item = iter.next();\n\nif (!opts.contains(item))\n{\nopts.add(item);\n}\n}\n\nreturn new ArrayList(opts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, hasArg, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getArgName()Ljava/lang/String;",
                                    "method_body": "public String getArgName()\n{\nreturn this.argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:getOptionComparator()Ljava/util/Comparator;",
                                    "method_body": "public Comparator getOptionComparator()\n{\nreturn this.optionComparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printUsage(Ljava/io/PrintWriter;ILjava/lang/String;Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "public void printUsage(PrintWriter pw, int width, String app,\nOptions options)\n{\n// initialise the string buffer\nStringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app)\n.append(\" \");\n\n// create a list for processed option groups\nfinal Collection processedGroups = new ArrayList();\n\n// temp variable\nOption option;\n\nList optList = new ArrayList(options.getOptions());\nCollections.sort(optList, getOptionComparator() );\n// iterate over the options\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\n// get the next Option\noption = (Option) i.next();\n\n// check if the option is part of an OptionGroup\nOptionGroup group = options.getOptionGroup(option);\n\n// if the option is part of a group\nif (group != null)\n{\n// and if the group has not already been processed\nif (!processedGroups.contains(group))\n{\n// add the group to the processed list\nprocessedGroups.add(group);\n\n\n// add the usage clause\nappendOptionGroup(buff, group);\n}\n\n// otherwise the option was displayed in the group\n// previously so ignore it.\n}\n\n// if the Option is not part of an OptionGroup\nelse\n{\nappendOption(buff, option, option.isRequired());\n}\n\nif (i.hasNext())\n{\nbuff.append(\" \");\n}\n}\n\n\n// call printWrapped\nprintWrapped(pw, width, buff.toString().indexOf(' ') + 1,\nbuff.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:appendOption(Ljava/lang/StringBuffer;Lorg/apache/commons/cli/Option;Z)V",
                                    "method_body": "private static void appendOption(final StringBuffer buff,\nfinal Option option,\nfinal boolean required)\n{\nif (!required)\n{\nbuff.append(\"[\");\n}\n\nif (option.getOpt() != null)\n{\nbuff.append(\"-\").append(option.getOpt());\n}\nelse\n{\nbuff.append(\"--\").append(option.getLongOpt());\n}\n\n// if the Option has a value\nif (option.hasArg() && (option.getArgName() != null))\n{\nbuff.append(\" <\").append(option.getArgName()).append(\">\");\n}\n\n// if the Option is not a required option\nif (!required)\n{\nbuff.append(\"]\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printWrapped(Ljava/io/PrintWriter;IILjava/lang/String;)V",
                                    "method_body": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop,\nString text)\n{\nStringBuffer sb = new StringBuffer(text.length());\n\nrenderWrappedText(sb, width, nextLineTabStop, text);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderWrappedText(Ljava/lang/StringBuffer;IILjava/lang/String;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderWrappedText(StringBuffer sb, int width,\nint nextLineTabStop, String text)\n{\nint pos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(rtrim(text));\n\nreturn sb;\n}\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n// all following lines must be padded with nextLineTabStop space\n// characters\nfinal String padding = createPadding(nextLineTabStop);\n\nwhile (true)\n{\ntext = padding + text.substring(pos).trim();\npos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(text);\n\nreturn sb;\n}\n\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:findWrapPos(Ljava/lang/String;II)I",
                                    "method_body": "protected int findWrapPos(String text, int width, int startPos)\n{\nint pos = -1;\n\n// the line ends before the max wrap pos or a new line char found\nif (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n|| ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n{\nreturn pos+1;\n}\nelse if ((startPos + width) >= text.length())\n{\nreturn -1;\n}\n\n\n// look for the last whitespace character before startPos+width\npos = startPos + width;\n\nchar c;\n\nwhile ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n--pos;\n}\n\n// if we found it - just return\nif (pos > startPos)\n{\nreturn pos;\n}\n\n// must look for the first whitespace chearacter after startPos\n// + width\npos = startPos + width;\n\nwhile ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n++pos;\n}\n\nreturn (pos == text.length())        ? (-1) : pos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:rtrim(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "protected String rtrim(String s)\n{\nif ((s == null) || (s.length() == 0))\n{\nreturn s;\n}\n\nint pos = s.length();\n\nwhile ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n{\n--pos;\n}\n\nreturn s.substring(0, pos);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 12,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.GnuParserTest.testShortWithEqual",
                            "test_body": "public void testShortWithEqual() throws Exception\n{\nString[] args = new String[] { \"-f=bar\" };\nOptions options = new Options();\noptions.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\nParser parser = new GnuParser();\nCommandLine cl = parser.parse(options, args);\nassertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null) {\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nif (str.startsWith(\"\\\"\")) {\nstr = str.substring(1, str.length());\n}\nif (str.endsWith(\"\\\"\")) {\nstr = str.substring(0, str.length()-1);\n}\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg,\nString description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt)\nthrows IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn (this.valuesep > 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
                                    "method_body": "void addValueForProcessing(String value)\n{\nswitch (numberOfArgs)\n{\ncase UNINITIALIZED:\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n\ndefault:\nprocessValue(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == (numberOfArgs - 1))\n{\nbreak;\n}\n\n\n// store\nadd(value.substring(0, index));\n\n\n// parse\nvalue = value.substring(index + 1);\n\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif ((numberOfArgs > 0) && (values.size() > (numberOfArgs - 1)))\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n\n// store value\nthis.values.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues()\n? null : (String[]) this.values.toArray(new String[this.values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn this.values.size() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hashCode()I",
                                    "method_body": "public int hashCode()\n{\nint result;\nresult = ( opt != null ? opt.hashCode() : 0 );\nresult = 31 * result + ( longOpt != null ? longOpt.hashCode() : 0 );\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options) {\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions() {\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions() {\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(),\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (getRequiredOptions().size() > 0)\n{\nIterator iter = getRequiredOptions().iterator();\nStringBuffer buff = new StringBuffer(\"Missing required option\");\nbuff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\nbuff.append(\": \");\n\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\nbuff.append(\", \");\n}\n\nthrow new MissingOptionException(buff.substring(0, buff.length() - 2));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(Option opt, ListIterator iter)\nthrows ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nString str = (String) iter.next();\n\n// found an Option, not an argument\nif (getOptions().hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n}\ncatch (RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif ((opt.getValues() == null) && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(\"Missing argument for option:\"\n+ opt.getKey());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \"\n+ arg);\n}\n\n// get the option represented by arg\nfinal Option opt = getOptions().getOption(arg);\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(String opt)\n{\nString[] values = getOptionValues(opt);\n\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Ljava/lang/String;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(String opt)\n{\nOption key = resolveOption( opt );\n\nif (options.contains(key))\n{\nreturn key.getValues();\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption( String opt )\n{\nopt = Util.stripLeadingHyphens(opt);\nfor ( Iterator it = options.iterator(); it.hasNext(); )\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\nif (opt.equals( option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.GnuParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\nList tokens = new ArrayList();\n\nboolean eatTheRest = false;\n\nfor (int i = 0; i < arguments.length; i++)\n{\nString arg = arguments[i];\n\nif (\"--\".equals(arg))\n{\neatTheRest = true;\ntokens.add(\"--\");\n}\nelse if (\"-\".equals(arg))\n{\ntokens.add(\"-\");\n}\nelse if (arg.startsWith(\"-\"))\n{\nString opt = Util.stripLeadingHyphens(arg);\n\nif (options.hasOption(opt))\n{\ntokens.add(arg);\n}\nelse\n{\nif (options.hasOption(arg.substring(0, 2)))\n{\n// the format is --foo=value or -foo=value\n// the format is a special properties option (-Dproperty=value)\ntokens.add(arg.substring(0, 2)); // -D\ntokens.add(arg.substring(2)); // property=value\n}\nelse\n{\neatTheRest = stopAtNonOption;\ntokens.add(arg);\n}\n}\n}\nelse\n{\ntokens.add(arg);\n}\n\nif (eatTheRest)\n{\nfor (i++; i < arguments.length; i++)\n{\ntokens.add(arguments[i]);\n}\n}\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.GnuParserTest.testLongWithEqual",
                            "test_body": "public void testLongWithEqual() throws Exception\n{\nString[] args = new String[] { \"--foo=bar\" };\nOptions options = new Options();\noptions.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\nParser parser = new GnuParser();\nCommandLine cl = parser.parse(options, args);\nassertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null) {\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg,\nString description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt)\nthrows IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options) {\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions() {\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(),\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \"\n+ arg);\n}\n\n// get the option represented by arg\nfinal Option opt = getOptions().getOption(arg);\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.GnuParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\nList tokens = new ArrayList();\n\nboolean eatTheRest = false;\n\nfor (int i = 0; i < arguments.length; i++)\n{\nString arg = arguments[i];\n\nif (\"--\".equals(arg))\n{\neatTheRest = true;\ntokens.add(\"--\");\n}\nelse if (\"-\".equals(arg))\n{\ntokens.add(\"-\");\n}\nelse if (arg.startsWith(\"-\"))\n{\nString opt = Util.stripLeadingHyphens(arg);\n\nif (options.hasOption(opt))\n{\ntokens.add(arg);\n}\nelse\n{\nif (options.hasOption(arg.substring(0, 2)))\n{\n// the format is --foo=value or -foo=value\n// the format is a special properties option (-Dproperty=value)\ntokens.add(arg.substring(0, 2)); // -D\ntokens.add(arg.substring(2)); // property=value\n}\nelse\n{\neatTheRest = stopAtNonOption;\ntokens.add(arg);\n}\n}\n}\nelse\n{\ntokens.add(arg);\n}\n\nif (eatTheRest)\n{\nfor (i++; i < arguments.length; i++)\n{\ntokens.add(arguments[i]);\n}\n}\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.UnrecognizedOptionException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public UnrecognizedOptionException(String message)\n{\nsuper(message);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.GnuParserTest.testLongWithEqualSingleDash",
                            "test_body": "public void testLongWithEqualSingleDash() throws Exception\n{\nString[] args = new String[] { \"-foo=bar\" };\nOptions options = new Options();\noptions.addOption(OptionBuilder.withLongOpt(\"foo\").hasArg().create('f'));\nParser parser = new GnuParser();\nCommandLine cl = parser.parse(options, args);\nassertEquals(\"bar\", cl.getOptionValue(\"foo\"));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null) {\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nif (str.startsWith(\"\\\"\")) {\nstr = str.substring(1, str.length());\n}\nif (str.endsWith(\"\\\"\")) {\nstr = str.substring(0, str.length()-1);\n}\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg,\nString description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt)\nthrows IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt)\nthrows IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn (this.valuesep > 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
                                    "method_body": "void addValueForProcessing(String value)\n{\nswitch (numberOfArgs)\n{\ncase UNINITIALIZED:\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n\ndefault:\nprocessValue(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == (numberOfArgs - 1))\n{\nbreak;\n}\n\n\n// store\nadd(value.substring(0, index));\n\n\n// parse\nvalue = value.substring(index + 1);\n\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif ((numberOfArgs > 0) && (values.size() > (numberOfArgs - 1)))\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n\n// store value\nthis.values.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues()\n? null : (String[]) this.values.toArray(new String[this.values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn this.values.size() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hashCode()I",
                                    "method_body": "public int hashCode()\n{\nint result;\nresult = ( opt != null ? opt.hashCode() : 0 );\nresult = 31 * result + ( longOpt != null ? longOpt.hashCode() : 0 );\nreturn result;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options) {\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions() {\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions() {\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(),\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (getRequiredOptions().size() > 0)\n{\nIterator iter = getRequiredOptions().iterator();\nStringBuffer buff = new StringBuffer(\"Missing required option\");\nbuff.append(getRequiredOptions().size() == 1 ? \"\" : \"s\");\nbuff.append(\": \");\n\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\nbuff.append(\", \");\n}\n\nthrow new MissingOptionException(buff.substring(0, buff.length() - 2));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(Option opt, ListIterator iter)\nthrows ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nString str = (String) iter.next();\n\n// found an Option, not an argument\nif (getOptions().hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n}\ncatch (RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif ((opt.getValues() == null) && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(\"Missing argument for option:\"\n+ opt.getKey());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \"\n+ arg);\n}\n\n// get the option represented by arg\nfinal Option opt = getOptions().getOption(arg);\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(String opt)\n{\nString[] values = getOptionValues(opt);\n\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Ljava/lang/String;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(String opt)\n{\nOption key = resolveOption( opt );\n\nif (options.contains(key))\n{\nreturn key.getValues();\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption( String opt )\n{\nopt = Util.stripLeadingHyphens(opt);\nfor ( Iterator it = options.iterator(); it.hasNext(); )\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\nif (opt.equals( option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.GnuParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\nList tokens = new ArrayList();\n\nboolean eatTheRest = false;\n\nfor (int i = 0; i < arguments.length; i++)\n{\nString arg = arguments[i];\n\nif (\"--\".equals(arg))\n{\neatTheRest = true;\ntokens.add(\"--\");\n}\nelse if (\"-\".equals(arg))\n{\ntokens.add(\"-\");\n}\nelse if (arg.startsWith(\"-\"))\n{\nString opt = Util.stripLeadingHyphens(arg);\n\nif (options.hasOption(opt))\n{\ntokens.add(arg);\n}\nelse\n{\nif (options.hasOption(arg.substring(0, 2)))\n{\n// the format is --foo=value or -foo=value\n// the format is a special properties option (-Dproperty=value)\ntokens.add(arg.substring(0, 2)); // -D\ntokens.add(arg.substring(2)); // property=value\n}\nelse\n{\neatTheRest = stopAtNonOption;\ntokens.add(arg);\n}\n}\n}\nelse\n{\ntokens.add(arg);\n}\n\nif (eatTheRest)\n{\nfor (i++; i < arguments.length; i++)\n{\ntokens.add(arguments[i]);\n}\n}\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 13,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli2.bug.BugLoopingOptionLookAlikeTest.testLoopingOptionLookAlike2",
                            "test_body": "public void testLoopingOptionLookAlike2() {\nfinal ArgumentBuilder abuilder = new ArgumentBuilder();\nfinal GroupBuilder gbuilder = new GroupBuilder();\nfinal Argument inputfile_opt = abuilder.withName(\"input\").withMinimum(1).withMaximum(1).create();\nfinal Argument outputfile_opt = abuilder.withName(\"output\").withMinimum(1).withMaximum(1).create();\nfinal Argument targets = new SourceDestArgument(inputfile_opt, outputfile_opt);\nfinal Group options = gbuilder.withOption(targets).create();\nfinal Parser parser = new Parser();\nparser.setGroup(options);\ntry {\nparser.parse(new String[] { \"testfile.txt\", \"testfile.txt\", \"testfile.txt\", \"testfile.txt\" });\nfail(\"OptionException\");\n} catch (OptionException e) {\nassertEquals(\"Unexpected testfile.txt while processing \", e.getMessage());\n}\n}    \n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<init>()V",
                                    "method_body": "public ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<clinit>()V",
                                    "method_body": "private final static ResourceHelper resources = ResourceHelper.getResourceHelper();\n\n/** name of the argument. Used for display and lookups in CommandLine */\nprivate String name;\n\n/** description of the argument. Used in the automated online help */\nprivate String description;\n\n/** minimum number of values required */\nprivate int minimum;\n\n/** maximum number of values permitted */\nprivate int maximum;\n\n/** character used to separate the values from the option */\nprivate char initialSeparator;\n\n/** character used to separate the values from each other */\nprivate char subsequentSeparator;\n\n/** object that should be used to ensure the values are valid */\nprivate Validator validator;\n\n/** used to identify the consume remaining option, typically \"--\" */\nprivate String consumeRemaining;\n\n/** default values for argument */\nprivate List defaultValues;\n\n/** id of the argument */\nprivate int id;\n\n/**\n* Creates a new ArgumentBuilder instance\n*/\npublic ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:create()Lorg/apache/commons/cli2/Argument;",
                                    "method_body": "public final Argument create() {\nfinal Argument argument =\nnew ArgumentImpl(\nname,\ndescription,\nminimum,\nmaximum,\ninitialSeparator,\nsubsequentSeparator,\nvalidator,\nconsumeRemaining,\ndefaultValues,\nid);\n\nreset();\n\nreturn argument;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:reset()Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder reset() {\nname = \"arg\";\ndescription = null;\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\ninitialSeparator = ArgumentImpl.DEFAULT_INITIAL_SEPARATOR;\nsubsequentSeparator = ArgumentImpl.DEFAULT_SUBSEQUENT_SEPARATOR;\nvalidator = null;\nconsumeRemaining = \"--\";\ndefaultValues = null;\nid = 0;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withName(final String newName) {\nif (newName == null) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_NAME));\n}\nif (\"\".equals(newName)) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_NAME));\n}\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withMinimum(I)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withMinimum(final int newMinimum) {\nif (newMinimum < 0) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MINIMUM));\n}\nthis.minimum = newMinimum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withMaximum(I)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withMaximum(final int newMaximum) {\nif (newMaximum < 0) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MAXIMUM));\n}\nthis.maximum = newMaximum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getMessage(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String getMessage(final String key,\nfinal Object value) {\nreturn getMessage(key, new Object[] { value });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getMessage(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String getMessage(final String key,\nfinal Object[] values) {\nfinal String msgFormatStr = bundle.getString(key);\nfinal MessageFormat msgFormat = new MessageFormat(msgFormatStr);\n\nreturn msgFormat.format(values);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = 0;\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn Collections.EMPTY_SET;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(WriteableCommandLine commandLine,\nListIterator args)\nthrows OptionException {\nprocessValues(commandLine, args, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn Collections.EMPTY_SET;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\nvalidate(commandLine, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine,\nfinal Option option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nif (values.size() < minimum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n}\n\nif (values.size() > maximum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n(String) values.get(maximum));\n}\n\nif (validator != null) {\ntry {\nvalidator.validate(values);\n} catch (InvalidArgumentException ive) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nive.getMessage());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display the outer optionality\nfinal boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n// allow numbering if multiple args\nfinal boolean numbered =\n(maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n\nfinal boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n\n// if infinite args are allowed then crop the list\nfinal int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n\nint i = 0;\n\n// for each argument\nwhile (i < max) {\n// if we're past the first add a space\nif (i > 0) {\nbuffer.append(' ');\n}\n\n// if the next arg is optional\nif ((i >= minimum) && (optional || (i > 0))) {\nbuffer.append('[');\n}\n\nif (bracketed) {\nbuffer.append('<');\n}\n\n// add name\nbuffer.append(name);\n++i;\n\n// if numbering\nif (numbered) {\nbuffer.append(i);\n}\n\nif (bracketed) {\nbuffer.append('>');\n}\n}\n\n// if infinite args are allowed\nif (maximum == Integer.MAX_VALUE) {\n// append elipsis\nbuffer.append(\" ...\");\n}\n\n// for each argument\nwhile (i > 0) {\n--i;\n\n// if the next arg is optional\nif ((i >= minimum) && (optional || (i > 0))) {\nbuffer.append(']');\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getMaximum()I",
                                    "method_body": "public int getMaximum() {\nreturn maximum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getMinimum()I",
                                    "method_body": "public int getMinimum() {\nreturn minimum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\ndefaultValues(commandLine, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum) {\nsuper(0, false);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (commandLine.looksLikeOption(arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (commandLine.looksLikeOption(arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\n// number of options found\nint present = 0;\n\n// reference to first unexpected option\nOption unexpected = null;\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// if the child option is required then validate it\nif (option.isRequired()) {\noption.validate(commandLine);\n}\n\nif (option instanceof Group) {\noption.validate(commandLine);\n}\n\n// if the child option is present then validate it\nif (commandLine.hasOption(option)) {\nif (++present > maximum) {\nunexpected = option;\n\nbreak;\n}\n\noption.validate(commandLine);\n}\n}\n\n// too many options\nif (unexpected != null) {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\nunexpected.getPreferredName());\n}\n\n// too few option\nif (present < minimum) {\nthrow new OptionException(this, ResourceConstants.MISSING_OPTION);\n}\n\n// validate each anonymous argument\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.validate(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guarenteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guarenteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object that) {\nif (that instanceof DisplaySetting) {\nreturn name.compareTo(that.toString()) == 0;\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:<init>(Lorg/apache/commons/cli2/Option;Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public OptionException(final Option option,\nfinal String messageKey,\nfinal String value) {\nthis.option = option;\n\nif (messageKey != null) {\nfinal StringBuffer buffer = new StringBuffer();\n\nif (value != null) {\nbuffer.append(helper.getMessage(messageKey, value));\n} else {\nbuffer.append(helper.getMessage(messageKey));\n}\n\nbuffer.append(\" \");\n\noption.appendUsage(buffer, HELP_SETTINGS, null);\nmessage = buffer.toString();\n} else {\nmessage = \"\";\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:<clinit>()V",
                                    "method_body": "public static final Set HELP_SETTINGS =\nCollections.unmodifiableSet(Collections.singleton(DisplaySetting.DISPLAY_PROPERTY_OPTION));\n\n/** resource helper instance */\nprivate static final ResourceHelper helper = ResourceHelper.getResourceHelper();\n\n/** The Option the exception relates to */\nprivate final Option option;\n\n/** The message explaining the Exception */\nprivate final String message;\n\n/**\n* Creates a new OptionException.\n*\n* @param option\n*            The Option the exception relates to\n*/\npublic OptionException(final Option option) {\nthis(option, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:getMessage()Ljava/lang/String;",
                                    "method_body": "public String getMessage() {\nreturn message;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public final boolean hasOption(final String trigger) {\nreturn hasOption(getOption(trigger));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final Option option) {\nreturn getValues(option, Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addValue(Lorg/apache/commons/cli2/Option;Ljava/lang/Object;)V",
                                    "method_body": "public void addValue(final Option option,\nfinal Object value) {\nif (option instanceof Argument) {\naddOption(option);\n}\n\nList valueList = (List) values.get(option);\n\nif (valueList == null) {\nvalueList = new ArrayList();\nvalues.put(option, valueList);\n}\n\nvalueList.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:hasOption(Lorg/apache/commons/cli2/Option;)Z",
                                    "method_body": "public boolean hasOption(final Option option) {\nfinal boolean present = options.contains(option);\n\nreturn present;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOption(Ljava/lang/String;)Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getOption(final String trigger) {\nreturn (Option) nameToOption.get(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List getValues(final Option option,\nfinal List defaultValues) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Secondly try the defaults supplied to the method\nif ((valueList == null) || valueList.isEmpty()) {\nvalueList = defaultValues;\n}\n\n// Thirdly try the option's default values\nif ((valueList == null) || valueList.isEmpty()) {\nvalueList = (List) this.defaultValues.get(option);\n}\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.SourceDestArgument:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Argument;)V",
                                    "method_body": "public SourceDestArgument(final Argument source,\nfinal Argument dest) {\nthis(source, dest, DEFAULT_INITIAL_SEPARATOR, DEFAULT_SUBSEQUENT_SEPARATOR,\nDEFAULT_CONSUME_REMAINING, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.SourceDestArgument:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Argument;CCLjava/lang/String;Ljava/util/List;)V",
                                    "method_body": "public SourceDestArgument(final Argument source,\nfinal Argument dest,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal String consumeRemaining,\nfinal List defaultValues) {\nsuper(\"SourceDestArgument\", null, sum(source.getMinimum(), dest.getMinimum()),\nsum(source.getMaximum(), dest.getMaximum()), initialSeparator, subsequentSeparator,\nnull, consumeRemaining, defaultValues, 0);\n\nthis.source = source;\nthis.dest = dest;\n\nif (dest.getMinimum() != dest.getMaximum()) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SOURCE_DEST_MUST_ENFORCE_VALUES));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.SourceDestArgument:sum(II)I",
                                    "method_body": "private static int sum(final int a,\nfinal int b) {\nreturn Math.max(a, Math.max(b, a + b));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.SourceDestArgument:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine,\nOption option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nfinal int limit = values.size() - dest.getMinimum();\nint count = 0;\n\nfinal Iterator i = values.iterator();\n\nwhile (count++ < limit) {\ncommandLine.addValue(source, i.next());\n}\n\nwhile (i.hasNext()) {\ncommandLine.addValue(dest, i.next());\n}\n\nsource.validate(commandLine, source);\ndest.validate(commandLine, dest);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.SourceDestArgument:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nreturn source.canProcess(commandLine, arg) || dest.canProcess(commandLine, arg);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 14,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli2.bug.BugCLI144Test.testFileValidator",
                            "test_body": "public void testFileValidator() {\nfinal DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\nfinal ArgumentBuilder abuilder = new ArgumentBuilder();\nfinal GroupBuilder gbuilder = new GroupBuilder();\nDefaultOption fileNameOption = obuilder.withShortName(\"f\")\n.withLongName(\"file-name\").withRequired(true).withDescription(\n\"name of an existing file\").withArgument(\nabuilder.withName(\"file-name\").withValidator(\nFileValidator.getExistingFileInstance())\n.create()).create();\nGroup options = gbuilder.withName(\"options\").withOption(fileNameOption)\n.create();\nParser parser = new Parser();\nparser.setHelpTrigger(\"--help\");\nparser.setGroup(options);\nfinal String fileName = \"src/test/org/apache/commons/cli2/bug/BugCLI144Test.java\";\nCommandLine cl = parser\n.parseAndHelp(new String[] { \"--file-name\", fileName });\nassertNotNull(cl);\nassertEquals(\"Wrong file\", new File(fileName), cl.getValue(fileNameOption));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object thatObj) {\nif (thatObj instanceof OptionImpl) {\nfinal OptionImpl that = (OptionImpl) thatObj;\n\nreturn (getId() == that.getId()) &&\nequals(getPreferredName(), that.getPreferredName()) &&\nequals(getDescription(), that.getDescription()) &&\nequals(getPrefixes(), that.getPrefixes()) &&\nequals(getTriggers(), that.getTriggers());\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "private boolean equals(Object left,\nObject right) {\nif ((left == null) && (right == null)) {\nreturn true;\n} else if ((left == null) || (right == null)) {\nreturn false;\n} else {\nreturn left.equals(right);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefixes(Ljava/util/Set;)V",
                                    "method_body": "protected void checkPrefixes(final Set prefixes) {\n// nothing to do if empty prefix list\nif (prefixes.isEmpty()) {\nreturn;\n}\n\n// check preferred name\ncheckPrefix(prefixes, getPreferredName());\n\n// check triggers\nthis.getTriggers();\n\nfor (final Iterator i = getTriggers().iterator(); i.hasNext();) {\ncheckPrefix(prefixes, (String) i.next());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefix(Ljava/util/Set;Ljava/lang/String;)V",
                                    "method_body": "private void checkPrefix(final Set prefixes,\nfinal String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nString prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn;\n}\n}\n\nfinal ResourceHelper helper = ResourceHelper.getResourceHelper();\nfinal String message =\nhelper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\nprefixes.toString());\nthrow new IllegalArgumentException(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;Ljava/lang/String;IZ)V",
                                    "method_body": "protected ParentImpl(final Argument argument,\nfinal Group children,\nfinal String description,\nfinal int id,\nfinal boolean required) {\nsuper(id, required);\nthis.children = children;\nthis.argument = argument;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nif (argument != null) {\nhandleInitialSeparator(arguments, argument.getInitialSeparator());\n}\n\nprocessParent(commandLine, arguments);\n\nif (argument != null) {\nargument.processValues(commandLine, arguments, this);\n}\n\nif ((children != null) && children.canProcess(commandLine, arguments)) {\nchildren.process(commandLine, arguments);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (commandLine.hasOption(this)) {\nif (argument != null) {\nargument.validate(commandLine, this);\n}\n\nif (children != null) {\nchildren.validate(commandLine);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:handleInitialSeparator(Ljava/util/ListIterator;C)V",
                                    "method_body": "private void handleInitialSeparator(final ListIterator arguments,\nfinal char separator) {\n// next token\nfinal String newArgument = (String) arguments.next();\n\n// split the token\nfinal int initialIndex = newArgument.indexOf(separator);\n\nif (initialIndex > 0) {\narguments.remove();\narguments.add(newArgument.substring(0, initialIndex));\nString value = newArgument.substring(initialIndex + 1);\n// The value obviously isn't an option, so we need to quote it if looks like an option.\n// The quotes will be removed later\nif (value.startsWith(\"-\")) {\nvalue = '\"' + value + '\"';\n}\narguments.add(value);\narguments.previous();\n}\n\narguments.previous();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nif (argument != null) {\nargument.defaultValues(commandLine, this);\n}\n\nif (children != null) {\nchildren.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<init>()V",
                                    "method_body": "public ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<clinit>()V",
                                    "method_body": "private final static ResourceHelper resources = ResourceHelper.getResourceHelper();\n\n/** name of the argument. Used for display and lookups in CommandLine */\nprivate String name;\n\n/** description of the argument. Used in the automated online help */\nprivate String description;\n\n/** minimum number of values required */\nprivate int minimum;\n\n/** maximum number of values permitted */\nprivate int maximum;\n\n/** character used to separate the values from the option */\nprivate char initialSeparator;\n\n/** character used to separate the values from each other */\nprivate char subsequentSeparator;\n\n/** object that should be used to ensure the values are valid */\nprivate Validator validator;\n\n/** used to identify the consume remaining option, typically \"--\" */\nprivate String consumeRemaining;\n\n/** default values for argument */\nprivate List defaultValues;\n\n/** id of the argument */\nprivate int id;\n\n/**\n* Creates a new ArgumentBuilder instance\n*/\npublic ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:create()Lorg/apache/commons/cli2/Argument;",
                                    "method_body": "public final Argument create() {\nfinal Argument argument =\nnew ArgumentImpl(\nname,\ndescription,\nminimum,\nmaximum,\ninitialSeparator,\nsubsequentSeparator,\nvalidator,\nconsumeRemaining,\ndefaultValues,\nid);\n\nreset();\n\nreturn argument;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:reset()Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder reset() {\nname = \"arg\";\ndescription = null;\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\ninitialSeparator = ArgumentImpl.DEFAULT_INITIAL_SEPARATOR;\nsubsequentSeparator = ArgumentImpl.DEFAULT_SUBSEQUENT_SEPARATOR;\nvalidator = null;\nconsumeRemaining = \"--\";\ndefaultValues = null;\nid = 0;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withName(final String newName) {\nif (newName == null) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_NAME));\n}\nif (\"\".equals(newName)) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_NAME));\n}\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withValidator(Lorg/apache/commons/cli2/validation/Validator;)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withValidator(final Validator newValidator) {\nif (newValidator == null) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_VALIDATOR));\n}\nthis.validator = newValidator;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = commandLine.getUndefaultedValues(option).size();\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getInitialSeparator()C",
                                    "method_body": "public char getInitialSeparator() {\nreturn this.initialSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine,\nfinal Option option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nif (values.size() < minimum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n}\n\nif (values.size() > maximum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n(String) values.get(maximum));\n}\n\nif (validator != null) {\ntry {\nvalidator.validate(values);\n} catch (InvalidArgumentException ive) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nive.getMessage());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>()V",
                                    "method_body": "public DefaultOptionBuilder() {\nthis(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\nDefaultOption.DEFAULT_BURST_ENABLED);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
                                    "method_body": "public DefaultOptionBuilder(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled)\nthrows IllegalArgumentException {\nif ((shortPrefix == null) || (shortPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n}\n\nif ((longPrefix == null) || (longPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n}\n\nthis.shortPrefix = shortPrefix;\nthis.longPrefix = longPrefix;\nthis.burstEnabled = burstEnabled;\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:create()Lorg/apache/commons/cli2/option/DefaultOption;",
                                    "method_body": "public DefaultOption create()\nthrows IllegalStateException {\nif (preferredName == null) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n}\n\nfinal DefaultOption option =\nnew DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\naliases, burstAliases, required, argument, children, id);\n\nreset();\n\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:reset()Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder reset() {\npreferredName = null;\ndescription = null;\naliases = new HashSet();\nburstAliases = new HashSet();\nrequired = false;\nargument = null;\nchildren = null;\nid = 0;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withShortName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withShortName(final String shortName) {\nfinal String name = shortPrefix + shortName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nif (burstEnabled && (name.length() == (shortPrefix.length() + 1))) {\nburstAliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withLongName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withLongName(final String longName) {\nfinal String name = longPrefix + longName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withDescription(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withDescription(final String newDescription) {\nthis.description = newDescription;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withRequired(Z)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withRequired(final boolean newRequired) {\nthis.required = newRequired;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withArgument(Lorg/apache/commons/cli2/Argument;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withArgument(final Argument newArgument) {\nthis.argument = newArgument;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/util/Set;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public DefaultOption(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled,\nfinal String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal Set burstAliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\nthis.shortPrefix = shortPrefix;\nthis.burstEnabled = burstEnabled;\n\nthis.burstLength = shortPrefix.length() + 1;\n\nthis.preferredName = preferredName;\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\nthis.burstAliases =\n(burstAliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(burstAliases));\n\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nnewTriggers.addAll(this.burstAliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n\nfinal Set newPrefixes = new HashSet(super.getPrefixes());\nnewPrefixes.add(shortPrefix);\nnewPrefixes.add(longPrefix);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n\ncheckPrefixes(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(WriteableCommandLine commandLine,\nListIterator arguments)\nthrows OptionException {\nfinal String argument = (String) arguments.next();\n\nif (triggers.contains(argument)) {\ncommandLine.addOption(this);\narguments.set(preferredName);\n} else if (burstEnabled && (argument.length() >= burstLength)) {\nfinal String burst = argument.substring(0, burstLength);\n\nif (burstAliases.contains(burst)) {\ncommandLine.addOption(this);\n\n//HMM test bursting all vs bursting one by one.\narguments.set(preferredName);\n\nif (getArgument() == null) {\narguments.add(shortPrefix + argument.substring(burstLength));\n} else {\narguments.add(argument.substring(burstLength));\n}\n\narguments.previous();\n} else {\nthrow new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n}\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withName(final String newName) {\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum) {\nsuper(0, false);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (commandLine.looksLikeOption(arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (commandLine.looksLikeOption(arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\n// number of options found\nint present = 0;\n\n// reference to first unexpected option\nOption unexpected = null;\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// needs validation?\nboolean validate = option.isRequired() || option instanceof Group;\nif (validate) {\noption.validate(commandLine);\n}\n\n// if the child option is present then validate it\nif (commandLine.hasOption(option)) {\nif (++present > maximum) {\nunexpected = option;\n\nbreak;\n}\n\noption.validate(commandLine);\n}\n}\n\n// too many options\nif (unexpected != null) {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\nunexpected.getPreferredName());\n}\n\n// too few option\nif (present < minimum) {\nthrow new OptionException(this, ResourceConstants.MISSING_OPTION);\n}\n\n// validate each anonymous argument\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.validate(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guarenteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guarenteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parseAndHelp([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parseAndHelp(final String[] arguments) {\nhelpFormatter.setGroup(group);\n\ntry {\n// attempt to parse the command line\nfinal CommandLine commandLine = parse(arguments);\n\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\nreturn commandLine;\n}\n} catch (final OptionException oe) {\n// display help regarding the exception\nhelpFormatter.setException(oe);\n}\n\n// print help\nhelpFormatter.print();\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setHelpTrigger(Ljava/lang/String;)V",
                                    "method_body": "public void setHelpTrigger(final String helpTrigger) {\nthis.helpTrigger = helpTrigger;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public final boolean hasOption(final String trigger) {\nreturn hasOption(getOption(trigger));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final Option option) {\nreturn getValues(option, Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addValue(Lorg/apache/commons/cli2/Option;Ljava/lang/Object;)V",
                                    "method_body": "public void addValue(final Option option,\nfinal Object value) {\nif (option instanceof Argument) {\naddOption(option);\n}\n\nList valueList = (List) values.get(option);\n\nif (valueList == null) {\nvalueList = new ArrayList();\nvalues.put(option, valueList);\n}\n\nvalueList.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:hasOption(Lorg/apache/commons/cli2/Option;)Z",
                                    "method_body": "public boolean hasOption(final Option option) {\nfinal boolean present = options.contains(option);\n\nreturn present;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOption(Ljava/lang/String;)Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getOption(final String trigger) {\nreturn (Option) nameToOption.get(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List getValues(final Option option,\nfinal List defaultValues) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Secondly try the defaults supplied to the method\nif ((valueList == null) || valueList.isEmpty()) {\nvalueList = defaultValues;\n}\n\n// Thirdly try the option's default values\nif ((valueList == null) || valueList.isEmpty()) {\nvalueList = (List) this.defaultValues.get(option);\n}\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getUndefaultedValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public List getUndefaultedValues(Option option) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.validation.FileValidator:getExistingFileInstance()Lorg/apache/commons/cli2/validation/FileValidator;",
                                    "method_body": "public static FileValidator getExistingFileInstance() {\nfinal FileValidator validator = new FileValidator();\nvalidator.setExisting(true);\nvalidator.setFile(true);\nreturn validator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.validation.FileValidator:validate(Ljava/util/List;)V",
                                    "method_body": "public void validate(final List values) throws InvalidArgumentException {\nfor (final ListIterator i = values.listIterator(); i.hasNext();) {\nfinal String name = (String)i.next();\nfinal File f = new File(name);\n\nif ((existing && !f.exists())\n|| (file && !f.isFile())\n|| (directory && !f.isDirectory())\n|| (hidden && !f.isHidden())\n|| (readable && !f.canRead())\n|| (writable && !f.canWrite())) {\n\nthrow new InvalidArgumentException(name);\n}\n\ni.set(f);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.validation.FileValidator:setExisting(Z)V",
                                    "method_body": "public void setExisting(boolean existing) {\nthis.existing = existing;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.validation.FileValidator:setFile(Z)V",
                                    "method_body": "public void setFile(boolean file) {\nthis.file = file;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 15,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli2.bug.BugCLI158Test.testSingleOptionSingleArgument",
                            "test_body": "public void testSingleOptionSingleArgument() throws Exception {\nParser parser = createDefaultValueParser(new String[]{\"100\", \"1000\"});\nString enteredValue1 = \"1\";\nString[] args = new String[]{\"-b\", enteredValue1};\nCommandLine cl = parser.parse(args);\nCommandLine cmd = cl;\nassertNotNull(cmd);\nList b = cmd.getValues(\"-b\");\nassertEquals(\"[\" + enteredValue1 + \", 1000]\", b + \"\");\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object thatObj) {\nif (thatObj instanceof OptionImpl) {\nfinal OptionImpl that = (OptionImpl) thatObj;\n\nreturn (getId() == that.getId()) &&\nequals(getPreferredName(), that.getPreferredName()) &&\nequals(getDescription(), that.getDescription()) &&\nequals(getPrefixes(), that.getPrefixes()) &&\nequals(getTriggers(), that.getTriggers());\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "private boolean equals(Object left,\nObject right) {\nif ((left == null) && (right == null)) {\nreturn true;\n} else if ((left == null) || (right == null)) {\nreturn false;\n} else {\nreturn left.equals(right);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefixes(Ljava/util/Set;)V",
                                    "method_body": "protected void checkPrefixes(final Set prefixes) {\n// nothing to do if empty prefix list\nif (prefixes.isEmpty()) {\nreturn;\n}\n\n// check preferred name\ncheckPrefix(prefixes, getPreferredName());\n\n// check triggers\nthis.getTriggers();\n\nfor (final Iterator i = getTriggers().iterator(); i.hasNext();) {\ncheckPrefix(prefixes, (String) i.next());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefix(Ljava/util/Set;Ljava/lang/String;)V",
                                    "method_body": "private void checkPrefix(final Set prefixes,\nfinal String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nString prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn;\n}\n}\n\nfinal ResourceHelper helper = ResourceHelper.getResourceHelper();\nfinal String message =\nhelper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\nprefixes.toString());\nthrow new IllegalArgumentException(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;Ljava/lang/String;IZ)V",
                                    "method_body": "protected ParentImpl(final Argument argument,\nfinal Group children,\nfinal String description,\nfinal int id,\nfinal boolean required) {\nsuper(id, required);\nthis.children = children;\nthis.argument = argument;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nif (argument != null) {\nhandleInitialSeparator(arguments, argument.getInitialSeparator());\n}\n\nprocessParent(commandLine, arguments);\n\nif (argument != null) {\nargument.processValues(commandLine, arguments, this);\n}\n\nif ((children != null) && children.canProcess(commandLine, arguments)) {\nchildren.process(commandLine, arguments);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (commandLine.hasOption(this)) {\nif (argument != null) {\nargument.validate(commandLine, this);\n}\n\nif (children != null) {\nchildren.validate(commandLine);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:handleInitialSeparator(Ljava/util/ListIterator;C)V",
                                    "method_body": "private void handleInitialSeparator(final ListIterator arguments,\nfinal char separator) {\n// next token\nfinal String newArgument = (String) arguments.next();\n\n// split the token\nfinal int initialIndex = newArgument.indexOf(separator);\n\nif (initialIndex > 0) {\narguments.remove();\narguments.add(newArgument.substring(0, initialIndex));\nString value = newArgument.substring(initialIndex + 1);\n// The value obviously isn't an option, so we need to quote it if looks like an option.\n// The quotes will be removed later\nif (value.startsWith(\"-\")) {\nvalue = '\"' + value + '\"';\n}\narguments.add(value);\narguments.previous();\n}\n\narguments.previous();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nif (argument != null) {\nargument.defaultValues(commandLine, this);\n}\n\nif (children != null) {\nchildren.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<init>()V",
                                    "method_body": "public ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<clinit>()V",
                                    "method_body": "private final static ResourceHelper resources = ResourceHelper.getResourceHelper();\n\n/** name of the argument. Used for display and lookups in CommandLine */\nprivate String name;\n\n/** description of the argument. Used in the automated online help */\nprivate String description;\n\n/** minimum number of values required */\nprivate int minimum;\n\n/** maximum number of values permitted */\nprivate int maximum;\n\n/** character used to separate the values from the option */\nprivate char initialSeparator;\n\n/** character used to separate the values from each other */\nprivate char subsequentSeparator;\n\n/** object that should be used to ensure the values are valid */\nprivate Validator validator;\n\n/** used to identify the consume remaining option, typically \"--\" */\nprivate String consumeRemaining;\n\n/** default values for argument */\nprivate List defaultValues;\n\n/** id of the argument */\nprivate int id;\n\n/**\n* Creates a new ArgumentBuilder instance\n*/\npublic ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:create()Lorg/apache/commons/cli2/Argument;",
                                    "method_body": "public final Argument create() {\nfinal Argument argument =\nnew ArgumentImpl(\nname,\ndescription,\nminimum,\nmaximum,\ninitialSeparator,\nsubsequentSeparator,\nvalidator,\nconsumeRemaining,\ndefaultValues,\nid);\n\nreset();\n\nreturn argument;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:reset()Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder reset() {\nname = \"arg\";\ndescription = null;\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\ninitialSeparator = ArgumentImpl.DEFAULT_INITIAL_SEPARATOR;\nsubsequentSeparator = ArgumentImpl.DEFAULT_SUBSEQUENT_SEPARATOR;\nvalidator = null;\nconsumeRemaining = \"--\";\ndefaultValues = null;\nid = 0;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withName(final String newName) {\nif (newName == null) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_NAME));\n}\nif (\"\".equals(newName)) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_NAME));\n}\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withMinimum(I)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withMinimum(final int newMinimum) {\nif (newMinimum < 0) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MINIMUM));\n}\nthis.minimum = newMinimum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withMaximum(I)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withMaximum(final int newMaximum) {\nif (newMaximum < 0) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MAXIMUM));\n}\nthis.maximum = newMaximum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withDefaults(Ljava/util/List;)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withDefaults(final List newDefaultValues) {\nif (newDefaultValues == null) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_DEFAULTS));\n}\nthis.defaultValues = newDefaultValues;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = commandLine.getUndefaultedValues(option).size();\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getInitialSeparator()C",
                                    "method_body": "public char getInitialSeparator() {\nreturn this.initialSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine,\nfinal Option option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nif (values.size() < minimum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n}\n\nif (values.size() > maximum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n(String) values.get(maximum));\n}\n\nif (validator != null) {\ntry {\nvalidator.validate(values);\n} catch (InvalidArgumentException ive) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nive.getMessage());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>()V",
                                    "method_body": "public DefaultOptionBuilder() {\nthis(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\nDefaultOption.DEFAULT_BURST_ENABLED);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
                                    "method_body": "public DefaultOptionBuilder(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled)\nthrows IllegalArgumentException {\nif ((shortPrefix == null) || (shortPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n}\n\nif ((longPrefix == null) || (longPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n}\n\nthis.shortPrefix = shortPrefix;\nthis.longPrefix = longPrefix;\nthis.burstEnabled = burstEnabled;\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:create()Lorg/apache/commons/cli2/option/DefaultOption;",
                                    "method_body": "public DefaultOption create()\nthrows IllegalStateException {\nif (preferredName == null) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n}\n\nfinal DefaultOption option =\nnew DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\naliases, burstAliases, required, argument, children, id);\n\nreset();\n\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:reset()Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder reset() {\npreferredName = null;\ndescription = null;\naliases = new HashSet();\nburstAliases = new HashSet();\nrequired = false;\nargument = null;\nchildren = null;\nid = 0;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withShortName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withShortName(final String shortName) {\nfinal String name = shortPrefix + shortName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nif (burstEnabled && (name.length() == (shortPrefix.length() + 1))) {\nburstAliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withLongName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withLongName(final String longName) {\nfinal String name = longPrefix + longName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withArgument(Lorg/apache/commons/cli2/Argument;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withArgument(final Argument newArgument) {\nthis.argument = newArgument;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/util/Set;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public DefaultOption(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled,\nfinal String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal Set burstAliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\nthis.shortPrefix = shortPrefix;\nthis.burstEnabled = burstEnabled;\n\nthis.burstLength = shortPrefix.length() + 1;\n\nthis.preferredName = preferredName;\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\nthis.burstAliases =\n(burstAliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(burstAliases));\n\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nnewTriggers.addAll(this.burstAliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n\nfinal Set newPrefixes = new HashSet(super.getPrefixes());\nnewPrefixes.add(shortPrefix);\nnewPrefixes.add(longPrefix);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n\ncheckPrefixes(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(WriteableCommandLine commandLine,\nListIterator arguments)\nthrows OptionException {\nfinal String argument = (String) arguments.next();\n\nif (triggers.contains(argument)) {\ncommandLine.addOption(this);\narguments.set(preferredName);\n} else if (burstEnabled && (argument.length() >= burstLength)) {\nfinal String burst = argument.substring(0, burstLength);\n\nif (burstAliases.contains(burst)) {\ncommandLine.addOption(this);\n\n//HMM test bursting all vs bursting one by one.\narguments.set(preferredName);\n\nif (getArgument() == null) {\narguments.add(shortPrefix + argument.substring(burstLength));\n} else {\narguments.add(argument.substring(burstLength));\n}\n\narguments.previous();\n} else {\nthrow new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n}\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withName(final String newName) {\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum) {\nsuper(0, false);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (commandLine.looksLikeOption(arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (commandLine.looksLikeOption(arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\n// number of options found\nint present = 0;\n\n// reference to first unexpected option\nOption unexpected = null;\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// needs validation?\nboolean validate = option.isRequired() || option instanceof Group;\n\n// if the child option is present then validate it\nif (commandLine.hasOption(option)) {\nif (++present > maximum) {\nunexpected = option;\n\nbreak;\n}\nvalidate = true;\n}\n\nif (validate) {\noption.validate(commandLine);\n}\n}\n\n// too many options\nif (unexpected != null) {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\nunexpected.getPreferredName());\n}\n\n// too few option\nif (present < minimum) {\nthrow new OptionException(this, ResourceConstants.MISSING_OPTION);\n}\n\n// validate each anonymous argument\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.validate(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guarenteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guarenteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setHelpTrigger(Ljava/lang/String;)V",
                                    "method_body": "public void setHelpTrigger(final String helpTrigger) {\nthis.helpTrigger = helpTrigger;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public final boolean hasOption(final String trigger) {\nreturn hasOption(getOption(trigger));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Ljava/lang/String;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final String trigger) {\nreturn getValues(getOption(trigger), Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final Option option) {\nreturn getValues(option, Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addValue(Lorg/apache/commons/cli2/Option;Ljava/lang/Object;)V",
                                    "method_body": "public void addValue(final Option option,\nfinal Object value) {\nif (option instanceof Argument) {\naddOption(option);\n}\n\nList valueList = (List) values.get(option);\n\nif (valueList == null) {\nvalueList = new ArrayList();\nvalues.put(option, valueList);\n}\n\nvalueList.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:hasOption(Lorg/apache/commons/cli2/Option;)Z",
                                    "method_body": "public boolean hasOption(final Option option) {\nfinal boolean present = options.contains(option);\n\nreturn present;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOption(Ljava/lang/String;)Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getOption(final String trigger) {\nreturn (Option) nameToOption.get(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List getValues(final Option option,\nList defaultValues) {\n// initialize the return list\nList valueList = (List) values.get(option);\n\n// grab the correct default values\nif ((valueList == null) || valueList.isEmpty()) {\nvalueList = defaultValues;\n}\n\n// augment the list with the default values\nif ((valueList == null) || valueList.isEmpty()) {\nvalueList = (List) this.defaultValues.get(option);\n}\n// if there are more default values as specified, add them to\n// the list.\n// copy the list first\n\nreturn valueList == null ? Collections.EMPTY_LIST : valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getUndefaultedValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public List getUndefaultedValues(Option option) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli2.bug.BugCLI158Test.testSingleOptionMaximumNumberOfArgument",
                            "test_body": "public void testSingleOptionMaximumNumberOfArgument() throws Exception {\nString[] args = new String[]{\"-b\", \"1\", \"2\"};\nfinal ArgumentBuilder abuilder = new ArgumentBuilder();\nfinal DefaultOptionBuilder obuilder = new DefaultOptionBuilder();\nfinal GroupBuilder gbuilder = new GroupBuilder();\nDefaultOption bOption = obuilder.withShortName(\"b\")\n.withLongName(\"b\")\n.withArgument(abuilder.withName(\"b\")\n.withMinimum(2)\n.withMaximum(4)\n.withDefault(\"100\")\n.withDefault(\"1000\")\n.withDefault(\"10000\")\n.create())\n.create();\nGroup options = gbuilder\n.withName(\"options\")\n.withOption(bOption)\n.create();\nParser parser = new Parser();\nparser.setHelpTrigger(\"--help\");\nparser.setGroup(options);\nCommandLine cl = parser.parse(args);\nCommandLine cmd = cl;\nassertNotNull(cmd);\nList b = cmd.getValues(\"-b\");\nassertEquals(\"[1, 2, 10000]\", b + \"\");\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object thatObj) {\nif (thatObj instanceof OptionImpl) {\nfinal OptionImpl that = (OptionImpl) thatObj;\n\nreturn (getId() == that.getId()) &&\nequals(getPreferredName(), that.getPreferredName()) &&\nequals(getDescription(), that.getDescription()) &&\nequals(getPrefixes(), that.getPrefixes()) &&\nequals(getTriggers(), that.getTriggers());\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "private boolean equals(Object left,\nObject right) {\nif ((left == null) && (right == null)) {\nreturn true;\n} else if ((left == null) || (right == null)) {\nreturn false;\n} else {\nreturn left.equals(right);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefixes(Ljava/util/Set;)V",
                                    "method_body": "protected void checkPrefixes(final Set prefixes) {\n// nothing to do if empty prefix list\nif (prefixes.isEmpty()) {\nreturn;\n}\n\n// check preferred name\ncheckPrefix(prefixes, getPreferredName());\n\n// check triggers\nthis.getTriggers();\n\nfor (final Iterator i = getTriggers().iterator(); i.hasNext();) {\ncheckPrefix(prefixes, (String) i.next());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefix(Ljava/util/Set;Ljava/lang/String;)V",
                                    "method_body": "private void checkPrefix(final Set prefixes,\nfinal String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nString prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn;\n}\n}\n\nfinal ResourceHelper helper = ResourceHelper.getResourceHelper();\nfinal String message =\nhelper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\nprefixes.toString());\nthrow new IllegalArgumentException(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;Ljava/lang/String;IZ)V",
                                    "method_body": "protected ParentImpl(final Argument argument,\nfinal Group children,\nfinal String description,\nfinal int id,\nfinal boolean required) {\nsuper(id, required);\nthis.children = children;\nthis.argument = argument;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nif (argument != null) {\nhandleInitialSeparator(arguments, argument.getInitialSeparator());\n}\n\nprocessParent(commandLine, arguments);\n\nif (argument != null) {\nargument.processValues(commandLine, arguments, this);\n}\n\nif ((children != null) && children.canProcess(commandLine, arguments)) {\nchildren.process(commandLine, arguments);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (commandLine.hasOption(this)) {\nif (argument != null) {\nargument.validate(commandLine, this);\n}\n\nif (children != null) {\nchildren.validate(commandLine);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:handleInitialSeparator(Ljava/util/ListIterator;C)V",
                                    "method_body": "private void handleInitialSeparator(final ListIterator arguments,\nfinal char separator) {\n// next token\nfinal String newArgument = (String) arguments.next();\n\n// split the token\nfinal int initialIndex = newArgument.indexOf(separator);\n\nif (initialIndex > 0) {\narguments.remove();\narguments.add(newArgument.substring(0, initialIndex));\nString value = newArgument.substring(initialIndex + 1);\n// The value obviously isn't an option, so we need to quote it if looks like an option.\n// The quotes will be removed later\nif (value.startsWith(\"-\")) {\nvalue = '\"' + value + '\"';\n}\narguments.add(value);\narguments.previous();\n}\n\narguments.previous();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nif (argument != null) {\nargument.defaultValues(commandLine, this);\n}\n\nif (children != null) {\nchildren.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<init>()V",
                                    "method_body": "public ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<clinit>()V",
                                    "method_body": "private final static ResourceHelper resources = ResourceHelper.getResourceHelper();\n\n/** name of the argument. Used for display and lookups in CommandLine */\nprivate String name;\n\n/** description of the argument. Used in the automated online help */\nprivate String description;\n\n/** minimum number of values required */\nprivate int minimum;\n\n/** maximum number of values permitted */\nprivate int maximum;\n\n/** character used to separate the values from the option */\nprivate char initialSeparator;\n\n/** character used to separate the values from each other */\nprivate char subsequentSeparator;\n\n/** object that should be used to ensure the values are valid */\nprivate Validator validator;\n\n/** used to identify the consume remaining option, typically \"--\" */\nprivate String consumeRemaining;\n\n/** default values for argument */\nprivate List defaultValues;\n\n/** id of the argument */\nprivate int id;\n\n/**\n* Creates a new ArgumentBuilder instance\n*/\npublic ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:create()Lorg/apache/commons/cli2/Argument;",
                                    "method_body": "public final Argument create() {\nfinal Argument argument =\nnew ArgumentImpl(\nname,\ndescription,\nminimum,\nmaximum,\ninitialSeparator,\nsubsequentSeparator,\nvalidator,\nconsumeRemaining,\ndefaultValues,\nid);\n\nreset();\n\nreturn argument;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:reset()Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder reset() {\nname = \"arg\";\ndescription = null;\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\ninitialSeparator = ArgumentImpl.DEFAULT_INITIAL_SEPARATOR;\nsubsequentSeparator = ArgumentImpl.DEFAULT_SUBSEQUENT_SEPARATOR;\nvalidator = null;\nconsumeRemaining = \"--\";\ndefaultValues = null;\nid = 0;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withName(final String newName) {\nif (newName == null) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_NAME));\n}\nif (\"\".equals(newName)) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_NAME));\n}\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withMinimum(I)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withMinimum(final int newMinimum) {\nif (newMinimum < 0) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MINIMUM));\n}\nthis.minimum = newMinimum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withMaximum(I)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withMaximum(final int newMaximum) {\nif (newMaximum < 0) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MAXIMUM));\n}\nthis.maximum = newMaximum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = commandLine.getUndefaultedValues(option).size();\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getInitialSeparator()C",
                                    "method_body": "public char getInitialSeparator() {\nreturn this.initialSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine,\nfinal Option option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nif (values.size() < minimum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n}\n\nif (values.size() > maximum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n(String) values.get(maximum));\n}\n\nif (validator != null) {\ntry {\nvalidator.validate(values);\n} catch (InvalidArgumentException ive) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nive.getMessage());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>()V",
                                    "method_body": "public DefaultOptionBuilder() {\nthis(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\nDefaultOption.DEFAULT_BURST_ENABLED);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
                                    "method_body": "public DefaultOptionBuilder(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled)\nthrows IllegalArgumentException {\nif ((shortPrefix == null) || (shortPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n}\n\nif ((longPrefix == null) || (longPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n}\n\nthis.shortPrefix = shortPrefix;\nthis.longPrefix = longPrefix;\nthis.burstEnabled = burstEnabled;\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:create()Lorg/apache/commons/cli2/option/DefaultOption;",
                                    "method_body": "public DefaultOption create()\nthrows IllegalStateException {\nif (preferredName == null) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n}\n\nfinal DefaultOption option =\nnew DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\naliases, burstAliases, required, argument, children, id);\n\nreset();\n\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:reset()Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder reset() {\npreferredName = null;\ndescription = null;\naliases = new HashSet();\nburstAliases = new HashSet();\nrequired = false;\nargument = null;\nchildren = null;\nid = 0;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withShortName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withShortName(final String shortName) {\nfinal String name = shortPrefix + shortName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nif (burstEnabled && (name.length() == (shortPrefix.length() + 1))) {\nburstAliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withLongName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withLongName(final String longName) {\nfinal String name = longPrefix + longName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withArgument(Lorg/apache/commons/cli2/Argument;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withArgument(final Argument newArgument) {\nthis.argument = newArgument;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/util/Set;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public DefaultOption(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled,\nfinal String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal Set burstAliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\nthis.shortPrefix = shortPrefix;\nthis.burstEnabled = burstEnabled;\n\nthis.burstLength = shortPrefix.length() + 1;\n\nthis.preferredName = preferredName;\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\nthis.burstAliases =\n(burstAliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(burstAliases));\n\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nnewTriggers.addAll(this.burstAliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n\nfinal Set newPrefixes = new HashSet(super.getPrefixes());\nnewPrefixes.add(shortPrefix);\nnewPrefixes.add(longPrefix);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n\ncheckPrefixes(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(WriteableCommandLine commandLine,\nListIterator arguments)\nthrows OptionException {\nfinal String argument = (String) arguments.next();\n\nif (triggers.contains(argument)) {\ncommandLine.addOption(this);\narguments.set(preferredName);\n} else if (burstEnabled && (argument.length() >= burstLength)) {\nfinal String burst = argument.substring(0, burstLength);\n\nif (burstAliases.contains(burst)) {\ncommandLine.addOption(this);\n\n//HMM test bursting all vs bursting one by one.\narguments.set(preferredName);\n\nif (getArgument() == null) {\narguments.add(shortPrefix + argument.substring(burstLength));\n} else {\narguments.add(argument.substring(burstLength));\n}\n\narguments.previous();\n} else {\nthrow new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n}\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withName(final String newName) {\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum) {\nsuper(0, false);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (commandLine.looksLikeOption(arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (commandLine.looksLikeOption(arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\n// number of options found\nint present = 0;\n\n// reference to first unexpected option\nOption unexpected = null;\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// needs validation?\nboolean validate = option.isRequired() || option instanceof Group;\n\n// if the child option is present then validate it\nif (commandLine.hasOption(option)) {\nif (++present > maximum) {\nunexpected = option;\n\nbreak;\n}\nvalidate = true;\n}\n\nif (validate) {\noption.validate(commandLine);\n}\n}\n\n// too many options\nif (unexpected != null) {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\nunexpected.getPreferredName());\n}\n\n// too few option\nif (present < minimum) {\nthrow new OptionException(this, ResourceConstants.MISSING_OPTION);\n}\n\n// validate each anonymous argument\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.validate(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guarenteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guarenteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setHelpTrigger(Ljava/lang/String;)V",
                                    "method_body": "public void setHelpTrigger(final String helpTrigger) {\nthis.helpTrigger = helpTrigger;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public final boolean hasOption(final String trigger) {\nreturn hasOption(getOption(trigger));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Ljava/lang/String;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final String trigger) {\nreturn getValues(getOption(trigger), Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final Option option) {\nreturn getValues(option, Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addValue(Lorg/apache/commons/cli2/Option;Ljava/lang/Object;)V",
                                    "method_body": "public void addValue(final Option option,\nfinal Object value) {\nif (option instanceof Argument) {\naddOption(option);\n}\n\nList valueList = (List) values.get(option);\n\nif (valueList == null) {\nvalueList = new ArrayList();\nvalues.put(option, valueList);\n}\n\nvalueList.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:hasOption(Lorg/apache/commons/cli2/Option;)Z",
                                    "method_body": "public boolean hasOption(final Option option) {\nfinal boolean present = options.contains(option);\n\nreturn present;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOption(Ljava/lang/String;)Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getOption(final String trigger) {\nreturn (Option) nameToOption.get(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List getValues(final Option option,\nList defaultValues) {\n// initialize the return list\nList valueList = (List) values.get(option);\n\n// grab the correct default values\nif ((valueList == null) || valueList.isEmpty()) {\nvalueList = defaultValues;\n}\n\n// augment the list with the default values\nif ((valueList == null) || valueList.isEmpty()) {\nvalueList = (List) this.defaultValues.get(option);\n}\n// if there are more default values as specified, add them to\n// the list.\n// copy the list first\n\nreturn valueList == null ? Collections.EMPTY_LIST : valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getUndefaultedValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public List getUndefaultedValues(Option option) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withDefault(Ljava/lang/Object;)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withDefault(final Object defaultValue) {\nif (defaultValue == null) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_DEFAULT));\n}\n\nif (this.defaultValues == null) {\nthis.defaultValues = new ArrayList(1);\n}\nthis.defaultValues.add(defaultValue);\nreturn this;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 16,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli2.commandline.PropertiesCommandLineTest.testGetOptions_Order",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object thatObj) {\nif (thatObj instanceof OptionImpl) {\nfinal OptionImpl that = (OptionImpl) thatObj;\n\nreturn (getId() == that.getId()) &&\nequals(getPreferredName(), that.getPreferredName()) &&\nequals(getDescription(), that.getDescription()) &&\nequals(getPrefixes(), that.getPrefixes()) &&\nequals(getTriggers(), that.getTriggers());\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "private boolean equals(Object left,\nObject right) {\nif ((left == null) && (right == null)) {\nreturn true;\n} else if ((left == null) || (right == null)) {\nreturn false;\n} else {\nreturn left.equals(right);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nif (getPreferredName() != null) {\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n}\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefixes(Ljava/util/Set;)V",
                                    "method_body": "protected void checkPrefixes(final Set prefixes) {\n// nothing to do if empty prefix list\nif (prefixes.isEmpty()) {\nreturn;\n}\n\n// check preferred name\ncheckPrefix(prefixes, getPreferredName());\n\n// check triggers\nthis.getTriggers();\n\nfor (final Iterator i = getTriggers().iterator(); i.hasNext();) {\ncheckPrefix(prefixes, (String) i.next());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefix(Ljava/util/Set;Ljava/lang/String;)V",
                                    "method_body": "private void checkPrefix(final Set prefixes,\nfinal String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nString prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn;\n}\n}\n\nfinal ResourceHelper helper = ResourceHelper.getResourceHelper();\nfinal String message =\nhelper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\nprefixes.toString());\nthrow new IllegalArgumentException(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;Ljava/lang/String;IZ)V",
                                    "method_body": "protected ParentImpl(final Argument argument,\nfinal Group children,\nfinal String description,\nfinal int id,\nfinal boolean required) {\nsuper(id, required);\nthis.children = children;\nthis.argument = argument;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nif (argument != null) {\nhandleInitialSeparator(arguments, argument.getInitialSeparator());\n}\n\nprocessParent(commandLine, arguments);\n\nif (argument != null) {\nargument.processValues(commandLine, arguments, this);\n}\n\nif ((children != null) && children.canProcess(commandLine, arguments)) {\nchildren.process(commandLine, arguments);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (commandLine.hasOption(this)) {\nif (argument != null) {\nargument.validate(commandLine, this);\n}\n\nif (children != null) {\nchildren.validate(commandLine);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:handleInitialSeparator(Ljava/util/ListIterator;C)V",
                                    "method_body": "private void handleInitialSeparator(final ListIterator arguments,\nfinal char separator) {\n// next token\nfinal String newArgument = (String) arguments.next();\n\n// split the token\nfinal int initialIndex = newArgument.indexOf(separator);\n\nif (initialIndex > 0) {\narguments.remove();\narguments.add(newArgument.substring(0, initialIndex));\nString value = newArgument.substring(initialIndex + 1);\n// The value obviously isn't an option, so we need to quote it if looks like an option.\n// The quotes will be removed later\nif (value.startsWith(\"-\")) {\nvalue = '\"' + value + '\"';\n}\narguments.add(value);\narguments.previous();\n}\n\narguments.previous();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nif (argument != null) {\nargument.defaultValues(commandLine, this);\n}\n\nif (children != null) {\nchildren.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = commandLine.getUndefaultedValues(option).size();\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getInitialSeparator()C",
                                    "method_body": "public char getInitialSeparator() {\nreturn this.initialSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine,\nfinal Option option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nif (values.size() < minimum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n}\n\nif (values.size() > maximum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n(String) values.get(maximum));\n}\n\nif (validator != null) {\ntry {\nvalidator.validate(values);\n} catch (InvalidArgumentException ive) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nive.getMessage());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>()V",
                                    "method_body": "public DefaultOptionBuilder() {\nthis(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\nDefaultOption.DEFAULT_BURST_ENABLED);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
                                    "method_body": "public DefaultOptionBuilder(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled)\nthrows IllegalArgumentException {\nif ((shortPrefix == null) || (shortPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n}\n\nif ((longPrefix == null) || (longPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n}\n\nthis.shortPrefix = shortPrefix;\nthis.longPrefix = longPrefix;\nthis.burstEnabled = burstEnabled;\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:create()Lorg/apache/commons/cli2/option/DefaultOption;",
                                    "method_body": "public DefaultOption create()\nthrows IllegalStateException {\nif (preferredName == null) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n}\n\nfinal DefaultOption option =\nnew DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\naliases, burstAliases, required, argument, children, id);\n\nreset();\n\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:reset()Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder reset() {\npreferredName = null;\ndescription = null;\naliases = new HashSet();\nburstAliases = new HashSet();\nrequired = false;\nargument = null;\nchildren = null;\nid = 0;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withLongName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withLongName(final String longName) {\nfinal String name = longPrefix + longName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/util/Set;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public DefaultOption(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled,\nfinal String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal Set burstAliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\nthis.shortPrefix = shortPrefix;\nthis.burstEnabled = burstEnabled;\n\nthis.burstLength = shortPrefix.length() + 1;\n\nthis.preferredName = preferredName;\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\nthis.burstAliases =\n(burstAliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(burstAliases));\n\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nnewTriggers.addAll(this.burstAliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n\nfinal Set newPrefixes = new HashSet(super.getPrefixes());\nnewPrefixes.add(shortPrefix);\nnewPrefixes.add(longPrefix);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n\ncheckPrefixes(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(WriteableCommandLine commandLine,\nListIterator arguments)\nthrows OptionException {\nfinal String argument = (String) arguments.next();\n\nif (triggers.contains(argument)) {\ncommandLine.addOption(this);\narguments.set(preferredName);\n} else if (burstEnabled && (argument.length() >= burstLength)) {\nfinal String burst = argument.substring(0, burstLength);\n\nif (burstAliases.contains(burst)) {\ncommandLine.addOption(this);\n\n//HMM test bursting all vs bursting one by one.\narguments.set(preferredName);\n\nif (getArgument() == null) {\narguments.add(shortPrefix + argument.substring(burstLength));\n} else {\narguments.add(argument.substring(burstLength));\n}\n\narguments.previous();\n} else {\nthrow new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n}\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum) {\nsuper(0, false);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (commandLine.looksLikeOption(arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (commandLine.looksLikeOption(arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\n// number of options found\nint present = 0;\n\n// reference to first unexpected option\nOption unexpected = null;\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// needs validation?\nboolean validate = option.isRequired() || option instanceof Group;\n\n// if the child option is present then validate it\nif (commandLine.hasOption(option)) {\nif (++present > maximum) {\nunexpected = option;\n\nbreak;\n}\nvalidate = true;\n}\n\nif (validate) {\noption.validate(commandLine);\n}\n}\n\n// too many options\nif (unexpected != null) {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\nunexpected.getPreferredName());\n}\n\n// too few option\nif (present < minimum) {\nthrow new OptionException(this, ResourceConstants.MISSING_OPTION);\n}\n\n// validate each anonymous argument\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.validate(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nappendUsage(buffer, helpSettings, comp, \"|\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;Ljava/lang/String;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp,\nfinal String separator) {\nfinal Set helpSettingsCopy = new HashSet(helpSettings);\n\nfinal boolean optional =\n(minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\nfinal boolean expanded =\n(name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\nfinal boolean named =\n!expanded ||\n((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\nfinal boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\nfinal boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nhelpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nfinal boolean both = named && expanded;\n\nif (optional) {\nbuffer.append('[');\n}\n\nif (named) {\nbuffer.append(name);\n}\n\nif (both) {\nbuffer.append(\" (\");\n}\n\nif (expanded) {\nfinal Set childSettings;\n\nif (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\nchildSettings = DisplaySetting.NONE;\n} else {\nchildSettings = new HashSet(helpSettingsCopy);\nchildSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n}\n\n// grab a list of the group's options.\nfinal List list;\n\nif (comp == null) {\n// default to using the initial order\nlist = options;\n} else {\n// sort options if comparator is supplied\nlist = new ArrayList(options);\nCollections.sort(list, comp);\n}\n\n// for each option.\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// append usage information\noption.appendUsage(buffer, childSettings, comp);\n\n// add separators as needed\nif (i.hasNext()) {\nbuffer.append(separator);\n}\n}\n}\n\nif (both) {\nbuffer.append(')');\n}\n\nif (optional && outer) {\nbuffer.append(']');\n}\n\nif (arguments) {\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nbuffer.append(' ');\n\nfinal Option option = (Option) i.next();\noption.appendUsage(buffer, helpSettingsCopy, comp);\n}\n}\n\nif (optional && !outer) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guarenteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guarenteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public final boolean hasOption(final String trigger) {\nreturn hasOption(getOption(trigger));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final Option option) {\nreturn getValues(option, Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n\n// ensure that all parent options are also added\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addValue(Lorg/apache/commons/cli2/Option;Ljava/lang/Object;)V",
                                    "method_body": "public void addValue(final Option option,\nfinal Object value) {\nif (option instanceof Argument) {\naddOption(option);\n}\n\nList valueList = (List) values.get(option);\n\nif (valueList == null) {\nvalueList = new ArrayList();\nvalues.put(option, valueList);\n}\n\nvalueList.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:hasOption(Lorg/apache/commons/cli2/Option;)Z",
                                    "method_body": "public boolean hasOption(final Option option) {\nfinal boolean present = options.contains(option);\n\nreturn present;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOption(Ljava/lang/String;)Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getOption(final String trigger) {\nreturn (Option) nameToOption.get(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List getValues(final Option option,\nList defaultValues) {\n// initialize the return list\nList valueList = (List) values.get(option);\n\n// grab the correct default values\nif (defaultValues == null || defaultValues.isEmpty()) {\ndefaultValues = (List) this.defaultValues.get(option);\n}\n\n// augment the list with the default values\nif (defaultValues != null && !defaultValues.isEmpty()) {\nif (valueList == null || valueList.isEmpty()) {\nvalueList = defaultValues;\n} else {\n// if there are more default values as specified, add them to\n// the list.\nif (defaultValues.size() > valueList.size()) {\n// copy the list first\nvalueList = new ArrayList(valueList);\nfor (int i=valueList.size(); i<defaultValues.size(); i++) {\nvalueList.add(defaultValues.get(i));\n}\n}\n}\n}\n\nreturn valueList == null ? Collections.EMPTY_LIST : valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getUndefaultedValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public List getUndefaultedValues(Option option) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nfinal StringBuffer buffer = new StringBuffer();\nappendUsage(buffer, DisplaySetting.ALL, null);\n\nreturn buffer.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nfinal Set triggers = getTriggers();\n\nif (argument != null) {\nfinal char separator = argument.getInitialSeparator();\n\n// if there is a valid separator character\nif (separator != NUL) {\nfinal int initialIndex = arg.indexOf(separator);\n\n// if there is a separator present\nif (initialIndex > 0) {\nreturn triggers.contains(arg.substring(0, initialIndex));\n}\n}\n}\n\nreturn triggers.contains(arg);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nfinal boolean displayArgument =\n(this.argument != null) &&\nhelpSettings.contains(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nfinal boolean displayChildren =\n(this.children != null) &&\nhelpSettings.contains(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n\nif (displayArgument) {\nbuffer.append(' ');\nargument.appendUsage(buffer, helpSettings, comp);\n}\n\nif (displayChildren) {\nbuffer.append(' ');\nchildren.appendUsage(buffer, helpSettings, comp);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public Command(final String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\n// check the preferred name is valid\nif ((preferredName == null) || (preferredName.length() < 1)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.COMMAND_PREFERRED_NAME_TOO_SHORT));\n}\n\nthis.preferredName = preferredName;\n\n// gracefully and defensively handle aliases\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\n// populate the triggers Set\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\n// grab the argument to process\nfinal String arg = (String) arguments.next();\n\n// if we can process it\nif (canProcess(commandLine, arg)) {\n// then note the option\ncommandLine.addOption(this);\n\n// normalise the argument list\narguments.set(preferredName);\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display optionality\nfinal boolean optional =\n!isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\nfinal boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n\nif (optional) {\nbuffer.append('[');\n}\n\nbuffer.append(preferredName);\n\nif (displayAliases && !aliases.isEmpty()) {\nbuffer.append(\" (\");\n\nfinal List list = new ArrayList(aliases);\nCollections.sort(list);\n\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal String alias = (String) i.next();\nbuffer.append(alias);\n\nif (i.hasNext()) {\nbuffer.append(',');\n}\n}\n\nbuffer.append(')');\n}\n\nsuper.appendUsage(buffer, helpSettings, comp);\n\nif (optional) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn Collections.EMPTY_SET;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(WriteableCommandLine commandLine,\nListIterator args)\nthrows OptionException {\nprocessValues(commandLine, args, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn Collections.EMPTY_SET;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\nvalidate(commandLine, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display the outer optionality\nfinal boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n// allow numbering if multiple args\nfinal boolean numbered =\n(maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n\nfinal boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n\n// if infinite args are allowed then crop the list\nfinal int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n\nint i = 0;\n\n// for each argument\nwhile (i < max) {\n// if we're past the first add a space\nif (i > 0) {\nbuffer.append(' ');\n}\n\n// if the next arg is optional\nif ((i >= minimum) && (optional || (i > 0))) {\nbuffer.append('[');\n}\n\nif (bracketed) {\nbuffer.append('<');\n}\n\n// add name\nbuffer.append(name);\n++i;\n\n// if numbering\nif (numbered) {\nbuffer.append(i);\n}\n\nif (bracketed) {\nbuffer.append('>');\n}\n}\n\n// if infinite args are allowed\nif (maximum == Integer.MAX_VALUE) {\n// append elipsis\nbuffer.append(\" ...\");\n}\n\n// for each argument\nwhile (i > 0) {\n--i;\n\n// if the next arg is optional\nif ((i >= minimum) && (optional || (i > 0))) {\nbuffer.append(']');\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\ndefaultValues(commandLine, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display optionality\nfinal boolean optional =\n!isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\nfinal boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n\nif (optional) {\nbuffer.append('[');\n}\n\nbuffer.append(preferredName);\n\nif (displayAliases && !aliases.isEmpty()) {\nbuffer.append(\" (\");\n\nfinal List list = new ArrayList(aliases);\nCollections.sort(list);\n\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal String alias = (String) i.next();\nbuffer.append(alias);\n\nif (i.hasNext()) {\nbuffer.append(',');\n}\n}\n\nbuffer.append(')');\n}\n\nsuper.appendUsage(buffer, helpSettings, comp);\n\nif (optional) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOptions()Ljava/util/List;",
                                    "method_body": "public List getOptions() {\nreturn Collections.unmodifiableList(options);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.PropertiesCommandLine:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/Properties;C)V",
                                    "method_body": "public PropertiesCommandLine(final Option root, final Properties properties, final char separator){\nthis.root = root;\nthis.properties = properties;\nthis.separator = separator;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli2.bug.BugCLI123Test.testMultipleChildOptions",
                            "test_body": "public void testMultipleChildOptions() throws OptionException {\nCommandLine cl = parser.parse(new String[] { \"--child\", \"test\",\n\"--sub\", \"anotherTest\" });\nassertTrue(\"Child option not found\", cl.hasOption(childOption1));\nassertEquals(\"Wrong value for option\", \"test\", cl\n.getValue(childOption1));\nassertTrue(\"Sub option not found\", cl.hasOption(childOption2));\nassertEquals(\"Wrong value for sub option\", \"anotherTest\", cl\n.getValue(childOption2));\nassertTrue(\"Child group not found\", cl.hasOption(childGroup));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object thatObj) {\nif (thatObj instanceof OptionImpl) {\nfinal OptionImpl that = (OptionImpl) thatObj;\n\nreturn (getId() == that.getId()) &&\nequals(getPreferredName(), that.getPreferredName()) &&\nequals(getDescription(), that.getDescription()) &&\nequals(getPrefixes(), that.getPrefixes()) &&\nequals(getTriggers(), that.getTriggers());\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "private boolean equals(Object left,\nObject right) {\nif ((left == null) && (right == null)) {\nreturn true;\n} else if ((left == null) || (right == null)) {\nreturn false;\n} else {\nreturn left.equals(right);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nif (getPreferredName() != null) {\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n}\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefixes(Ljava/util/Set;)V",
                                    "method_body": "protected void checkPrefixes(final Set prefixes) {\n// nothing to do if empty prefix list\nif (prefixes.isEmpty()) {\nreturn;\n}\n\n// check preferred name\ncheckPrefix(prefixes, getPreferredName());\n\n// check triggers\nthis.getTriggers();\n\nfor (final Iterator i = getTriggers().iterator(); i.hasNext();) {\ncheckPrefix(prefixes, (String) i.next());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefix(Ljava/util/Set;Ljava/lang/String;)V",
                                    "method_body": "private void checkPrefix(final Set prefixes,\nfinal String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nString prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn;\n}\n}\n\nfinal ResourceHelper helper = ResourceHelper.getResourceHelper();\nfinal String message =\nhelper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\nprefixes.toString());\nthrow new IllegalArgumentException(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;Ljava/lang/String;IZ)V",
                                    "method_body": "protected ParentImpl(final Argument argument,\nfinal Group children,\nfinal String description,\nfinal int id,\nfinal boolean required) {\nsuper(id, required);\nthis.children = children;\nthis.argument = argument;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nif (argument != null) {\nhandleInitialSeparator(arguments, argument.getInitialSeparator());\n}\n\nprocessParent(commandLine, arguments);\n\nif (argument != null) {\nargument.processValues(commandLine, arguments, this);\n}\n\nif ((children != null) && children.canProcess(commandLine, arguments)) {\nchildren.process(commandLine, arguments);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (commandLine.hasOption(this)) {\nif (argument != null) {\nargument.validate(commandLine, this);\n}\n\nif (children != null) {\nchildren.validate(commandLine);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:handleInitialSeparator(Ljava/util/ListIterator;C)V",
                                    "method_body": "private void handleInitialSeparator(final ListIterator arguments,\nfinal char separator) {\n// next token\nfinal String newArgument = (String) arguments.next();\n\n// split the token\nfinal int initialIndex = newArgument.indexOf(separator);\n\nif (initialIndex > 0) {\narguments.remove();\narguments.add(newArgument.substring(0, initialIndex));\nString value = newArgument.substring(initialIndex + 1);\n// The value obviously isn't an option, so we need to quote it if looks like an option.\n// The quotes will be removed later\nif (value.startsWith(\"-\")) {\nvalue = '\"' + value + '\"';\n}\narguments.add(value);\narguments.previous();\n}\n\narguments.previous();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nif (argument != null) {\nargument.defaultValues(commandLine, this);\n}\n\nif (children != null) {\nchildren.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<init>()V",
                                    "method_body": "public ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<clinit>()V",
                                    "method_body": "private final static ResourceHelper resources = ResourceHelper.getResourceHelper();\n\n/** name of the argument. Used for display and lookups in CommandLine */\nprivate String name;\n\n/** description of the argument. Used in the automated online help */\nprivate String description;\n\n/** minimum number of values required */\nprivate int minimum;\n\n/** maximum number of values permitted */\nprivate int maximum;\n\n/** character used to separate the values from the option */\nprivate char initialSeparator;\n\n/** character used to separate the values from each other */\nprivate char subsequentSeparator;\n\n/** object that should be used to ensure the values are valid */\nprivate Validator validator;\n\n/** used to identify the consume remaining option, typically \"--\" */\nprivate String consumeRemaining;\n\n/** default values for argument */\nprivate List defaultValues;\n\n/** id of the argument */\nprivate int id;\n\n/**\n* Creates a new ArgumentBuilder instance\n*/\npublic ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:create()Lorg/apache/commons/cli2/Argument;",
                                    "method_body": "public final Argument create() {\nfinal Argument argument =\nnew ArgumentImpl(\nname,\ndescription,\nminimum,\nmaximum,\ninitialSeparator,\nsubsequentSeparator,\nvalidator,\nconsumeRemaining,\ndefaultValues,\nid);\n\nreset();\n\nreturn argument;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:reset()Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder reset() {\nname = \"arg\";\ndescription = null;\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\ninitialSeparator = ArgumentImpl.DEFAULT_INITIAL_SEPARATOR;\nsubsequentSeparator = ArgumentImpl.DEFAULT_SUBSEQUENT_SEPARATOR;\nvalidator = null;\nconsumeRemaining = \"--\";\ndefaultValues = null;\nid = 0;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withName(final String newName) {\nif (newName == null) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_NAME));\n}\nif (\"\".equals(newName)) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_NAME));\n}\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getMessage(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getMessage(final String key) {\nreturn getMessage(key, new Object[] {  });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getMessage(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String getMessage(final String key,\nfinal Object[] values) {\nfinal String msgFormatStr = bundle.getString(key);\nfinal MessageFormat msgFormat = new MessageFormat(msgFormatStr);\n\nreturn msgFormat.format(values);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = commandLine.getUndefaultedValues(option).size();\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getInitialSeparator()C",
                                    "method_body": "public char getInitialSeparator() {\nreturn this.initialSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine,\nfinal Option option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nif (values.size() < minimum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n}\n\nif (values.size() > maximum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n(String) values.get(maximum));\n}\n\nif (validator != null) {\ntry {\nvalidator.validate(values);\n} catch (InvalidArgumentException ive) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nive.getMessage());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>()V",
                                    "method_body": "public DefaultOptionBuilder() {\nthis(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\nDefaultOption.DEFAULT_BURST_ENABLED);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
                                    "method_body": "public DefaultOptionBuilder(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled)\nthrows IllegalArgumentException {\nif ((shortPrefix == null) || (shortPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n}\n\nif ((longPrefix == null) || (longPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n}\n\nthis.shortPrefix = shortPrefix;\nthis.longPrefix = longPrefix;\nthis.burstEnabled = burstEnabled;\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:create()Lorg/apache/commons/cli2/option/DefaultOption;",
                                    "method_body": "public DefaultOption create()\nthrows IllegalStateException {\nif (preferredName == null) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n}\n\nfinal DefaultOption option =\nnew DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\naliases, burstAliases, required, argument, children, id);\n\nreset();\n\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:reset()Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder reset() {\npreferredName = null;\ndescription = null;\naliases = new HashSet();\nburstAliases = new HashSet();\nrequired = false;\nargument = null;\nchildren = null;\nid = 0;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withShortName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withShortName(final String shortName) {\nfinal String name = shortPrefix + shortName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nif (burstEnabled && (name.length() == (shortPrefix.length() + 1))) {\nburstAliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withLongName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withLongName(final String longName) {\nfinal String name = longPrefix + longName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withArgument(Lorg/apache/commons/cli2/Argument;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withArgument(final Argument newArgument) {\nthis.argument = newArgument;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/util/Set;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public DefaultOption(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled,\nfinal String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal Set burstAliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\nthis.shortPrefix = shortPrefix;\nthis.burstEnabled = burstEnabled;\n\nthis.burstLength = shortPrefix.length() + 1;\n\nthis.preferredName = preferredName;\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\nthis.burstAliases =\n(burstAliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(burstAliases));\n\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nnewTriggers.addAll(this.burstAliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n\nfinal Set newPrefixes = new HashSet(super.getPrefixes());\nnewPrefixes.add(shortPrefix);\nnewPrefixes.add(longPrefix);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n\ncheckPrefixes(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(WriteableCommandLine commandLine,\nListIterator arguments)\nthrows OptionException {\nfinal String argument = (String) arguments.next();\n\nif (triggers.contains(argument)) {\ncommandLine.addOption(this);\narguments.set(preferredName);\n} else if (burstEnabled && (argument.length() >= burstLength)) {\nfinal String burst = argument.substring(0, burstLength);\n\nif (burstAliases.contains(burst)) {\ncommandLine.addOption(this);\n\n//HMM test bursting all vs bursting one by one.\narguments.set(preferredName);\n\nif (getArgument() == null) {\narguments.add(shortPrefix + argument.substring(burstLength));\n} else {\narguments.add(argument.substring(burstLength));\n}\n\narguments.previous();\n} else {\nthrow new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n}\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withName(final String newName) {\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withMinimum(I)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withMinimum(final int newMinimum) {\nthis.minimum = newMinimum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withMaximum(I)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withMaximum(final int newMaximum) {\nthis.maximum = newMaximum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum) {\nsuper(0, false);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (commandLine.looksLikeOption(arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn optionMap.keySet();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (commandLine.looksLikeOption(arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\n// number of options found\nint present = 0;\n\n// reference to first unexpected option\nOption unexpected = null;\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// needs validation?\nboolean validate = option.isRequired() || option instanceof Group;\n\n// if the child option is present then validate it\nif (commandLine.hasOption(option)) {\nif (++present > maximum) {\nunexpected = option;\n\nbreak;\n}\nvalidate = true;\n}\n\nif (validate) {\noption.validate(commandLine);\n}\n}\n\n// too many options\nif (unexpected != null) {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\nunexpected.getPreferredName());\n}\n\n// too few option\nif (present < minimum) {\nthrow new OptionException(this, ResourceConstants.MISSING_OPTION);\n}\n\n// validate each anonymous argument\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.validate(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nappendUsage(buffer, helpSettings, comp, \"|\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;Ljava/lang/String;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp,\nfinal String separator) {\nfinal Set helpSettingsCopy = new HashSet(helpSettings);\n\nfinal boolean optional =\n(minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\nfinal boolean expanded =\n(name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\nfinal boolean named =\n!expanded ||\n((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\nfinal boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\nfinal boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nhelpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nfinal boolean both = named && expanded;\n\nif (optional) {\nbuffer.append('[');\n}\n\nif (named) {\nbuffer.append(name);\n}\n\nif (both) {\nbuffer.append(\" (\");\n}\n\nif (expanded) {\nfinal Set childSettings;\n\nif (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\nchildSettings = DisplaySetting.NONE;\n} else {\nchildSettings = new HashSet(helpSettingsCopy);\nchildSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n}\n\n// grab a list of the group's options.\nfinal List list;\n\nif (comp == null) {\n// default to using the initial order\nlist = options;\n} else {\n// sort options if comparator is supplied\nlist = new ArrayList(options);\nCollections.sort(list, comp);\n}\n\n// for each option.\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// append usage information\noption.appendUsage(buffer, childSettings, comp);\n\n// add separators as needed\nif (i.hasNext()) {\nbuffer.append(separator);\n}\n}\n}\n\nif (both) {\nbuffer.append(')');\n}\n\nif (optional && outer) {\nbuffer.append(']');\n}\n\nif (arguments) {\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nbuffer.append(' ');\n\nfinal Option option = (Option) i.next();\noption.appendUsage(buffer, helpSettingsCopy, comp);\n}\n}\n\nif (optional && !outer) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getMinimum()I",
                                    "method_body": "public int getMinimum() {\nreturn minimum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn getMinimum() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guarenteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guarenteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:<init>(Lorg/apache/commons/cli2/Option;Ljava/lang/String;)V",
                                    "method_body": "public OptionException(final Option option,\nfinal String messageKey) {\nthis(option, messageKey, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:<init>(Lorg/apache/commons/cli2/Option;Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public OptionException(final Option option,\nfinal String messageKey,\nfinal String value) {\nthis.option = option;\n\nif (messageKey != null) {\nfinal StringBuffer buffer = new StringBuffer();\n\nif (value != null) {\nbuffer.append(helper.getMessage(messageKey, value));\n} else {\nbuffer.append(helper.getMessage(messageKey));\n}\n\nbuffer.append(\" \");\n\noption.appendUsage(buffer, HELP_SETTINGS, null);\nmessage = buffer.toString();\n} else {\nmessage = \"\";\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:<clinit>()V",
                                    "method_body": "public static final Set HELP_SETTINGS =\nCollections.unmodifiableSet(Collections.singleton(DisplaySetting.DISPLAY_PROPERTY_OPTION));\n\n/** resource helper instance */\nprivate static final ResourceHelper helper = ResourceHelper.getResourceHelper();\n\n/** The Option the exception relates to */\nprivate final Option option;\n\n/** The message explaining the Exception */\nprivate final String message;\n\n/**\n* Creates a new OptionException.\n*\n* @param option\n*            The Option the exception relates to\n*/\npublic OptionException(final Option option) {\nthis(option, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:getMessage()Ljava/lang/String;",
                                    "method_body": "public String getMessage() {\nreturn message;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public final boolean hasOption(final String trigger) {\nreturn hasOption(getOption(trigger));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final Option option) {\nreturn getValues(option, Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n\n// ensure that all parent options are also added\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addValue(Lorg/apache/commons/cli2/Option;Ljava/lang/Object;)V",
                                    "method_body": "public void addValue(final Option option,\nfinal Object value) {\nif (option instanceof Argument) {\naddOption(option);\n}\n\nList valueList = (List) values.get(option);\n\nif (valueList == null) {\nvalueList = new ArrayList();\nvalues.put(option, valueList);\n}\n\nvalueList.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:hasOption(Lorg/apache/commons/cli2/Option;)Z",
                                    "method_body": "public boolean hasOption(final Option option) {\nfinal boolean present = options.contains(option);\n\nreturn present;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOption(Ljava/lang/String;)Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getOption(final String trigger) {\nreturn (Option) nameToOption.get(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List getValues(final Option option,\nList defaultValues) {\n// initialize the return list\nList valueList = (List) values.get(option);\n\n// grab the correct default values\nif (defaultValues == null || defaultValues.isEmpty()) {\ndefaultValues = (List) this.defaultValues.get(option);\n}\n\n// augment the list with the default values\nif (defaultValues != null && !defaultValues.isEmpty()) {\nif (valueList == null || valueList.isEmpty()) {\nvalueList = defaultValues;\n} else {\n// if there are more default values as specified, add them to\n// the list.\nif (defaultValues.size() > valueList.size()) {\n// copy the list first\nvalueList = new ArrayList(valueList);\nfor (int i=valueList.size(); i<defaultValues.size(); i++) {\nvalueList.add(defaultValues.get(i));\n}\n}\n}\n}\n\nreturn valueList == null ? Collections.EMPTY_LIST : valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getUndefaultedValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public List getUndefaultedValues(Option option) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli2.commandline.PreferencesCommandLineTest.testGetOptions_Order",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object thatObj) {\nif (thatObj instanceof OptionImpl) {\nfinal OptionImpl that = (OptionImpl) thatObj;\n\nreturn (getId() == that.getId()) &&\nequals(getPreferredName(), that.getPreferredName()) &&\nequals(getDescription(), that.getDescription()) &&\nequals(getPrefixes(), that.getPrefixes()) &&\nequals(getTriggers(), that.getTriggers());\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "private boolean equals(Object left,\nObject right) {\nif ((left == null) && (right == null)) {\nreturn true;\n} else if ((left == null) || (right == null)) {\nreturn false;\n} else {\nreturn left.equals(right);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nif (getPreferredName() != null) {\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n}\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefixes(Ljava/util/Set;)V",
                                    "method_body": "protected void checkPrefixes(final Set prefixes) {\n// nothing to do if empty prefix list\nif (prefixes.isEmpty()) {\nreturn;\n}\n\n// check preferred name\ncheckPrefix(prefixes, getPreferredName());\n\n// check triggers\nthis.getTriggers();\n\nfor (final Iterator i = getTriggers().iterator(); i.hasNext();) {\ncheckPrefix(prefixes, (String) i.next());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefix(Ljava/util/Set;Ljava/lang/String;)V",
                                    "method_body": "private void checkPrefix(final Set prefixes,\nfinal String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nString prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn;\n}\n}\n\nfinal ResourceHelper helper = ResourceHelper.getResourceHelper();\nfinal String message =\nhelper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\nprefixes.toString());\nthrow new IllegalArgumentException(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;Ljava/lang/String;IZ)V",
                                    "method_body": "protected ParentImpl(final Argument argument,\nfinal Group children,\nfinal String description,\nfinal int id,\nfinal boolean required) {\nsuper(id, required);\nthis.children = children;\nthis.argument = argument;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nif (argument != null) {\nhandleInitialSeparator(arguments, argument.getInitialSeparator());\n}\n\nprocessParent(commandLine, arguments);\n\nif (argument != null) {\nargument.processValues(commandLine, arguments, this);\n}\n\nif ((children != null) && children.canProcess(commandLine, arguments)) {\nchildren.process(commandLine, arguments);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (commandLine.hasOption(this)) {\nif (argument != null) {\nargument.validate(commandLine, this);\n}\n\nif (children != null) {\nchildren.validate(commandLine);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:handleInitialSeparator(Ljava/util/ListIterator;C)V",
                                    "method_body": "private void handleInitialSeparator(final ListIterator arguments,\nfinal char separator) {\n// next token\nfinal String newArgument = (String) arguments.next();\n\n// split the token\nfinal int initialIndex = newArgument.indexOf(separator);\n\nif (initialIndex > 0) {\narguments.remove();\narguments.add(newArgument.substring(0, initialIndex));\nString value = newArgument.substring(initialIndex + 1);\n// The value obviously isn't an option, so we need to quote it if looks like an option.\n// The quotes will be removed later\nif (value.startsWith(\"-\")) {\nvalue = '\"' + value + '\"';\n}\narguments.add(value);\narguments.previous();\n}\n\narguments.previous();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nif (argument != null) {\nargument.defaultValues(commandLine, this);\n}\n\nif (children != null) {\nchildren.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = commandLine.getUndefaultedValues(option).size();\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getInitialSeparator()C",
                                    "method_body": "public char getInitialSeparator() {\nreturn this.initialSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine,\nfinal Option option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nif (values.size() < minimum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n}\n\nif (values.size() > maximum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n(String) values.get(maximum));\n}\n\nif (validator != null) {\ntry {\nvalidator.validate(values);\n} catch (InvalidArgumentException ive) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nive.getMessage());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>()V",
                                    "method_body": "public DefaultOptionBuilder() {\nthis(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\nDefaultOption.DEFAULT_BURST_ENABLED);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
                                    "method_body": "public DefaultOptionBuilder(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled)\nthrows IllegalArgumentException {\nif ((shortPrefix == null) || (shortPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n}\n\nif ((longPrefix == null) || (longPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n}\n\nthis.shortPrefix = shortPrefix;\nthis.longPrefix = longPrefix;\nthis.burstEnabled = burstEnabled;\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:create()Lorg/apache/commons/cli2/option/DefaultOption;",
                                    "method_body": "public DefaultOption create()\nthrows IllegalStateException {\nif (preferredName == null) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n}\n\nfinal DefaultOption option =\nnew DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\naliases, burstAliases, required, argument, children, id);\n\nreset();\n\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:reset()Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder reset() {\npreferredName = null;\ndescription = null;\naliases = new HashSet();\nburstAliases = new HashSet();\nrequired = false;\nargument = null;\nchildren = null;\nid = 0;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withLongName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withLongName(final String longName) {\nfinal String name = longPrefix + longName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/util/Set;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public DefaultOption(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled,\nfinal String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal Set burstAliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\nthis.shortPrefix = shortPrefix;\nthis.burstEnabled = burstEnabled;\n\nthis.burstLength = shortPrefix.length() + 1;\n\nthis.preferredName = preferredName;\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\nthis.burstAliases =\n(burstAliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(burstAliases));\n\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nnewTriggers.addAll(this.burstAliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n\nfinal Set newPrefixes = new HashSet(super.getPrefixes());\nnewPrefixes.add(shortPrefix);\nnewPrefixes.add(longPrefix);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n\ncheckPrefixes(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(WriteableCommandLine commandLine,\nListIterator arguments)\nthrows OptionException {\nfinal String argument = (String) arguments.next();\n\nif (triggers.contains(argument)) {\ncommandLine.addOption(this);\narguments.set(preferredName);\n} else if (burstEnabled && (argument.length() >= burstLength)) {\nfinal String burst = argument.substring(0, burstLength);\n\nif (burstAliases.contains(burst)) {\ncommandLine.addOption(this);\n\n//HMM test bursting all vs bursting one by one.\narguments.set(preferredName);\n\nif (getArgument() == null) {\narguments.add(shortPrefix + argument.substring(burstLength));\n} else {\narguments.add(argument.substring(burstLength));\n}\n\narguments.previous();\n} else {\nthrow new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n}\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum) {\nsuper(0, false);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (commandLine.looksLikeOption(arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (commandLine.looksLikeOption(arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\n// number of options found\nint present = 0;\n\n// reference to first unexpected option\nOption unexpected = null;\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// needs validation?\nboolean validate = option.isRequired() || option instanceof Group;\n\n// if the child option is present then validate it\nif (commandLine.hasOption(option)) {\nif (++present > maximum) {\nunexpected = option;\n\nbreak;\n}\nvalidate = true;\n}\n\nif (validate) {\noption.validate(commandLine);\n}\n}\n\n// too many options\nif (unexpected != null) {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\nunexpected.getPreferredName());\n}\n\n// too few option\nif (present < minimum) {\nthrow new OptionException(this, ResourceConstants.MISSING_OPTION);\n}\n\n// validate each anonymous argument\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.validate(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nappendUsage(buffer, helpSettings, comp, \"|\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;Ljava/lang/String;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp,\nfinal String separator) {\nfinal Set helpSettingsCopy = new HashSet(helpSettings);\n\nfinal boolean optional =\n(minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\nfinal boolean expanded =\n(name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\nfinal boolean named =\n!expanded ||\n((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\nfinal boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\nfinal boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nhelpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nfinal boolean both = named && expanded;\n\nif (optional) {\nbuffer.append('[');\n}\n\nif (named) {\nbuffer.append(name);\n}\n\nif (both) {\nbuffer.append(\" (\");\n}\n\nif (expanded) {\nfinal Set childSettings;\n\nif (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\nchildSettings = DisplaySetting.NONE;\n} else {\nchildSettings = new HashSet(helpSettingsCopy);\nchildSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n}\n\n// grab a list of the group's options.\nfinal List list;\n\nif (comp == null) {\n// default to using the initial order\nlist = options;\n} else {\n// sort options if comparator is supplied\nlist = new ArrayList(options);\nCollections.sort(list, comp);\n}\n\n// for each option.\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// append usage information\noption.appendUsage(buffer, childSettings, comp);\n\n// add separators as needed\nif (i.hasNext()) {\nbuffer.append(separator);\n}\n}\n}\n\nif (both) {\nbuffer.append(')');\n}\n\nif (optional && outer) {\nbuffer.append(']');\n}\n\nif (arguments) {\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nbuffer.append(' ');\n\nfinal Option option = (Option) i.next();\noption.appendUsage(buffer, helpSettingsCopy, comp);\n}\n}\n\nif (optional && !outer) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guarenteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guarenteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public final boolean hasOption(final String trigger) {\nreturn hasOption(getOption(trigger));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final Option option) {\nreturn getValues(option, Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n\n// ensure that all parent options are also added\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addValue(Lorg/apache/commons/cli2/Option;Ljava/lang/Object;)V",
                                    "method_body": "public void addValue(final Option option,\nfinal Object value) {\nif (option instanceof Argument) {\naddOption(option);\n}\n\nList valueList = (List) values.get(option);\n\nif (valueList == null) {\nvalueList = new ArrayList();\nvalues.put(option, valueList);\n}\n\nvalueList.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:hasOption(Lorg/apache/commons/cli2/Option;)Z",
                                    "method_body": "public boolean hasOption(final Option option) {\nfinal boolean present = options.contains(option);\n\nreturn present;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOption(Ljava/lang/String;)Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getOption(final String trigger) {\nreturn (Option) nameToOption.get(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List getValues(final Option option,\nList defaultValues) {\n// initialize the return list\nList valueList = (List) values.get(option);\n\n// grab the correct default values\nif (defaultValues == null || defaultValues.isEmpty()) {\ndefaultValues = (List) this.defaultValues.get(option);\n}\n\n// augment the list with the default values\nif (defaultValues != null && !defaultValues.isEmpty()) {\nif (valueList == null || valueList.isEmpty()) {\nvalueList = defaultValues;\n} else {\n// if there are more default values as specified, add them to\n// the list.\nif (defaultValues.size() > valueList.size()) {\n// copy the list first\nvalueList = new ArrayList(valueList);\nfor (int i=valueList.size(); i<defaultValues.size(); i++) {\nvalueList.add(defaultValues.get(i));\n}\n}\n}\n}\n\nreturn valueList == null ? Collections.EMPTY_LIST : valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getUndefaultedValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public List getUndefaultedValues(Option option) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nfinal StringBuffer buffer = new StringBuffer();\nappendUsage(buffer, DisplaySetting.ALL, null);\n\nreturn buffer.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nfinal Set triggers = getTriggers();\n\nif (argument != null) {\nfinal char separator = argument.getInitialSeparator();\n\n// if there is a valid separator character\nif (separator != NUL) {\nfinal int initialIndex = arg.indexOf(separator);\n\n// if there is a separator present\nif (initialIndex > 0) {\nreturn triggers.contains(arg.substring(0, initialIndex));\n}\n}\n}\n\nreturn triggers.contains(arg);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nfinal boolean displayArgument =\n(this.argument != null) &&\nhelpSettings.contains(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nfinal boolean displayChildren =\n(this.children != null) &&\nhelpSettings.contains(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n\nif (displayArgument) {\nbuffer.append(' ');\nargument.appendUsage(buffer, helpSettings, comp);\n}\n\nif (displayChildren) {\nbuffer.append(' ');\nchildren.appendUsage(buffer, helpSettings, comp);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public Command(final String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\n// check the preferred name is valid\nif ((preferredName == null) || (preferredName.length() < 1)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.COMMAND_PREFERRED_NAME_TOO_SHORT));\n}\n\nthis.preferredName = preferredName;\n\n// gracefully and defensively handle aliases\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\n// populate the triggers Set\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\n// grab the argument to process\nfinal String arg = (String) arguments.next();\n\n// if we can process it\nif (canProcess(commandLine, arg)) {\n// then note the option\ncommandLine.addOption(this);\n\n// normalise the argument list\narguments.set(preferredName);\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display optionality\nfinal boolean optional =\n!isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\nfinal boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n\nif (optional) {\nbuffer.append('[');\n}\n\nbuffer.append(preferredName);\n\nif (displayAliases && !aliases.isEmpty()) {\nbuffer.append(\" (\");\n\nfinal List list = new ArrayList(aliases);\nCollections.sort(list);\n\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal String alias = (String) i.next();\nbuffer.append(alias);\n\nif (i.hasNext()) {\nbuffer.append(',');\n}\n}\n\nbuffer.append(')');\n}\n\nsuper.appendUsage(buffer, helpSettings, comp);\n\nif (optional) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn Collections.EMPTY_SET;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(WriteableCommandLine commandLine,\nListIterator args)\nthrows OptionException {\nprocessValues(commandLine, args, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn Collections.EMPTY_SET;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\nvalidate(commandLine, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display the outer optionality\nfinal boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n// allow numbering if multiple args\nfinal boolean numbered =\n(maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n\nfinal boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n\n// if infinite args are allowed then crop the list\nfinal int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n\nint i = 0;\n\n// for each argument\nwhile (i < max) {\n// if we're past the first add a space\nif (i > 0) {\nbuffer.append(' ');\n}\n\n// if the next arg is optional\nif ((i >= minimum) && (optional || (i > 0))) {\nbuffer.append('[');\n}\n\nif (bracketed) {\nbuffer.append('<');\n}\n\n// add name\nbuffer.append(name);\n++i;\n\n// if numbering\nif (numbered) {\nbuffer.append(i);\n}\n\nif (bracketed) {\nbuffer.append('>');\n}\n}\n\n// if infinite args are allowed\nif (maximum == Integer.MAX_VALUE) {\n// append elipsis\nbuffer.append(\" ...\");\n}\n\n// for each argument\nwhile (i > 0) {\n--i;\n\n// if the next arg is optional\nif ((i >= minimum) && (optional || (i > 0))) {\nbuffer.append(']');\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\ndefaultValues(commandLine, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display optionality\nfinal boolean optional =\n!isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\nfinal boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n\nif (optional) {\nbuffer.append('[');\n}\n\nbuffer.append(preferredName);\n\nif (displayAliases && !aliases.isEmpty()) {\nbuffer.append(\" (\");\n\nfinal List list = new ArrayList(aliases);\nCollections.sort(list);\n\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal String alias = (String) i.next();\nbuffer.append(alias);\n\nif (i.hasNext()) {\nbuffer.append(',');\n}\n}\n\nbuffer.append(')');\n}\n\nsuper.appendUsage(buffer, helpSettings, comp);\n\nif (optional) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOptions()Ljava/util/List;",
                                    "method_body": "public List getOptions() {\nreturn Collections.unmodifiableList(options);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.PreferencesCommandLine:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/prefs/Preferences;C)V",
                                    "method_body": "public PreferencesCommandLine(final Option root, final Preferences preferences, final char separator){\nthis.root = root;\nthis.preferences = preferences;\nthis.separator = separator;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli2.commandline.DefaultingCommandLineTest.testGetOptions_Order",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object thatObj) {\nif (thatObj instanceof OptionImpl) {\nfinal OptionImpl that = (OptionImpl) thatObj;\n\nreturn (getId() == that.getId()) &&\nequals(getPreferredName(), that.getPreferredName()) &&\nequals(getDescription(), that.getDescription()) &&\nequals(getPrefixes(), that.getPrefixes()) &&\nequals(getTriggers(), that.getTriggers());\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "private boolean equals(Object left,\nObject right) {\nif ((left == null) && (right == null)) {\nreturn true;\n} else if ((left == null) || (right == null)) {\nreturn false;\n} else {\nreturn left.equals(right);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nif (getPreferredName() != null) {\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n}\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefixes(Ljava/util/Set;)V",
                                    "method_body": "protected void checkPrefixes(final Set prefixes) {\n// nothing to do if empty prefix list\nif (prefixes.isEmpty()) {\nreturn;\n}\n\n// check preferred name\ncheckPrefix(prefixes, getPreferredName());\n\n// check triggers\nthis.getTriggers();\n\nfor (final Iterator i = getTriggers().iterator(); i.hasNext();) {\ncheckPrefix(prefixes, (String) i.next());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefix(Ljava/util/Set;Ljava/lang/String;)V",
                                    "method_body": "private void checkPrefix(final Set prefixes,\nfinal String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nString prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn;\n}\n}\n\nfinal ResourceHelper helper = ResourceHelper.getResourceHelper();\nfinal String message =\nhelper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\nprefixes.toString());\nthrow new IllegalArgumentException(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;Ljava/lang/String;IZ)V",
                                    "method_body": "protected ParentImpl(final Argument argument,\nfinal Group children,\nfinal String description,\nfinal int id,\nfinal boolean required) {\nsuper(id, required);\nthis.children = children;\nthis.argument = argument;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nif (argument != null) {\nhandleInitialSeparator(arguments, argument.getInitialSeparator());\n}\n\nprocessParent(commandLine, arguments);\n\nif (argument != null) {\nargument.processValues(commandLine, arguments, this);\n}\n\nif ((children != null) && children.canProcess(commandLine, arguments)) {\nchildren.process(commandLine, arguments);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (commandLine.hasOption(this)) {\nif (argument != null) {\nargument.validate(commandLine, this);\n}\n\nif (children != null) {\nchildren.validate(commandLine);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:handleInitialSeparator(Ljava/util/ListIterator;C)V",
                                    "method_body": "private void handleInitialSeparator(final ListIterator arguments,\nfinal char separator) {\n// next token\nfinal String newArgument = (String) arguments.next();\n\n// split the token\nfinal int initialIndex = newArgument.indexOf(separator);\n\nif (initialIndex > 0) {\narguments.remove();\narguments.add(newArgument.substring(0, initialIndex));\nString value = newArgument.substring(initialIndex + 1);\n// The value obviously isn't an option, so we need to quote it if looks like an option.\n// The quotes will be removed later\nif (value.startsWith(\"-\")) {\nvalue = '\"' + value + '\"';\n}\narguments.add(value);\narguments.previous();\n}\n\narguments.previous();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nif (argument != null) {\nargument.defaultValues(commandLine, this);\n}\n\nif (children != null) {\nchildren.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = commandLine.getUndefaultedValues(option).size();\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getInitialSeparator()C",
                                    "method_body": "public char getInitialSeparator() {\nreturn this.initialSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine,\nfinal Option option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nif (values.size() < minimum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n}\n\nif (values.size() > maximum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n(String) values.get(maximum));\n}\n\nif (validator != null) {\ntry {\nvalidator.validate(values);\n} catch (InvalidArgumentException ive) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nive.getMessage());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>()V",
                                    "method_body": "public DefaultOptionBuilder() {\nthis(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\nDefaultOption.DEFAULT_BURST_ENABLED);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
                                    "method_body": "public DefaultOptionBuilder(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled)\nthrows IllegalArgumentException {\nif ((shortPrefix == null) || (shortPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n}\n\nif ((longPrefix == null) || (longPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n}\n\nthis.shortPrefix = shortPrefix;\nthis.longPrefix = longPrefix;\nthis.burstEnabled = burstEnabled;\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:create()Lorg/apache/commons/cli2/option/DefaultOption;",
                                    "method_body": "public DefaultOption create()\nthrows IllegalStateException {\nif (preferredName == null) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n}\n\nfinal DefaultOption option =\nnew DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\naliases, burstAliases, required, argument, children, id);\n\nreset();\n\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:reset()Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder reset() {\npreferredName = null;\ndescription = null;\naliases = new HashSet();\nburstAliases = new HashSet();\nrequired = false;\nargument = null;\nchildren = null;\nid = 0;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withLongName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withLongName(final String longName) {\nfinal String name = longPrefix + longName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/util/Set;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public DefaultOption(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled,\nfinal String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal Set burstAliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\nthis.shortPrefix = shortPrefix;\nthis.burstEnabled = burstEnabled;\n\nthis.burstLength = shortPrefix.length() + 1;\n\nthis.preferredName = preferredName;\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\nthis.burstAliases =\n(burstAliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(burstAliases));\n\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nnewTriggers.addAll(this.burstAliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n\nfinal Set newPrefixes = new HashSet(super.getPrefixes());\nnewPrefixes.add(shortPrefix);\nnewPrefixes.add(longPrefix);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n\ncheckPrefixes(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(WriteableCommandLine commandLine,\nListIterator arguments)\nthrows OptionException {\nfinal String argument = (String) arguments.next();\n\nif (triggers.contains(argument)) {\ncommandLine.addOption(this);\narguments.set(preferredName);\n} else if (burstEnabled && (argument.length() >= burstLength)) {\nfinal String burst = argument.substring(0, burstLength);\n\nif (burstAliases.contains(burst)) {\ncommandLine.addOption(this);\n\n//HMM test bursting all vs bursting one by one.\narguments.set(preferredName);\n\nif (getArgument() == null) {\narguments.add(shortPrefix + argument.substring(burstLength));\n} else {\narguments.add(argument.substring(burstLength));\n}\n\narguments.previous();\n} else {\nthrow new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n}\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum) {\nsuper(0, false);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (commandLine.looksLikeOption(arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (commandLine.looksLikeOption(arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\n// number of options found\nint present = 0;\n\n// reference to first unexpected option\nOption unexpected = null;\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// needs validation?\nboolean validate = option.isRequired() || option instanceof Group;\n\n// if the child option is present then validate it\nif (commandLine.hasOption(option)) {\nif (++present > maximum) {\nunexpected = option;\n\nbreak;\n}\nvalidate = true;\n}\n\nif (validate) {\noption.validate(commandLine);\n}\n}\n\n// too many options\nif (unexpected != null) {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\nunexpected.getPreferredName());\n}\n\n// too few option\nif (present < minimum) {\nthrow new OptionException(this, ResourceConstants.MISSING_OPTION);\n}\n\n// validate each anonymous argument\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.validate(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nappendUsage(buffer, helpSettings, comp, \"|\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;Ljava/lang/String;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp,\nfinal String separator) {\nfinal Set helpSettingsCopy = new HashSet(helpSettings);\n\nfinal boolean optional =\n(minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\nfinal boolean expanded =\n(name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\nfinal boolean named =\n!expanded ||\n((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\nfinal boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\nfinal boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nhelpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nfinal boolean both = named && expanded;\n\nif (optional) {\nbuffer.append('[');\n}\n\nif (named) {\nbuffer.append(name);\n}\n\nif (both) {\nbuffer.append(\" (\");\n}\n\nif (expanded) {\nfinal Set childSettings;\n\nif (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\nchildSettings = DisplaySetting.NONE;\n} else {\nchildSettings = new HashSet(helpSettingsCopy);\nchildSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n}\n\n// grab a list of the group's options.\nfinal List list;\n\nif (comp == null) {\n// default to using the initial order\nlist = options;\n} else {\n// sort options if comparator is supplied\nlist = new ArrayList(options);\nCollections.sort(list, comp);\n}\n\n// for each option.\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// append usage information\noption.appendUsage(buffer, childSettings, comp);\n\n// add separators as needed\nif (i.hasNext()) {\nbuffer.append(separator);\n}\n}\n}\n\nif (both) {\nbuffer.append(')');\n}\n\nif (optional && outer) {\nbuffer.append(']');\n}\n\nif (arguments) {\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nbuffer.append(' ');\n\nfinal Option option = (Option) i.next();\noption.appendUsage(buffer, helpSettingsCopy, comp);\n}\n}\n\nif (optional && !outer) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guarenteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guarenteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public final boolean hasOption(final String trigger) {\nreturn hasOption(getOption(trigger));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final Option option) {\nreturn getValues(option, Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n\n// ensure that all parent options are also added\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addValue(Lorg/apache/commons/cli2/Option;Ljava/lang/Object;)V",
                                    "method_body": "public void addValue(final Option option,\nfinal Object value) {\nif (option instanceof Argument) {\naddOption(option);\n}\n\nList valueList = (List) values.get(option);\n\nif (valueList == null) {\nvalueList = new ArrayList();\nvalues.put(option, valueList);\n}\n\nvalueList.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:hasOption(Lorg/apache/commons/cli2/Option;)Z",
                                    "method_body": "public boolean hasOption(final Option option) {\nfinal boolean present = options.contains(option);\n\nreturn present;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOption(Ljava/lang/String;)Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getOption(final String trigger) {\nreturn (Option) nameToOption.get(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List getValues(final Option option,\nList defaultValues) {\n// initialize the return list\nList valueList = (List) values.get(option);\n\n// grab the correct default values\nif (defaultValues == null || defaultValues.isEmpty()) {\ndefaultValues = (List) this.defaultValues.get(option);\n}\n\n// augment the list with the default values\nif (defaultValues != null && !defaultValues.isEmpty()) {\nif (valueList == null || valueList.isEmpty()) {\nvalueList = defaultValues;\n} else {\n// if there are more default values as specified, add them to\n// the list.\nif (defaultValues.size() > valueList.size()) {\n// copy the list first\nvalueList = new ArrayList(valueList);\nfor (int i=valueList.size(); i<defaultValues.size(); i++) {\nvalueList.add(defaultValues.get(i));\n}\n}\n}\n}\n\nreturn valueList == null ? Collections.EMPTY_LIST : valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getUndefaultedValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public List getUndefaultedValues(Option option) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nfinal StringBuffer buffer = new StringBuffer();\nappendUsage(buffer, DisplaySetting.ALL, null);\n\nreturn buffer.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nfinal Set triggers = getTriggers();\n\nif (argument != null) {\nfinal char separator = argument.getInitialSeparator();\n\n// if there is a valid separator character\nif (separator != NUL) {\nfinal int initialIndex = arg.indexOf(separator);\n\n// if there is a separator present\nif (initialIndex > 0) {\nreturn triggers.contains(arg.substring(0, initialIndex));\n}\n}\n}\n\nreturn triggers.contains(arg);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nfinal boolean displayArgument =\n(this.argument != null) &&\nhelpSettings.contains(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nfinal boolean displayChildren =\n(this.children != null) &&\nhelpSettings.contains(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n\nif (displayArgument) {\nbuffer.append(' ');\nargument.appendUsage(buffer, helpSettings, comp);\n}\n\nif (displayChildren) {\nbuffer.append(' ');\nchildren.appendUsage(buffer, helpSettings, comp);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public Command(final String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\n// check the preferred name is valid\nif ((preferredName == null) || (preferredName.length() < 1)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.COMMAND_PREFERRED_NAME_TOO_SHORT));\n}\n\nthis.preferredName = preferredName;\n\n// gracefully and defensively handle aliases\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\n// populate the triggers Set\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\n// grab the argument to process\nfinal String arg = (String) arguments.next();\n\n// if we can process it\nif (canProcess(commandLine, arg)) {\n// then note the option\ncommandLine.addOption(this);\n\n// normalise the argument list\narguments.set(preferredName);\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display optionality\nfinal boolean optional =\n!isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\nfinal boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n\nif (optional) {\nbuffer.append('[');\n}\n\nbuffer.append(preferredName);\n\nif (displayAliases && !aliases.isEmpty()) {\nbuffer.append(\" (\");\n\nfinal List list = new ArrayList(aliases);\nCollections.sort(list);\n\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal String alias = (String) i.next();\nbuffer.append(alias);\n\nif (i.hasNext()) {\nbuffer.append(',');\n}\n}\n\nbuffer.append(')');\n}\n\nsuper.appendUsage(buffer, helpSettings, comp);\n\nif (optional) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn Collections.EMPTY_SET;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(WriteableCommandLine commandLine,\nListIterator args)\nthrows OptionException {\nprocessValues(commandLine, args, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn Collections.EMPTY_SET;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\nvalidate(commandLine, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display the outer optionality\nfinal boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n// allow numbering if multiple args\nfinal boolean numbered =\n(maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n\nfinal boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n\n// if infinite args are allowed then crop the list\nfinal int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n\nint i = 0;\n\n// for each argument\nwhile (i < max) {\n// if we're past the first add a space\nif (i > 0) {\nbuffer.append(' ');\n}\n\n// if the next arg is optional\nif ((i >= minimum) && (optional || (i > 0))) {\nbuffer.append('[');\n}\n\nif (bracketed) {\nbuffer.append('<');\n}\n\n// add name\nbuffer.append(name);\n++i;\n\n// if numbering\nif (numbered) {\nbuffer.append(i);\n}\n\nif (bracketed) {\nbuffer.append('>');\n}\n}\n\n// if infinite args are allowed\nif (maximum == Integer.MAX_VALUE) {\n// append elipsis\nbuffer.append(\" ...\");\n}\n\n// for each argument\nwhile (i > 0) {\n--i;\n\n// if the next arg is optional\nif ((i >= minimum) && (optional || (i > 0))) {\nbuffer.append(']');\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\ndefaultValues(commandLine, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display optionality\nfinal boolean optional =\n!isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\nfinal boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n\nif (optional) {\nbuffer.append('[');\n}\n\nbuffer.append(preferredName);\n\nif (displayAliases && !aliases.isEmpty()) {\nbuffer.append(\" (\");\n\nfinal List list = new ArrayList(aliases);\nCollections.sort(list);\n\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal String alias = (String) i.next();\nbuffer.append(alias);\n\nif (i.hasNext()) {\nbuffer.append(',');\n}\n}\n\nbuffer.append(')');\n}\n\nsuper.appendUsage(buffer, helpSettings, comp);\n\nif (optional) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addSwitch(Lorg/apache/commons/cli2/Option;Z)V",
                                    "method_body": "public void addSwitch(final Option option,\nfinal boolean value) {\naddOption(option);\n\nif (switches.containsKey(option)) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n} else {\nswitches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addProperty(Lorg/apache/commons/cli2/Option;Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public void addProperty(final Option option,\nfinal String property,\nfinal String value) {\nProperties properties = (Properties) optionToProperties.get(option);\nif (properties == null) {\nproperties = new Properties();\noptionToProperties.put(option, properties);\n}\nproperties.setProperty(property, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addProperty(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public void addProperty(final String property, final String value) {\naddProperty(new PropertyOption(), property, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOptions()Ljava/util/List;",
                                    "method_body": "public List getOptions() {\nreturn Collections.unmodifiableList(options);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:<init>()V",
                                    "method_body": "public PropertyOption() {\nthis(DEFAULT_OPTION_STRING, DEFAULT_DESCRIPTION, 'D');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:<init>(Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public PropertyOption(final String optionString,\nfinal String description,\nfinal int id) {\nsuper(id, false);\nthis.optionString = optionString;\nthis.description = description;\nthis.prefixes = Collections.singleton(optionString);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:<clinit>()V",
                                    "method_body": "public static final String DEFAULT_OPTION_STRING = \"-D\";\npublic static final String DEFAULT_DESCRIPTION =\n\"Passes properties and values to the application\";\n\n/**\n* A default PropertyOption instance\n*/\npublic static final PropertyOption INSTANCE = new PropertyOption();\nprivate final String optionString;\nprivate final String description;\nprivate final Set prefixes;\n\n/**\n* Creates a new PropertyOption using the default settings of a \"-D\" trigger\n* and an id of 'D'\n*/\npublic PropertyOption() {\nthis(DEFAULT_OPTION_STRING, DEFAULT_DESCRIPTION, 'D');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn Collections.singleton(optionString);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn optionString;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.DefaultingCommandLine:appendCommandLine(Lorg/apache/commons/cli2/CommandLine;)V",
                                    "method_body": "public void appendCommandLine(final CommandLine commandLine) {\ncommandLines.add(commandLine);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli2.bug.BugCLI123Test.testSingleChildOption",
                            "test_body": "public void testSingleChildOption() throws OptionException {\nCommandLine cl = parser.parse(new String[] { \"--child\", \"test\" });\nassertTrue(\"Child option not found\", cl.hasOption(childOption1));\nassertEquals(\"Wrong value for option\", \"test\", cl\n.getValue(childOption1));\nassertTrue(\"Child group not found\", cl.hasOption(childGroup));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object thatObj) {\nif (thatObj instanceof OptionImpl) {\nfinal OptionImpl that = (OptionImpl) thatObj;\n\nreturn (getId() == that.getId()) &&\nequals(getPreferredName(), that.getPreferredName()) &&\nequals(getDescription(), that.getDescription()) &&\nequals(getPrefixes(), that.getPrefixes()) &&\nequals(getTriggers(), that.getTriggers());\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "private boolean equals(Object left,\nObject right) {\nif ((left == null) && (right == null)) {\nreturn true;\n} else if ((left == null) || (right == null)) {\nreturn false;\n} else {\nreturn left.equals(right);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nif (getPreferredName() != null) {\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n}\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefixes(Ljava/util/Set;)V",
                                    "method_body": "protected void checkPrefixes(final Set prefixes) {\n// nothing to do if empty prefix list\nif (prefixes.isEmpty()) {\nreturn;\n}\n\n// check preferred name\ncheckPrefix(prefixes, getPreferredName());\n\n// check triggers\nthis.getTriggers();\n\nfor (final Iterator i = getTriggers().iterator(); i.hasNext();) {\ncheckPrefix(prefixes, (String) i.next());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefix(Ljava/util/Set;Ljava/lang/String;)V",
                                    "method_body": "private void checkPrefix(final Set prefixes,\nfinal String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nString prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn;\n}\n}\n\nfinal ResourceHelper helper = ResourceHelper.getResourceHelper();\nfinal String message =\nhelper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\nprefixes.toString());\nthrow new IllegalArgumentException(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;Ljava/lang/String;IZ)V",
                                    "method_body": "protected ParentImpl(final Argument argument,\nfinal Group children,\nfinal String description,\nfinal int id,\nfinal boolean required) {\nsuper(id, required);\nthis.children = children;\nthis.argument = argument;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nif (argument != null) {\nhandleInitialSeparator(arguments, argument.getInitialSeparator());\n}\n\nprocessParent(commandLine, arguments);\n\nif (argument != null) {\nargument.processValues(commandLine, arguments, this);\n}\n\nif ((children != null) && children.canProcess(commandLine, arguments)) {\nchildren.process(commandLine, arguments);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (commandLine.hasOption(this)) {\nif (argument != null) {\nargument.validate(commandLine, this);\n}\n\nif (children != null) {\nchildren.validate(commandLine);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:handleInitialSeparator(Ljava/util/ListIterator;C)V",
                                    "method_body": "private void handleInitialSeparator(final ListIterator arguments,\nfinal char separator) {\n// next token\nfinal String newArgument = (String) arguments.next();\n\n// split the token\nfinal int initialIndex = newArgument.indexOf(separator);\n\nif (initialIndex > 0) {\narguments.remove();\narguments.add(newArgument.substring(0, initialIndex));\nString value = newArgument.substring(initialIndex + 1);\n// The value obviously isn't an option, so we need to quote it if looks like an option.\n// The quotes will be removed later\nif (value.startsWith(\"-\")) {\nvalue = '\"' + value + '\"';\n}\narguments.add(value);\narguments.previous();\n}\n\narguments.previous();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nif (argument != null) {\nargument.defaultValues(commandLine, this);\n}\n\nif (children != null) {\nchildren.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<init>()V",
                                    "method_body": "public ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<clinit>()V",
                                    "method_body": "private final static ResourceHelper resources = ResourceHelper.getResourceHelper();\n\n/** name of the argument. Used for display and lookups in CommandLine */\nprivate String name;\n\n/** description of the argument. Used in the automated online help */\nprivate String description;\n\n/** minimum number of values required */\nprivate int minimum;\n\n/** maximum number of values permitted */\nprivate int maximum;\n\n/** character used to separate the values from the option */\nprivate char initialSeparator;\n\n/** character used to separate the values from each other */\nprivate char subsequentSeparator;\n\n/** object that should be used to ensure the values are valid */\nprivate Validator validator;\n\n/** used to identify the consume remaining option, typically \"--\" */\nprivate String consumeRemaining;\n\n/** default values for argument */\nprivate List defaultValues;\n\n/** id of the argument */\nprivate int id;\n\n/**\n* Creates a new ArgumentBuilder instance\n*/\npublic ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:create()Lorg/apache/commons/cli2/Argument;",
                                    "method_body": "public final Argument create() {\nfinal Argument argument =\nnew ArgumentImpl(\nname,\ndescription,\nminimum,\nmaximum,\ninitialSeparator,\nsubsequentSeparator,\nvalidator,\nconsumeRemaining,\ndefaultValues,\nid);\n\nreset();\n\nreturn argument;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:reset()Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder reset() {\nname = \"arg\";\ndescription = null;\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\ninitialSeparator = ArgumentImpl.DEFAULT_INITIAL_SEPARATOR;\nsubsequentSeparator = ArgumentImpl.DEFAULT_SUBSEQUENT_SEPARATOR;\nvalidator = null;\nconsumeRemaining = \"--\";\ndefaultValues = null;\nid = 0;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withName(final String newName) {\nif (newName == null) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_NAME));\n}\nif (\"\".equals(newName)) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_NAME));\n}\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getMessage(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getMessage(final String key) {\nreturn getMessage(key, new Object[] {  });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getMessage(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String getMessage(final String key,\nfinal Object[] values) {\nfinal String msgFormatStr = bundle.getString(key);\nfinal MessageFormat msgFormat = new MessageFormat(msgFormatStr);\n\nreturn msgFormat.format(values);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = commandLine.getUndefaultedValues(option).size();\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getInitialSeparator()C",
                                    "method_body": "public char getInitialSeparator() {\nreturn this.initialSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine,\nfinal Option option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nif (values.size() < minimum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n}\n\nif (values.size() > maximum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n(String) values.get(maximum));\n}\n\nif (validator != null) {\ntry {\nvalidator.validate(values);\n} catch (InvalidArgumentException ive) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nive.getMessage());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>()V",
                                    "method_body": "public DefaultOptionBuilder() {\nthis(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\nDefaultOption.DEFAULT_BURST_ENABLED);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
                                    "method_body": "public DefaultOptionBuilder(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled)\nthrows IllegalArgumentException {\nif ((shortPrefix == null) || (shortPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n}\n\nif ((longPrefix == null) || (longPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n}\n\nthis.shortPrefix = shortPrefix;\nthis.longPrefix = longPrefix;\nthis.burstEnabled = burstEnabled;\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:create()Lorg/apache/commons/cli2/option/DefaultOption;",
                                    "method_body": "public DefaultOption create()\nthrows IllegalStateException {\nif (preferredName == null) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n}\n\nfinal DefaultOption option =\nnew DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\naliases, burstAliases, required, argument, children, id);\n\nreset();\n\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:reset()Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder reset() {\npreferredName = null;\ndescription = null;\naliases = new HashSet();\nburstAliases = new HashSet();\nrequired = false;\nargument = null;\nchildren = null;\nid = 0;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withShortName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withShortName(final String shortName) {\nfinal String name = shortPrefix + shortName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nif (burstEnabled && (name.length() == (shortPrefix.length() + 1))) {\nburstAliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withLongName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withLongName(final String longName) {\nfinal String name = longPrefix + longName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withArgument(Lorg/apache/commons/cli2/Argument;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withArgument(final Argument newArgument) {\nthis.argument = newArgument;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/util/Set;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public DefaultOption(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled,\nfinal String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal Set burstAliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\nthis.shortPrefix = shortPrefix;\nthis.burstEnabled = burstEnabled;\n\nthis.burstLength = shortPrefix.length() + 1;\n\nthis.preferredName = preferredName;\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\nthis.burstAliases =\n(burstAliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(burstAliases));\n\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nnewTriggers.addAll(this.burstAliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n\nfinal Set newPrefixes = new HashSet(super.getPrefixes());\nnewPrefixes.add(shortPrefix);\nnewPrefixes.add(longPrefix);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n\ncheckPrefixes(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(WriteableCommandLine commandLine,\nListIterator arguments)\nthrows OptionException {\nfinal String argument = (String) arguments.next();\n\nif (triggers.contains(argument)) {\ncommandLine.addOption(this);\narguments.set(preferredName);\n} else if (burstEnabled && (argument.length() >= burstLength)) {\nfinal String burst = argument.substring(0, burstLength);\n\nif (burstAliases.contains(burst)) {\ncommandLine.addOption(this);\n\n//HMM test bursting all vs bursting one by one.\narguments.set(preferredName);\n\nif (getArgument() == null) {\narguments.add(shortPrefix + argument.substring(burstLength));\n} else {\narguments.add(argument.substring(burstLength));\n}\n\narguments.previous();\n} else {\nthrow new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n}\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withName(final String newName) {\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withMinimum(I)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withMinimum(final int newMinimum) {\nthis.minimum = newMinimum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withMaximum(I)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withMaximum(final int newMaximum) {\nthis.maximum = newMaximum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum) {\nsuper(0, false);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (commandLine.looksLikeOption(arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn optionMap.keySet();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (commandLine.looksLikeOption(arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\n// number of options found\nint present = 0;\n\n// reference to first unexpected option\nOption unexpected = null;\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// needs validation?\nboolean validate = option.isRequired() || option instanceof Group;\n\n// if the child option is present then validate it\nif (commandLine.hasOption(option)) {\nif (++present > maximum) {\nunexpected = option;\n\nbreak;\n}\nvalidate = true;\n}\n\nif (validate) {\noption.validate(commandLine);\n}\n}\n\n// too many options\nif (unexpected != null) {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\nunexpected.getPreferredName());\n}\n\n// too few option\nif (present < minimum) {\nthrow new OptionException(this, ResourceConstants.MISSING_OPTION);\n}\n\n// validate each anonymous argument\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.validate(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nappendUsage(buffer, helpSettings, comp, \"|\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;Ljava/lang/String;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp,\nfinal String separator) {\nfinal Set helpSettingsCopy = new HashSet(helpSettings);\n\nfinal boolean optional =\n(minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\nfinal boolean expanded =\n(name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\nfinal boolean named =\n!expanded ||\n((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\nfinal boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\nfinal boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nhelpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nfinal boolean both = named && expanded;\n\nif (optional) {\nbuffer.append('[');\n}\n\nif (named) {\nbuffer.append(name);\n}\n\nif (both) {\nbuffer.append(\" (\");\n}\n\nif (expanded) {\nfinal Set childSettings;\n\nif (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\nchildSettings = DisplaySetting.NONE;\n} else {\nchildSettings = new HashSet(helpSettingsCopy);\nchildSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n}\n\n// grab a list of the group's options.\nfinal List list;\n\nif (comp == null) {\n// default to using the initial order\nlist = options;\n} else {\n// sort options if comparator is supplied\nlist = new ArrayList(options);\nCollections.sort(list, comp);\n}\n\n// for each option.\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// append usage information\noption.appendUsage(buffer, childSettings, comp);\n\n// add separators as needed\nif (i.hasNext()) {\nbuffer.append(separator);\n}\n}\n}\n\nif (both) {\nbuffer.append(')');\n}\n\nif (optional && outer) {\nbuffer.append(']');\n}\n\nif (arguments) {\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nbuffer.append(' ');\n\nfinal Option option = (Option) i.next();\noption.appendUsage(buffer, helpSettingsCopy, comp);\n}\n}\n\nif (optional && !outer) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getMinimum()I",
                                    "method_body": "public int getMinimum() {\nreturn minimum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn getMinimum() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guarenteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guarenteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:<init>(Lorg/apache/commons/cli2/Option;Ljava/lang/String;)V",
                                    "method_body": "public OptionException(final Option option,\nfinal String messageKey) {\nthis(option, messageKey, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:<init>(Lorg/apache/commons/cli2/Option;Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public OptionException(final Option option,\nfinal String messageKey,\nfinal String value) {\nthis.option = option;\n\nif (messageKey != null) {\nfinal StringBuffer buffer = new StringBuffer();\n\nif (value != null) {\nbuffer.append(helper.getMessage(messageKey, value));\n} else {\nbuffer.append(helper.getMessage(messageKey));\n}\n\nbuffer.append(\" \");\n\noption.appendUsage(buffer, HELP_SETTINGS, null);\nmessage = buffer.toString();\n} else {\nmessage = \"\";\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:<clinit>()V",
                                    "method_body": "public static final Set HELP_SETTINGS =\nCollections.unmodifiableSet(Collections.singleton(DisplaySetting.DISPLAY_PROPERTY_OPTION));\n\n/** resource helper instance */\nprivate static final ResourceHelper helper = ResourceHelper.getResourceHelper();\n\n/** The Option the exception relates to */\nprivate final Option option;\n\n/** The message explaining the Exception */\nprivate final String message;\n\n/**\n* Creates a new OptionException.\n*\n* @param option\n*            The Option the exception relates to\n*/\npublic OptionException(final Option option) {\nthis(option, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:getMessage()Ljava/lang/String;",
                                    "method_body": "public String getMessage() {\nreturn message;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public final boolean hasOption(final String trigger) {\nreturn hasOption(getOption(trigger));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final Option option) {\nreturn getValues(option, Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n\n// ensure that all parent options are also added\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addValue(Lorg/apache/commons/cli2/Option;Ljava/lang/Object;)V",
                                    "method_body": "public void addValue(final Option option,\nfinal Object value) {\nif (option instanceof Argument) {\naddOption(option);\n}\n\nList valueList = (List) values.get(option);\n\nif (valueList == null) {\nvalueList = new ArrayList();\nvalues.put(option, valueList);\n}\n\nvalueList.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:hasOption(Lorg/apache/commons/cli2/Option;)Z",
                                    "method_body": "public boolean hasOption(final Option option) {\nfinal boolean present = options.contains(option);\n\nreturn present;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOption(Ljava/lang/String;)Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getOption(final String trigger) {\nreturn (Option) nameToOption.get(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List getValues(final Option option,\nList defaultValues) {\n// initialize the return list\nList valueList = (List) values.get(option);\n\n// grab the correct default values\nif (defaultValues == null || defaultValues.isEmpty()) {\ndefaultValues = (List) this.defaultValues.get(option);\n}\n\n// augment the list with the default values\nif (defaultValues != null && !defaultValues.isEmpty()) {\nif (valueList == null || valueList.isEmpty()) {\nvalueList = defaultValues;\n} else {\n// if there are more default values as specified, add them to\n// the list.\nif (defaultValues.size() > valueList.size()) {\n// copy the list first\nvalueList = new ArrayList(valueList);\nfor (int i=valueList.size(); i<defaultValues.size(); i++) {\nvalueList.add(defaultValues.get(i));\n}\n}\n}\n}\n\nreturn valueList == null ? Collections.EMPTY_LIST : valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getUndefaultedValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public List getUndefaultedValues(Option option) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli2.commandline.WriteableCommandLineImplTest.testGetOptions_Order",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object thatObj) {\nif (thatObj instanceof OptionImpl) {\nfinal OptionImpl that = (OptionImpl) thatObj;\n\nreturn (getId() == that.getId()) &&\nequals(getPreferredName(), that.getPreferredName()) &&\nequals(getDescription(), that.getDescription()) &&\nequals(getPrefixes(), that.getPrefixes()) &&\nequals(getTriggers(), that.getTriggers());\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "private boolean equals(Object left,\nObject right) {\nif ((left == null) && (right == null)) {\nreturn true;\n} else if ((left == null) || (right == null)) {\nreturn false;\n} else {\nreturn left.equals(right);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nif (getPreferredName() != null) {\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n}\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefixes(Ljava/util/Set;)V",
                                    "method_body": "protected void checkPrefixes(final Set prefixes) {\n// nothing to do if empty prefix list\nif (prefixes.isEmpty()) {\nreturn;\n}\n\n// check preferred name\ncheckPrefix(prefixes, getPreferredName());\n\n// check triggers\nthis.getTriggers();\n\nfor (final Iterator i = getTriggers().iterator(); i.hasNext();) {\ncheckPrefix(prefixes, (String) i.next());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefix(Ljava/util/Set;Ljava/lang/String;)V",
                                    "method_body": "private void checkPrefix(final Set prefixes,\nfinal String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nString prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn;\n}\n}\n\nfinal ResourceHelper helper = ResourceHelper.getResourceHelper();\nfinal String message =\nhelper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\nprefixes.toString());\nthrow new IllegalArgumentException(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;Ljava/lang/String;IZ)V",
                                    "method_body": "protected ParentImpl(final Argument argument,\nfinal Group children,\nfinal String description,\nfinal int id,\nfinal boolean required) {\nsuper(id, required);\nthis.children = children;\nthis.argument = argument;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nif (argument != null) {\nhandleInitialSeparator(arguments, argument.getInitialSeparator());\n}\n\nprocessParent(commandLine, arguments);\n\nif (argument != null) {\nargument.processValues(commandLine, arguments, this);\n}\n\nif ((children != null) && children.canProcess(commandLine, arguments)) {\nchildren.process(commandLine, arguments);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (commandLine.hasOption(this)) {\nif (argument != null) {\nargument.validate(commandLine, this);\n}\n\nif (children != null) {\nchildren.validate(commandLine);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:handleInitialSeparator(Ljava/util/ListIterator;C)V",
                                    "method_body": "private void handleInitialSeparator(final ListIterator arguments,\nfinal char separator) {\n// next token\nfinal String newArgument = (String) arguments.next();\n\n// split the token\nfinal int initialIndex = newArgument.indexOf(separator);\n\nif (initialIndex > 0) {\narguments.remove();\narguments.add(newArgument.substring(0, initialIndex));\nString value = newArgument.substring(initialIndex + 1);\n// The value obviously isn't an option, so we need to quote it if looks like an option.\n// The quotes will be removed later\nif (value.startsWith(\"-\")) {\nvalue = '\"' + value + '\"';\n}\narguments.add(value);\narguments.previous();\n}\n\narguments.previous();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nif (argument != null) {\nargument.defaultValues(commandLine, this);\n}\n\nif (children != null) {\nchildren.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = commandLine.getUndefaultedValues(option).size();\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getInitialSeparator()C",
                                    "method_body": "public char getInitialSeparator() {\nreturn this.initialSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine,\nfinal Option option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nif (values.size() < minimum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n}\n\nif (values.size() > maximum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n(String) values.get(maximum));\n}\n\nif (validator != null) {\ntry {\nvalidator.validate(values);\n} catch (InvalidArgumentException ive) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nive.getMessage());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>()V",
                                    "method_body": "public DefaultOptionBuilder() {\nthis(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\nDefaultOption.DEFAULT_BURST_ENABLED);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
                                    "method_body": "public DefaultOptionBuilder(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled)\nthrows IllegalArgumentException {\nif ((shortPrefix == null) || (shortPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n}\n\nif ((longPrefix == null) || (longPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n}\n\nthis.shortPrefix = shortPrefix;\nthis.longPrefix = longPrefix;\nthis.burstEnabled = burstEnabled;\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:create()Lorg/apache/commons/cli2/option/DefaultOption;",
                                    "method_body": "public DefaultOption create()\nthrows IllegalStateException {\nif (preferredName == null) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n}\n\nfinal DefaultOption option =\nnew DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\naliases, burstAliases, required, argument, children, id);\n\nreset();\n\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:reset()Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder reset() {\npreferredName = null;\ndescription = null;\naliases = new HashSet();\nburstAliases = new HashSet();\nrequired = false;\nargument = null;\nchildren = null;\nid = 0;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withLongName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withLongName(final String longName) {\nfinal String name = longPrefix + longName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/util/Set;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public DefaultOption(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled,\nfinal String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal Set burstAliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\nthis.shortPrefix = shortPrefix;\nthis.burstEnabled = burstEnabled;\n\nthis.burstLength = shortPrefix.length() + 1;\n\nthis.preferredName = preferredName;\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\nthis.burstAliases =\n(burstAliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(burstAliases));\n\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nnewTriggers.addAll(this.burstAliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n\nfinal Set newPrefixes = new HashSet(super.getPrefixes());\nnewPrefixes.add(shortPrefix);\nnewPrefixes.add(longPrefix);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n\ncheckPrefixes(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(WriteableCommandLine commandLine,\nListIterator arguments)\nthrows OptionException {\nfinal String argument = (String) arguments.next();\n\nif (triggers.contains(argument)) {\ncommandLine.addOption(this);\narguments.set(preferredName);\n} else if (burstEnabled && (argument.length() >= burstLength)) {\nfinal String burst = argument.substring(0, burstLength);\n\nif (burstAliases.contains(burst)) {\ncommandLine.addOption(this);\n\n//HMM test bursting all vs bursting one by one.\narguments.set(preferredName);\n\nif (getArgument() == null) {\narguments.add(shortPrefix + argument.substring(burstLength));\n} else {\narguments.add(argument.substring(burstLength));\n}\n\narguments.previous();\n} else {\nthrow new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n}\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum) {\nsuper(0, false);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (commandLine.looksLikeOption(arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (commandLine.looksLikeOption(arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\n// number of options found\nint present = 0;\n\n// reference to first unexpected option\nOption unexpected = null;\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// needs validation?\nboolean validate = option.isRequired() || option instanceof Group;\n\n// if the child option is present then validate it\nif (commandLine.hasOption(option)) {\nif (++present > maximum) {\nunexpected = option;\n\nbreak;\n}\nvalidate = true;\n}\n\nif (validate) {\noption.validate(commandLine);\n}\n}\n\n// too many options\nif (unexpected != null) {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\nunexpected.getPreferredName());\n}\n\n// too few option\nif (present < minimum) {\nthrow new OptionException(this, ResourceConstants.MISSING_OPTION);\n}\n\n// validate each anonymous argument\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.validate(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nappendUsage(buffer, helpSettings, comp, \"|\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;Ljava/lang/String;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp,\nfinal String separator) {\nfinal Set helpSettingsCopy = new HashSet(helpSettings);\n\nfinal boolean optional =\n(minimum == 0) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\nfinal boolean expanded =\n(name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\nfinal boolean named =\n!expanded ||\n((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\nfinal boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\nfinal boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nhelpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nfinal boolean both = named && expanded;\n\nif (optional) {\nbuffer.append('[');\n}\n\nif (named) {\nbuffer.append(name);\n}\n\nif (both) {\nbuffer.append(\" (\");\n}\n\nif (expanded) {\nfinal Set childSettings;\n\nif (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\nchildSettings = DisplaySetting.NONE;\n} else {\nchildSettings = new HashSet(helpSettingsCopy);\nchildSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n}\n\n// grab a list of the group's options.\nfinal List list;\n\nif (comp == null) {\n// default to using the initial order\nlist = options;\n} else {\n// sort options if comparator is supplied\nlist = new ArrayList(options);\nCollections.sort(list, comp);\n}\n\n// for each option.\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// append usage information\noption.appendUsage(buffer, childSettings, comp);\n\n// add separators as needed\nif (i.hasNext()) {\nbuffer.append(separator);\n}\n}\n}\n\nif (both) {\nbuffer.append(')');\n}\n\nif (optional && outer) {\nbuffer.append(']');\n}\n\nif (arguments) {\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nbuffer.append(' ');\n\nfinal Option option = (Option) i.next();\noption.appendUsage(buffer, helpSettingsCopy, comp);\n}\n}\n\nif (optional && !outer) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guarenteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guarenteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public final boolean hasOption(final String trigger) {\nreturn hasOption(getOption(trigger));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final Option option) {\nreturn getValues(option, Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n\n// ensure that all parent options are also added\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addValue(Lorg/apache/commons/cli2/Option;Ljava/lang/Object;)V",
                                    "method_body": "public void addValue(final Option option,\nfinal Object value) {\nif (option instanceof Argument) {\naddOption(option);\n}\n\nList valueList = (List) values.get(option);\n\nif (valueList == null) {\nvalueList = new ArrayList();\nvalues.put(option, valueList);\n}\n\nvalueList.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:hasOption(Lorg/apache/commons/cli2/Option;)Z",
                                    "method_body": "public boolean hasOption(final Option option) {\nfinal boolean present = options.contains(option);\n\nreturn present;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOption(Ljava/lang/String;)Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getOption(final String trigger) {\nreturn (Option) nameToOption.get(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List getValues(final Option option,\nList defaultValues) {\n// initialize the return list\nList valueList = (List) values.get(option);\n\n// grab the correct default values\nif (defaultValues == null || defaultValues.isEmpty()) {\ndefaultValues = (List) this.defaultValues.get(option);\n}\n\n// augment the list with the default values\nif (defaultValues != null && !defaultValues.isEmpty()) {\nif (valueList == null || valueList.isEmpty()) {\nvalueList = defaultValues;\n} else {\n// if there are more default values as specified, add them to\n// the list.\nif (defaultValues.size() > valueList.size()) {\n// copy the list first\nvalueList = new ArrayList(valueList);\nfor (int i=valueList.size(); i<defaultValues.size(); i++) {\nvalueList.add(defaultValues.get(i));\n}\n}\n}\n}\n\nreturn valueList == null ? Collections.EMPTY_LIST : valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getUndefaultedValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public List getUndefaultedValues(Option option) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:toString()Ljava/lang/String;",
                                    "method_body": "public String toString() {\nfinal StringBuffer buffer = new StringBuffer();\nappendUsage(buffer, DisplaySetting.ALL, null);\n\nreturn buffer.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nfinal Set triggers = getTriggers();\n\nif (argument != null) {\nfinal char separator = argument.getInitialSeparator();\n\n// if there is a valid separator character\nif (separator != NUL) {\nfinal int initialIndex = arg.indexOf(separator);\n\n// if there is a separator present\nif (initialIndex > 0) {\nreturn triggers.contains(arg.substring(0, initialIndex));\n}\n}\n}\n\nreturn triggers.contains(arg);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nfinal boolean displayArgument =\n(this.argument != null) &&\nhelpSettings.contains(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nfinal boolean displayChildren =\n(this.children != null) &&\nhelpSettings.contains(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n\nif (displayArgument) {\nbuffer.append(' ');\nargument.appendUsage(buffer, helpSettings, comp);\n}\n\nif (displayChildren) {\nbuffer.append(' ');\nchildren.appendUsage(buffer, helpSettings, comp);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public Command(final String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\n// check the preferred name is valid\nif ((preferredName == null) || (preferredName.length() < 1)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.COMMAND_PREFERRED_NAME_TOO_SHORT));\n}\n\nthis.preferredName = preferredName;\n\n// gracefully and defensively handle aliases\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\n// populate the triggers Set\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\n// grab the argument to process\nfinal String arg = (String) arguments.next();\n\n// if we can process it\nif (canProcess(commandLine, arg)) {\n// then note the option\ncommandLine.addOption(this);\n\n// normalise the argument list\narguments.set(preferredName);\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display optionality\nfinal boolean optional =\n!isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\nfinal boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n\nif (optional) {\nbuffer.append('[');\n}\n\nbuffer.append(preferredName);\n\nif (displayAliases && !aliases.isEmpty()) {\nbuffer.append(\" (\");\n\nfinal List list = new ArrayList(aliases);\nCollections.sort(list);\n\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal String alias = (String) i.next();\nbuffer.append(alias);\n\nif (i.hasNext()) {\nbuffer.append(',');\n}\n}\n\nbuffer.append(')');\n}\n\nsuper.appendUsage(buffer, helpSettings, comp);\n\nif (optional) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.Command:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn Collections.EMPTY_SET;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(WriteableCommandLine commandLine,\nListIterator args)\nthrows OptionException {\nprocessValues(commandLine, args, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn Collections.EMPTY_SET;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\nvalidate(commandLine, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display the outer optionality\nfinal boolean optional = helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\n\n// allow numbering if multiple args\nfinal boolean numbered =\n(maximum > 1) && helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_NUMBERED);\n\nfinal boolean bracketed = helpSettings.contains(DisplaySetting.DISPLAY_ARGUMENT_BRACKETED);\n\n// if infinite args are allowed then crop the list\nfinal int max = (maximum == Integer.MAX_VALUE) ? 2 : maximum;\n\nint i = 0;\n\n// for each argument\nwhile (i < max) {\n// if we're past the first add a space\nif (i > 0) {\nbuffer.append(' ');\n}\n\n// if the next arg is optional\nif ((i >= minimum) && (optional || (i > 0))) {\nbuffer.append('[');\n}\n\nif (bracketed) {\nbuffer.append('<');\n}\n\n// add name\nbuffer.append(name);\n++i;\n\n// if numbering\nif (numbered) {\nbuffer.append(i);\n}\n\nif (bracketed) {\nbuffer.append('>');\n}\n}\n\n// if infinite args are allowed\nif (maximum == Integer.MAX_VALUE) {\n// append elipsis\nbuffer.append(\" ...\");\n}\n\n// for each argument\nwhile (i > 0) {\n--i;\n\n// if the next arg is optional\nif ((i >= minimum) && (optional || (i > 0))) {\nbuffer.append(']');\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\ndefaultValues(commandLine, this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display optionality\nfinal boolean optional =\n!isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\nfinal boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n\nif (optional) {\nbuffer.append('[');\n}\n\nbuffer.append(preferredName);\n\nif (displayAliases && !aliases.isEmpty()) {\nbuffer.append(\" (\");\n\nfinal List list = new ArrayList(aliases);\nCollections.sort(list);\n\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal String alias = (String) i.next();\nbuffer.append(alias);\n\nif (i.hasNext()) {\nbuffer.append(',');\n}\n}\n\nbuffer.append(')');\n}\n\nsuper.appendUsage(buffer, helpSettings, comp);\n\nif (optional) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addSwitch(Lorg/apache/commons/cli2/Option;Z)V",
                                    "method_body": "public void addSwitch(final Option option,\nfinal boolean value) {\naddOption(option);\n\nif (switches.containsKey(option)) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.SWITCH_ALREADY_SET));\n} else {\nswitches.put(option, value ? Boolean.TRUE : Boolean.FALSE);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addProperty(Lorg/apache/commons/cli2/Option;Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public void addProperty(final Option option,\nfinal String property,\nfinal String value) {\nProperties properties = (Properties) optionToProperties.get(option);\nif (properties == null) {\nproperties = new Properties();\noptionToProperties.put(option, properties);\n}\nproperties.setProperty(property, value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOptions()Ljava/util/List;",
                                    "method_body": "public List getOptions() {\nreturn Collections.unmodifiableList(options);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:<init>()V",
                                    "method_body": "public PropertyOption() {\nthis(DEFAULT_OPTION_STRING, DEFAULT_DESCRIPTION, 'D');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:<init>(Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public PropertyOption(final String optionString,\nfinal String description,\nfinal int id) {\nsuper(id, false);\nthis.optionString = optionString;\nthis.description = description;\nthis.prefixes = Collections.singleton(optionString);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:<clinit>()V",
                                    "method_body": "public static final String DEFAULT_OPTION_STRING = \"-D\";\npublic static final String DEFAULT_DESCRIPTION =\n\"Passes properties and values to the application\";\n\n/**\n* A default PropertyOption instance\n*/\npublic static final PropertyOption INSTANCE = new PropertyOption();\nprivate final String optionString;\nprivate final String description;\nprivate final Set prefixes;\n\n/**\n* Creates a new PropertyOption using the default settings of a \"-D\" trigger\n* and an id of 'D'\n*/\npublic PropertyOption() {\nthis(DEFAULT_OPTION_STRING, DEFAULT_DESCRIPTION, 'D');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn Collections.singleton(optionString);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn optionString;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.PropertyOption:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli2.bug.BugCLI123Test.testParentOptionAndChildOption",
                            "test_body": "public void testParentOptionAndChildOption() throws OptionException {\ntry {\nparser.parse(new String[] { \"--parent\", \"error\", \"--child\",\n\"exception\" });\nfail(\"Maximum restriction for parent not verified!\");\n} catch (OptionException oex) {\n// ok\n}\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object thatObj) {\nif (thatObj instanceof OptionImpl) {\nfinal OptionImpl that = (OptionImpl) thatObj;\n\nreturn (getId() == that.getId()) &&\nequals(getPreferredName(), that.getPreferredName()) &&\nequals(getDescription(), that.getDescription()) &&\nequals(getPrefixes(), that.getPrefixes()) &&\nequals(getTriggers(), that.getTriggers());\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "private boolean equals(Object left,\nObject right) {\nif ((left == null) && (right == null)) {\nreturn true;\n} else if ((left == null) || (right == null)) {\nreturn false;\n} else {\nreturn left.equals(right);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nif (getPreferredName() != null) {\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n}\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefixes(Ljava/util/Set;)V",
                                    "method_body": "protected void checkPrefixes(final Set prefixes) {\n// nothing to do if empty prefix list\nif (prefixes.isEmpty()) {\nreturn;\n}\n\n// check preferred name\ncheckPrefix(prefixes, getPreferredName());\n\n// check triggers\nthis.getTriggers();\n\nfor (final Iterator i = getTriggers().iterator(); i.hasNext();) {\ncheckPrefix(prefixes, (String) i.next());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefix(Ljava/util/Set;Ljava/lang/String;)V",
                                    "method_body": "private void checkPrefix(final Set prefixes,\nfinal String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nString prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn;\n}\n}\n\nfinal ResourceHelper helper = ResourceHelper.getResourceHelper();\nfinal String message =\nhelper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\nprefixes.toString());\nthrow new IllegalArgumentException(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;Ljava/lang/String;IZ)V",
                                    "method_body": "protected ParentImpl(final Argument argument,\nfinal Group children,\nfinal String description,\nfinal int id,\nfinal boolean required) {\nsuper(id, required);\nthis.children = children;\nthis.argument = argument;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nif (argument != null) {\nhandleInitialSeparator(arguments, argument.getInitialSeparator());\n}\n\nprocessParent(commandLine, arguments);\n\nif (argument != null) {\nargument.processValues(commandLine, arguments, this);\n}\n\nif ((children != null) && children.canProcess(commandLine, arguments)) {\nchildren.process(commandLine, arguments);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (commandLine.hasOption(this)) {\nif (argument != null) {\nargument.validate(commandLine, this);\n}\n\nif (children != null) {\nchildren.validate(commandLine);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:handleInitialSeparator(Ljava/util/ListIterator;C)V",
                                    "method_body": "private void handleInitialSeparator(final ListIterator arguments,\nfinal char separator) {\n// next token\nfinal String newArgument = (String) arguments.next();\n\n// split the token\nfinal int initialIndex = newArgument.indexOf(separator);\n\nif (initialIndex > 0) {\narguments.remove();\narguments.add(newArgument.substring(0, initialIndex));\nString value = newArgument.substring(initialIndex + 1);\n// The value obviously isn't an option, so we need to quote it if looks like an option.\n// The quotes will be removed later\nif (value.startsWith(\"-\")) {\nvalue = '\"' + value + '\"';\n}\narguments.add(value);\narguments.previous();\n}\n\narguments.previous();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nif (argument != null) {\nargument.defaultValues(commandLine, this);\n}\n\nif (children != null) {\nchildren.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<init>()V",
                                    "method_body": "public ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<clinit>()V",
                                    "method_body": "private final static ResourceHelper resources = ResourceHelper.getResourceHelper();\n\n/** name of the argument. Used for display and lookups in CommandLine */\nprivate String name;\n\n/** description of the argument. Used in the automated online help */\nprivate String description;\n\n/** minimum number of values required */\nprivate int minimum;\n\n/** maximum number of values permitted */\nprivate int maximum;\n\n/** character used to separate the values from the option */\nprivate char initialSeparator;\n\n/** character used to separate the values from each other */\nprivate char subsequentSeparator;\n\n/** object that should be used to ensure the values are valid */\nprivate Validator validator;\n\n/** used to identify the consume remaining option, typically \"--\" */\nprivate String consumeRemaining;\n\n/** default values for argument */\nprivate List defaultValues;\n\n/** id of the argument */\nprivate int id;\n\n/**\n* Creates a new ArgumentBuilder instance\n*/\npublic ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:create()Lorg/apache/commons/cli2/Argument;",
                                    "method_body": "public final Argument create() {\nfinal Argument argument =\nnew ArgumentImpl(\nname,\ndescription,\nminimum,\nmaximum,\ninitialSeparator,\nsubsequentSeparator,\nvalidator,\nconsumeRemaining,\ndefaultValues,\nid);\n\nreset();\n\nreturn argument;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:reset()Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder reset() {\nname = \"arg\";\ndescription = null;\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\ninitialSeparator = ArgumentImpl.DEFAULT_INITIAL_SEPARATOR;\nsubsequentSeparator = ArgumentImpl.DEFAULT_SUBSEQUENT_SEPARATOR;\nvalidator = null;\nconsumeRemaining = \"--\";\ndefaultValues = null;\nid = 0;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withName(final String newName) {\nif (newName == null) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_NAME));\n}\nif (\"\".equals(newName)) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_EMPTY_NAME));\n}\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = commandLine.getUndefaultedValues(option).size();\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getInitialSeparator()C",
                                    "method_body": "public char getInitialSeparator() {\nreturn this.initialSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine,\nfinal Option option)\nthrows OptionException {\nfinal List values = commandLine.getValues(option);\n\nif (values.size() < minimum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_MISSING_VALUES);\n}\n\nif (values.size() > maximum) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\n(String) values.get(maximum));\n}\n\nif (validator != null) {\ntry {\nvalidator.validate(values);\n} catch (InvalidArgumentException ive) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nive.getMessage());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>()V",
                                    "method_body": "public DefaultOptionBuilder() {\nthis(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\nDefaultOption.DEFAULT_BURST_ENABLED);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
                                    "method_body": "public DefaultOptionBuilder(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled)\nthrows IllegalArgumentException {\nif ((shortPrefix == null) || (shortPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n}\n\nif ((longPrefix == null) || (longPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n}\n\nthis.shortPrefix = shortPrefix;\nthis.longPrefix = longPrefix;\nthis.burstEnabled = burstEnabled;\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:create()Lorg/apache/commons/cli2/option/DefaultOption;",
                                    "method_body": "public DefaultOption create()\nthrows IllegalStateException {\nif (preferredName == null) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n}\n\nfinal DefaultOption option =\nnew DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\naliases, burstAliases, required, argument, children, id);\n\nreset();\n\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:reset()Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder reset() {\npreferredName = null;\ndescription = null;\naliases = new HashSet();\nburstAliases = new HashSet();\nrequired = false;\nargument = null;\nchildren = null;\nid = 0;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withShortName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withShortName(final String shortName) {\nfinal String name = shortPrefix + shortName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nif (burstEnabled && (name.length() == (shortPrefix.length() + 1))) {\nburstAliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withLongName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withLongName(final String longName) {\nfinal String name = longPrefix + longName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withArgument(Lorg/apache/commons/cli2/Argument;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withArgument(final Argument newArgument) {\nthis.argument = newArgument;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/util/Set;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public DefaultOption(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled,\nfinal String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal Set burstAliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\nthis.shortPrefix = shortPrefix;\nthis.burstEnabled = burstEnabled;\n\nthis.burstLength = shortPrefix.length() + 1;\n\nthis.preferredName = preferredName;\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\nthis.burstAliases =\n(burstAliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(burstAliases));\n\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nnewTriggers.addAll(this.burstAliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n\nfinal Set newPrefixes = new HashSet(super.getPrefixes());\nnewPrefixes.add(shortPrefix);\nnewPrefixes.add(longPrefix);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n\ncheckPrefixes(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(WriteableCommandLine commandLine,\nListIterator arguments)\nthrows OptionException {\nfinal String argument = (String) arguments.next();\n\nif (triggers.contains(argument)) {\ncommandLine.addOption(this);\narguments.set(preferredName);\n} else if (burstEnabled && (argument.length() >= burstLength)) {\nfinal String burst = argument.substring(0, burstLength);\n\nif (burstAliases.contains(burst)) {\ncommandLine.addOption(this);\n\n//HMM test bursting all vs bursting one by one.\narguments.set(preferredName);\n\nif (getArgument() == null) {\narguments.add(shortPrefix + argument.substring(burstLength));\n} else {\narguments.add(argument.substring(burstLength));\n}\n\narguments.previous();\n} else {\nthrow new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n}\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(WriteableCommandLine commandLine)\nthrows OptionException {\nif (isRequired() && !commandLine.hasOption(this)) {\nthrow new OptionException(this, ResourceConstants.OPTION_MISSING_REQUIRED,\ngetPreferredName());\n}\n\nsuper.validate(commandLine);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withName(final String newName) {\nthis.name = newName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withMinimum(I)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withMinimum(final int newMinimum) {\nthis.minimum = newMinimum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withMaximum(I)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withMaximum(final int newMaximum) {\nthis.maximum = newMaximum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;II)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum) {\nsuper(0, false);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (commandLine.looksLikeOption(arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn optionMap.keySet();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (commandLine.looksLikeOption(arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:validate(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void validate(final WriteableCommandLine commandLine)\nthrows OptionException {\n// number of options found\nint present = 0;\n\n// reference to first unexpected option\nOption unexpected = null;\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// needs validation?\nboolean validate = option.isRequired() || option instanceof Group;\n\n// if the child option is present then validate it\nif (commandLine.hasOption(option)) {\nif (++present > maximum) {\nunexpected = option;\n\nbreak;\n}\nvalidate = true;\n}\n\nif (validate) {\noption.validate(commandLine);\n}\n}\n\n// too many options\nif (unexpected != null) {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN,\nunexpected.getPreferredName());\n}\n\n// too few option\nif (present < minimum) {\nthrow new OptionException(this, ResourceConstants.MISSING_OPTION);\n}\n\n// validate each anonymous argument\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.validate(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getMinimum()I",
                                    "method_body": "public int getMinimum() {\nreturn minimum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn getMinimum() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guarenteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guarenteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:getMessage()Ljava/lang/String;",
                                    "method_body": "public String getMessage() {\nreturn message;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public final boolean hasOption(final String trigger) {\nreturn hasOption(getOption(trigger));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.CommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public final List getValues(final Option option) {\nreturn getValues(option, Collections.EMPTY_LIST);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n\n// ensure that all parent options are also added\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addValue(Lorg/apache/commons/cli2/Option;Ljava/lang/Object;)V",
                                    "method_body": "public void addValue(final Option option,\nfinal Object value) {\nif (option instanceof Argument) {\naddOption(option);\n}\n\nList valueList = (List) values.get(option);\n\nif (valueList == null) {\nvalueList = new ArrayList();\nvalues.put(option, valueList);\n}\n\nvalueList.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:hasOption(Lorg/apache/commons/cli2/Option;)Z",
                                    "method_body": "public boolean hasOption(final Option option) {\nfinal boolean present = options.contains(option);\n\nreturn present;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getOption(Ljava/lang/String;)Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getOption(final String trigger) {\nreturn (Option) nameToOption.get(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)Ljava/util/List;",
                                    "method_body": "public List getValues(final Option option,\nList defaultValues) {\n// initialize the return list\nList valueList = (List) values.get(option);\n\n// grab the correct default values\nif (defaultValues == null || defaultValues.isEmpty()) {\ndefaultValues = (List) this.defaultValues.get(option);\n}\n\n// augment the list with the default values\nif (defaultValues != null && !defaultValues.isEmpty()) {\nif (valueList == null || valueList.isEmpty()) {\nvalueList = defaultValues;\n} else {\n// if there are more default values as specified, add them to\n// the list.\nif (defaultValues.size() > valueList.size()) {\n// copy the list first\nvalueList = new ArrayList(valueList);\nfor (int i=valueList.size(); i<defaultValues.size(); i++) {\nvalueList.add(defaultValues.get(i));\n}\n}\n}\n}\n\nreturn valueList == null ? Collections.EMPTY_LIST : valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getUndefaultedValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public List getUndefaultedValues(Option option) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn true;\n}\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 17,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.PosixParserTest.testStopBursting",
                            "test_body": "public void testStopBursting() throws Exception\n{\nString[] args = new String[] { \"-azc\" };\nCommandLine cl = parser.parse(options, args, true);\nassertTrue( \"Confirm -a is set\", cl.hasOption(\"a\") );\nassertFalse( \"Confirm -c is not set\", cl.hasOption(\"c\") );\nassertTrue( \"Confirm  1 extra arg: \" + cl.getArgList().size(), cl.getArgList().size() == 1);\nassertTrue(cl.getArgList().contains(\"zc\"));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null) {\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg,\nString description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals( Object o )\n{\nif ( this == o )\n{\nreturn true;\n}\nif ( o == null || getClass() != o.getClass() )\n{\nreturn false;\n}\n\nOption option = (Option) o;\n\n\nif ( opt != null ? !opt.equals( option.opt ) : option.opt != null )\n{\nreturn false;\n}\nif ( longOpt != null ? !longOpt.equals( option.longOpt ) : option.longOpt != null )\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone() {\ntry {\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n} catch(CloneNotSupportedException cnse) {\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options) {\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions() {\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions() {\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nboolean stopAtNonOption)\nthrows ParseException\n{\nreturn parse(options, arguments, null, stopAtNonOption);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(),\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processsed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains( resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption( String opt )\n{\nopt = Util.stripLeadingHyphens(opt);\nfor ( Iterator it = options.iterator(); it.hasNext(); )\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\nif (opt.equals( option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getArgList()Ljava/util/List;",
                                    "method_body": "public List getArgList()\n{\nreturn args;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addArg(Ljava/lang/String;)V",
                                    "method_body": "void addArg(String arg)\n{\nargs.add(arg);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nString token = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nint tokenLength = token.length();\n\nif (tokenLength == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token))\n{\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nif (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:process(Ljava/lang/String;)V",
                                    "method_body": "private void process(String value)\n{\nif (currentOption != null && currentOption.hasArg())\n{\nif (currentOption.hasArg())\n{\ntokens.add(value);\ncurrentOption = null;\n}\nelse if (currentOption.hasArgs())\n{\ntokens.add(value);\n}\n}\nelse\n{\neatTheRest = true;\ntokens.add(\"--\");\ntokens.add(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:burstToken(Ljava/lang/String;Z)V",
                                    "method_body": "protected void burstToken(String token, boolean stopAtNonOption)\n{\nfor (int i = 1; i < token.length(); i++)\n{\nString ch = String.valueOf(token.charAt(i));\n\nif (options.hasOption(ch))\n{\ntokens.add(\"-\" + ch);\ncurrentOption = options.getOption(ch);\n\nif (currentOption.hasArg() && (token.length() != (i + 1)))\n{\ntokens.add(token.substring(i + 1));\n\nbreak;\n}\n}\nelse if (stopAtNonOption)\n{\nprocess(token.substring(i));\n}\nelse\n{\ntokens.add(token);\nbreak;\n}\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 18,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.PosixParserTest.testStop2",
                            "test_body": "public void testStop2() throws Exception\n{\nString[] args = new String[]{\"-z\",\n\"-a\",\n\"-btoast\"};\nCommandLine cl = parser.parse(options, args, true);\nassertFalse(\"Confirm -a is not set\", cl.hasOption(\"a\"));\nassertTrue(\"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null) {\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg,\nString description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals( Object o )\n{\nif ( this == o )\n{\nreturn true;\n}\nif ( o == null || getClass() != o.getClass() )\n{\nreturn false;\n}\n\nOption option = (Option) o;\n\n\nif ( opt != null ? !opt.equals( option.opt ) : option.opt != null )\n{\nreturn false;\n}\nif ( longOpt != null ? !longOpt.equals( option.longOpt ) : option.longOpt != null )\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone() {\ntry {\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n} catch(CloneNotSupportedException cnse) {\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options) {\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions() {\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions() {\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nboolean stopAtNonOption)\nthrows ParseException\n{\nreturn parse(options, arguments, null, stopAtNonOption);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(),\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processsed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains( resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption( String opt )\n{\nopt = Util.stripLeadingHyphens(opt);\nfor ( Iterator it = options.iterator(); it.hasNext(); )\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\nif (opt.equals( option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addArg(Ljava/lang/String;)V",
                                    "method_body": "void addArg(String arg)\n{\nargs.add(arg);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nString token = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token))\n{\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse if (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (options.hasOption(token))\n{\ncurrentOption = options.getOption(token);\ntokens.add(token);\n}\nelse if (stopAtNonOption)\n{\neatTheRest = true;\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 19,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.PosixParserTest.testUnrecognizedOption2",
                            "test_body": "public void testUnrecognizedOption2() throws Exception\n{\nString[] args = new String[] { \"-z\", \"-abtoast\", \"foo\", \"bar\" };\ntry\n{\nparser.parse(options, args);\nfail(\"UnrecognizedOptionException wasn't thrown\");\n}\ncatch (UnrecognizedOptionException e)\n{\nassertEquals(\"-z\", e.getOption());\n}\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null) {\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nif (str.startsWith(\"\\\"\")) {\nstr = str.substring(1, str.length());\n}\nif (str.endsWith(\"\\\"\")) {\nstr = str.substring(0, str.length()-1);\n}\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg,\nString description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn (this.valuesep > 0);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
                                    "method_body": "void addValueForProcessing(String value)\n{\nswitch (numberOfArgs)\n{\ncase UNINITIALIZED:\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n\ndefault:\nprocessValue(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == (numberOfArgs - 1))\n{\nbreak;\n}\n\n\n// store\nadd(value.substring(0, index));\n\n\n// parse\nvalue = value.substring(index + 1);\n\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif ((numberOfArgs > 0) && (values.size() > (numberOfArgs - 1)))\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n\n// store value\nthis.values.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues()\n? null : (String[]) this.values.toArray(new String[this.values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn this.values.size() == 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone() {\ntry {\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n} catch(CloneNotSupportedException cnse) {\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options) {\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions() {\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions() {\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(),\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processsed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(Option opt, ListIterator iter)\nthrows ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nString str = (String) iter.next();\n\n// found an Option, not an argument\nif (getOptions().hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValueForProcessing( Util.stripLeadingAndTrailingQuotes(str) );\n}\ncatch (RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif ((opt.getValues() == null) && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter)\nthrows ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addArg(Ljava/lang/String;)V",
                                    "method_body": "void addArg(String arg)\n{\nargs.add(arg);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nString token = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\ntokens.add(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token))\n{\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse if (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (options.hasOption(token))\n{\ncurrentOption = options.getOption(token);\ntokens.add(token);\n}\nelse if (stopAtNonOption)\n{\neatTheRest = true;\ntokens.add(token);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:burstToken(Ljava/lang/String;Z)V",
                                    "method_body": "protected void burstToken(String token, boolean stopAtNonOption)\n{\nfor (int i = 1; i < token.length(); i++)\n{\nString ch = String.valueOf(token.charAt(i));\n\nif (options.hasOption(ch))\n{\ntokens.add(\"-\" + ch);\ncurrentOption = options.getOption(ch);\n\nif (currentOption.hasArg() && (token.length() != (i + 1)))\n{\ntokens.add(token.substring(i + 1));\n\nbreak;\n}\n}\nelse if (stopAtNonOption)\n{\nprocess(token.substring(i));\nbreak;\n}\nelse\n{\ntokens.add(token);\nbreak;\n}\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 20,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.PosixParserTest.testStop3",
                            "test_body": "public void testStop3() throws Exception\n{\nString[] args = new String[]{\"--zop==1\",\n\"-abtoast\",\n\"--b=bar\"};\nCommandLine cl = parser.parse(options, args, true);\nassertFalse(\"Confirm -a is not set\", cl.hasOption(\"a\"));\nassertFalse(\"Confirm -b is not set\", cl.hasOption(\"b\"));\nassertTrue(\"Confirm  3 extra args: \" + cl.getArgList().size(), cl.getArgList().size() == 3);\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null) {\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:<init>()V",
                                    "method_body": "public Options()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg,\nString description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn this.longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn (this.numberOfArgs > 0) || (numberOfArgs == UNLIMITED_VALUES);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues() {\nthis.values.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options) {\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions() {\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions() {\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nboolean stopAtNonOption)\nthrows ParseException\n{\nreturn parse(options, arguments, null, stopAtNonOption);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(),\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processsed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains( resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption( String opt )\n{\nopt = Util.stripLeadingHyphens(opt);\nfor ( Iterator it = options.iterator(); it.hasNext(); )\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\nif (opt.equals( option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getArgList()Ljava/util/List;",
                                    "method_body": "public List getArgList()\n{\nreturn args;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addArg(Ljava/lang/String;)V",
                                    "method_body": "void addArg(String arg)\n{\nargs.add(arg);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nString token = (String) iter.next();\n\n// handle long option --foo or --foo=bar\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1, token.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\ntokens.add(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token))\n{\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse if (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:burstToken(Ljava/lang/String;Z)V",
                                    "method_body": "protected void burstToken(String token, boolean stopAtNonOption)\n{\nfor (int i = 1; i < token.length(); i++)\n{\nString ch = String.valueOf(token.charAt(i));\n\nif (options.hasOption(ch))\n{\ntokens.add(\"-\" + ch);\ncurrentOption = options.getOption(ch);\n\nif (currentOption.hasArg() && (token.length() != (i + 1)))\n{\ntokens.add(token.substring(i + 1));\n\nbreak;\n}\n}\nelse if (stopAtNonOption)\n{\nprocess(token.substring(i));\nbreak;\n}\nelse\n{\ntokens.add(token);\nbreak;\n}\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 21,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli2.bug.BugCLI150Test.testNegativeNumber",
                            "test_body": "public void testNegativeNumber() throws OptionException\n{\nfinal DefaultOptionBuilder oBuilder = new DefaultOptionBuilder();\nfinal ArgumentBuilder aBuilder = new ArgumentBuilder();\nfinal GroupBuilder gBuilder = new GroupBuilder();\nfinal Argument numArg = aBuilder.withValidator(\nNumberValidator.getNumberInstance()).withMinimum(1)\n.withMaximum(1).create();\nfinal Option numOpt = oBuilder.withLongName(\"num\").withArgument(numArg)\n.create();\nfinal Group options = gBuilder.withOption(numOpt).create();\nfinal Parser parser = new Parser();\nparser.setGroup(options);\nCommandLine cl = parser.parse(new String[] {\n\"--num\", \"-42\"\n});\nNumber num = (Number) cl.getValue(numOpt);\nassertEquals(\"Wrong option value\", -42, num.intValue());\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:<init>(IZ)V",
                                    "method_body": "public OptionImpl(final int id,\nfinal boolean required) {\nthis.id = id;\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal ListIterator arguments) {\nif (arguments.hasNext()) {\nfinal String argument = (String) arguments.next();\narguments.previous();\n\nreturn canProcess(commandLine, argument);\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getId()I",
                                    "method_body": "public int getId() {\nreturn id;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object thatObj) {\nif (thatObj instanceof OptionImpl) {\nfinal OptionImpl that = (OptionImpl) thatObj;\n\nreturn (getId() == that.getId()) &&\nequals(getPreferredName(), that.getPreferredName()) &&\nequals(getDescription(), that.getDescription()) &&\nequals(getPrefixes(), that.getPrefixes()) &&\nequals(getTriggers(), that.getTriggers());\n} else {\nreturn false;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:equals(Ljava/lang/Object;Ljava/lang/Object;)Z",
                                    "method_body": "private boolean equals(Object left,\nObject right) {\nif ((left == null) && (right == null)) {\nreturn true;\n} else if ((left == null) || (right == null)) {\nreturn false;\n} else {\nreturn left.equals(right);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:hashCode()I",
                                    "method_body": "public int hashCode() {\nint hashCode = getId();\nif (getPreferredName() != null) {\nhashCode = (hashCode * 37) + getPreferredName().hashCode();\n}\n\nif (getDescription() != null) {\nhashCode = (hashCode * 37) + getDescription().hashCode();\n}\n\nhashCode = (hashCode * 37) + getPrefixes().hashCode();\nhashCode = (hashCode * 37) + getTriggers().hashCode();\n\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired() {\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\n// nothing to do normally\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:getParent()Lorg/apache/commons/cli2/Option;",
                                    "method_body": "public Option getParent() {\nreturn parent;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:setParent(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void setParent(Option parent) {\nthis.parent = parent;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefixes(Ljava/util/Set;)V",
                                    "method_body": "protected void checkPrefixes(final Set prefixes) {\n// nothing to do if empty prefix list\nif (prefixes.isEmpty()) {\nreturn;\n}\n\n// check preferred name\ncheckPrefix(prefixes, getPreferredName());\n\n// check triggers\nthis.getTriggers();\n\nfor (final Iterator i = getTriggers().iterator(); i.hasNext();) {\ncheckPrefix(prefixes, (String) i.next());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.OptionImpl:checkPrefix(Ljava/util/Set;Ljava/lang/String;)V",
                                    "method_body": "private void checkPrefix(final Set prefixes,\nfinal String trigger) {\nfor (final Iterator i = prefixes.iterator(); i.hasNext();) {\nString prefix = (String) i.next();\n\nif (trigger.startsWith(prefix)) {\nreturn;\n}\n}\n\nfinal ResourceHelper helper = ResourceHelper.getResourceHelper();\nfinal String message =\nhelper.getMessage(ResourceConstants.OPTION_TRIGGER_NEEDS_PREFIX, trigger,\nprefixes.toString());\nthrow new IllegalArgumentException(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:<init>(Lorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;Ljava/lang/String;IZ)V",
                                    "method_body": "protected ParentImpl(final Argument argument,\nfinal Group children,\nfinal String description,\nfinal int id,\nfinal boolean required) {\nsuper(id, required);\nthis.children = children;\nthis.argument = argument;\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nif (argument != null) {\nhandleInitialSeparator(arguments, argument.getInitialSeparator());\n}\n\nprocessParent(commandLine, arguments);\n\nif (argument != null) {\nargument.processValues(commandLine, arguments, this);\n}\n\nif ((children != null) && children.canProcess(commandLine, arguments)) {\nchildren.process(commandLine, arguments);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nfinal Set triggers = getTriggers();\n\nif (argument != null) {\nfinal char separator = argument.getInitialSeparator();\n\n// if there is a valid separator character\nif (separator != NUL) {\nfinal int initialIndex = arg.indexOf(separator);\n\n// if there is a separator present\nif (initialIndex > 0) {\nreturn triggers.contains(arg.substring(0, initialIndex));\n}\n}\n}\n\nreturn triggers.contains(arg);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn (children == null) ? Collections.EMPTY_SET : children.getPrefixes();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nfinal boolean displayArgument =\n(this.argument != null) &&\nhelpSettings.contains(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nfinal boolean displayChildren =\n(this.children != null) &&\nhelpSettings.contains(DisplaySetting.DISPLAY_PARENT_CHILDREN);\n\nif (displayArgument) {\nbuffer.append(' ');\nargument.appendUsage(buffer, helpSettings, comp);\n}\n\nif (displayChildren) {\nbuffer.append(' ');\nchildren.appendUsage(buffer, helpSettings, comp);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription() {\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:handleInitialSeparator(Ljava/util/ListIterator;C)V",
                                    "method_body": "private void handleInitialSeparator(final ListIterator arguments,\nfinal char separator) {\n// next token\nfinal String newArgument = (String) arguments.next();\n\n// split the token\nfinal int initialIndex = newArgument.indexOf(separator);\n\nif (initialIndex > 0) {\narguments.remove();\narguments.add(newArgument.substring(0, initialIndex));\nString value = newArgument.substring(initialIndex + 1);\n// The value obviously isn't an option, so we need to quote it if looks like an option.\n// The quotes will be removed later\nif (value.startsWith(\"-\")) {\nvalue = '\"' + value + '\"';\n}\narguments.add(value);\narguments.previous();\n}\n\narguments.previous();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ParentImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nif (argument != null) {\nargument.defaultValues(commandLine, this);\n}\n\nif (children != null) {\nchildren.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<init>()V",
                                    "method_body": "public ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:<clinit>()V",
                                    "method_body": "private final static ResourceHelper resources = ResourceHelper.getResourceHelper();\n\n/** name of the argument. Used for display and lookups in CommandLine */\nprivate String name;\n\n/** description of the argument. Used in the automated online help */\nprivate String description;\n\n/** minimum number of values required */\nprivate int minimum;\n\n/** maximum number of values permitted */\nprivate int maximum;\n\n/** character used to separate the values from the option */\nprivate char initialSeparator;\n\n/** character used to separate the values from each other */\nprivate char subsequentSeparator;\n\n/** object that should be used to ensure the values are valid */\nprivate Validator validator;\n\n/** used to identify the consume remaining option, typically \"--\" */\nprivate String consumeRemaining;\n\n/** default values for argument */\nprivate List defaultValues;\n\n/** id of the argument */\nprivate int id;\n\n/**\n* Creates a new ArgumentBuilder instance\n*/\npublic ArgumentBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:create()Lorg/apache/commons/cli2/Argument;",
                                    "method_body": "public final Argument create() {\nfinal Argument argument =\nnew ArgumentImpl(\nname,\ndescription,\nminimum,\nmaximum,\ninitialSeparator,\nsubsequentSeparator,\nvalidator,\nconsumeRemaining,\ndefaultValues,\nid);\n\nreset();\n\nreturn argument;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:reset()Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder reset() {\nname = \"arg\";\ndescription = null;\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\ninitialSeparator = ArgumentImpl.DEFAULT_INITIAL_SEPARATOR;\nsubsequentSeparator = ArgumentImpl.DEFAULT_SUBSEQUENT_SEPARATOR;\nvalidator = null;\nconsumeRemaining = \"--\";\ndefaultValues = null;\nid = 0;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withMinimum(I)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withMinimum(final int newMinimum) {\nif (newMinimum < 0) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MINIMUM));\n}\nthis.minimum = newMinimum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withMaximum(I)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withMaximum(final int newMaximum) {\nif (newMaximum < 0) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NEGATIVE_MAXIMUM));\n}\nthis.maximum = newMaximum;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.ArgumentBuilder:withValidator(Lorg/apache/commons/cli2/validation/Validator;)Lorg/apache/commons/cli2/builder/ArgumentBuilder;",
                                    "method_body": "public final ArgumentBuilder withValidator(final Validator newValidator) {\nif (newValidator == null) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_BUILDER_NULL_VALIDATOR));\n}\nthis.validator = newValidator;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:<init>()V",
                                    "method_body": "private ResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\n\nif (bundleName == null) {\nbundleName = DEFAULT_BUNDLE;\n}\n\nthis.prop = bundleName;\n\nint firstUnderscore = bundleName.indexOf('_');\nint secondUnderscore = bundleName.indexOf('_', firstUnderscore + 1);\n\nLocale locale;\nif (firstUnderscore != -1) {\nString language = bundleName.substring(firstUnderscore + 1, secondUnderscore);\nString country = bundleName.substring(secondUnderscore + 1);\nlocale = new Locale(language, country);\n}\nelse {\nlocale = Locale.getDefault();\n}\n// initialize the bundle\ntry {\nbundle = ResourceBundle.getBundle(bundleName, locale);\n} catch (MissingResourceException exp) {\nbundle = ResourceBundle.getBundle(DEFAULT_BUNDLE, locale);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getBundleName()Ljava/lang/String;",
                                    "method_body": "public String getBundleName() {\nreturn this.prop;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getResourceHelper()Lorg/apache/commons/cli2/resource/ResourceHelper;",
                                    "method_body": "public static ResourceHelper getResourceHelper() {\nString bundleName = System.getProperty(PROP_LOCALE);\nif (helper == null || !helper.getBundleName().equals(bundleName)) {\nhelper = new ResourceHelper();\n}\n\nreturn helper;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getMessage(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String getMessage(final String key,\nfinal Object value) {\nreturn getMessage(key, new Object[] { value });\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.resource.ResourceHelper:getMessage(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String;",
                                    "method_body": "public String getMessage(final String key,\nfinal Object[] values) {\nfinal String msgFormatStr = bundle.getString(key);\nfinal MessageFormat msgFormat = new MessageFormat(msgFormatStr);\n\nreturn msgFormat.format(values);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:<init>(Ljava/lang/String;Ljava/lang/String;IICCLorg/apache/commons/cli2/validation/Validator;Ljava/lang/String;Ljava/util/List;I)V",
                                    "method_body": "public ArgumentImpl(final String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal char initialSeparator,\nfinal char subsequentSeparator,\nfinal Validator validator,\nfinal String consumeRemaining,\nfinal List valueDefaults,\nfinal int id) {\nsuper(id, false);\n\nthis.name = (name == null) ? \"arg\" : name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\nthis.initialSeparator = initialSeparator;\nthis.subsequentSeparator = subsequentSeparator;\nthis.subsequentSplit = subsequentSeparator != NUL;\nthis.validator = validator;\nthis.consumeRemaining = consumeRemaining;\nthis.defaultValues = valueDefaults;\n\nif (minimum > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_MIN_EXCEEDS_MAX));\n}\n\nif ((valueDefaults != null) && (valueDefaults.size() > 0)) {\nif (valueDefaults.size() < minimum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_FEW_DEFAULTS));\n}\n\nif (valueDefaults.size() > maximum) {\nthrow new IllegalArgumentException(resources.getMessage(ResourceConstants.ARGUMENT_TOO_MANY_DEFAULTS));\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:processValues(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void processValues(final WriteableCommandLine commandLine,\nfinal ListIterator arguments,\nfinal Option option)\nthrows OptionException {\n// count of arguments processed for this option.\nint argumentCount = commandLine.getUndefaultedValues(option).size();\n\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\nfinal String allValuesQuoted = (String) arguments.next();\nfinal String allValues = stripBoundaryQuotes(allValuesQuoted);\n\n// should we ignore things that look like options?\nif (allValuesQuoted.equals(consumeRemaining)) {\nwhile (arguments.hasNext() && (argumentCount < maximum)) {\n++argumentCount;\ncommandLine.addValue(option, arguments.next());\n}\n}\n// does it look like an option?\nelse if (commandLine.looksLikeOption(allValuesQuoted)) {\narguments.previous();\n\nbreak;\n}\n// should we split the string up?\nelse if (subsequentSplit) {\nfinal StringTokenizer values =\nnew StringTokenizer(allValues, String.valueOf(subsequentSeparator));\n\narguments.remove();\n\nwhile (values.hasMoreTokens() && (argumentCount < maximum)) {\n++argumentCount;\n\nfinal String token = values.nextToken();\ncommandLine.addValue(option, token);\narguments.add(token);\n}\n\nif (values.hasMoreTokens()) {\nthrow new OptionException(option, ResourceConstants.ARGUMENT_UNEXPECTED_VALUE,\nvalues.nextToken());\n}\n}\n// it must be a value as it is\nelse {\n++argumentCount;\ncommandLine.addValue(option, allValues);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:getInitialSeparator()C",
                                    "method_body": "public char getInitialSeparator() {\nreturn this.initialSeparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:stripBoundaryQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String stripBoundaryQuotes(String token) {\nif (!token.startsWith(\"\\\"\") || !token.endsWith(\"\\\"\")) {\nreturn token;\n}\n\ntoken = token.substring(1, token.length() - 1);\n\nreturn token;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.ArgumentImpl:defaultValues(Lorg/apache/commons/cli2/WriteableCommandLine;Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void defaultValues(final WriteableCommandLine commandLine,\nfinal Option option) {\ncommandLine.setDefaultValues(option, defaultValues);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>()V",
                                    "method_body": "public DefaultOptionBuilder() {\nthis(DefaultOption.DEFAULT_SHORT_PREFIX, DefaultOption.DEFAULT_LONG_PREFIX,\nDefaultOption.DEFAULT_BURST_ENABLED);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:<init>(Ljava/lang/String;Ljava/lang/String;Z)V",
                                    "method_body": "public DefaultOptionBuilder(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled)\nthrows IllegalArgumentException {\nif ((shortPrefix == null) || (shortPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_SHORT_PREFIX));\n}\n\nif ((longPrefix == null) || (longPrefix.length() == 0)) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_ILLEGAL_LONG_PREFIX));\n}\n\nthis.shortPrefix = shortPrefix;\nthis.longPrefix = longPrefix;\nthis.burstEnabled = burstEnabled;\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:create()Lorg/apache/commons/cli2/option/DefaultOption;",
                                    "method_body": "public DefaultOption create()\nthrows IllegalStateException {\nif (preferredName == null) {\nthrow new IllegalStateException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.OPTION_NO_NAME));\n}\n\nfinal DefaultOption option =\nnew DefaultOption(shortPrefix, longPrefix, burstEnabled, preferredName, description,\naliases, burstAliases, required, argument, children, id);\n\nreset();\n\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:reset()Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder reset() {\npreferredName = null;\ndescription = null;\naliases = new HashSet();\nburstAliases = new HashSet();\nrequired = false;\nargument = null;\nchildren = null;\nid = 0;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withLongName(Ljava/lang/String;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withLongName(final String longName) {\nfinal String name = longPrefix + longName;\n\nif (preferredName == null) {\npreferredName = name;\n} else {\naliases.add(name);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.DefaultOptionBuilder:withArgument(Lorg/apache/commons/cli2/Argument;)Lorg/apache/commons/cli2/builder/DefaultOptionBuilder;",
                                    "method_body": "public DefaultOptionBuilder withArgument(final Argument newArgument) {\nthis.argument = newArgument;\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;Ljava/lang/String;Ljava/util/Set;Ljava/util/Set;ZLorg/apache/commons/cli2/Argument;Lorg/apache/commons/cli2/Group;I)V",
                                    "method_body": "public DefaultOption(final String shortPrefix,\nfinal String longPrefix,\nfinal boolean burstEnabled,\nfinal String preferredName,\nfinal String description,\nfinal Set aliases,\nfinal Set burstAliases,\nfinal boolean required,\nfinal Argument argument,\nfinal Group children,\nfinal int id) {\nsuper(argument, children, description, id, required);\n\nthis.shortPrefix = shortPrefix;\nthis.burstEnabled = burstEnabled;\n\nthis.burstLength = shortPrefix.length() + 1;\n\nthis.preferredName = preferredName;\nthis.aliases =\n(aliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(aliases));\n\nthis.burstAliases =\n(burstAliases == null) ? Collections.EMPTY_SET\n: Collections.unmodifiableSet(new HashSet(burstAliases));\n\nfinal Set newTriggers = new HashSet();\nnewTriggers.add(preferredName);\nnewTriggers.addAll(this.aliases);\nnewTriggers.addAll(this.burstAliases);\nthis.triggers = Collections.unmodifiableSet(newTriggers);\n\nfinal Set newPrefixes = new HashSet(super.getPrefixes());\nnewPrefixes.add(shortPrefix);\nnewPrefixes.add(longPrefix);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n\ncheckPrefixes(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String argument) {\nreturn (argument != null) &&\n(super.canProcess(commandLine, argument) ||\n((argument.length() >= burstLength) &&\nburstAliases.contains(argument.substring(0, burstLength))));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:processParent(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processParent(WriteableCommandLine commandLine,\nListIterator arguments)\nthrows OptionException {\nfinal String argument = (String) arguments.next();\n\nif (triggers.contains(argument)) {\ncommandLine.addOption(this);\narguments.set(preferredName);\n} else if (burstEnabled && (argument.length() >= burstLength)) {\nfinal String burst = argument.substring(0, burstLength);\n\nif (burstAliases.contains(burst)) {\ncommandLine.addOption(this);\n\n//HMM test bursting all vs bursting one by one.\narguments.set(preferredName);\n\nif (getArgument() == null) {\narguments.add(shortPrefix + argument.substring(burstLength));\n} else {\narguments.add(argument.substring(burstLength));\n}\n\narguments.previous();\n} else {\nthrow new OptionException(this, ResourceConstants.CANNOT_BURST, argument);\n}\n} else {\nthrow new OptionException(this, ResourceConstants.UNEXPECTED_TOKEN, argument);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getTriggers()Ljava/util/Set;",
                                    "method_body": "public Set getTriggers() {\nreturn triggers;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\n// do we display optionality\nfinal boolean optional =\n!isRequired() && helpSettings.contains(DisplaySetting.DISPLAY_OPTIONAL);\nfinal boolean displayAliases = helpSettings.contains(DisplaySetting.DISPLAY_ALIASES);\n\nif (optional) {\nbuffer.append('[');\n}\n\nbuffer.append(preferredName);\n\nif (displayAliases && !aliases.isEmpty()) {\nbuffer.append(\" (\");\n\nfinal List list = new ArrayList(aliases);\nCollections.sort(list);\n\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal String alias = (String) i.next();\nbuffer.append(alias);\n\nif (i.hasNext()) {\nbuffer.append(',');\n}\n}\n\nbuffer.append(')');\n}\n\nsuper.appendUsage(buffer, helpSettings, comp);\n\nif (optional) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.DefaultOption:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn preferredName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:<init>()V",
                                    "method_body": "public GroupBuilder() {\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:create()Lorg/apache/commons/cli2/Group;",
                                    "method_body": "public Group create() {\nfinal GroupImpl group =\nnew GroupImpl(options, name, description, minimum, maximum, required);\n\nreset();\n\nreturn group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:reset()Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder reset() {\nname = null;\ndescription = null;\noptions = new ArrayList();\nminimum = 0;\nmaximum = Integer.MAX_VALUE;\nrequired = true;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.builder.GroupBuilder:withOption(Lorg/apache/commons/cli2/Option;)Lorg/apache/commons/cli2/builder/GroupBuilder;",
                                    "method_body": "public GroupBuilder withOption(final Option option) {\nthis.options.add(option);\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:<init>(Ljava/util/List;Ljava/lang/String;Ljava/lang/String;IIZ)V",
                                    "method_body": "public GroupImpl(final List options,\nfinal String name,\nfinal String description,\nfinal int minimum,\nfinal int maximum,\nfinal boolean required) {\nsuper(0, required);\n\nthis.name = name;\nthis.description = description;\nthis.minimum = minimum;\nthis.maximum = maximum;\n\n// store a copy of the options to be used by the\n// help methods\nthis.options = Collections.unmodifiableList(options);\n\n// anonymous Argument temporary storage\nfinal List newAnonymous = new ArrayList();\n\n// map (key=trigger & value=Option) temporary storage\nfinal SortedMap newOptionMap = new TreeMap(ReverseStringComparator.getInstance());\n\n// prefixes temporary storage\nfinal Set newPrefixes = new HashSet();\n\n// process the options\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.setParent(this);\n\nif (option instanceof Argument) {\ni.remove();\nnewAnonymous.add(option);\n} else {\nfinal Set triggers = option.getTriggers();\n\nfor (Iterator j = triggers.iterator(); j.hasNext();) {\nnewOptionMap.put(j.next(), option);\n}\n\n// store the prefixes\nnewPrefixes.addAll(option.getPrefixes());\n}\n}\n\nthis.anonymous = Collections.unmodifiableList(newAnonymous);\nthis.optionMap = Collections.unmodifiableSortedMap(newOptionMap);\nthis.prefixes = Collections.unmodifiableSet(newPrefixes);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:canProcess(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "public boolean canProcess(final WriteableCommandLine commandLine,\nfinal String arg) {\nif (arg == null) {\nreturn false;\n}\n\n// if arg does not require bursting\nif (optionMap.containsKey(arg)) {\nreturn true;\n}\n\n// filter\nfinal Map tailMap = optionMap.tailMap(arg);\n\n// check if bursting is required\nfor (final Iterator iter = tailMap.values().iterator(); iter.hasNext();) {\nfinal Option option = (Option) iter.next();\n\nif (option.canProcess(commandLine, arg)) {\nreturn true;\n}\n}\n\nif (looksLikeOption(commandLine, arg)) {\nreturn false;\n}\n\n// anonymous argument(s) means we can process it\nif (anonymous.size() > 0) {\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPrefixes()Ljava/util/Set;",
                                    "method_body": "public Set getPrefixes() {\nreturn prefixes;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:process(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/util/ListIterator;)V",
                                    "method_body": "public void process(final WriteableCommandLine commandLine,\nfinal ListIterator arguments)\nthrows OptionException {\nString previous = null;\n\n// [START process each command line token\nwhile (arguments.hasNext()) {\n// grab the next argument\nfinal String arg = (String) arguments.next();\n\n// if we have just tried to process this instance\nif (arg == previous) {\n// rollback and abort\narguments.previous();\n\nbreak;\n}\n\n// remember last processed instance\nprevious = arg;\n\nfinal Option opt = (Option) optionMap.get(arg);\n\n// option found\nif (opt != null) {\narguments.previous();\nopt.process(commandLine, arguments);\n}\n// [START option NOT found\nelse {\n// it might be an anonymous argument continue search\n// [START argument may be anonymous\nif (looksLikeOption(commandLine, arg)) {\n// narrow the search\nfinal Collection values = optionMap.tailMap(arg).values();\n\nboolean foundMemberOption = false;\n\nfor (Iterator i = values.iterator(); i.hasNext() && !foundMemberOption;) {\nfinal Option option = (Option) i.next();\n\nif (option.canProcess(commandLine, arg)) {\nfoundMemberOption = true;\narguments.previous();\noption.process(commandLine, arguments);\n}\n}\n\n// back track and abort this group if necessary\nif (!foundMemberOption) {\narguments.previous();\n\nreturn;\n}\n} // [END argument may be anonymous\n\n// [START argument is NOT anonymous\nelse {\n// move iterator back, current value not used\narguments.previous();\n\n// if there are no anonymous arguments then this group can't\n// process the argument\nif (anonymous.isEmpty()) {\nbreak;\n}\n\n// TODO: why do we iterate over all anonymous arguments?\n// canProcess will always return true?\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Argument argument = (Argument) i.next();\n\nif (argument.canProcess(commandLine, arguments)) {\nargument.process(commandLine, arguments);\n}\n}\n} // [END argument is NOT anonymous\n} // [END option NOT found\n} // [END process each command line token\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getPreferredName()Ljava/lang/String;",
                                    "method_body": "public String getPreferredName() {\nreturn name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp) {\nappendUsage(buffer, helpSettings, comp, \"|\");\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:appendUsage(Ljava/lang/StringBuffer;Ljava/util/Set;Ljava/util/Comparator;Ljava/lang/String;)V",
                                    "method_body": "public void appendUsage(final StringBuffer buffer,\nfinal Set helpSettings,\nfinal Comparator comp,\nfinal String separator) {\nfinal Set helpSettingsCopy = new HashSet(helpSettings);\n\nfinal boolean optional = !isRequired()\n&& (helpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL) ||\nhelpSettingsCopy.contains(DisplaySetting.DISPLAY_OPTIONAL_CHILD_GROUP));\n\nfinal boolean expanded =\n(name == null) || helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED);\n\nfinal boolean named =\n!expanded ||\n((name != null) && helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_NAME));\n\nfinal boolean arguments = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_ARGUMENT);\n\nfinal boolean outer = helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nhelpSettingsCopy.remove(DisplaySetting.DISPLAY_GROUP_OUTER);\n\nfinal boolean both = named && expanded;\n\nif (optional) {\nbuffer.append('[');\n}\n\nif (named) {\nbuffer.append(name);\n}\n\nif (both) {\nbuffer.append(\" (\");\n}\n\nif (expanded) {\nfinal Set childSettings;\n\nif (!helpSettingsCopy.contains(DisplaySetting.DISPLAY_GROUP_EXPANDED)) {\nchildSettings = DisplaySetting.NONE;\n} else {\nchildSettings = new HashSet(helpSettingsCopy);\nchildSettings.remove(DisplaySetting.DISPLAY_OPTIONAL);\n}\n\n// grab a list of the group's options.\nfinal List list;\n\nif (comp == null) {\n// default to using the initial order\nlist = options;\n} else {\n// sort options if comparator is supplied\nlist = new ArrayList(options);\nCollections.sort(list, comp);\n}\n\n// for each option.\nfor (final Iterator i = list.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\n\n// append usage information\noption.appendUsage(buffer, childSettings, comp);\n\n// add separators as needed\nif (i.hasNext()) {\nbuffer.append(separator);\n}\n}\n}\n\nif (both) {\nbuffer.append(')');\n}\n\nif (optional && outer) {\nbuffer.append(']');\n}\n\nif (arguments) {\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nbuffer.append(' ');\n\nfinal Option option = (Option) i.next();\noption.appendUsage(buffer, helpSettingsCopy, comp);\n}\n}\n\nif (optional && !outer) {\nbuffer.append(']');\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:getMinimum()I",
                                    "method_body": "public int getMinimum() {\nreturn minimum;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn (getParent() == null || super.isRequired()) && getMinimum() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:defaults(Lorg/apache/commons/cli2/WriteableCommandLine;)V",
                                    "method_body": "public void defaults(final WriteableCommandLine commandLine) {\nsuper.defaults(commandLine);\n\nfor (final Iterator i = options.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n\nfor (final Iterator i = anonymous.iterator(); i.hasNext();) {\nfinal Option option = (Option) i.next();\noption.defaults(commandLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.option.GroupImpl:looksLikeOption(Lorg/apache/commons/cli2/WriteableCommandLine;Ljava/lang/String;)Z",
                                    "method_body": "private boolean looksLikeOption(final WriteableCommandLine commandLine,\nfinal String trigger) {\nreturn commandLine.looksLikeOption(trigger);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>()V",
                                    "method_body": "public HelpFormatter() {\nthis(DEFAULT_GUTTER_LEFT, DEFAULT_GUTTER_CENTER, DEFAULT_GUTTER_RIGHT, DEFAULT_FULL_WIDTH);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<init>(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;I)V",
                                    "method_body": "public HelpFormatter(final String gutterLeft,\nfinal String gutterCenter,\nfinal String gutterRight,\nfinal int fullWidth) {\n// default the left gutter to empty string\nthis.gutterLeft = (gutterLeft == null) ? DEFAULT_GUTTER_LEFT : gutterLeft;\n\n// default the center gutter to a single space\nthis.gutterCenter = (gutterCenter == null) ? DEFAULT_GUTTER_CENTER : gutterCenter;\n\n// default the right gutter to empty string\nthis.gutterRight = (gutterRight == null) ? DEFAULT_GUTTER_RIGHT : gutterRight;\n\n// calculate the available page width\nthis.pageWidth = fullWidth - this.gutterLeft.length() - this.gutterRight.length();\n\n// check available page width is valid\nint availableWidth = fullWidth - pageWidth + this.gutterCenter.length();\n\nif (availableWidth < 2) {\nthrow new IllegalArgumentException(ResourceHelper.getResourceHelper().getMessage(ResourceConstants.HELPFORMATTER_GUTTER_TOO_LONG));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.util.HelpFormatter:<clinit>()V",
                                    "method_body": "public static final int DEFAULT_FULL_WIDTH = 80;\n\n/**\n* The default screen furniture left of screen\n*/\npublic static final String DEFAULT_GUTTER_LEFT = \"\";\n\n/**\n* The default screen furniture right of screen\n*/\npublic static final String DEFAULT_GUTTER_CENTER = \"    \";\n\n/**\n* The default screen furniture between columns\n*/\npublic static final String DEFAULT_GUTTER_RIGHT = \"\";\n\n/**\n* The default DisplaySettings used to select the elements to display in the\n* displayed line of full usage information.\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_FULL_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the elements of usage per help\n* line in the main body of help\n*\n* @see DisplaySetting\n*/\npublic static final Set DEFAULT_LINE_USAGE_SETTINGS;\n\n/**\n* The default DisplaySettings used to select the help lines in the main\n* body of help\n*/\npublic static final Set DEFAULT_DISPLAY_USAGE_SETTINGS;\n\nstatic {\nfinal Set fullUsage = new HashSet(DisplaySetting.ALL);\nfullUsage.remove(DisplaySetting.DISPLAY_ALIASES);\nfullUsage.remove(DisplaySetting.DISPLAY_GROUP_NAME);\nfullUsage.remove(DisplaySetting.DISPLAY_OPTIONAL_CHILD_GROUP);\nDEFAULT_FULL_USAGE_SETTINGS = Collections.unmodifiableSet(fullUsage);\n\nfinal Set lineUsage = new HashSet();\nlineUsage.add(DisplaySetting.DISPLAY_ALIASES);\nlineUsage.add(DisplaySetting.DISPLAY_GROUP_NAME);\nlineUsage.add(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_LINE_USAGE_SETTINGS = Collections.unmodifiableSet(lineUsage);\n\nfinal Set displayUsage = new HashSet(DisplaySetting.ALL);\ndisplayUsage.remove(DisplaySetting.DISPLAY_PARENT_ARGUMENT);\nDEFAULT_DISPLAY_USAGE_SETTINGS = Collections.unmodifiableSet(displayUsage);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<init>(Ljava/lang/String;)V",
                                    "method_body": "private DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:<clinit>()V",
                                    "method_body": "private static final Set all = new HashSet();\n\n/**\n* A Set guaranteed to contain all possible DisplaySetting values\n*/\npublic static final Set ALL = Collections.unmodifiableSet(all);\n\n/**\n* A Set guaranteed to contain no DisplaySetting values\n*/\npublic static final Set NONE = Collections.EMPTY_SET;\n\n/**\n* Indicates that aliases should be included\n*/\npublic static final DisplaySetting DISPLAY_ALIASES =\nnew DisplaySetting(\"DISPLAY_ALIASES\");\n\n/**\n* Indicates that optionality should be included\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL =\nnew DisplaySetting(\"DISPLAY_OPTIONAL\");\n\n/**\n* Indicates that optional child groups should be displayed in square\n* brackets.\n*/\npublic static final DisplaySetting DISPLAY_OPTIONAL_CHILD_GROUP =\nnew DisplaySetting(\"DISPLAY_OPTIONAL_CHILD_GROUP\");\n\n/**\n* Indicates that property options should be included\n*/\npublic static final DisplaySetting DISPLAY_PROPERTY_OPTION =\nnew DisplaySetting(\"DISPLAY_PROPERTY_OPTION\");\n\n/**\n* Indicates that switches should be included enabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_ENABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_ENABLED\");\n\n/**\n* Indicates that switches should be included disabled\n*/\npublic static final DisplaySetting DISPLAY_SWITCH_DISABLED =\nnew DisplaySetting(\"DISPLAY_SWITCH_DISABLED\");\n\n/**\n* Indicates that group names should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_NAME =\nnew DisplaySetting(\"DISPLAY_GROUP_NAME\");\n\n/**\n* Indicates that groups should be included expanded\n*/\npublic static final DisplaySetting DISPLAY_GROUP_EXPANDED =\nnew DisplaySetting(\"DISPLAY_GROUP_EXPANDED\");\n\n/**\n* Indicates that group arguments should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_GROUP_ARGUMENT\");\n\n/**\n* Indicates that group outer brackets should be included\n*/\npublic static final DisplaySetting DISPLAY_GROUP_OUTER =\nnew DisplaySetting(\"DISPLAY_GROUP_OUTER\");\n\n/**\n* Indicates that arguments should be included numbered\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_NUMBERED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_NUMBERED\");\n\n/**\n* Indicates that arguments should be included bracketed\n*/\npublic static final DisplaySetting DISPLAY_ARGUMENT_BRACKETED =\nnew DisplaySetting(\"DISPLAY_ARGUMENT_BRACKETED\");\n\n/**\n* Indicates that arguments of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_ARGUMENT =\nnew DisplaySetting(\"DISPLAY_PARENT_ARGUMENT\");\n\n/**\n* Indicates that children of Parents should be included\n*/\npublic static final DisplaySetting DISPLAY_PARENT_CHILDREN =\nnew DisplaySetting(\"DISPLAY_PARENT_CHILDREN\");\n\n/**\n* The name of the setting\n*/\nprivate final String name;\n\n/**\n* The hashCode of the setting\n*/\nprivate final int hashCode;\n\n/**\n* Creates a new DisplaySetting with the specified name\n* @param name the name of the setting\n*/\nprivate DisplaySetting(final String name) {\nthis.name = name;\nthis.hashCode = name.hashCode();\nall.add(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.DisplaySetting:hashCode()I",
                                    "method_body": "public int hashCode() {\nreturn hashCode;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:<init>(Lorg/apache/commons/cli2/Option;Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public OptionException(final Option option,\nfinal String messageKey,\nfinal String value) {\nthis.option = option;\n\nif (messageKey != null) {\nfinal StringBuffer buffer = new StringBuffer();\n\nif (value != null) {\nbuffer.append(helper.getMessage(messageKey, value));\n} else {\nbuffer.append(helper.getMessage(messageKey));\n}\n\nbuffer.append(\" \");\n\noption.appendUsage(buffer, HELP_SETTINGS, null);\nmessage = buffer.toString();\n} else {\nmessage = \"\";\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:<clinit>()V",
                                    "method_body": "public static final Set HELP_SETTINGS =\nCollections.unmodifiableSet(Collections.singleton(DisplaySetting.DISPLAY_PROPERTY_OPTION));\n\n/** resource helper instance */\nprivate static final ResourceHelper helper = ResourceHelper.getResourceHelper();\n\n/** The Option the exception relates to */\nprivate final Option option;\n\n/** The message explaining the Exception */\nprivate final String message;\n\n/**\n* Creates a new OptionException.\n*\n* @param option\n*            The Option the exception relates to\n*/\npublic OptionException(final Option option) {\nthis(option, null, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.OptionException:getMessage()Ljava/lang/String;",
                                    "method_body": "public String getMessage() {\nreturn message;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:parse([Ljava/lang/String;)Lorg/apache/commons/cli2/CommandLine;",
                                    "method_body": "public CommandLine parse(final String[] arguments)\nthrows OptionException {\n// build a mutable list for the arguments\nfinal List argumentList = new LinkedList();\n\n// copy the arguments into the new list\nfor (int i = 0; i < arguments.length; i++) {\nfinal String argument = arguments[i];\n\n// ensure non intern'd strings are used\n// so that == comparisons work as expected\nargumentList.add(new String(argument));\n}\n\n// wet up a command line for this group\nfinal WriteableCommandLine commandLine = new WriteableCommandLineImpl(group, argumentList);\n\n// pick up any defaults from the model\ngroup.defaults(commandLine);\n\n// process the options as far as possible\nfinal ListIterator iterator = argumentList.listIterator();\nObject previous = null;\n\nwhile (group.canProcess(commandLine, iterator)) {\n// peek at the next item and backtrack\nfinal Object next = iterator.next();\niterator.previous();\n\n// if we have just tried to process this instance\nif (next == previous) {\n// abort\nbreak;\n}\n\n// remember previous\nprevious = next;\n\ngroup.process(commandLine, iterator);\n}\n\n// if there are more arguments we have a problem\nif (iterator.hasNext()) {\nfinal String arg = (String) iterator.next();\nthrow new OptionException(group, ResourceConstants.UNEXPECTED_TOKEN, arg);\n}\n\n// no need to validate if the help option is present\nif (!commandLine.hasOption(helpOption) && !commandLine.hasOption(helpTrigger)) {\ngroup.validate(commandLine);\n}\n\nreturn commandLine;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.Parser:setGroup(Lorg/apache/commons/cli2/Group;)V",
                                    "method_body": "public void setGroup(final Group group) {\nthis.group = group;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:<init>(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public WriteableCommandLineImpl(final Option rootOption,\nfinal List arguments) {\nthis.prefixes = rootOption.getPrefixes();\nthis.normalised = arguments;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:addOption(Lorg/apache/commons/cli2/Option;)V",
                                    "method_body": "public void addOption(Option option) {\noptions.add(option);\nnameToOption.put(option.getPreferredName(), option);\n\nfor (Iterator i = option.getTriggers().iterator(); i.hasNext();) {\nnameToOption.put(i.next(), option);\n}\n\n// ensure that all parent options are also added\nOption parent = option.getParent();\nwhile (parent != null && !options.contains(parent)) {\noptions.add(parent);\nparent = parent.getParent();\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:getUndefaultedValues(Lorg/apache/commons/cli2/Option;)Ljava/util/List;",
                                    "method_body": "public List getUndefaultedValues(Option option) {\n// First grab the command line values\nList valueList = (List) values.get(option);\n\n// Finally use an empty list\nif (valueList == null) {\nvalueList = Collections.EMPTY_LIST;\n}\n\nreturn valueList;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:looksLikeOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean looksLikeOption(final String trigger)\n{\n// this is a reentrant call\n\nfor (final Iterator i = prefixes.iterator(); i.hasNext();)\n{\nfinal String prefix = (String) i.next();\n\nif (trigger.startsWith(prefix))\n{\nreturn true;\n}\n}\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.commandline.WriteableCommandLineImpl:setDefaultValues(Lorg/apache/commons/cli2/Option;Ljava/util/List;)V",
                                    "method_body": "public void setDefaultValues(final Option option,\nfinal List defaults) {\nif (defaults == null) {\ndefaultValues.remove(option);\n} else {\ndefaultValues.put(option, defaults);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.validation.NumberValidator:<init>(Ljava/text/NumberFormat;)V",
                                    "method_body": "public NumberValidator(final NumberFormat format) {\nsetFormat(format);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.validation.NumberValidator:getNumberInstance()Lorg/apache/commons/cli2/validation/NumberValidator;",
                                    "method_body": "public static NumberValidator getNumberInstance() {\nreturn new NumberValidator(NumberFormat.getNumberInstance());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli2.validation.NumberValidator:setFormat(Ljava/text/NumberFormat;)V",
                                    "method_body": "protected void setFormat(NumberFormat format) {\nthis.format = format;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 22,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.ApplicationTest.testGroovy",
                            "test_body": "public void testGroovy() throws Exception {\nOptions options = new Options();\noptions.addOption(\nOptionBuilder.withLongOpt(\"define\").\nwithDescription(\"define a system property\").\nhasArg(true).\nwithArgName(\"name=value\").\ncreate('D'));\noptions.addOption(\nOptionBuilder.hasArg(false)\n.withDescription(\"usage information\")\n.withLongOpt(\"help\")\n.create('h'));\noptions.addOption(\nOptionBuilder.hasArg(false)\n.withDescription(\"debug mode will print out full stack traces\")\n.withLongOpt(\"debug\")\n.create('d'));\noptions.addOption(\nOptionBuilder.hasArg(false)\n.withDescription(\"display the Groovy and JVM versions\")\n.withLongOpt(\"version\")\n.create('v'));\noptions.addOption(\nOptionBuilder.withArgName(\"charset\")\n.hasArg()\n.withDescription(\"specify the encoding of the files\")\n.withLongOpt(\"encoding\")\n.create('c'));\noptions.addOption(\nOptionBuilder.withArgName(\"script\")\n.hasArg()\n.withDescription(\"specify a command line script\")\n.create('e'));\noptions.addOption(\nOptionBuilder.withArgName(\"extension\")\n.hasOptionalArg()\n.withDescription(\"modify files in place; create backup if extension is given (e.g. \\'.bak\\')\")\n.create('i'));\noptions.addOption(\nOptionBuilder.hasArg(false)\n.withDescription(\"process files line by line using implicit 'line' variable\")\n.create('n'));\noptions.addOption(\nOptionBuilder.hasArg(false)\n.withDescription(\"process files line by line and print result (see also -n)\")\n.create('p'));\noptions.addOption(\nOptionBuilder.withArgName(\"port\")\n.hasOptionalArg()\n.withDescription(\"listen on a port and process inbound lines\")\n.create('l'));\noptions.addOption(\nOptionBuilder.withArgName(\"splitPattern\")\n.hasOptionalArg()\n.withDescription(\"split lines using splitPattern (default '\\\\s') using implicit 'split' variable\")\n.withLongOpt(\"autosplit\")\n.create('a'));\nParser parser = new PosixParser();\nCommandLine line = parser.parse(options, new String[] { \"-e\", \"println 'hello'\" }, true);\nassertTrue(line.hasOption('e'));\nassertEquals(\"println 'hello'\", line.getOptionValue('e'));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nif (str.startsWith(\"\\\"\"))\n{\nstr = str.substring(1, str.length());\n}\nif (str.endsWith(\"\\\"\"))\n{\nstr = str.substring(0, str.length() - 1);\n}\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg(Z)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg(boolean hasArg)\n{\nOptionBuilder.numberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withArgName(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withArgName(String name)\n{\nOptionBuilder.argName = name;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasOptionalArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasOptionalArg()\n{\nOptionBuilder.numberOfArgs = 1;\nOptionBuilder.optionalArg = true;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withDescription(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withDescription(String newDescription)\n{\nOptionBuilder.description = newDescription;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt) throws IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt) throws IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n\n\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn valuesep > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
                                    "method_body": "void addValueForProcessing(String value)\n{\nswitch (numberOfArgs)\n{\ncase UNINITIALIZED:\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n\ndefault:\nprocessValue(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == (numberOfArgs - 1))\n{\nbreak;\n}\n\n// store\nadd(value.substring(0, index));\n\n// parse\nvalue = value.substring(index + 1);\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif ((numberOfArgs > 0) && (values.size() > (numberOfArgs - 1)))\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n// store value\nvalues.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValuesList()Ljava/util/List;",
                                    "method_body": "public List getValuesList()\n{\nreturn values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn values.isEmpty();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o)\n{\nif (this == o)\n{\nreturn true;\n}\nif (o == null || getClass() != o.getClass())\n{\nreturn false;\n}\n\nOption option = (Option) o;\n\n\nif (opt != null ? !opt.equals(option.opt) : option.opt != null)\n{\nreturn false;\n}\nif (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == ' ' || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions()\n{\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n{\nreturn parse(options, arguments, null, stopAtNonOption);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processsed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(Option opt, ListIterator iter) throws ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nString str = (String) iter.next();\n\n// found an Option, not an argument\nif (getOptions().hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n}\ncatch (RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif (opt.getValues() == null && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter) throws ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(C)Z",
                                    "method_body": "public boolean hasOption(char opt)\n{\nreturn hasOption(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(String opt)\n{\nString[] values = getOptionValues(opt);\n\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(C)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(char opt)\n{\nreturn getOptionValue(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Ljava/lang/String;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(String opt)\n{\nList values = new ArrayList();\n\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n{\nvalues.addAll(option.getValuesList());\n}\n}\n\nreturn values.isEmpty() ? null : (String[]) values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addArg(Ljava/lang/String;)V",
                                    "method_body": "void addArg(String arg)\n{\nargs.add(arg);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nString token = (String) iter.next();\n\n// handle long option --foo or --foo=bar\nif (token.startsWith(\"--\"))\n{\nint pos = token.indexOf('=');\nString opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\nif (!options.hasOption(opt))\n{\nprocessNonOptionToken(token);\n}\nelse\n{\n\ntokens.add(opt);\nif (pos != -1)\n{\ntokens.add(token.substring(pos + 1));\n}\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\ntokens.add(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2 || options.hasOption(token))\n{\nprocessOptionToken(token, stopAtNonOption);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse if (stopAtNonOption)\n{\nprocessNonOptionToken(token);\n}\nelse\n{\ntokens.add(token);\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processNonOptionToken(Ljava/lang/String;)V",
                                    "method_body": "private void processNonOptionToken(String value)\n{\neatTheRest = true;\ntokens.add(\"--\");\n\ntokens.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (stopAtNonOption && !options.hasOption(token))\n{\neatTheRest = true;\n}\n\n\ntokens.add(token);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.PosixParserTest.testStopAtExpectedArg",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nif (str.startsWith(\"\\\"\"))\n{\nstr = str.substring(1, str.length());\n}\nif (str.endsWith(\"\\\"\"))\n{\nstr = str.substring(0, str.length() - 1);\n}\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn valuesep > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
                                    "method_body": "void addValueForProcessing(String value)\n{\nswitch (numberOfArgs)\n{\ncase UNINITIALIZED:\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n\ndefault:\nprocessValue(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == (numberOfArgs - 1))\n{\nbreak;\n}\n\n// store\nadd(value.substring(0, index));\n\n// parse\nvalue = value.substring(index + 1);\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif ((numberOfArgs > 0) && (values.size() > (numberOfArgs - 1)))\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n// store value\nvalues.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValuesList()Ljava/util/List;",
                                    "method_body": "public List getValuesList()\n{\nreturn values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn values.isEmpty();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o)\n{\nif (this == o)\n{\nreturn true;\n}\nif (o == null || getClass() != o.getClass())\n{\nreturn false;\n}\n\nOption option = (Option) o;\n\n\nif (opt != null ? !opt.equals(option.opt) : option.opt != null)\n{\nreturn false;\n}\nif (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == ' ' || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions()\n{\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n{\nreturn parse(options, arguments, null, stopAtNonOption);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processsed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(Option opt, ListIterator iter) throws ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nString str = (String) iter.next();\n\n// found an Option, not an argument\nif (getOptions().hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n}\ncatch (RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif (opt.getValues() == null && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter) throws ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(C)Z",
                                    "method_body": "public boolean hasOption(char opt)\n{\nreturn hasOption(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(String opt)\n{\nString[] values = getOptionValues(opt);\n\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(C)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(char opt)\n{\nreturn getOptionValue(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Ljava/lang/String;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(String opt)\n{\nList values = new ArrayList();\n\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n{\nvalues.addAll(option.getValuesList());\n}\n}\n\nreturn values.isEmpty() ? null : (String[]) values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addArg(Ljava/lang/String;)V",
                                    "method_body": "void addArg(String arg)\n{\nargs.add(arg);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nString token = (String) iter.next();\n\n// handle long option --foo or --foo=bar\nif (token.startsWith(\"--\"))\n{\nint pos = token.indexOf('=');\nString opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\nif (!options.hasOption(opt))\n{\nprocessNonOptionToken(token);\n}\nelse\n{\n\ntokens.add(opt);\nif (pos != -1)\n{\ntokens.add(token.substring(pos + 1));\n}\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\ntokens.add(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2 || options.hasOption(token))\n{\nprocessOptionToken(token, stopAtNonOption);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse if (stopAtNonOption)\n{\nprocessNonOptionToken(token);\n}\nelse\n{\ntokens.add(token);\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processNonOptionToken(Ljava/lang/String;)V",
                                    "method_body": "private void processNonOptionToken(String value)\n{\neatTheRest = true;\ntokens.add(\"--\");\n\ntokens.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (stopAtNonOption && !options.hasOption(token))\n{\neatTheRest = true;\n}\n\n\ntokens.add(token);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 23,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI162Test.testPrintHelpLongLines",
                            "test_body": "public void testPrintHelpLongLines() throws ParseException, IOException {\n// Constants used for options\nfinal String OPT = \"-\";\nfinal String OPT_COLUMN_NAMES = \"l\";\nfinal String OPT_CONNECTION = \"c\";\nfinal String OPT_DESCRIPTION = \"e\";\nfinal String OPT_DRIVER = \"d\";\nfinal String OPT_DRIVER_INFO = \"n\";\nfinal String OPT_FILE_BINDING = \"b\";\nfinal String OPT_FILE_JDBC = \"j\";\nfinal String OPT_FILE_SFMD = \"f\";\nfinal String OPT_HELP = \"h\";\nfinal String OPT_HELP_ = \"help\";\nfinal String OPT_INTERACTIVE = \"i\";\nfinal String OPT_JDBC_TO_SFMD = \"2\";\nfinal String OPT_JDBC_TO_SFMD_L = \"jdbc2sfmd\";\nfinal String OPT_METADATA = \"m\";\nfinal String OPT_PARAM_MODES_INT = \"o\";\nfinal String OPT_PARAM_MODES_NAME = \"O\";\nfinal String OPT_PARAM_NAMES = \"a\";\nfinal String OPT_PARAM_TYPES_INT = \"y\";\nfinal String OPT_PARAM_TYPES_NAME = \"Y\";\nfinal String OPT_PASSWORD = \"p\";\nfinal String OPT_PASSWORD_L = \"password\";\nfinal String OPT_SQL = \"s\";\nfinal String OPT_SQL_L = \"sql\";\nfinal String OPT_SQL_SPLIT_DEFAULT = \"###\";\nfinal String OPT_SQL_SPLIT_L = \"splitSql\";\nfinal String OPT_STACK_TRACE = \"t\";\nfinal String OPT_TIMING = \"g\";\nfinal String OPT_TRIM_L = \"trim\";\nfinal String OPT_USER = \"u\";\nfinal String OPT_WRITE_TO_FILE = \"w\";\nfinal String _PMODE_IN = \"IN\";\nfinal String _PMODE_INOUT = \"INOUT\";\nfinal String _PMODE_OUT = \"OUT\";\nfinal String _PMODE_UNK = \"Unknown\";\nfinal String PMODES = _PMODE_IN + \", \" + _PMODE_INOUT + \", \" + _PMODE_OUT + \", \" + _PMODE_UNK;\n// Options build\nOptions commandLineOptions;\ncommandLineOptions = new Options();\ncommandLineOptions.addOption(OPT_HELP, OPT_HELP_, false, \"Prints help and quits\");\ncommandLineOptions.addOption(OPT_DRIVER, \"driver\", true, \"JDBC driver class name\");\ncommandLineOptions.addOption(OPT_DRIVER_INFO, \"info\", false, \"Prints driver information and properties. If \"\n+ OPT\n+ OPT_CONNECTION\n+ \" is not specified, all drivers on the classpath are displayed.\");\ncommandLineOptions.addOption(OPT_CONNECTION, \"url\", true, \"Connection URL\");\ncommandLineOptions.addOption(OPT_USER, \"user\", true, \"A database user name\");\ncommandLineOptions\n.addOption(\nOPT_PASSWORD,\nOPT_PASSWORD_L,\ntrue,\n\"The database password for the user specified with the \"\n+ OPT\n+ OPT_USER\n+ \" option. You can obfuscate the password with org.mortbay.jetty.security.Password, see http://docs.codehaus.org/display/JETTY/Securing+Passwords\");\ncommandLineOptions.addOption(OPT_SQL, OPT_SQL_L, true, \"Runs SQL or {call stored_procedure(?, ?)} or {?=call function(?, ?)}\");\ncommandLineOptions.addOption(OPT_FILE_SFMD, \"sfmd\", true, \"Writes a SFMD file for the given SQL\");\ncommandLineOptions.addOption(OPT_FILE_BINDING, \"jdbc\", true, \"Writes a JDBC binding node file for the given SQL\");\ncommandLineOptions.addOption(OPT_FILE_JDBC, \"node\", true, \"Writes a JDBC node file for the given SQL (internal debugging)\");\ncommandLineOptions.addOption(OPT_WRITE_TO_FILE, \"outfile\", true, \"Writes the SQL output to the given file\");\ncommandLineOptions.addOption(OPT_DESCRIPTION, \"description\", true,\n\"SFMD description. A default description is used if omited. Example: \" + OPT + OPT_DESCRIPTION + \" \\\"Runs such and such\\\"\");\ncommandLineOptions.addOption(OPT_INTERACTIVE, \"interactive\", false,\n\"Runs in interactive mode, reading and writing from the console, 'go' or '/' sends a statement\");\ncommandLineOptions.addOption(OPT_TIMING, \"printTiming\", false, \"Prints timing information\");\ncommandLineOptions.addOption(OPT_METADATA, \"printMetaData\", false, \"Prints metadata information\");\ncommandLineOptions.addOption(OPT_STACK_TRACE, \"printStack\", false, \"Prints stack traces on errors\");\nOption option = new Option(OPT_COLUMN_NAMES, \"columnNames\", true, \"Column XML names; default names column labels. Example: \"\n+ OPT\n+ OPT_COLUMN_NAMES\n+ \" \\\"cname1 cname2\\\"\");\ncommandLineOptions.addOption(option);\noption = new Option(OPT_PARAM_NAMES, \"paramNames\", true, \"Parameter XML names; default names are param1, param2, etc. Example: \"\n+ OPT\n+ OPT_PARAM_NAMES\n+ \" \\\"pname1 pname2\\\"\");\ncommandLineOptions.addOption(option);\n//\nOptionGroup pOutTypesOptionGroup = new OptionGroup();\nString pOutTypesOptionGroupDoc = OPT + OPT_PARAM_TYPES_INT + \" and \" + OPT + OPT_PARAM_TYPES_NAME + \" are mutually exclusive.\";\nfinal String typesClassName = Types.class.getName();\noption = new Option(OPT_PARAM_TYPES_INT, \"paramTypes\", true, \"Parameter types from \"\n+ typesClassName\n+ \". \"\n+ pOutTypesOptionGroupDoc\n+ \" Example: \"\n+ OPT\n+ OPT_PARAM_TYPES_INT\n+ \" \\\"-10 12\\\"\");\ncommandLineOptions.addOption(option);\noption = new Option(OPT_PARAM_TYPES_NAME, \"paramTypeNames\", true, \"Parameter \"\n+ typesClassName\n+ \" names. \"\n+ pOutTypesOptionGroupDoc\n+ \" Example: \"\n+ OPT\n+ OPT_PARAM_TYPES_NAME\n+ \" \\\"CURSOR VARCHAR\\\"\");\ncommandLineOptions.addOption(option);\ncommandLineOptions.addOptionGroup(pOutTypesOptionGroup);\n//\nOptionGroup modesOptionGroup = new OptionGroup();\nString modesOptionGroupDoc = OPT + OPT_PARAM_MODES_INT + \" and \" + OPT + OPT_PARAM_MODES_NAME + \" are mutually exclusive.\";\noption = new Option(OPT_PARAM_MODES_INT, \"paramModes\", true, \"Parameters modes (\"\n+ ParameterMetaData.parameterModeIn\n+ \"=IN, \"\n+ ParameterMetaData.parameterModeInOut\n+ \"=INOUT, \"\n+ ParameterMetaData.parameterModeOut\n+ \"=OUT, \"\n+ ParameterMetaData.parameterModeUnknown\n+ \"=Unknown\"\n+ \"). \"\n+ modesOptionGroupDoc\n+ \" Example for 2 parameters, OUT and IN: \"\n+ OPT\n+ OPT_PARAM_MODES_INT\n+ \" \\\"\"\n+ ParameterMetaData.parameterModeOut\n+ \" \"\n+ ParameterMetaData.parameterModeIn\n+ \"\\\"\");\nmodesOptionGroup.addOption(option);\noption = new Option(OPT_PARAM_MODES_NAME, \"paramModeNames\", true, \"Parameters mode names (\"\n+ PMODES\n+ \"). \"\n+ modesOptionGroupDoc\n+ \" Example for 2 parameters, OUT and IN: \"\n+ OPT\n+ OPT_PARAM_MODES_NAME\n+ \" \\\"\"\n+ _PMODE_OUT\n+ \" \"\n+ _PMODE_IN\n+ \"\\\"\");\nmodesOptionGroup.addOption(option);\ncommandLineOptions.addOptionGroup(modesOptionGroup);\noption = new Option(null, OPT_TRIM_L, true,\n\"Trims leading and trailing spaces from all column values. Column XML names can be optionally specified to set which columns to trim.\");\noption.setOptionalArg(true);\ncommandLineOptions.addOption(option);\noption = new Option(OPT_JDBC_TO_SFMD, OPT_JDBC_TO_SFMD_L, true,\n\"Converts the JDBC file in the first argument to an SMFD file specified in the second argument.\");\noption.setArgs(2);\ncommandLineOptions.addOption(option);\nthis.testPrintHelp(commandLineOptions);\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOptionGroup(Lorg/apache/commons/cli/OptionGroup;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOptionGroup(OptionGroup group)\n{\nIterator options = group.getOptions().iterator();\n\nif (group.isRequired())\n{\nrequiredOpts.add(group);\n}\n\nwhile (options.hasNext())\n{\nOption option = (Option) options.next();\n\n// an Option cannot be required if it is in an\n// OptionGroup, either the group is required or\n// nothing is required\noption.setRequired(false);\naddOption(option);\n\noptionGroups.put(option.getKey(), group);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription()\n{\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getArgName()Ljava/lang/String;",
                                    "method_body": "public String getArgName()\n{\nreturn argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArgName()Z",
                                    "method_body": "public boolean hasArgName()\n{\nreturn argName != null && argName.length() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == ' ' || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:getOptionComparator()Ljava/util/Comparator;",
                                    "method_body": "public Comparator getOptionComparator()\n{\nreturn optionComparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printHelp(Ljava/lang/String;Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "public void printHelp(String cmdLineSyntax, Options options)\n{\nprintHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printHelp(ILjava/lang/String;Ljava/lang/String;Lorg/apache/commons/cli/Options;Ljava/lang/String;Z)V",
                                    "method_body": "public void printHelp(int width, String cmdLineSyntax, String header,\nOptions options, String footer, boolean autoUsage)\n{\nPrintWriter pw = new PrintWriter(System.out);\n\nprintHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\npw.flush();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printHelp(Ljava/io/PrintWriter;ILjava/lang/String;Ljava/lang/String;Lorg/apache/commons/cli/Options;IILjava/lang/String;Z)V",
                                    "method_body": "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\nString header, Options options, int leftPad,\nint descPad, String footer, boolean autoUsage)\n{\nif ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n{\nthrow new IllegalArgumentException(\"cmdLineSyntax not provided\");\n}\n\nif (autoUsage)\n{\nprintUsage(pw, width, cmdLineSyntax, options);\n}\nelse\n{\nprintUsage(pw, width, cmdLineSyntax);\n}\n\nif ((header != null) && (header.trim().length() > 0))\n{\nprintWrapped(pw, width, header);\n}\n\nprintOptions(pw, width, options, leftPad, descPad);\n\nif ((footer != null) && (footer.trim().length() > 0))\n{\nprintWrapped(pw, width, footer);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printUsage(Ljava/io/PrintWriter;ILjava/lang/String;)V",
                                    "method_body": "public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n{\nint argPos = cmdLineSyntax.indexOf(' ') + 1;\n\nprintWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printOptions(Ljava/io/PrintWriter;ILorg/apache/commons/cli/Options;II)V",
                                    "method_body": "public void printOptions(PrintWriter pw, int width, Options options,\nint leftPad, int descPad)\n{\nStringBuffer sb = new StringBuffer();\n\nrenderOptions(sb, width, options, leftPad, descPad);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printWrapped(Ljava/io/PrintWriter;IILjava/lang/String;)V",
                                    "method_body": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n{\nStringBuffer sb = new StringBuffer(text.length());\n\nrenderWrappedText(sb, width, nextLineTabStop, text);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderOptions(Ljava/lang/StringBuffer;ILorg/apache/commons/cli/Options;II)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n{\nfinal String lpad = createPadding(leftPad);\nfinal String dpad = createPadding(descPad);\n\n// first create list containing only <lpad>-a,--aaa where\n// -a is opt and --aaa is long opt; in parallel look for\n// the longest opt string this list will be then used to\n// sort options ascending\nint max = 0;\nStringBuffer optBuf;\nList prefixList = new ArrayList();\n\nList optList = options.helpOptions();\n\nCollections.sort(optList, getOptionComparator());\n\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\nOption option = (Option) i.next();\noptBuf = new StringBuffer(8);\n\nif (option.getOpt() == null)\n{\noptBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n}\nelse\n{\noptBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\nif (option.hasLongOpt())\n{\noptBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n}\n}\n\nif (option.hasArg())\n{\nif (option.hasArgName())\n{\noptBuf.append(\" <\").append(option.getArgName()).append(\">\");\n}\nelse\n{\noptBuf.append(' ');\n}\n}\n\nprefixList.add(optBuf);\nmax = (optBuf.length() > max) ? optBuf.length() : max;\n}\n\nint x = 0;\n\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\nOption option = (Option) i.next();\noptBuf = new StringBuffer(prefixList.get(x++).toString());\n\nif (optBuf.length() < max)\n{\noptBuf.append(createPadding(max - optBuf.length()));\n}\n\noptBuf.append(dpad);\n\nint nextLineTabStop = max + descPad;\n\nif (option.getDescription() != null)\n{\noptBuf.append(option.getDescription());\n}\n\nrenderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\nif (i.hasNext())\n{\nsb.append(defaultNewLine);\n}\n}\n\nreturn sb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderWrappedText(Ljava/lang/StringBuffer;IILjava/lang/String;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderWrappedText(StringBuffer sb, int width,\nint nextLineTabStop, String text)\n{\nint pos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(rtrim(text));\n\nreturn sb;\n}\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n// all following lines must be padded with nextLineTabStop space\n// characters\nfinal String padding = createPadding(nextLineTabStop);\n\nwhile (true)\n{\nint lastPos = pos;\ntext = padding + text.substring(pos).trim();\npos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(text);\n\nreturn sb;\n} else\nif (pos == lastPos)\n{\nthrow new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n}\n\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:findWrapPos(Ljava/lang/String;II)I",
                                    "method_body": "protected int findWrapPos(String text, int width, int startPos)\n{\nint pos = -1;\n\n// the line ends before the max wrap pos or a new line char found\nif (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n|| ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n{\nreturn pos + 1;\n}\nelse if (startPos + width >= text.length())\n{\nreturn -1;\n}\n\n\n// look for the last whitespace character before startPos+width\npos = startPos + width;\n\nchar c;\n\nwhile ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n--pos;\n}\n\n// if we found it - just return\nif (pos > startPos)\n{\nreturn pos;\n}\n\n// must look for the first whitespace chearacter after startPos\n// + width\npos = startPos + width;\n\nwhile ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n++pos;\n}\n\nreturn (pos == text.length()) ? (-1) : pos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:createPadding(I)Ljava/lang/String;",
                                    "method_body": "protected String createPadding(int len)\n{\nStringBuffer sb = new StringBuffer(len);\n\nfor (int i = 0; i < len; ++i)\n{\nsb.append(' ');\n}\n\nreturn sb.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:rtrim(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "protected String rtrim(String s)\n{\nif ((s == null) || (s.length() == 0))\n{\nreturn s;\n}\n\nint pos = s.length();\n\nwhile ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n{\n--pos;\n}\n\nreturn s.substring(0, pos);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter$OptionComparator:compare(Ljava/lang/Object;Ljava/lang/Object;)I",
                                    "method_body": "public int compare(Object o1, Object o2)\n{\nOption opt1 = (Option) o1;\nOption opt2 = (Option) o2;\n\nreturn opt1.getKey().compareToIgnoreCase(opt2.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup addOption(Option option)\n{\n// key   - option name\n// value - the option\noptionMap.put(option.getKey(), option);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\n// the values are the collection of options\nreturn optionMap.values();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI162Test.testInfiniteLoop",
                            "test_body": "public void testInfiniteLoop() {\nHelpFormatter formatter = new HelpFormatter();\nformatter.setWidth(20);\nformatter.printHelp(\"app\", options); // used to hang & crash\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription()\n{\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == ' ' || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:getOptionComparator()Ljava/util/Comparator;",
                                    "method_body": "public Comparator getOptionComparator()\n{\nreturn optionComparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printHelp(Ljava/lang/String;Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "public void printHelp(String cmdLineSyntax, Options options)\n{\nprintHelp(defaultWidth, cmdLineSyntax, null, options, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printHelp(ILjava/lang/String;Ljava/lang/String;Lorg/apache/commons/cli/Options;Ljava/lang/String;Z)V",
                                    "method_body": "public void printHelp(int width, String cmdLineSyntax, String header,\nOptions options, String footer, boolean autoUsage)\n{\nPrintWriter pw = new PrintWriter(System.out);\n\nprintHelp(pw, width, cmdLineSyntax, header, options, defaultLeftPad, defaultDescPad, footer, autoUsage);\npw.flush();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printHelp(Ljava/io/PrintWriter;ILjava/lang/String;Ljava/lang/String;Lorg/apache/commons/cli/Options;IILjava/lang/String;Z)V",
                                    "method_body": "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\nString header, Options options, int leftPad,\nint descPad, String footer, boolean autoUsage)\n{\nif ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n{\nthrow new IllegalArgumentException(\"cmdLineSyntax not provided\");\n}\n\nif (autoUsage)\n{\nprintUsage(pw, width, cmdLineSyntax, options);\n}\nelse\n{\nprintUsage(pw, width, cmdLineSyntax);\n}\n\nif ((header != null) && (header.trim().length() > 0))\n{\nprintWrapped(pw, width, header);\n}\n\nprintOptions(pw, width, options, leftPad, descPad);\n\nif ((footer != null) && (footer.trim().length() > 0))\n{\nprintWrapped(pw, width, footer);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printUsage(Ljava/io/PrintWriter;ILjava/lang/String;)V",
                                    "method_body": "public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n{\nint argPos = cmdLineSyntax.indexOf(' ') + 1;\n\nprintWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printOptions(Ljava/io/PrintWriter;ILorg/apache/commons/cli/Options;II)V",
                                    "method_body": "public void printOptions(PrintWriter pw, int width, Options options,\nint leftPad, int descPad)\n{\nStringBuffer sb = new StringBuffer();\n\nrenderOptions(sb, width, options, leftPad, descPad);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printWrapped(Ljava/io/PrintWriter;IILjava/lang/String;)V",
                                    "method_body": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n{\nStringBuffer sb = new StringBuffer(text.length());\n\nrenderWrappedText(sb, width, nextLineTabStop, text);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderOptions(Ljava/lang/StringBuffer;ILorg/apache/commons/cli/Options;II)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n{\nfinal String lpad = createPadding(leftPad);\nfinal String dpad = createPadding(descPad);\n\n// first create list containing only <lpad>-a,--aaa where\n// -a is opt and --aaa is long opt; in parallel look for\n// the longest opt string this list will be then used to\n// sort options ascending\nint max = 0;\nStringBuffer optBuf;\nList prefixList = new ArrayList();\n\nList optList = options.helpOptions();\n\nCollections.sort(optList, getOptionComparator());\n\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\nOption option = (Option) i.next();\noptBuf = new StringBuffer(8);\n\nif (option.getOpt() == null)\n{\noptBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n}\nelse\n{\noptBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\nif (option.hasLongOpt())\n{\noptBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n}\n}\n\nif (option.hasArg())\n{\nif (option.hasArgName())\n{\noptBuf.append(\" <\").append(option.getArgName()).append(\">\");\n}\nelse\n{\noptBuf.append(' ');\n}\n}\n\nprefixList.add(optBuf);\nmax = (optBuf.length() > max) ? optBuf.length() : max;\n}\n\nint x = 0;\n\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\nOption option = (Option) i.next();\noptBuf = new StringBuffer(prefixList.get(x++).toString());\n\nif (optBuf.length() < max)\n{\noptBuf.append(createPadding(max - optBuf.length()));\n}\n\noptBuf.append(dpad);\n\nint nextLineTabStop = max + descPad;\n\nif (option.getDescription() != null)\n{\noptBuf.append(option.getDescription());\n}\n\nrenderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\nif (i.hasNext())\n{\nsb.append(defaultNewLine);\n}\n}\n\nreturn sb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderWrappedText(Ljava/lang/StringBuffer;IILjava/lang/String;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderWrappedText(StringBuffer sb, int width,\nint nextLineTabStop, String text)\n{\nint pos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(rtrim(text));\n\nreturn sb;\n}\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\n// all following lines must be padded with nextLineTabStop space\n// characters\nfinal String padding = createPadding(nextLineTabStop);\n\nwhile (true)\n{\nint lastPos = pos;\ntext = padding + text.substring(pos).trim();\npos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(text);\n\nreturn sb;\n} else\nif (pos == lastPos)\n{\nthrow new RuntimeException(\"Text too long for line - throwing exception to avoid infinite loop [CLI-162]: \" + text);\n}\n\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:findWrapPos(Ljava/lang/String;II)I",
                                    "method_body": "protected int findWrapPos(String text, int width, int startPos)\n{\nint pos = -1;\n\n// the line ends before the max wrap pos or a new line char found\nif (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n|| ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n{\nreturn pos + 1;\n}\nelse if (startPos + width >= text.length())\n{\nreturn -1;\n}\n\n\n// look for the last whitespace character before startPos+width\npos = startPos + width;\n\nchar c;\n\nwhile ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n--pos;\n}\n\n// if we found it - just return\nif (pos > startPos)\n{\nreturn pos;\n}\n\n// must look for the first whitespace chearacter after startPos\n// + width\npos = startPos + width;\n\nwhile ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n++pos;\n}\n\nreturn (pos == text.length()) ? (-1) : pos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:createPadding(I)Ljava/lang/String;",
                                    "method_body": "protected String createPadding(int len)\n{\nStringBuffer sb = new StringBuffer(len);\n\nfor (int i = 0; i < len; ++i)\n{\nsb.append(' ');\n}\n\nreturn sb.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:rtrim(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "protected String rtrim(String s)\n{\nif ((s == null) || (s.length() == 0))\n{\nreturn s;\n}\n\nint pos = s.length();\n\nwhile ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n{\n--pos;\n}\n\nreturn s.substring(0, pos);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:setWidth(I)V",
                                    "method_body": "public void setWidth(int width)\n{\nthis.defaultWidth = width;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 24,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI162Test.testLongLineChunkingIndentIgnored",
                            "test_body": "public void testLongLineChunkingIndentIgnored() throws ParseException, IOException {\nOptions options = new Options();\noptions.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\" );\nHelpFormatter formatter = new HelpFormatter();\nStringWriter sw = new StringWriter();\nformatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\nString expected = \"usage:\\n\" +\n\"       org.apache.comm\\n\" +\n\"       ons.cli.bug.Bug\\n\" +\n\"       CLI162Test\\n\" +\n\"Header\\n\" +\n\"-x,--extralongarg\\n\" +\n\"                     T\\n\" +\n\"                     h\\n\" +\n\"                     i\\n\" +\n\"                     s\\n\" +\n\"                     d\\n\" +\n\"                     e\\n\" +\n\"                     s\\n\" +\n\"                     c\\n\" +\n\"                     r\\n\" +\n\"                     i\\n\" +\n\"                     p\\n\" +\n\"                     t\\n\" +\n\"                     i\\n\" +\n\"                     o\\n\" +\n\"                     n\\n\" +\n\"                     i\\n\" +\n\"                     s\\n\" +\n\"                     L\\n\" +\n\"                     o\\n\" +\n\"                     n\\n\" +\n\"                     g\\n\" +\n\"                     .\\n\" +\n\"Footer\\n\";\nassertEquals( \"Long arguments did not split as expected\", expected, sw.toString() );\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription()\n{\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == ' ' || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:getOptionComparator()Ljava/util/Comparator;",
                                    "method_body": "public Comparator getOptionComparator()\n{\nreturn optionComparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printHelp(Ljava/io/PrintWriter;ILjava/lang/String;Ljava/lang/String;Lorg/apache/commons/cli/Options;IILjava/lang/String;)V",
                                    "method_body": "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\nString header, Options options, int leftPad,\nint descPad, String footer)\n{\nprintHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printHelp(Ljava/io/PrintWriter;ILjava/lang/String;Ljava/lang/String;Lorg/apache/commons/cli/Options;IILjava/lang/String;Z)V",
                                    "method_body": "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\nString header, Options options, int leftPad,\nint descPad, String footer, boolean autoUsage)\n{\nif ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n{\nthrow new IllegalArgumentException(\"cmdLineSyntax not provided\");\n}\n\nif (autoUsage)\n{\nprintUsage(pw, width, cmdLineSyntax, options);\n}\nelse\n{\nprintUsage(pw, width, cmdLineSyntax);\n}\n\nif ((header != null) && (header.trim().length() > 0))\n{\nprintWrapped(pw, width, header);\n}\n\nprintOptions(pw, width, options, leftPad, descPad);\n\nif ((footer != null) && (footer.trim().length() > 0))\n{\nprintWrapped(pw, width, footer);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printUsage(Ljava/io/PrintWriter;ILjava/lang/String;)V",
                                    "method_body": "public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n{\nint argPos = cmdLineSyntax.indexOf(' ') + 1;\n\nprintWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printOptions(Ljava/io/PrintWriter;ILorg/apache/commons/cli/Options;II)V",
                                    "method_body": "public void printOptions(PrintWriter pw, int width, Options options,\nint leftPad, int descPad)\n{\nStringBuffer sb = new StringBuffer();\n\nrenderOptions(sb, width, options, leftPad, descPad);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printWrapped(Ljava/io/PrintWriter;ILjava/lang/String;)V",
                                    "method_body": "public void printWrapped(PrintWriter pw, int width, String text)\n{\nprintWrapped(pw, width, 0, text);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printWrapped(Ljava/io/PrintWriter;IILjava/lang/String;)V",
                                    "method_body": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n{\nStringBuffer sb = new StringBuffer(text.length());\n\nrenderWrappedText(sb, width, nextLineTabStop, text);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderOptions(Ljava/lang/StringBuffer;ILorg/apache/commons/cli/Options;II)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n{\nfinal String lpad = createPadding(leftPad);\nfinal String dpad = createPadding(descPad);\n\n// first create list containing only <lpad>-a,--aaa where\n// -a is opt and --aaa is long opt; in parallel look for\n// the longest opt string this list will be then used to\n// sort options ascending\nint max = 0;\nStringBuffer optBuf;\nList prefixList = new ArrayList();\n\nList optList = options.helpOptions();\n\nCollections.sort(optList, getOptionComparator());\n\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\nOption option = (Option) i.next();\noptBuf = new StringBuffer(8);\n\nif (option.getOpt() == null)\n{\noptBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n}\nelse\n{\noptBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\nif (option.hasLongOpt())\n{\noptBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n}\n}\n\nif (option.hasArg())\n{\nif (option.hasArgName())\n{\noptBuf.append(\" <\").append(option.getArgName()).append(\">\");\n}\nelse\n{\noptBuf.append(' ');\n}\n}\n\nprefixList.add(optBuf);\nmax = (optBuf.length() > max) ? optBuf.length() : max;\n}\n\nint x = 0;\n\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\nOption option = (Option) i.next();\noptBuf = new StringBuffer(prefixList.get(x++).toString());\n\nif (optBuf.length() < max)\n{\noptBuf.append(createPadding(max - optBuf.length()));\n}\n\noptBuf.append(dpad);\n\nint nextLineTabStop = max + descPad;\n\nif (option.getDescription() != null)\n{\noptBuf.append(option.getDescription());\n}\n\nrenderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\nif (i.hasNext())\n{\nsb.append(defaultNewLine);\n}\n}\n\nreturn sb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderWrappedText(Ljava/lang/StringBuffer;IILjava/lang/String;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderWrappedText(StringBuffer sb, int width,\nint nextLineTabStop, String text)\n{\nint pos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(rtrim(text));\n\nreturn sb;\n}\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\nif (nextLineTabStop >= width)\n{\n// stops infinite loop happening\nthrow new IllegalStateException(\"Total width is less than the width of the argument and indent \" +\n\"- no room for the description\");\n}\n\n// all following lines must be padded with nextLineTabStop space\n// characters\nfinal String padding = createPadding(nextLineTabStop);\n\nwhile (true)\n{\ntext = padding + text.substring(pos).trim();\npos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(text);\n\nreturn sb;\n}\n\nif ( (text.length() > width) && (pos == nextLineTabStop - 1) )\n{\npos = width;\n}\n\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:findWrapPos(Ljava/lang/String;II)I",
                                    "method_body": "protected int findWrapPos(String text, int width, int startPos)\n{\nint pos = -1;\n\n// the line ends before the max wrap pos or a new line char found\nif (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n|| ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n{\nreturn pos + 1;\n}\nelse if (startPos + width >= text.length())\n{\nreturn -1;\n}\n\n\n// look for the last whitespace character before startPos+width\npos = startPos + width;\n\nchar c;\n\nwhile ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n--pos;\n}\n\n// if we found it - just return\nif (pos > startPos)\n{\nreturn pos;\n}\n\n// must look for the first whitespace chearacter after startPos\n// + width\npos = startPos + width;\n\nwhile ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n++pos;\n}\n\nreturn (pos == text.length()) ? (-1) : pos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:createPadding(I)Ljava/lang/String;",
                                    "method_body": "protected String createPadding(int len)\n{\nStringBuffer sb = new StringBuffer(len);\n\nfor (int i = 0; i < len; ++i)\n{\nsb.append(' ');\n}\n\nreturn sb.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:rtrim(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "protected String rtrim(String s)\n{\nif ((s == null) || (s.length() == 0))\n{\nreturn s;\n}\n\nint pos = s.length();\n\nwhile ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n{\n--pos;\n}\n\nreturn s.substring(0, pos);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 25,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI162Test.testLongLineChunkingIndentIgnored",
                            "test_body": "public void testLongLineChunkingIndentIgnored() throws ParseException, IOException {\nOptions options = new Options();\noptions.addOption(\"x\", \"extralongarg\", false, \"This description is Long.\" );\nHelpFormatter formatter = new HelpFormatter();\nStringWriter sw = new StringWriter();\nformatter.printHelp(new PrintWriter(sw), 22, this.getClass().getName(), \"Header\", options, 0, 5, \"Footer\");\nSystem.err.println(sw.toString());\nString expected = \"usage:\\n\" +\n\"       org.apache.comm\\n\" +\n\"       ons.cli.bug.Bug\\n\" +\n\"       CLI162Test\\n\" +\n\"Header\\n\" +\n\"-x,--extralongarg\\n\" +\n\" This description is\\n\" +\n\" Long.\\n\" +\n\"Footer\\n\";\nassertEquals( \"Long arguments did not split as expected\", expected, sw.toString() );\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription()\n{\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == ' ' || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:getOptionComparator()Ljava/util/Comparator;",
                                    "method_body": "public Comparator getOptionComparator()\n{\nreturn optionComparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printHelp(Ljava/io/PrintWriter;ILjava/lang/String;Ljava/lang/String;Lorg/apache/commons/cli/Options;IILjava/lang/String;)V",
                                    "method_body": "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\nString header, Options options, int leftPad,\nint descPad, String footer)\n{\nprintHelp(pw, width, cmdLineSyntax, header, options, leftPad, descPad, footer, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printHelp(Ljava/io/PrintWriter;ILjava/lang/String;Ljava/lang/String;Lorg/apache/commons/cli/Options;IILjava/lang/String;Z)V",
                                    "method_body": "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\nString header, Options options, int leftPad,\nint descPad, String footer, boolean autoUsage)\n{\nif ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n{\nthrow new IllegalArgumentException(\"cmdLineSyntax not provided\");\n}\n\nif (autoUsage)\n{\nprintUsage(pw, width, cmdLineSyntax, options);\n}\nelse\n{\nprintUsage(pw, width, cmdLineSyntax);\n}\n\nif ((header != null) && (header.trim().length() > 0))\n{\nprintWrapped(pw, width, header);\n}\n\nprintOptions(pw, width, options, leftPad, descPad);\n\nif ((footer != null) && (footer.trim().length() > 0))\n{\nprintWrapped(pw, width, footer);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printUsage(Ljava/io/PrintWriter;ILjava/lang/String;)V",
                                    "method_body": "public void printUsage(PrintWriter pw, int width, String cmdLineSyntax)\n{\nint argPos = cmdLineSyntax.indexOf(' ') + 1;\n\nprintWrapped(pw, width, defaultSyntaxPrefix.length() + argPos, defaultSyntaxPrefix + cmdLineSyntax);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printOptions(Ljava/io/PrintWriter;ILorg/apache/commons/cli/Options;II)V",
                                    "method_body": "public void printOptions(PrintWriter pw, int width, Options options,\nint leftPad, int descPad)\n{\nStringBuffer sb = new StringBuffer();\n\nrenderOptions(sb, width, options, leftPad, descPad);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printWrapped(Ljava/io/PrintWriter;ILjava/lang/String;)V",
                                    "method_body": "public void printWrapped(PrintWriter pw, int width, String text)\n{\nprintWrapped(pw, width, 0, text);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printWrapped(Ljava/io/PrintWriter;IILjava/lang/String;)V",
                                    "method_body": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n{\nStringBuffer sb = new StringBuffer(text.length());\n\nrenderWrappedText(sb, width, nextLineTabStop, text);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderOptions(Ljava/lang/StringBuffer;ILorg/apache/commons/cli/Options;II)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n{\nfinal String lpad = createPadding(leftPad);\nfinal String dpad = createPadding(descPad);\n\n// first create list containing only <lpad>-a,--aaa where\n// -a is opt and --aaa is long opt; in parallel look for\n// the longest opt string this list will be then used to\n// sort options ascending\nint max = 0;\nStringBuffer optBuf;\nList prefixList = new ArrayList();\n\nList optList = options.helpOptions();\n\nCollections.sort(optList, getOptionComparator());\n\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\nOption option = (Option) i.next();\noptBuf = new StringBuffer(8);\n\nif (option.getOpt() == null)\n{\noptBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n}\nelse\n{\noptBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\nif (option.hasLongOpt())\n{\noptBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n}\n}\n\nif (option.hasArg())\n{\nif (option.hasArgName())\n{\noptBuf.append(\" <\").append(option.getArgName()).append(\">\");\n}\nelse\n{\noptBuf.append(' ');\n}\n}\n\nprefixList.add(optBuf);\nmax = (optBuf.length() > max) ? optBuf.length() : max;\n}\n\nint x = 0;\n\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\nOption option = (Option) i.next();\noptBuf = new StringBuffer(prefixList.get(x++).toString());\n\nif (optBuf.length() < max)\n{\noptBuf.append(createPadding(max - optBuf.length()));\n}\n\noptBuf.append(dpad);\n\nint nextLineTabStop = max + descPad;\n\nif (option.getDescription() != null)\n{\noptBuf.append(option.getDescription());\n}\n\nrenderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\nif (i.hasNext())\n{\nsb.append(defaultNewLine);\n}\n}\n\nreturn sb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderWrappedText(Ljava/lang/StringBuffer;IILjava/lang/String;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderWrappedText(StringBuffer sb, int width,\nint nextLineTabStop, String text)\n{\nint pos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(rtrim(text));\n\nreturn sb;\n}\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\nif (nextLineTabStop >= width)\n{\n// stops infinite loop happening\nnextLineTabStop = width - 1;\n}\n\n// all following lines must be padded with nextLineTabStop space\n// characters\nfinal String padding = createPadding(nextLineTabStop);\n\nwhile (true)\n{\ntext = padding + text.substring(pos).trim();\npos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(text);\n\nreturn sb;\n}\n\nif ( (text.length() > width) && (pos == nextLineTabStop - 1) )\n{\npos = width;\n}\n\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:findWrapPos(Ljava/lang/String;II)I",
                                    "method_body": "protected int findWrapPos(String text, int width, int startPos)\n{\nint pos = -1;\n\n// the line ends before the max wrap pos or a new line char found\nif (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n|| ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n{\nreturn pos + 1;\n}\nelse if (startPos + width >= text.length())\n{\nreturn -1;\n}\n\n\n// look for the last whitespace character before startPos+width\npos = startPos + width;\n\nchar c;\n\nwhile ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n--pos;\n}\n\n// if we found it - just return\nif (pos > startPos)\n{\nreturn pos;\n}\n\n// must look for the first whitespace chearacter after startPos\n// + width\npos = startPos + width;\n\nwhile ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n++pos;\n}\n\nreturn (pos == text.length()) ? (-1) : pos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:createPadding(I)Ljava/lang/String;",
                                    "method_body": "protected String createPadding(int len)\n{\nStringBuffer sb = new StringBuffer(len);\n\nfor (int i = 0; i < len; ++i)\n{\nsb.append(' ');\n}\n\nreturn sb.toString();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:rtrim(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "protected String rtrim(String s)\n{\nif ((s == null) || (s.length() == 0))\n{\nreturn s;\n}\n\nint pos = s.length();\n\nwhile ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n{\n--pos;\n}\n\nreturn s.substring(0, pos);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 26,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.OptionBuilderTest.testBuilderIsResettedAlways",
                            "test_body": "public void testBuilderIsResettedAlways() {\ntry\n{\nOptionBuilder.withDescription(\"JUnit\").create('\"');\nfail(\"IllegalArgumentException expected\");\n}\ncatch (IllegalArgumentException e)\n{\n// expected\n}\nassertNull(\"we inherited a description\", OptionBuilder.create('x').getDescription());\ntry\n{\nOptionBuilder.withDescription(\"JUnit\").create();\nfail(\"IllegalArgumentException expected\");\n}\ncatch (IllegalArgumentException e)\n{\n// expected\n}\nassertNull(\"we inherited a description\", OptionBuilder.create('x').getDescription());\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withDescription(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withDescription(String newDescription)\n{\nOptionBuilder.description = newDescription;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt) throws IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt) throws IllegalArgumentException\n{\n// create the option\nOption option = new Option(opt, description);\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription()\n{\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == ' ' || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 27,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.BasicParserTest.testOptionGroupLong",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOptionGroup(Lorg/apache/commons/cli/OptionGroup;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOptionGroup(OptionGroup group)\n{\nIterator options = group.getOptions().iterator();\n\nif (group.isRequired())\n{\nrequiredOpts.add(group);\n}\n\nwhile (options.hasNext())\n{\nOption option = (Option) options.next();\n\n// an Option cannot be required if it is in an\n// OptionGroup, either the group is required or\n// nothing is required\noption.setRequired(false);\naddOption(option);\n\noptionGroups.put(option.getKey(), group);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create()Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create() throws IllegalArgumentException\n{\nif (longopt == null)\n{\nOptionBuilder.reset();\nthrow new IllegalArgumentException(\"must specify longopt\");\n}\n\nreturn create(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt) throws IllegalArgumentException\n{\nOption option = null;\ntry {\n// create the option\noption = new Option(opt, description);\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n} finally {\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n}\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o)\n{\nif (this == o)\n{\nreturn true;\n}\nif (o == null || getClass() != o.getClass())\n{\nreturn false;\n}\n\nOption option = (Option) o;\n\n\nif (opt != null ? !opt.equals(option.opt) : option.opt != null)\n{\nreturn false;\n}\nif (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == ' ' || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions()\n{\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments) throws ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processsed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter) throws ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup addOption(Option option)\n{\n// key   - option name\n// value - the option\noptionMap.put(option.getKey(), option);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\n// the values are the collection of options\nreturn optionMap.values();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:setSelected(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public void setSelected(Option option) throws AlreadySelectedException\n{\nif (option == null)\n{\n// reset the option previously selected\nselected = null;\nreturn;\n}\n\n// if no option has already been selected or the\n// same option is being reselected then set the\n// selected member variable\nif (selected == null || selected.equals(option.getOpt()))\n{\nselected = option.getOpt();\n}\nelse\n{\nthrow new AlreadySelectedException(this, option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getSelected()Ljava/lang/String;",
                                    "method_body": "public String getSelected()\n{\nreturn selected;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.BasicParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\n// just echo the arguments\nreturn arguments;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.PosixParserTest.testOptionGroupLong",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOptionGroup(Lorg/apache/commons/cli/OptionGroup;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOptionGroup(OptionGroup group)\n{\nIterator options = group.getOptions().iterator();\n\nif (group.isRequired())\n{\nrequiredOpts.add(group);\n}\n\nwhile (options.hasNext())\n{\nOption option = (Option) options.next();\n\n// an Option cannot be required if it is in an\n// OptionGroup, either the group is required or\n// nothing is required\noption.setRequired(false);\naddOption(option);\n\noptionGroups.put(option.getKey(), group);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create()Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create() throws IllegalArgumentException\n{\nif (longopt == null)\n{\nOptionBuilder.reset();\nthrow new IllegalArgumentException(\"must specify longopt\");\n}\n\nreturn create(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt) throws IllegalArgumentException\n{\nOption option = null;\ntry {\n// create the option\noption = new Option(opt, description);\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n} finally {\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n}\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o)\n{\nif (this == o)\n{\nreturn true;\n}\nif (o == null || getClass() != o.getClass())\n{\nreturn false;\n}\n\nOption option = (Option) o;\n\n\nif (opt != null ? !opt.equals(option.opt) : option.opt != null)\n{\nreturn false;\n}\nif (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == ' ' || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions()\n{\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments) throws ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processsed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter) throws ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup addOption(Option option)\n{\n// key   - option name\n// value - the option\noptionMap.put(option.getKey(), option);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\n// the values are the collection of options\nreturn optionMap.values();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:setSelected(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public void setSelected(Option option) throws AlreadySelectedException\n{\nif (option == null)\n{\n// reset the option previously selected\nselected = null;\nreturn;\n}\n\n// if no option has already been selected or the\n// same option is being reselected then set the\n// selected member variable\nif (selected == null || selected.equals(option.getOpt()))\n{\nselected = option.getOpt();\n}\nelse\n{\nthrow new AlreadySelectedException(this, option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getSelected()Ljava/lang/String;",
                                    "method_body": "public String getSelected()\n{\nreturn selected;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getMatchingOptions(Ljava/lang/String;)Ljava/util/List;",
                                    "method_body": "public List getMatchingOptions(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nList matchingOpts = new ArrayList();\n\nIterator it = longOpts.keySet().iterator();\nwhile (it.hasNext())\n{\nString longOpt = (String) it.next();\nif (longOpt.startsWith(opt))\n{\nmatchingOpts.add(longOpt);\n}\n}\n\nreturn matchingOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nString token = (String) iter.next();\n\n// single or double hyphen\nif (\"-\".equals(token) || \"--\".equals(token))\n{\ntokens.add(token);\n}\n\n// handle long option --foo or --foo=bar\nelse if (token.startsWith(\"--\"))\n{\nint pos = token.indexOf('=');\nString opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\nList matchingOpts = options.getMatchingOptions(opt);\n\nif (matchingOpts.isEmpty())\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\nelse if (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(opt, matchingOpts);\n}\nelse\n{\ncurrentOption = options.getOption((String) matchingOpts.get(0));\n\ntokens.add(\"--\" + currentOption.getLongOpt());\nif (pos != -1)\n{\ntokens.add(token.substring(pos + 1));\n}\n}\n}\n\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2 || options.hasOption(token))\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (!options.getMatchingOptions(token).isEmpty())\n{\nList matchingOpts = options.getMatchingOptions(token);\nif (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(token, matchingOpts);\n}\nelse\n{\nOption opt = options.getOption((String) matchingOpts.get(0));\nprocessOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n}\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.GnuParserTest.testOptionGroupLong",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOptionGroup(Lorg/apache/commons/cli/OptionGroup;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOptionGroup(OptionGroup group)\n{\nIterator options = group.getOptions().iterator();\n\nif (group.isRequired())\n{\nrequiredOpts.add(group);\n}\n\nwhile (options.hasNext())\n{\nOption option = (Option) options.next();\n\n// an Option cannot be required if it is in an\n// OptionGroup, either the group is required or\n// nothing is required\noption.setRequired(false);\naddOption(option);\n\noptionGroups.put(option.getKey(), group);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create()Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create() throws IllegalArgumentException\n{\nif (longopt == null)\n{\nOptionBuilder.reset();\nthrow new IllegalArgumentException(\"must specify longopt\");\n}\n\nreturn create(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt) throws IllegalArgumentException\n{\nOption option = null;\ntry {\n// create the option\noption = new Option(opt, description);\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n} finally {\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n}\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o)\n{\nif (this == o)\n{\nreturn true;\n}\nif (o == null || getClass() != o.getClass())\n{\nreturn false;\n}\n\nOption option = (Option) o;\n\n\nif (opt != null ? !opt.equals(option.opt) : option.opt != null)\n{\nreturn false;\n}\nif (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == ' ' || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions()\n{\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments) throws ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processsed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter) throws ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.GnuParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\nList tokens = new ArrayList();\n\nboolean eatTheRest = false;\n\nfor (int i = 0; i < arguments.length; i++)\n{\nString arg = arguments[i];\n\nif (\"--\".equals(arg))\n{\neatTheRest = true;\ntokens.add(\"--\");\n}\nelse if (\"-\".equals(arg))\n{\ntokens.add(\"-\");\n}\nelse if (arg.startsWith(\"-\"))\n{\nString opt = Util.stripLeadingHyphens(arg);\n\nif (options.hasOption(opt))\n{\ntokens.add(arg);\n}\nelse\n{\nif (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n{\n// the format is --foo=value or -foo=value\ntokens.add(arg.substring(0, arg.indexOf('='))); // --foo\ntokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n}\nelse if (options.hasOption(arg.substring(0, 2)))\n{\n// the format is a special properties option (-Dproperty=value)\ntokens.add(arg.substring(0, 2)); // -D\ntokens.add(arg.substring(2)); // property=value\n}\nelse\n{\neatTheRest = stopAtNonOption;\ntokens.add(arg);\n}\n}\n}\nelse\n{\ntokens.add(arg);\n}\n\nif (eatTheRest)\n{\nfor (i++; i < arguments.length; i++)\n{\ntokens.add(arguments[i]);\n}\n}\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup addOption(Option option)\n{\n// key   - option name\n// value - the option\noptionMap.put(option.getKey(), option);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\n// the values are the collection of options\nreturn optionMap.values();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:setSelected(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public void setSelected(Option option) throws AlreadySelectedException\n{\nif (option == null)\n{\n// reset the option previously selected\nselected = null;\nreturn;\n}\n\n// if no option has already been selected or the\n// same option is being reselected then set the\n// selected member variable\nif (selected == null || selected.equals(option.getOpt()))\n{\nselected = option.getOpt();\n}\nelse\n{\nthrow new AlreadySelectedException(this, option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getSelected()Ljava/lang/String;",
                                    "method_body": "public String getSelected()\n{\nreturn selected;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 28,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.ValueTest.testPropertyOptionFlags",
                            "test_body": "public void testPropertyOptionFlags() throws Exception\n{\nProperties properties = new Properties();\nproperties.setProperty( \"a\", \"true\" );\nproperties.setProperty( \"c\", \"yes\" );\nproperties.setProperty( \"e\", \"1\" );\nParser parser = new PosixParser();\nCommandLine cmd = parser.parse(opts, null, properties);\nassertTrue( cmd.hasOption(\"a\") );\nassertTrue( cmd.hasOption(\"c\") );\nassertTrue( cmd.hasOption(\"e\") );\nproperties = new Properties();\nproperties.setProperty( \"a\", \"false\" );\nproperties.setProperty( \"c\", \"no\" );\nproperties.setProperty( \"e\", \"0\" );\ncmd = parser.parse(opts, null, properties);\nassertTrue( !cmd.hasOption(\"a\") );\nassertTrue( !cmd.hasOption(\"c\") );\nassertTrue( cmd.hasOption(\"e\") ); // this option accepts as argument\nproperties = new Properties();\nproperties.setProperty( \"a\", \"TRUE\" );\nproperties.setProperty( \"c\", \"nO\" );\nproperties.setProperty( \"e\", \"TrUe\" );\ncmd = parser.parse(opts, null, properties);\nassertTrue( cmd.hasOption(\"a\") );\nassertTrue( !cmd.hasOption(\"c\") );\nassertTrue( cmd.hasOption(\"e\") );\nproperties = new Properties();\nproperties.setProperty( \"a\", \"just a string\" );\nproperties.setProperty( \"e\", \"\" );\ncmd = parser.parse(opts, null, properties);\nassertTrue( !cmd.hasOption(\"a\") );\nassertTrue( !cmd.hasOption(\"c\") );\nassertTrue( cmd.hasOption(\"e\") );\n} \n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nif (str.startsWith(\"\\\"\"))\n{\nstr = str.substring(1, str.length());\n}\nif (str.endsWith(\"\\\"\"))\n{\nstr = str.substring(0, str.length() - 1);\n}\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, boolean hasArg, String description)\n{\naddOption(opt, null, hasArg, description);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getMatchingOptions(Ljava/lang/String;)Ljava/util/List;",
                                    "method_body": "public List getMatchingOptions(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nList matchingOpts = new ArrayList();\n\nIterator it = longOpts.keySet().iterator();\nwhile (it.hasNext())\n{\nString longOpt = (String) it.next();\nif (longOpt.startsWith(opt))\n{\nmatchingOpts.add(longOpt);\n}\n}\n\nreturn matchingOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\n/**\n* private constructor to prevent instances being created\n*/\nprivate OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\n\n\n// PMM 9/6/02 - these were missing\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withValueSeparator(C)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withValueSeparator(char sep)\n{\nOptionBuilder.valuesep = sep;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArgs()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArgs()\n{\nOptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasOptionalArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasOptionalArg()\n{\nOptionBuilder.numberOfArgs = 1;\nOptionBuilder.optionalArg = true;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasOptionalArgs()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasOptionalArgs()\n{\nOptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\nOptionBuilder.optionalArg = true;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasOptionalArgs(I)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasOptionalArgs(int numArgs)\n{\nOptionBuilder.numberOfArgs = numArgs;\nOptionBuilder.optionalArg = true;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt) throws IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create()Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create() throws IllegalArgumentException\n{\nif (longopt == null)\n{\nOptionBuilder.reset();\nthrow new IllegalArgumentException(\"must specify longopt\");\n}\n\nreturn create(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt) throws IllegalArgumentException\n{\nOption option = null;\ntry {\n// create the option\noption = new Option(opt, description);\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n} finally {\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n}\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn valuesep > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
                                    "method_body": "void addValueForProcessing(String value)\n{\nswitch (numberOfArgs)\n{\ncase UNINITIALIZED:\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n\ndefault:\nprocessValue(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == (numberOfArgs - 1))\n{\nbreak;\n}\n\n// store\nadd(value.substring(0, index));\n\n// parse\nvalue = value.substring(index + 1);\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif (!acceptsArg())\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n// store value\nvalues.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues() ? null : (String[]) values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn values.isEmpty();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o)\n{\nif (this == o)\n{\nreturn true;\n}\nif (o == null || getClass() != o.getClass())\n{\nreturn false;\n}\n\nOption option = (Option) o;\n\n\nif (opt != null ? !opt.equals(option.opt) : option.opt != null)\n{\nreturn false;\n}\nif (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:acceptsArg()Z",
                                    "method_body": "boolean acceptsArg()\n{\nreturn (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"opt contains illegal character value '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == ' ' || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions()\n{\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments) throws ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processsed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(Option opt, ListIterator iter) throws ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nString str = (String) iter.next();\n\n// found an Option, not an argument\nif (getOptions().hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n}\ncatch (RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif (opt.getValues() == null && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter) throws ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nString token = (String) iter.next();\n\n// single or double hyphen\nif (\"-\".equals(token) || \"--\".equals(token))\n{\ntokens.add(token);\n}\n\n// handle long option --foo or --foo=bar\nelse if (token.startsWith(\"--\"))\n{\nint pos = token.indexOf('=');\nString opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\nList matchingOpts = options.getMatchingOptions(opt);\n\nif (matchingOpts.isEmpty())\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\nelse if (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(opt, matchingOpts);\n}\nelse\n{\ncurrentOption = options.getOption((String) matchingOpts.get(0));\n\ntokens.add(\"--\" + currentOption.getLongOpt());\nif (pos != -1)\n{\ntokens.add(token.substring(pos + 1));\n}\n}\n}\n\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2 || options.hasOption(token))\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (!options.getMatchingOptions(token).isEmpty())\n{\nList matchingOpts = options.getMatchingOptions(token);\nif (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(token, matchingOpts);\n}\nelse\n{\nOption opt = options.getOption((String) matchingOpts.get(0));\nprocessOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n}\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processNonOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processNonOptionToken(String value, boolean stopAtNonOption)\n{\nif (stopAtNonOption && (currentOption == null || !currentOption.hasArg()))\n{\neatTheRest = true;\ntokens.add(\"--\");\n}\n\ntokens.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (stopAtNonOption && !options.hasOption(token))\n{\neatTheRest = true;\n}\n\nif (options.hasOption(token))\n{\ncurrentOption = options.getOption(token);\n}\n\ntokens.add(token);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 29,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.UtilTest.testStripLeadingAndTrailingQuotes",
                            "test_body": "public void testStripLeadingAndTrailingQuotes()\n{\nassertEquals(\"foo\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\"\"));\nassertEquals(\"foo \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"foo \\\"bar\\\"\"));\nassertEquals(\"\\\"foo\\\" bar\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" bar\"));\nassertEquals(\"\\\"foo\\\" and \\\"bar\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"foo\\\" and \\\"bar\\\"\"));\nassertEquals(\"\\\"\", Util.stripLeadingAndTrailingQuotes(\"\\\"\"));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nif (str.startsWith(\"\\\"\"))\n{\nstr = str.substring(1, str.length());\n}\nint length = str.length();\nif (str.endsWith(\"\\\"\"))\n{\nstr = str.substring(0, length - 1);\n}\n\nreturn str;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 30,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.GnuParserTest.testPropertyOptionUnexpected",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// if the option is part of a group, check if another option of the group has been selected\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\ncontinue;\n}\n\ncmd.addOption(opt);\nupdateRequiredOptions(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.GnuParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\nList tokens = new ArrayList();\n\nboolean eatTheRest = false;\n\nfor (int i = 0; i < arguments.length; i++)\n{\nString arg = arguments[i];\n\nif (\"--\".equals(arg))\n{\neatTheRest = true;\ntokens.add(\"--\");\n}\nelse if (\"-\".equals(arg))\n{\ntokens.add(\"-\");\n}\nelse if (arg.startsWith(\"-\"))\n{\nString opt = Util.stripLeadingHyphens(arg);\n\nif (options.hasOption(opt))\n{\ntokens.add(arg);\n}\nelse\n{\nif (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n{\n// the format is --foo=value or -foo=value\ntokens.add(arg.substring(0, arg.indexOf('='))); // --foo\ntokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n}\nelse if (options.hasOption(arg.substring(0, 2)))\n{\n// the format is a special properties option (-Dproperty=value)\ntokens.add(arg.substring(0, 2)); // -D\ntokens.add(arg.substring(2)); // property=value\n}\nelse\n{\neatTheRest = stopAtNonOption;\ntokens.add(arg);\n}\n}\n}\nelse\n{\ntokens.add(arg);\n}\n\nif (eatTheRest)\n{\nfor (i++; i < arguments.length; i++)\n{\ntokens.add(arguments[i]);\n}\n}\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.BasicParserTest.testPropertyOptionGroup",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOptionGroup(Lorg/apache/commons/cli/OptionGroup;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOptionGroup(OptionGroup group)\n{\nIterator options = group.getOptions().iterator();\n\nif (group.isRequired())\n{\nrequiredOpts.add(group);\n}\n\nwhile (options.hasNext())\n{\nOption option = (Option) options.next();\n\n// an Option cannot be required if it is in an\n// OptionGroup, either the group is required or\n// nothing is required\noption.setRequired(false);\naddOption(option);\n\noptionGroups.put(option.getKey(), group);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup addOption(Option option)\n{\n// key   - option name\n// value - the option\noptionMap.put(option.getKey(), option);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\n// the values are the collection of options\nreturn optionMap.values();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:setSelected(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public void setSelected(Option option) throws AlreadySelectedException\n{\nif (option == null)\n{\n// reset the option previously selected\nselected = null;\nreturn;\n}\n\n// if no option has already been selected or the\n// same option is being reselected then set the\n// selected member variable\nif (selected == null || selected.equals(option.getKey()))\n{\nselected = option.getKey();\n}\nelse\n{\nthrow new AlreadySelectedException(this, option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getSelected()Ljava/lang/String;",
                                    "method_body": "public String getSelected()\n{\nreturn selected;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AlreadySelectedException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public AlreadySelectedException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AlreadySelectedException:<init>(Lorg/apache/commons/cli/OptionGroup;Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public AlreadySelectedException(OptionGroup group, Option option)\n{\nthis(\"The option '\" + option.getKey() + \"' was specified but an option from this group \"\n+ \"has already been selected: '\" + group.getSelected() + \"'\");\nthis.group = group;\nthis.option = option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// if the option is part of a group, check if another option of the group has been selected\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\ncontinue;\n}\n\ncmd.addOption(opt);\nupdateRequiredOptions(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter) throws ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// update the required options and groups\nupdateRequiredOptions(opt);\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:updateRequiredOptions(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void updateRequiredOptions(Option opt) throws ParseException\n{\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.BasicParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\n// just echo the arguments\nreturn arguments;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.GnuParserTest.testPropertyOptionGroup",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOptionGroup(Lorg/apache/commons/cli/OptionGroup;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOptionGroup(OptionGroup group)\n{\nIterator options = group.getOptions().iterator();\n\nif (group.isRequired())\n{\nrequiredOpts.add(group);\n}\n\nwhile (options.hasNext())\n{\nOption option = (Option) options.next();\n\n// an Option cannot be required if it is in an\n// OptionGroup, either the group is required or\n// nothing is required\noption.setRequired(false);\naddOption(option);\n\noptionGroups.put(option.getKey(), group);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup addOption(Option option)\n{\n// key   - option name\n// value - the option\noptionMap.put(option.getKey(), option);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\n// the values are the collection of options\nreturn optionMap.values();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:setSelected(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public void setSelected(Option option) throws AlreadySelectedException\n{\nif (option == null)\n{\n// reset the option previously selected\nselected = null;\nreturn;\n}\n\n// if no option has already been selected or the\n// same option is being reselected then set the\n// selected member variable\nif (selected == null || selected.equals(option.getKey()))\n{\nselected = option.getKey();\n}\nelse\n{\nthrow new AlreadySelectedException(this, option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getSelected()Ljava/lang/String;",
                                    "method_body": "public String getSelected()\n{\nreturn selected;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AlreadySelectedException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public AlreadySelectedException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AlreadySelectedException:<init>(Lorg/apache/commons/cli/OptionGroup;Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public AlreadySelectedException(OptionGroup group, Option option)\n{\nthis(\"The option '\" + option.getKey() + \"' was specified but an option from this group \"\n+ \"has already been selected: '\" + group.getSelected() + \"'\");\nthis.group = group;\nthis.option = option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// if the option is part of a group, check if another option of the group has been selected\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\ncontinue;\n}\n\ncmd.addOption(opt);\nupdateRequiredOptions(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter) throws ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// update the required options and groups\nupdateRequiredOptions(opt);\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:updateRequiredOptions(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void updateRequiredOptions(Option opt) throws ParseException\n{\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.GnuParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\nList tokens = new ArrayList();\n\nboolean eatTheRest = false;\n\nfor (int i = 0; i < arguments.length; i++)\n{\nString arg = arguments[i];\n\nif (\"--\".equals(arg))\n{\neatTheRest = true;\ntokens.add(\"--\");\n}\nelse if (\"-\".equals(arg))\n{\ntokens.add(\"-\");\n}\nelse if (arg.startsWith(\"-\"))\n{\nString opt = Util.stripLeadingHyphens(arg);\n\nif (options.hasOption(opt))\n{\ntokens.add(arg);\n}\nelse\n{\nif (opt.indexOf('=') != -1 && options.hasOption(opt.substring(0, opt.indexOf('='))))\n{\n// the format is --foo=value or -foo=value\ntokens.add(arg.substring(0, arg.indexOf('='))); // --foo\ntokens.add(arg.substring(arg.indexOf('=') + 1)); // value\n}\nelse if (options.hasOption(arg.substring(0, 2)))\n{\n// the format is a special properties option (-Dproperty=value)\ntokens.add(arg.substring(0, 2)); // -D\ntokens.add(arg.substring(2)); // property=value\n}\nelse\n{\neatTheRest = stopAtNonOption;\ntokens.add(arg);\n}\n}\n}\nelse\n{\ntokens.add(arg);\n}\n\nif (eatTheRest)\n{\nfor (i++; i < arguments.length; i++)\n{\ntokens.add(arguments[i]);\n}\n}\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.PosixParserTest.testPropertyOptionUnexpected",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// if the option is part of a group, check if another option of the group has been selected\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\ncontinue;\n}\n\ncmd.addOption(opt);\nupdateRequiredOptions(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nString token = (String) iter.next();\n\n// single or double hyphen\nif (\"-\".equals(token) || \"--\".equals(token))\n{\ntokens.add(token);\n}\n\n// handle long option --foo or --foo=bar\nelse if (token.startsWith(\"--\"))\n{\nint pos = token.indexOf('=');\nString opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\nList matchingOpts = options.getMatchingOptions(opt);\n\nif (matchingOpts.isEmpty())\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\nelse if (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(opt, matchingOpts);\n}\nelse\n{\ncurrentOption = options.getOption((String) matchingOpts.get(0));\n\ntokens.add(\"--\" + currentOption.getLongOpt());\nif (pos != -1)\n{\ntokens.add(token.substring(pos + 1));\n}\n}\n}\n\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2 || options.hasOption(token))\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (!options.getMatchingOptions(token).isEmpty())\n{\nList matchingOpts = options.getMatchingOptions(token);\nif (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(token, matchingOpts);\n}\nelse\n{\nOption opt = options.getOption((String) matchingOpts.get(0));\nprocessOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n}\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.DefaultParserTest.testPropertyOptionUnexpected",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException\n{\nthis.options = options;\nthis.stopAtNonOption = stopAtNonOption;\nskipParsing = false;\ncurrentOption = null;\nexpectedOpts = new ArrayList(options.getRequiredOptions());\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\ncmd = new CommandLine();\n\nif (arguments != null)\n{\nfor (int i = 0; i < arguments.length; i++)\n{\nhandleToken(arguments[i]);\n}\n}\n\n// check the arguments of the last option\ncheckRequiredArgs();\n\n// add the default options\nhandleProperties(properties);\n\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleProperties(Ljava/util/Properties;)V",
                                    "method_body": "private void handleProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = options.getOption(option);\n\n// if the option is part of a group, check if another option of the group has been selected\n\n// get the value from the properties\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\nopt.addValueForProcessing(value);\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the option to the CommandLine\ncontinue;\n}\n\nhandleOption(opt);\ncurrentOption = null;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:checkRequiredArgs()V",
                                    "method_body": "private void checkRequiredArgs() throws ParseException\n{\nif (currentOption != null && currentOption.requiresArg())\n{\nthrow new MissingArgumentException(currentOption);\n}\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.PosixParserTest.testPropertyOptionGroup",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOptionGroup(Lorg/apache/commons/cli/OptionGroup;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOptionGroup(OptionGroup group)\n{\nIterator options = group.getOptions().iterator();\n\nif (group.isRequired())\n{\nrequiredOpts.add(group);\n}\n\nwhile (options.hasNext())\n{\nOption option = (Option) options.next();\n\n// an Option cannot be required if it is in an\n// OptionGroup, either the group is required or\n// nothing is required\noption.setRequired(false);\naddOption(option);\n\noptionGroups.put(option.getKey(), group);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup addOption(Option option)\n{\n// key   - option name\n// value - the option\noptionMap.put(option.getKey(), option);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\n// the values are the collection of options\nreturn optionMap.values();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:setSelected(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public void setSelected(Option option) throws AlreadySelectedException\n{\nif (option == null)\n{\n// reset the option previously selected\nselected = null;\nreturn;\n}\n\n// if no option has already been selected or the\n// same option is being reselected then set the\n// selected member variable\nif (selected == null || selected.equals(option.getKey()))\n{\nselected = option.getKey();\n}\nelse\n{\nthrow new AlreadySelectedException(this, option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getSelected()Ljava/lang/String;",
                                    "method_body": "public String getSelected()\n{\nreturn selected;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AlreadySelectedException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public AlreadySelectedException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AlreadySelectedException:<init>(Lorg/apache/commons/cli/OptionGroup;Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public AlreadySelectedException(OptionGroup group, Option option)\n{\nthis(\"The option '\" + option.getKey() + \"' was specified but an option from this group \"\n+ \"has already been selected: '\" + group.getSelected() + \"'\");\nthis.group = group;\nthis.option = option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// if the option is part of a group, check if another option of the group has been selected\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\ncontinue;\n}\n\ncmd.addOption(opt);\nupdateRequiredOptions(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter) throws ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// update the required options and groups\nupdateRequiredOptions(opt);\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:updateRequiredOptions(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void updateRequiredOptions(Option opt) throws ParseException\n{\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nString token = (String) iter.next();\n\n// single or double hyphen\nif (\"-\".equals(token) || \"--\".equals(token))\n{\ntokens.add(token);\n}\n\n// handle long option --foo or --foo=bar\nelse if (token.startsWith(\"--\"))\n{\nint pos = token.indexOf('=');\nString opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\nList matchingOpts = options.getMatchingOptions(opt);\n\nif (matchingOpts.isEmpty())\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\nelse if (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(opt, matchingOpts);\n}\nelse\n{\ncurrentOption = options.getOption((String) matchingOpts.get(0));\n\ntokens.add(\"--\" + currentOption.getLongOpt());\nif (pos != -1)\n{\ntokens.add(token.substring(pos + 1));\n}\n}\n}\n\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2 || options.hasOption(token))\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (!options.getMatchingOptions(token).isEmpty())\n{\nList matchingOpts = options.getMatchingOptions(token);\nif (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(token, matchingOpts);\n}\nelse\n{\nOption opt = options.getOption((String) matchingOpts.get(0));\nprocessOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n}\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (stopAtNonOption && !options.hasOption(token))\n{\neatTheRest = true;\n}\n\nif (options.hasOption(token))\n{\ncurrentOption = options.getOption(token);\n}\n\ntokens.add(token);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.DefaultParserTest.testPropertyOptionGroup",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException\n{\nthis.options = options;\nthis.stopAtNonOption = stopAtNonOption;\nskipParsing = false;\ncurrentOption = null;\nexpectedOpts = new ArrayList(options.getRequiredOptions());\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\ncmd = new CommandLine();\n\nif (arguments != null)\n{\nfor (int i = 0; i < arguments.length; i++)\n{\nhandleToken(arguments[i]);\n}\n}\n\n// check the arguments of the last option\ncheckRequiredArgs();\n\n// add the default options\nhandleProperties(properties);\n\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleProperties(Ljava/util/Properties;)V",
                                    "method_body": "private void handleProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = options.getOption(option);\n\n// if the option is part of a group, check if another option of the group has been selected\n\n// get the value from the properties\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\nopt.addValueForProcessing(value);\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the option to the CommandLine\ncontinue;\n}\n\nhandleOption(opt);\ncurrentOption = null;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:checkRequiredArgs()V",
                                    "method_body": "private void checkRequiredArgs() throws ParseException\n{\nif (currentOption != null && currentOption.requiresArg())\n{\nthrow new MissingArgumentException(currentOption);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOptionGroup(Lorg/apache/commons/cli/OptionGroup;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOptionGroup(OptionGroup group)\n{\nIterator options = group.getOptions().iterator();\n\nif (group.isRequired())\n{\nrequiredOpts.add(group);\n}\n\nwhile (options.hasNext())\n{\nOption option = (Option) options.next();\n\n// an Option cannot be required if it is in an\n// OptionGroup, either the group is required or\n// nothing is required\noption.setRequired(false);\naddOption(option);\n\noptionGroups.put(option.getKey(), group);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasShortOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasShortOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleToken(Ljava/lang/String;)V",
                                    "method_body": "private void handleToken(String token) throws ParseException\n{\ncurrentToken = token;\n\nif (skipParsing)\n{\ncmd.addArg(token);\n}\nelse if (\"--\".equals(token))\n{\nskipParsing = true;\n}\nelse if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n{\ncurrentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n}\nelse if (token.startsWith(\"--\"))\n{\nhandleLongOption(token);\n}\nelse if (token.startsWith(\"-\") && !\"-\".equals(token))\n{\nhandleShortAndLongOption(token);\n}\nelse\n{\nhandleUnknownToken(token);\n}\n\nif (currentOption != null && !currentOption.acceptsArg())\n{\ncurrentOption = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleShortAndLongOption(Ljava/lang/String;)V",
                                    "method_body": "private void handleShortAndLongOption(String token) throws ParseException\n{\nString t = Util.stripLeadingHyphens(token);\n\nint pos = t.indexOf('=');\n\nif (t.length() == 1)\n{\n// -S\nif (options.hasShortOption(t))\n{\nhandleOption(options.getOption(t));\n}\nelse\n{\nhandleUnknownToken(token);\n}\n}\nelse if (pos == -1)\n{\nif (options.hasShortOption(t))\n{\nhandleOption(options.getOption(t));\n}\nelse if (!options.getMatchingOptions(t).isEmpty())\n{\n// -L or -l\nhandleLongOptionWithoutEqual(token);\n}\nelse\n{\n// look for a long prefix (-Xmx512m)\nString opt = getLongPrefix(t);\n\nif (opt != null && options.getOption(opt).acceptsArg())\n{\nhandleOption(options.getOption(opt));\ncurrentOption.addValueForProcessing(t.substring(opt.length()));\ncurrentOption = null;\n}\nelse if (isJavaProperty(t))\n{\n// -SV1 (-Dflag)\nhandleOption(options.getOption(t.substring(0, 1)));\ncurrentOption.addValueForProcessing(t.substring(1));\ncurrentOption = null;\n}\nelse\n{\n// -S1S2S3 or -S1S2V\nhandleConcatenatedOptions(token);\n}\n}\n}\nelse\n{\nString opt = t.substring(0, pos);\nString value = t.substring(pos + 1);\n\nif (opt.length() == 1)\n{\n// -S=V\nOption option = options.getOption(opt);\nif (option != null && option.acceptsArg())\n{\nhandleOption(option);\ncurrentOption.addValueForProcessing(value);\ncurrentOption = null;\n}\nelse\n{\nhandleUnknownToken(token);\n}\n}\nelse if (isJavaProperty(opt))\n{\n// -SV1=V2 (-Dkey=value)\nhandleOption(options.getOption(opt.substring(0, 1)));\ncurrentOption.addValueForProcessing(opt.substring(1));\ncurrentOption.addValueForProcessing(value);\ncurrentOption = null;\n}\nelse\n{\n// -L=V or -l=V\nhandleLongOptionWithEqual(token);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void handleOption(Option option) throws ParseException\n{\n// check the previous option before handling the next one\ncheckRequiredArgs();\n\noption = (Option) option.clone();\n\nupdateRequiredOptions(option);\n\ncmd.addOption(option);\n\nif (option.hasArg())\n{\ncurrentOption = option;\n}\nelse\n{\ncurrentOption = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:updateRequiredOptions(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void updateRequiredOptions(Option option) throws AlreadySelectedException\n{\nif (option.isRequired())\n{\nexpectedOpts.remove(option.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected option of the group\nif (options.getOptionGroup(option) != null)\n{\nOptionGroup group = options.getOptionGroup(option);\n\nif (group.isRequired())\n{\nexpectedOpts.remove(group);\n}\n\ngroup.setSelected(option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup addOption(Option option)\n{\n// key   - option name\n// value - the option\noptionMap.put(option.getKey(), option);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\n// the values are the collection of options\nreturn optionMap.values();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:setSelected(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public void setSelected(Option option) throws AlreadySelectedException\n{\nif (option == null)\n{\n// reset the option previously selected\nselected = null;\nreturn;\n}\n\n// if no option has already been selected or the\n// same option is being reselected then set the\n// selected member variable\nif (selected == null || selected.equals(option.getKey()))\n{\nselected = option.getKey();\n}\nelse\n{\nthrow new AlreadySelectedException(this, option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getSelected()Ljava/lang/String;",
                                    "method_body": "public String getSelected()\n{\nreturn selected;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AlreadySelectedException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public AlreadySelectedException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AlreadySelectedException:<init>(Lorg/apache/commons/cli/OptionGroup;Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public AlreadySelectedException(OptionGroup group, Option option)\n{\nthis(\"The option '\" + option.getKey() + \"' was specified but an option from this group \"\n+ \"has already been selected: '\" + group.getSelected() + \"'\");\nthis.group = group;\nthis.option = option;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.OptionGroupTest.testTwoOptionsFromGroupWithProperties",
                            "test_body": "public void testTwoOptionsFromGroupWithProperties() throws Exception\n{\nString[] args = new String[] { \"-f\" };\nProperties properties = new Properties();\nproperties.put(\"d\", \"true\");\nCommandLine cl = parser.parse( _options, args, properties);\nassertTrue(cl.hasOption(\"f\"));\nassertTrue(!cl.hasOption(\"d\"));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOptionGroup(Lorg/apache/commons/cli/OptionGroup;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOptionGroup(OptionGroup group)\n{\nIterator options = group.getOptions().iterator();\n\nif (group.isRequired())\n{\nrequiredOpts.add(group);\n}\n\nwhile (options.hasNext())\n{\nOption option = (Option) options.next();\n\n// an Option cannot be required if it is in an\n// OptionGroup, either the group is required or\n// nothing is required\noption.setRequired(false);\naddOption(option);\n\noptionGroups.put(option.getKey(), group);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup addOption(Option option)\n{\n// key   - option name\n// value - the option\noptionMap.put(option.getKey(), option);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\n// the values are the collection of options\nreturn optionMap.values();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:setSelected(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public void setSelected(Option option) throws AlreadySelectedException\n{\nif (option == null)\n{\n// reset the option previously selected\nselected = null;\nreturn;\n}\n\n// if no option has already been selected or the\n// same option is being reselected then set the\n// selected member variable\nif (selected == null || selected.equals(option.getKey()))\n{\nselected = option.getKey();\n}\nelse\n{\nthrow new AlreadySelectedException(this, option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getSelected()Ljava/lang/String;",
                                    "method_body": "public String getSelected()\n{\nreturn selected;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AlreadySelectedException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public AlreadySelectedException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AlreadySelectedException:<init>(Lorg/apache/commons/cli/OptionGroup;Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "public AlreadySelectedException(OptionGroup group, Option option)\n{\nthis(\"The option '\" + option.getKey() + \"' was specified but an option from this group \"\n+ \"has already been selected: '\" + group.getSelected() + \"'\");\nthis.group = group;\nthis.option = option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// if the option is part of a group, check if another option of the group has been selected\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\ncontinue;\n}\n\ncmd.addOption(opt);\nupdateRequiredOptions(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(String arg, ListIterator iter) throws ParseException\n{\nboolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognisedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nOption opt = (Option) getOptions().getOption(arg).clone();\n\n// update the required options and groups\nupdateRequiredOptions(opt);\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:updateRequiredOptions(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void updateRequiredOptions(Option opt) throws ParseException\n{\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nOptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption) throws ParseException\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nString token = (String) iter.next();\n\n// single or double hyphen\nif (\"-\".equals(token) || \"--\".equals(token))\n{\ntokens.add(token);\n}\n\n// handle long option --foo or --foo=bar\nelse if (token.startsWith(\"--\"))\n{\nint pos = token.indexOf('=');\nString opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\nList matchingOpts = options.getMatchingOptions(opt);\n\nif (matchingOpts.isEmpty())\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\nelse if (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(opt, matchingOpts);\n}\nelse\n{\ncurrentOption = options.getOption((String) matchingOpts.get(0));\n\ntokens.add(\"--\" + currentOption.getLongOpt());\nif (pos != -1)\n{\ntokens.add(token.substring(pos + 1));\n}\n}\n}\n\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2 || options.hasOption(token))\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (!options.getMatchingOptions(token).isEmpty())\n{\nList matchingOpts = options.getMatchingOptions(token);\nif (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(token, matchingOpts);\n}\nelse\n{\nOption opt = options.getOption((String) matchingOpts.get(0));\nprocessOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n}\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(Iterator iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(String token, boolean stopAtNonOption)\n{\nif (stopAtNonOption && !options.hasOption(token))\n{\neatTheRest = true;\n}\n\nif (options.hasOption(token))\n{\ncurrentOption = options.getOption(token);\n}\n\ntokens.add(token);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.BasicParserTest.testPropertyOptionUnexpected",
                            "test_body": null,
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();)\n{\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = getOptions().getOption(option);\n\n// if the option is part of a group, check if another option of the group has been selected\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\ncontinue;\n}\n\ncmd.addOption(opt);\nupdateRequiredOptions(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.BasicParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(Options options, String[] arguments, boolean stopAtNonOption)\n{\n// just echo the arguments\nreturn arguments;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 31,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.HelpFormatterTest.testDefaultArgName",
                            "test_body": "public void testDefaultArgName()\n{\nOption option = OptionBuilder.hasArg().isRequired().create(\"f\");\nOptions options = new Options();\noptions.addOption(option);\nStringWriter out = new StringWriter();\nHelpFormatter formatter = new HelpFormatter();\nformatter.setArgName(\"argument\");\nformatter.printUsage(new PrintWriter(out), 80, \"app\", options);\nassertEquals(\"usage: app -f <argument>\" + EOL, out.toString());\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\nreturn Collections.unmodifiableCollection(helpOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Object type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\nstatic\n{\n// ensure the consistency of the initial values\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = \"arg\";\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:isRequired()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder isRequired()\n{\nOptionBuilder.required = true;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt) throws IllegalArgumentException\n{\nOption option = null;\ntry\n{\n// create the option\noption = new Option(opt, description);\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n}\nfinally\n{\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n}\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Object;)V",
                                    "method_body": "public void setType(Object type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getArgName()Ljava/lang/String;",
                                    "method_body": "public String getArgName()\n{\nreturn argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArgName()Z",
                                    "method_body": "public boolean hasArgName()\n{\nreturn argName != null && argName.length() > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String name)\n{\nthis.defaultArgName = name;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:getOptionComparator()Ljava/util/Comparator;",
                                    "method_body": "public Comparator getOptionComparator()\n{\nreturn optionComparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printUsage(Ljava/io/PrintWriter;ILjava/lang/String;Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "public void printUsage(PrintWriter pw, int width, String app, Options options)\n{\n// initialise the string buffer\nStringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n// create a list for processed option groups\nfinal Collection processedGroups = new ArrayList();\n\n// temp variable\nOption option;\n\nList optList = new ArrayList(options.getOptions());\nCollections.sort(optList, getOptionComparator());\n// iterate over the options\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\n// get the next Option\noption = (Option) i.next();\n\n// check if the option is part of an OptionGroup\nOptionGroup group = options.getOptionGroup(option);\n\n// if the option is part of a group\nif (group != null)\n{\n// and if the group has not already been processed\nif (!processedGroups.contains(group))\n{\n// add the group to the processed list\nprocessedGroups.add(group);\n\n\n// add the usage clause\nappendOptionGroup(buff, group);\n}\n\n// otherwise the option was displayed in the group\n// previously so ignore it.\n}\n\n// if the Option is not part of an OptionGroup\nelse\n{\nappendOption(buff, option, option.isRequired());\n}\n\nif (i.hasNext())\n{\nbuff.append(\" \");\n}\n}\n\n\n// call printWrapped\nprintWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:appendOption(Ljava/lang/StringBuffer;Lorg/apache/commons/cli/Option;Z)V",
                                    "method_body": "private void appendOption(final StringBuffer buff, final Option option, final boolean required)\n{\nif (!required)\n{\nbuff.append(\"[\");\n}\n\nif (option.getOpt() != null)\n{\nbuff.append(\"-\").append(option.getOpt());\n}\nelse\n{\nbuff.append(\"--\").append(option.getLongOpt());\n}\n\n// if the Option has a value and a non blank argname\nif (option.hasArg() && option.hasArgName())\n{\nbuff.append(option.getOpt() == null ? longOptSeparator : \" \");\nbuff.append(\"<\").append(option.getArgName()).append(\">\");\n}\n\n// if the Option is not a required option\nif (!required)\n{\nbuff.append(\"]\");\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printWrapped(Ljava/io/PrintWriter;IILjava/lang/String;)V",
                                    "method_body": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n{\nStringBuffer sb = new StringBuffer(text.length());\n\nrenderWrappedText(sb, width, nextLineTabStop, text);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderWrappedText(Ljava/lang/StringBuffer;IILjava/lang/String;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderWrappedText(StringBuffer sb, int width,\nint nextLineTabStop, String text)\n{\nint pos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(rtrim(text));\n\nreturn sb;\n}\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\nif (nextLineTabStop >= width)\n{\n// stops infinite loop happening\nnextLineTabStop = 1;\n}\n\n// all following lines must be padded with nextLineTabStop space\n// characters\nfinal String padding = createPadding(nextLineTabStop);\n\nwhile (true)\n{\ntext = padding + text.substring(pos).trim();\npos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(text);\n\nreturn sb;\n}\n\nif ((text.length() > width) && (pos == nextLineTabStop - 1))\n{\npos = width;\n}\n\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:findWrapPos(Ljava/lang/String;II)I",
                                    "method_body": "protected int findWrapPos(String text, int width, int startPos)\n{\nint pos = -1;\n\n// the line ends before the max wrap pos or a new line char found\nif (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n|| ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n{\nreturn pos + 1;\n}\nelse if (startPos + width >= text.length())\n{\nreturn -1;\n}\n\n\n// look for the last whitespace character before startPos+width\npos = startPos + width;\n\nchar c;\n\nwhile ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n--pos;\n}\n\n// if we found it - just return\nif (pos > startPos)\n{\nreturn pos;\n}\n\n// must look for the first whitespace chearacter after startPos\n// + width\npos = startPos + width;\n\nwhile ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n++pos;\n}\n\nreturn (pos == text.length()) ? (-1) : pos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:rtrim(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "protected String rtrim(String s)\n{\nif ((s == null) || (s.length() == 0))\n{\nreturn s;\n}\n\nint pos = s.length();\n\nwhile ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n{\n--pos;\n}\n\nreturn s.substring(0, pos);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 32,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.HelpFormatterTest.testFindWrapPos",
                            "test_body": "public void testFindWrapPos() throws Exception\n{\nHelpFormatter hf = new HelpFormatter();\nString text = \"This is a test.\";\n// text width should be max 8; the wrap position is 7\nassertEquals(\"wrap position\", 7, hf.findWrapPos(text, 8, 0));\n// starting from 8 must give -1 - the wrap pos is after end\nassertEquals(\"wrap position 2\", -1, hf.findWrapPos(text, 8, 8));\n// words longer than the width are cut\ntext = \"aaaa aa\";\nassertEquals(\"wrap position 3\", 3, hf.findWrapPos(text, 3, 0));\n// last word length is equal to the width\ntext = \"aaaaaa aaaaaa\";\nassertEquals(\"wrap position 4\", 6, hf.findWrapPos(text, 6, 0));\nassertEquals(\"wrap position 4\", -1, hf.findWrapPos(text, 6, 7));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:findWrapPos(Ljava/lang/String;II)I",
                                    "method_body": "protected int findWrapPos(String text, int width, int startPos)\n{\nint pos;\n\n// the line ends before the max wrap pos or a new line char found\nif (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n|| ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n{\nreturn pos + 1;\n}\nelse if (startPos + width >= text.length())\n{\nreturn -1;\n}\n\n\n// look for the last whitespace character before startPos+width\npos = startPos + width;\n\nchar c;\n\nwhile ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n--pos;\n}\n\n// if we found it - just return\nif (pos > startPos)\n{\nreturn pos;\n}\n\n// if we didn't find one, simply chop at startPos+width\npos = startPos + width;\nwhile ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n++pos;\n}\nreturn pos == text.length() ? -1 : pos;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.HelpFormatterTest.testRenderWrappedTextWordCut",
                            "test_body": "public void testRenderWrappedTextWordCut()\n{\nint width = 7;\nint padding = 0;\nString text = \"Thisisatest.\";\nString expected = \"Thisisa\" + EOL + \n\"test.\";\nStringBuffer sb = new StringBuffer();\nnew HelpFormatter().renderWrappedText(sb, width, padding, text);\nassertEquals(\"cut and wrap\", expected, sb.toString());\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:findWrapPos(Ljava/lang/String;II)I",
                                    "method_body": "protected int findWrapPos(String text, int width, int startPos)\n{\nint pos;\n\n// the line ends before the max wrap pos or a new line char found\nif (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n|| ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n{\nreturn pos + 1;\n}\nelse if (startPos + width >= text.length())\n{\nreturn -1;\n}\n\n\n// look for the last whitespace character before startPos+width\npos = startPos + width;\n\nchar c;\n\nwhile ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n--pos;\n}\n\n// if we found it - just return\nif (pos > startPos)\n{\nreturn pos;\n}\n\n// if we didn't find one, simply chop at startPos+width\npos = startPos + width;\nwhile ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n++pos;\n}\nreturn pos == text.length() ? -1 : pos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderWrappedText(Ljava/lang/StringBuffer;IILjava/lang/String;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderWrappedText(StringBuffer sb, int width,\nint nextLineTabStop, String text)\n{\nint pos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(rtrim(text));\n\nreturn sb;\n}\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\nif (nextLineTabStop >= width)\n{\n// stops infinite loop happening\nnextLineTabStop = 1;\n}\n\n// all following lines must be padded with nextLineTabStop space characters\nfinal String padding = createPadding(nextLineTabStop);\n\nwhile (true)\n{\ntext = padding + text.substring(pos).trim();\npos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(text);\n\nreturn sb;\n}\n\nif ((text.length() > width) && (pos == nextLineTabStop - 1))\n{\npos = width;\n}\n\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n}\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 33,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.HelpFormatterTest.testIndentedHeaderAndFooter",
                            "test_body": "public void testIndentedHeaderAndFooter()\n{\n// related to CLI-207\nOptions options = new Options();\nHelpFormatter formatter = new HelpFormatter();\nString header = \"  Header1\\n  Header2\";\nString footer = \"  Footer1\\n  Footer2\";\nStringWriter out = new StringWriter();\nformatter.printHelp(new PrintWriter(out), 80, \"foobar\", header, options, 2, 2, footer, true);\nassertEquals(\n\"usage: foobar\" + EOL +\n\"  Header1\" + EOL +\n\"  Header2\" + EOL +\n\"\" + EOL +\n\"  Footer1\" + EOL +\n\"  Footer2\" + EOL\n, out.toString());\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection getOptions()\n{\nreturn Collections.unmodifiableCollection(helpOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List helpOptions()\n{\nreturn new ArrayList(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:getOptionComparator()Ljava/util/Comparator;",
                                    "method_body": "public Comparator getOptionComparator()\n{\nreturn optionComparator;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printHelp(Ljava/io/PrintWriter;ILjava/lang/String;Ljava/lang/String;Lorg/apache/commons/cli/Options;IILjava/lang/String;Z)V",
                                    "method_body": "public void printHelp(PrintWriter pw, int width, String cmdLineSyntax,\nString header, Options options, int leftPad,\nint descPad, String footer, boolean autoUsage)\n{\nif ((cmdLineSyntax == null) || (cmdLineSyntax.length() == 0))\n{\nthrow new IllegalArgumentException(\"cmdLineSyntax not provided\");\n}\n\nif (autoUsage)\n{\nprintUsage(pw, width, cmdLineSyntax, options);\n}\nelse\n{\nprintUsage(pw, width, cmdLineSyntax);\n}\n\nif ((header != null) && (header.trim().length() > 0))\n{\nprintWrapped(pw, width, header);\n}\n\nprintOptions(pw, width, options, leftPad, descPad);\n\nif ((footer != null) && (footer.trim().length() > 0))\n{\nprintWrapped(pw, width, footer);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printUsage(Ljava/io/PrintWriter;ILjava/lang/String;Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "public void printUsage(PrintWriter pw, int width, String app, Options options)\n{\n// initialise the string buffer\nStringBuffer buff = new StringBuffer(defaultSyntaxPrefix).append(app).append(\" \");\n\n// create a list for processed option groups\nfinal Collection processedGroups = new ArrayList();\n\n// temp variable\nOption option;\n\nList optList = new ArrayList(options.getOptions());\nCollections.sort(optList, getOptionComparator());\n// iterate over the options\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\n// get the next Option\noption = (Option) i.next();\n\n// check if the option is part of an OptionGroup\nOptionGroup group = options.getOptionGroup(option);\n\n// if the option is part of a group\nif (group != null)\n{\n// and if the group has not already been processed\nif (!processedGroups.contains(group))\n{\n// add the group to the processed list\nprocessedGroups.add(group);\n\n\n// add the usage clause\nappendOptionGroup(buff, group);\n}\n\n// otherwise the option was displayed in the group\n// previously so ignore it.\n}\n\n// if the Option is not part of an OptionGroup\nelse\n{\nappendOption(buff, option, option.isRequired());\n}\n\nif (i.hasNext())\n{\nbuff.append(\" \");\n}\n}\n\n\n// call printWrapped\nprintWrapped(pw, width, buff.toString().indexOf(' ') + 1, buff.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printOptions(Ljava/io/PrintWriter;ILorg/apache/commons/cli/Options;II)V",
                                    "method_body": "public void printOptions(PrintWriter pw, int width, Options options,\nint leftPad, int descPad)\n{\nStringBuffer sb = new StringBuffer();\n\nrenderOptions(sb, width, options, leftPad, descPad);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printWrapped(Ljava/io/PrintWriter;ILjava/lang/String;)V",
                                    "method_body": "public void printWrapped(PrintWriter pw, int width, String text)\n{\nprintWrapped(pw, width, 0, text);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:printWrapped(Ljava/io/PrintWriter;IILjava/lang/String;)V",
                                    "method_body": "public void printWrapped(PrintWriter pw, int width, int nextLineTabStop, String text)\n{\nStringBuffer sb = new StringBuffer(text.length());\n\nrenderWrappedText(sb, width, nextLineTabStop, text);\npw.println(sb.toString());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderOptions(Ljava/lang/StringBuffer;ILorg/apache/commons/cli/Options;II)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderOptions(StringBuffer sb, int width, Options options, int leftPad, int descPad)\n{\nfinal String lpad = createPadding(leftPad);\nfinal String dpad = createPadding(descPad);\n\n// first create list containing only <lpad>-a,--aaa where\n// -a is opt and --aaa is long opt; in parallel look for\n// the longest opt string this list will be then used to\n// sort options ascending\nint max = 0;\nStringBuffer optBuf;\nList prefixList = new ArrayList();\n\nList optList = options.helpOptions();\n\nCollections.sort(optList, getOptionComparator());\n\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\nOption option = (Option) i.next();\noptBuf = new StringBuffer();\n\nif (option.getOpt() == null)\n{\noptBuf.append(lpad).append(\"   \" + defaultLongOptPrefix).append(option.getLongOpt());\n}\nelse\n{\noptBuf.append(lpad).append(defaultOptPrefix).append(option.getOpt());\n\nif (option.hasLongOpt())\n{\noptBuf.append(',').append(defaultLongOptPrefix).append(option.getLongOpt());\n}\n}\n\nif (option.hasArg())\n{\nString argName = option.getArgName();\nif (argName != null && argName.length() == 0)\n{\n// if the option has a blank argname\noptBuf.append(' ');\n}\nelse\n{\noptBuf.append(option.hasLongOpt() ? longOptSeparator : \" \");\noptBuf.append(\"<\").append(argName != null ? option.getArgName() : getArgName()).append(\">\");\n}\n}\n\nprefixList.add(optBuf);\nmax = (optBuf.length() > max) ? optBuf.length() : max;\n}\n\nint x = 0;\n\nfor (Iterator i = optList.iterator(); i.hasNext();)\n{\nOption option = (Option) i.next();\noptBuf = new StringBuffer(prefixList.get(x++).toString());\n\nif (optBuf.length() < max)\n{\noptBuf.append(createPadding(max - optBuf.length()));\n}\n\noptBuf.append(dpad);\n\nint nextLineTabStop = max + descPad;\n\nif (option.getDescription() != null)\n{\noptBuf.append(option.getDescription());\n}\n\nrenderWrappedText(sb, width, nextLineTabStop, optBuf.toString());\n\nif (i.hasNext())\n{\nsb.append(defaultNewLine);\n}\n}\n\nreturn sb;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:renderWrappedText(Ljava/lang/StringBuffer;IILjava/lang/String;)Ljava/lang/StringBuffer;",
                                    "method_body": "protected StringBuffer renderWrappedText(StringBuffer sb, int width,\nint nextLineTabStop, String text)\n{\nint pos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(rtrim(text));\n\nreturn sb;\n}\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n\nif (nextLineTabStop >= width)\n{\n// stops infinite loop happening\nnextLineTabStop = 1;\n}\n\n// all following lines must be padded with nextLineTabStop space characters\nfinal String padding = createPadding(nextLineTabStop);\n\nwhile (true)\n{\ntext = padding + text.substring(pos).trim();\npos = findWrapPos(text, width, 0);\n\nif (pos == -1)\n{\nsb.append(text);\n\nreturn sb;\n}\n\nif ((text.length() > width) && (pos == nextLineTabStop - 1))\n{\npos = width;\n}\n\nsb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:findWrapPos(Ljava/lang/String;II)I",
                                    "method_body": "protected int findWrapPos(String text, int width, int startPos)\n{\nint pos;\n\n// the line ends before the max wrap pos or a new line char found\nif (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n|| ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n{\nreturn pos + 1;\n}\nelse if (startPos + width >= text.length())\n{\nreturn -1;\n}\n\n\n// look for the last whitespace character before startPos+width\npos = startPos + width;\n\nchar c;\n\nwhile ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n&& (c != '\\n') && (c != '\\r'))\n{\n--pos;\n}\n\n// if we found it - just return\nif (pos > startPos)\n{\nreturn pos;\n}\n\n// if we didn't find one, simply chop at startPos+width\npos = startPos + width;\n\nreturn pos == text.length() ? -1 : pos;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:createPadding(I)Ljava/lang/String;",
                                    "method_body": "protected String createPadding(int len)\n{\nchar[] padding = new char[len];\nArrays.fill(padding, ' ');\n\nreturn new String(padding);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.HelpFormatter:rtrim(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "protected String rtrim(String s)\n{\nif ((s == null) || (s.length() == 0))\n{\nreturn s;\n}\n\nint pos = s.length();\n\nwhile ((pos > 0) && Character.isWhitespace(s.charAt(pos - 1)))\n{\n--pos;\n}\n\nreturn s.substring(0, pos);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 34,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.CommandLineTest.testGetParsedOptionValue",
                            "test_body": "public void testGetParsedOptionValue() throws Exception {\nOptions options = new Options();\noptions.addOption(OptionBuilder.hasArg().withType(Number.class).create(\"i\"));\noptions.addOption(OptionBuilder.hasArg().create(\"f\"));\nCommandLineParser parser = new DefaultParser();\nCommandLine cmd = parser.parse(options, new String[] { \"-i\", \"123\", \"-f\", \"foo\" });\nassertEquals(123, ((Number) cmd.getParsedOptionValue(\"i\")).intValue());\nassertEquals(\"foo\", cmd.getParsedOptionValue(\"f\"));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nint length = str.length();\nif (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\n{\nstr = str.substring(1, length - 1);\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection getOptionGroups()\n{\nreturn new HashSet(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn (Option) shortOpts.get(opt);\n}\n\nreturn (Option) longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasShortOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasShortOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn (OptionGroup) optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Class type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\nstatic\n{\n// ensure the consistency of the initial values\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = null;\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withType(Ljava/lang/Class;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withType(Class newType)\n{\nOptionBuilder.type = newType;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt) throws IllegalArgumentException\n{\nOption option = null;\ntry\n{\n// create the option\noption = new Option(opt, description);\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n}\nfinally\n{\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n}\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn longOpt;\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getType()Ljava/lang/Object;",
                                    "method_body": "public Object getType()\n{\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Class;)V",
                                    "method_body": "public void setType(Class type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn valuesep > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
                                    "method_body": "void addValueForProcessing(String value)\n{\nswitch (numberOfArgs)\n{\ncase UNINITIALIZED:\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n\ndefault:\nprocessValue(value);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == (numberOfArgs - 1))\n{\nbreak;\n}\n\n// store\nadd(value.substring(0, index));\n\n// parse\nvalue = value.substring(index + 1);\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif (!acceptsArg())\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n// store value\nvalues.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValuesList()Ljava/util/List;",
                                    "method_body": "public List getValuesList()\n{\nreturn values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:acceptsArg()Z",
                                    "method_body": "boolean acceptsArg()\n{\nreturn (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "protected CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getParsedOptionValue(Ljava/lang/String;)Ljava/lang/Object;",
                                    "method_body": "public Object getParsedOptionValue(String opt) throws ParseException\n{\nString res = getOptionValue(opt);\nOption option = resolveOption(opt);\n\nif (option == null || res == null)\n{\nreturn null;\n}\n\nreturn TypeHandler.createValue(res, option.getType());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(String opt)\n{\nString[] values = getOptionValues(opt);\n\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Ljava/lang/String;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(String opt)\n{\nList values = new ArrayList();\n\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n{\nvalues.addAll(option.getValuesList());\n}\n}\n\nreturn values.isEmpty() ? null : (String[]) values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Iterator it = options.iterator(); it.hasNext();)\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "protected void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments) throws ParseException\n{\nreturn parse(options, arguments, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption) throws ParseException\n{\nthis.options = options;\nthis.stopAtNonOption = stopAtNonOption;\nskipParsing = false;\ncurrentOption = null;\nexpectedOpts = new ArrayList(options.getRequiredOptions());\n\n// clear the data from the groups\nfor (Iterator it = options.getOptionGroups().iterator(); it.hasNext();)\n{\nOptionGroup group = (OptionGroup) it.next();\ngroup.setSelected(null);\n}\n\ncmd = new CommandLine();\n\nif (arguments != null)\n{\nfor (int i = 0; i < arguments.length; i++)\n{\nhandleToken(arguments[i]);\n}\n}\n\n// check the arguments of the last option\ncheckRequiredArgs();\n\n// add the default options\nhandleProperties(properties);\n\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleProperties(Ljava/util/Properties;)V",
                                    "method_body": "private void handleProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nOption opt = options.getOption(option);\nif (opt == null)\n{\nthrow new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n}\n\n// if the option is part of a group, check if another option of the group has been selected\nOptionGroup group = options.getOptionGroup(opt);\nboolean selected = group != null && group.getSelected() != null;\n\nif (!cmd.hasOption(option) && !selected)\n{\n// get the value from the properties\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\nopt.addValueForProcessing(value);\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the option to the CommandLine\ncontinue;\n}\n\nhandleOption(opt);\ncurrentOption = null;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:checkRequiredOptions()V",
                                    "method_body": "private void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processsed\nif (!expectedOpts.isEmpty())\n{\nthrow new MissingOptionException(expectedOpts);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:checkRequiredArgs()V",
                                    "method_body": "private void checkRequiredArgs() throws ParseException\n{\nif (currentOption != null && currentOption.requiresArg())\n{\nthrow new MissingArgumentException(currentOption);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleToken(Ljava/lang/String;)V",
                                    "method_body": "private void handleToken(String token) throws ParseException\n{\ncurrentToken = token;\n\nif (skipParsing)\n{\ncmd.addArg(token);\n}\nelse if (\"--\".equals(token))\n{\nskipParsing = true;\n}\nelse if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n{\ncurrentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n}\nelse if (token.startsWith(\"--\"))\n{\nhandleLongOption(token);\n}\nelse if (token.startsWith(\"-\") && !\"-\".equals(token))\n{\nhandleShortAndLongOption(token);\n}\nelse\n{\nhandleUnknownToken(token);\n}\n\nif (currentOption != null && !currentOption.acceptsArg())\n{\ncurrentOption = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isArgument(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isArgument(String token)\n{\nreturn !isOption(token) || isNegativeNumber(token);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isOption(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isOption(String token)\n{\nreturn isLongOption(token) || isShortOption(token);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isShortOption(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isShortOption(String token)\n{\n// short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\nreturn token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isLongOption(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isLongOption(String token)\n{\nif (!token.startsWith(\"-\") || token.length() == 1)\n{\nreturn false;\n}\n\nint pos = token.indexOf(\"=\");\nString t = pos == -1 ? token : token.substring(0, pos);\n\nif (!options.getMatchingOptions(t).isEmpty())\n{\n// long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\nreturn true;\n}\nelse if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n{\n// -LV\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleShortAndLongOption(Ljava/lang/String;)V",
                                    "method_body": "private void handleShortAndLongOption(String token) throws ParseException\n{\nString t = Util.stripLeadingHyphens(token);\n\nint pos = t.indexOf('=');\n\nif (t.length() == 1)\n{\n// -S\nif (options.hasShortOption(t))\n{\nhandleOption(options.getOption(t));\n}\nelse\n{\nhandleUnknownToken(token);\n}\n}\nelse if (pos == -1)\n{\nif (options.hasShortOption(t))\n{\nhandleOption(options.getOption(t));\n}\nelse if (!options.getMatchingOptions(t).isEmpty())\n{\n// -L or -l\nhandleLongOptionWithoutEqual(token);\n}\nelse\n{\n// look for a long prefix (-Xmx512m)\nString opt = getLongPrefix(t);\n\nif (opt != null && options.getOption(opt).acceptsArg())\n{\nhandleOption(options.getOption(opt));\ncurrentOption.addValueForProcessing(t.substring(opt.length()));\ncurrentOption = null;\n}\nelse if (isJavaProperty(t))\n{\n// -SV1 (-Dflag)\nhandleOption(options.getOption(t.substring(0, 1)));\ncurrentOption.addValueForProcessing(t.substring(1));\ncurrentOption = null;\n}\nelse\n{\n// -S1S2S3 or -S1S2V\nhandleConcatenatedOptions(token);\n}\n}\n}\nelse\n{\nString opt = t.substring(0, pos);\nString value = t.substring(pos + 1);\n\nif (opt.length() == 1)\n{\n// -S=V\nOption option = options.getOption(opt);\nif (option != null && option.acceptsArg())\n{\nhandleOption(option);\ncurrentOption.addValueForProcessing(value);\ncurrentOption = null;\n}\nelse\n{\nhandleUnknownToken(token);\n}\n}\nelse if (isJavaProperty(opt))\n{\n// -SV1=V2 (-Dkey=value)\nhandleOption(options.getOption(opt.substring(0, 1)));\ncurrentOption.addValueForProcessing(opt.substring(1));\ncurrentOption.addValueForProcessing(value);\ncurrentOption = null;\n}\nelse\n{\n// -L=V or -l=V\nhandleLongOptionWithEqual(token);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void handleOption(Option option) throws ParseException\n{\n// check the previous option before handling the next one\ncheckRequiredArgs();\n\noption = (Option) option.clone();\n\nupdateRequiredOptions(option);\n\ncmd.addOption(option);\n\nif (option.hasArg())\n{\ncurrentOption = option;\n}\nelse\n{\ncurrentOption = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:updateRequiredOptions(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void updateRequiredOptions(Option option) throws AlreadySelectedException\n{\nif (option.isRequired())\n{\nexpectedOpts.remove(option.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected option of the group\nif (options.getOptionGroup(option) != null)\n{\nOptionGroup group = options.getOptionGroup(option);\n\nif (group.isRequired())\n{\nexpectedOpts.remove(group);\n}\n\ngroup.setSelected(option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createValue(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static Object createValue(String str, Object obj) throws ParseException\n{\nreturn createValue(str, (Class) obj);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createValue(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public static Object createValue(String str, Class clazz) throws ParseException\n{\nif (PatternOptionBuilder.STRING_VALUE == clazz)\n{\nreturn str;\n}\nelse if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n{\nreturn createObject(str);\n}\nelse if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n{\nreturn createNumber(str);\n}\nelse if (PatternOptionBuilder.DATE_VALUE == clazz)\n{\nreturn createDate(str);\n}\nelse if (PatternOptionBuilder.CLASS_VALUE == clazz)\n{\nreturn createClass(str);\n}\nelse if (PatternOptionBuilder.FILE_VALUE == clazz)\n{\nreturn createFile(str);\n}\nelse if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n{\nreturn createFile(str);\n}\nelse if (PatternOptionBuilder.FILES_VALUE == clazz)\n{\nreturn createFiles(str);\n}\nelse if (PatternOptionBuilder.URL_VALUE == clazz)\n{\nreturn createURL(str);\n}\nelse\n{\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createNumber(Ljava/lang/String;)Ljava/lang/Number;",
                                    "method_body": "public static Number createNumber(String str) throws ParseException\n{\ntry\n{\nif (str.indexOf('.') != -1)\n{\nreturn Double.valueOf(str);\n}\nelse\n{\nreturn Long.valueOf(str);\n}\n}\ncatch (NumberFormatException e)\n{\nthrow new ParseException(e.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:<clinit>()V",
                                    "method_body": "public static final Class STRING_VALUE = String.class;\n\n/** Object class */\npublic static final Class OBJECT_VALUE = Object.class;\n\n/** Number class */\npublic static final Class NUMBER_VALUE = Number.class;\n\n/** Date class */\npublic static final Class DATE_VALUE = Date.class;\n\n/** Class class */\npublic static final Class CLASS_VALUE = Class.class;\n\n/// can we do this one??\n// is meant to check that the file exists, else it errors.\n// ie) it's for reading not writing.\n\n/** FileInputStream class */\npublic static final Class EXISTING_FILE_VALUE = FileInputStream.class;\n\n/** File class */\npublic static final Class FILE_VALUE = File.class;\n\n/** File array class */\npublic static final Class FILES_VALUE = File[].class;\n\n/** URL class */\npublic static final Class URL_VALUE = URL.class;\n\n/**\n* Retrieve the class that <code>ch</code> represents.\n*\n* @param ch the specified character\n* @return The class that <code>ch</code> represents\n*/\npublic static Class getValueClass(char ch)\n{\nswitch (ch)\n{\ncase '@':\nreturn PatternOptionBuilder.OBJECT_VALUE;\ncase ':':\nreturn PatternOptionBuilder.STRING_VALUE;\ncase '%':\nreturn PatternOptionBuilder.NUMBER_VALUE;\ncase '+':\nreturn PatternOptionBuilder.CLASS_VALUE;\ncase '#':\nreturn PatternOptionBuilder.DATE_VALUE;\ncase '<':\nreturn PatternOptionBuilder.EXISTING_FILE_VALUE;\ncase '>':\nreturn PatternOptionBuilder.FILE_VALUE;\ncase '*':\nreturn PatternOptionBuilder.FILES_VALUE;\ncase '/':\nreturn PatternOptionBuilder.URL_VALUE;\n}\n\nreturn null;\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.OptionBuilderTest.testTwoCompleteOptions",
                            "test_body": "public void testTwoCompleteOptions( ) {\nOption simple = OptionBuilder.withLongOpt( \"simple option\")\n.hasArg( )\n.isRequired( )\n.hasArgs( )\n.withType( Float.class )\n.withDescription( \"this is a simple option\" )\n.create( 's' );\nassertEquals( \"s\", simple.getOpt() );\nassertEquals( \"simple option\", simple.getLongOpt() );\nassertEquals( \"this is a simple option\", simple.getDescription() );\nassertEquals( simple.getType(), Float.class );\nassertTrue( simple.hasArg() );\nassertTrue( simple.isRequired() );\nassertTrue( simple.hasArgs() );\nsimple = OptionBuilder.withLongOpt( \"dimple option\")\n.hasArg( )\n.withDescription( \"this is a dimple option\" )\n.create( 'd' );\nassertEquals( \"d\", simple.getOpt() );\nassertEquals( \"dimple option\", simple.getLongOpt() );\nassertEquals( \"this is a dimple option\", simple.getDescription() );\nassertEquals( String.class, simple.getType() );\nassertTrue( simple.hasArg() );\nassertTrue( !simple.isRequired() );\nassertTrue( !simple.hasArgs() );\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<init>()V",
                                    "method_body": "private OptionBuilder()\n{\n// hide the constructor\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:<clinit>()V",
                                    "method_body": "private static String longopt;\n\n/** option description */\nprivate static String description;\n\n/** argument name */\nprivate static String argName;\n\n/** is required? */\nprivate static boolean required;\n\n/** the number of arguments */\nprivate static int numberOfArgs = Option.UNINITIALIZED;\n\n/** option type */\nprivate static Class type;\n\n/** option can have an optional argument value */\nprivate static boolean optionalArg;\n\n/** value separator for argument value */\nprivate static char valuesep;\n\n/** option builder instance */\nprivate static OptionBuilder instance = new OptionBuilder();\n\nstatic\n{\n// ensure the consistency of the initial values\nreset();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:reset()V",
                                    "method_body": "private static void reset()\n{\ndescription = null;\nargName = null;\nlongopt = null;\ntype = null;\nrequired = false;\nnumberOfArgs = Option.UNINITIALIZED;\noptionalArg = false;\nvaluesep = (char) 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArg()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArg()\n{\nOptionBuilder.numberOfArgs = 1;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withType(Ljava/lang/Class;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withType(Class newType)\n{\nOptionBuilder.type = newType;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(String opt) throws IllegalArgumentException\n{\nOption option = null;\ntry\n{\n// create the option\noption = new Option(opt, description);\n\n// set the option properties\noption.setLongOpt(longopt);\noption.setRequired(required);\noption.setOptionalArg(optionalArg);\noption.setArgs(numberOfArgs);\noption.setType(type);\noption.setValueSeparator(valuesep);\noption.setArgName(argName);\n}\nfinally\n{\n// reset the OptionBuilder properties\nOptionBuilder.reset();\n}\n\n// return the Option instance\nreturn option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public Option(String opt, String description) throws IllegalArgumentException\n{\nthis(opt, null, false, description);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getType()Ljava/lang/Object;",
                                    "method_body": "public Object getType()\n{\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setType(Ljava/lang/Class;)V",
                                    "method_body": "public void setType(Class type)\n{\nthis.type = type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setLongOpt(Ljava/lang/String;)V",
                                    "method_body": "public void setLongOpt(String longOpt)\n{\nthis.longOpt = longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setOptionalArg(Z)V",
                                    "method_body": "public void setOptionalArg(boolean optionalArg)\n{\nthis.optionalArg = optionalArg;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgName(Ljava/lang/String;)V",
                                    "method_body": "public void setArgName(String argName)\n{\nthis.argName = argName;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setArgs(I)V",
                                    "method_body": "public void setArgs(int num)\n{\nthis.numberOfArgs = num;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setValueSeparator(C)V",
                                    "method_body": "public void setValueSeparator(char sep)\n{\nthis.valuesep = sep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal character : '\" + chars[i] + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withLongOpt(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withLongOpt(String newLongopt)\n{\nOptionBuilder.longopt = newLongopt;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:isRequired()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder isRequired()\n{\nOptionBuilder.required = true;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:hasArgs()Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder hasArgs()\n{\nOptionBuilder.numberOfArgs = Option.UNLIMITED_VALUES;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:withDescription(Ljava/lang/String;)Lorg/apache/commons/cli/OptionBuilder;",
                                    "method_body": "public static OptionBuilder withDescription(String newDescription)\n{\nOptionBuilder.description = newDescription;\n\nreturn instance;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionBuilder:create(C)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public static Option create(char opt) throws IllegalArgumentException\n{\nreturn create(String.valueOf(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getDescription()Ljava/lang/String;",
                                    "method_body": "public String getDescription()\n{\nreturn description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArgs()Z",
                                    "method_body": "public boolean hasArgs()\n{\nreturn numberOfArgs > 1 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 35,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI252Test.testExactOptionNameMatch",
                            "test_body": "public void testExactOptionNameMatch() throws ParseException {\nnew DefaultParser().parse(getOptions(), new String[]{\"--prefix\"});\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection<OptionGroup> getOptionGroups()\n{\nreturn new HashSet<OptionGroup>(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(String opt, String longOpt, boolean hasArg, String description)\n{\naddOption(new Option(opt, longOpt, hasArg, description));\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn Collections.unmodifiableList(requiredOpts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getMatchingOptions(Ljava/lang/String;)Ljava/util/List;",
                                    "method_body": "public List<String> getMatchingOptions(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nList<String> matchingOpts = new ArrayList<String>();\n\n// for a perfect match return the single option only\n\nfor (String longOpt : longOpts.keySet())\n{\nif (longOpt.startsWith(opt))\n{\nmatchingOpts.add(longOpt);\n}\n}\n\nreturn matchingOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Lorg/apache/commons/cli/Option$Builder;)V",
                                    "method_body": "private Option(final Builder builder)\n{\nthis.argName = builder.argName;\nthis.description = builder.description;\nthis.longOpt = builder.longOpt;\nthis.numberOfArgs = builder.numberOfArgs;\nthis.opt = builder.opt;\nthis.optionalArg = builder.optionalArg;\nthis.required = builder.required;\nthis.type = builder.type;\nthis.valuesep = builder.valuesep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
                                    "method_body": "public Option(String opt, String longOpt, boolean hasArg, String description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.description = description;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nreturn (opt == null) ? longOpt : opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:builder()Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public static Builder builder()\n{\nreturn builder(null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:builder(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public static Builder builder(final String opt)\n{\nreturn new Builder(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// if opt is NULL do not check further\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nfor (char ch : opt.toCharArray())\n{\nif (!isValidChar(ch))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal \"\n+ \"character : '\" + ch + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments) throws ParseException\n{\nreturn parse(options, arguments, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\nthis.options = options;\nthis.stopAtNonOption = stopAtNonOption;\nskipParsing = false;\ncurrentOption = null;\nexpectedOpts = new ArrayList(options.getRequiredOptions());\n\n// clear the data from the groups\nfor (OptionGroup group : options.getOptionGroups())\n{\ngroup.setSelected(null);\n}\n\ncmd = new CommandLine();\n\nif (arguments != null)\n{\nfor (String argument : arguments)\n{\nhandleToken(argument);\n}\n}\n\n// check the arguments of the last option\ncheckRequiredArgs();\n\n// add the default options\nhandleProperties(properties);\n\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleToken(Ljava/lang/String;)V",
                                    "method_body": "private void handleToken(String token) throws ParseException\n{\ncurrentToken = token;\n\nif (skipParsing)\n{\ncmd.addArg(token);\n}\nelse if (\"--\".equals(token))\n{\nskipParsing = true;\n}\nelse if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n{\ncurrentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n}\nelse if (token.startsWith(\"--\"))\n{\nhandleLongOption(token);\n}\nelse if (token.startsWith(\"-\") && !\"-\".equals(token))\n{\nhandleShortAndLongOption(token);\n}\nelse\n{\nhandleUnknownToken(token);\n}\n\nif (currentOption != null && !currentOption.acceptsArg())\n{\ncurrentOption = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleLongOption(Ljava/lang/String;)V",
                                    "method_body": "private void handleLongOption(String token) throws ParseException\n{\nif (token.indexOf('=') == -1)\n{\nhandleLongOptionWithoutEqual(token);\n}\nelse\n{\nhandleLongOptionWithEqual(token);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleLongOptionWithoutEqual(Ljava/lang/String;)V",
                                    "method_body": "private void handleLongOptionWithoutEqual(String token) throws ParseException\n{\nList<String> matchingOpts = options.getMatchingOptions(token);\nif (matchingOpts.isEmpty())\n{\nhandleUnknownToken(currentToken);\n}\nelse if (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(token, matchingOpts);\n}\nelse\n{\nhandleOption(options.getOption(matchingOpts.get(0)));\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "protected CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:<init>(Ljava/lang/String;)V",
                                    "method_body": "private Builder(final String opt) throws IllegalArgumentException\n{\nOptionValidator.validateOption(opt);\nthis.opt = opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:longOpt(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder longOpt(final String longOpt)\n{\nthis.longOpt = longOpt;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:build()Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option build()\n{\nif (opt == null && longOpt == null)\n{\nthrow new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n}\nreturn new Option(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.ParseException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public ParseException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.UnrecognizedOptionException:<init>(Ljava/lang/String;)V",
                                    "method_body": "public UnrecognizedOptionException(String message)\n{\nsuper(message);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.UnrecognizedOptionException:<init>(Ljava/lang/String;Ljava/lang/String;)V",
                                    "method_body": "public UnrecognizedOptionException(String message, String option)\n{\nthis(message);\nthis.option = option;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AmbiguousOptionException:<init>(Ljava/lang/String;Ljava/util/Collection;)V",
                                    "method_body": "public AmbiguousOptionException(String option, Collection<String> matchingOptions)\n{\nsuper(createMessage(option, matchingOptions), option);\nthis.matchingOptions = matchingOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.AmbiguousOptionException:createMessage(Ljava/lang/String;Ljava/util/Collection;)Ljava/lang/String;",
                                    "method_body": "private static String createMessage(String option, Collection<String> matchingOptions)\n{\nStringBuilder buf = new StringBuilder(\"Ambiguous option: '\");\nbuf.append(option);\nbuf.append(\"'  (could be: \");\n\nIterator<String> it = matchingOptions.iterator();\nwhile (it.hasNext())\n{\nbuf.append(\"'\");\nbuf.append(it.next());\nbuf.append(\"'\");\nif (it.hasNext())\n{\nbuf.append(\", \");\n}\n}\nbuf.append(\")\");\n\nreturn buf.toString();\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 36,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI266Test.testOptionComparatorInsertedOrder",
                            "test_body": "public void testOptionComparatorInsertedOrder() throws ParseException {\nCollection<Option> options = getOptions().getOptions();\nint i = 0;\nfor(Option o: options) {\nAssert.assertEquals(o.getOpt(), insertedOrder.get(i));\ni++;\n}\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOptionGroup(Lorg/apache/commons/cli/OptionGroup;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOptionGroup(OptionGroup group)\n{\nif (group.isRequired())\n{\nrequiredOpts.add(group);\n}\n\nfor (Option option : group.getOptions())\n{\n// an Option cannot be required if it is in an\n// OptionGroup, either the group is required or\n// nothing is required\noption.setRequired(false);\naddOption(option);\n\noptionGroups.put(option.getKey(), group);\n}\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection<Option> getOptions()\n{\nreturn Collections.unmodifiableCollection(helpOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List<Option> helpOptions()\n{\nreturn new ArrayList<Option>(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Lorg/apache/commons/cli/Option$Builder;)V",
                                    "method_body": "private Option(final Builder builder)\n{\nthis.argName = builder.argName;\nthis.description = builder.description;\nthis.longOpt = builder.longOpt;\nthis.numberOfArgs = builder.numberOfArgs;\nthis.opt = builder.opt;\nthis.optionalArg = builder.optionalArg;\nthis.required = builder.required;\nthis.type = builder.type;\nthis.valuesep = builder.valuesep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nreturn (opt == null) ? longOpt : opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getLongOpt()Ljava/lang/String;",
                                    "method_body": "public String getLongOpt()\n{\nreturn longOpt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:builder(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public static Builder builder(final String opt)\n{\nreturn new Builder(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// if opt is NULL do not check further\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nfor (char ch : opt.toCharArray())\n{\nif (!isValidChar(ch))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal \"\n+ \"character : '\" + ch + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:<init>(Ljava/lang/String;)V",
                                    "method_body": "private Builder(final String opt) throws IllegalArgumentException\n{\nOptionValidator.validateOption(opt);\nthis.opt = opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:argName(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder argName(final String argName)\n{\nthis.argName = argName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:desc(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder desc(final String description)\n{\nthis.description = description;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:longOpt(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder longOpt(final String longOpt)\n{\nthis.longOpt = longOpt;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:required()Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder required()\n{\nreturn required(true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:required(Z)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder required(final boolean required)\n{\nthis.required = required;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:hasArg()Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder hasArg()\n{\nreturn hasArg(true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:hasArg(Z)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder hasArg(final boolean hasArg)\n{\n// set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\nnumberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:build()Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option build()\n{\nif (opt == null && longOpt == null)\n{\nthrow new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n}\nreturn new Option(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup addOption(Option option)\n{\n// key   - option name\n// value - the option\noptionMap.put(option.getKey(), option);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:getOptions()Ljava/util/Collection;",
                                    "method_body": "public Collection<Option> getOptions()\n{\n// the values are the collection of options\nreturn optionMap.values();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:setRequired(Z)V",
                                    "method_body": "public void setRequired(boolean required)\n{\nthis.required = required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionGroup:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 37,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI265Test.shouldParseShortOptionWithoutValue",
                            "test_body": "public void shouldParseShortOptionWithoutValue() throws Exception {\nString[] twoShortOptions = new String[]{\"-t1\", \"-last\"};\nfinal CommandLine commandLine = parser.parse(options, twoShortOptions);\nassertTrue(commandLine.hasOption(\"t1\"));\nassertNotEquals(\"Second option has been used as value for first option\", \"-last\", commandLine.getOptionValue(\"t1\"));\nassertTrue(\"Second option has not been detected\", commandLine.hasOption(\"last\"));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nint length = str.length();\nif (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\n{\nstr = str.substring(1, length - 1);\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection<OptionGroup> getOptionGroups()\n{\nreturn new HashSet<OptionGroup>(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn Collections.unmodifiableList(requiredOpts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn shortOpts.get(opt);\n}\n\nreturn longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getMatchingOptions(Ljava/lang/String;)Ljava/util/List;",
                                    "method_body": "public List<String> getMatchingOptions(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nList<String> matchingOpts = new ArrayList<String>();\n\n// for a perfect match return the single option only\nif (longOpts.keySet().contains(opt))\n{\nreturn Collections.singletonList(opt);\n}\n\nfor (String longOpt : longOpts.keySet())\n{\nif (longOpt.startsWith(opt))\n{\nmatchingOpts.add(longOpt);\n}\n}\n\nreturn matchingOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasLongOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasLongOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasShortOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasShortOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Lorg/apache/commons/cli/Option$Builder;)V",
                                    "method_body": "private Option(final Builder builder)\n{\nthis.argName = builder.argName;\nthis.description = builder.description;\nthis.longOpt = builder.longOpt;\nthis.numberOfArgs = builder.numberOfArgs;\nthis.opt = builder.opt;\nthis.optionalArg = builder.optionalArg;\nthis.required = builder.required;\nthis.type = builder.type;\nthis.valuesep = builder.valuesep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nreturn (opt == null) ? longOpt : opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn valuesep > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
                                    "method_body": "void addValueForProcessing(String value)\n{\nif (numberOfArgs == UNINITIALIZED)\n{\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n}\nprocessValue(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == numberOfArgs - 1)\n{\nbreak;\n}\n\n// store\nadd(value.substring(0, index));\n\n// parse\nvalue = value.substring(index + 1);\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif (!acceptsArg())\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n// store value\nvalues.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValuesList()Ljava/util/List;",
                                    "method_body": "public List<String> getValuesList()\n{\nreturn values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o)\n{\nif (this == o)\n{\nreturn true;\n}\nif (o == null || getClass() != o.getClass())\n{\nreturn false;\n}\n\nOption option = (Option) o;\n\n\nif (opt != null ? !opt.equals(option.opt) : option.opt != null)\n{\nreturn false;\n}\nif (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList<String>(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:acceptsArg()Z",
                                    "method_body": "boolean acceptsArg()\n{\nreturn (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:builder(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public static Builder builder(final String opt)\n{\nreturn new Builder(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// if opt is NULL do not check further\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nfor (char ch : opt.toCharArray())\n{\nif (!isValidChar(ch))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal \"\n+ \"character : '\" + ch + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments) throws ParseException\n{\nreturn parse(options, arguments, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\nthis.options = options;\nthis.stopAtNonOption = stopAtNonOption;\nskipParsing = false;\ncurrentOption = null;\nexpectedOpts = new ArrayList(options.getRequiredOptions());\n\n// clear the data from the groups\nfor (OptionGroup group : options.getOptionGroups())\n{\ngroup.setSelected(null);\n}\n\ncmd = new CommandLine();\n\nif (arguments != null)\n{\nfor (String argument : arguments)\n{\nhandleToken(argument);\n}\n}\n\n// check the arguments of the last option\ncheckRequiredArgs();\n\n// add the default options\nhandleProperties(properties);\n\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleProperties(Ljava/util/Properties;)V",
                                    "method_body": "private void handleProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nOption opt = options.getOption(option);\nif (opt == null)\n{\nthrow new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n}\n\n// if the option is part of a group, check if another option of the group has been selected\nOptionGroup group = options.getOptionGroup(opt);\nboolean selected = group != null && group.getSelected() != null;\n\nif (!cmd.hasOption(option) && !selected)\n{\n// get the value from the properties\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\nopt.addValueForProcessing(value);\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the option to the CommandLine\ncontinue;\n}\n\nhandleOption(opt);\ncurrentOption = null;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:checkRequiredOptions()V",
                                    "method_body": "private void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processed\nif (!expectedOpts.isEmpty())\n{\nthrow new MissingOptionException(expectedOpts);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:checkRequiredArgs()V",
                                    "method_body": "private void checkRequiredArgs() throws ParseException\n{\nif (currentOption != null && currentOption.requiresArg())\n{\nthrow new MissingArgumentException(currentOption);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleToken(Ljava/lang/String;)V",
                                    "method_body": "private void handleToken(String token) throws ParseException\n{\ncurrentToken = token;\n\nif (skipParsing)\n{\ncmd.addArg(token);\n}\nelse if (\"--\".equals(token))\n{\nskipParsing = true;\n}\nelse if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n{\ncurrentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n}\nelse if (token.startsWith(\"--\"))\n{\nhandleLongOption(token);\n}\nelse if (token.startsWith(\"-\") && !\"-\".equals(token))\n{\nhandleShortAndLongOption(token);\n}\nelse\n{\nhandleUnknownToken(token);\n}\n\nif (currentOption != null && !currentOption.acceptsArg())\n{\ncurrentOption = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isArgument(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isArgument(String token)\n{\nreturn !isOption(token) || isNegativeNumber(token);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isOption(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isOption(String token)\n{\nreturn isLongOption(token) || isShortOption(token);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isShortOption(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isShortOption(String token)\n{\n// short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\nreturn token.startsWith(\"-\") && token.length() >= 2 && options.hasShortOption(token.substring(1, 2));\n\n// remove leading \"-\" and \"=value\"\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isLongOption(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isLongOption(String token)\n{\nif (!token.startsWith(\"-\") || token.length() == 1)\n{\nreturn false;\n}\n\nint pos = token.indexOf(\"=\");\nString t = pos == -1 ? token : token.substring(0, pos);\n\nif (!options.getMatchingOptions(t).isEmpty())\n{\n// long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\nreturn true;\n}\nelse if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n{\n// -LV\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleShortAndLongOption(Ljava/lang/String;)V",
                                    "method_body": "private void handleShortAndLongOption(String token) throws ParseException\n{\nString t = Util.stripLeadingHyphens(token);\n\nint pos = t.indexOf('=');\n\nif (t.length() == 1)\n{\n// -S\nif (options.hasShortOption(t))\n{\nhandleOption(options.getOption(t));\n}\nelse\n{\nhandleUnknownToken(token);\n}\n}\nelse if (pos == -1)\n{\n// no equal sign found (-xxx)\nif (options.hasShortOption(t))\n{\nhandleOption(options.getOption(t));\n}\nelse if (!options.getMatchingOptions(t).isEmpty())\n{\n// -L or -l\nhandleLongOptionWithoutEqual(token);\n}\nelse\n{\n// look for a long prefix (-Xmx512m)\nString opt = getLongPrefix(t);\n\nif (opt != null && options.getOption(opt).acceptsArg())\n{\nhandleOption(options.getOption(opt));\ncurrentOption.addValueForProcessing(t.substring(opt.length()));\ncurrentOption = null;\n}\nelse if (isJavaProperty(t))\n{\n// -SV1 (-Dflag)\nhandleOption(options.getOption(t.substring(0, 1)));\ncurrentOption.addValueForProcessing(t.substring(1));\ncurrentOption = null;\n}\nelse\n{\n// -S1S2S3 or -S1S2V\nhandleConcatenatedOptions(token);\n}\n}\n}\nelse\n{\n// equal sign found (-xxx=yyy)\nString opt = t.substring(0, pos);\nString value = t.substring(pos + 1);\n\nif (opt.length() == 1)\n{\n// -S=V\nOption option = options.getOption(opt);\nif (option != null && option.acceptsArg())\n{\nhandleOption(option);\ncurrentOption.addValueForProcessing(value);\ncurrentOption = null;\n}\nelse\n{\nhandleUnknownToken(token);\n}\n}\nelse if (isJavaProperty(opt))\n{\n// -SV1=V2 (-Dkey=value)\nhandleOption(options.getOption(opt.substring(0, 1)));\ncurrentOption.addValueForProcessing(opt.substring(1));\ncurrentOption.addValueForProcessing(value);\ncurrentOption = null;\n}\nelse\n{\n// -L=V or -l=V\nhandleLongOptionWithEqual(token);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:getLongPrefix(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String getLongPrefix(String token)\n{\nString t = Util.stripLeadingHyphens(token);\n\nint i;\nString opt = null;\nfor (i = t.length() - 2; i > 1; i--)\n{\nString prefix = t.substring(0, i);\nif (options.hasLongOption(prefix))\n{\nopt = prefix;\nbreak;\n}\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void handleOption(Option option) throws ParseException\n{\n// check the previous option before handling the next one\ncheckRequiredArgs();\n\noption = (Option) option.clone();\n\nupdateRequiredOptions(option);\n\ncmd.addOption(option);\n\nif (option.hasArg())\n{\ncurrentOption = option;\n}\nelse\n{\ncurrentOption = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:updateRequiredOptions(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void updateRequiredOptions(Option option) throws AlreadySelectedException\n{\nif (option.isRequired())\n{\nexpectedOpts.remove(option.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected option of the group\nif (options.getOptionGroup(option) != null)\n{\nOptionGroup group = options.getOptionGroup(option);\n\nif (group.isRequired())\n{\nexpectedOpts.remove(group);\n}\n\ngroup.setSelected(option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "protected CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(String opt)\n{\nString[] values = getOptionValues(opt);\n\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Ljava/lang/String;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(String opt)\n{\nList<String> values = new ArrayList<String>();\n\nfor (Option option : options)\n{\nif (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n{\nvalues.addAll(option.getValuesList());\n}\n}\n\nreturn values.isEmpty() ? null : values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Option option : options)\n{\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "protected void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:<init>(Ljava/lang/String;)V",
                                    "method_body": "private Builder(final String opt) throws IllegalArgumentException\n{\nOptionValidator.validateOption(opt);\nthis.opt = opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:argName(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder argName(final String argName)\n{\nthis.argName = argName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:numberOfArgs(I)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder numberOfArgs(final int numberOfArgs)\n{\nthis.numberOfArgs = numberOfArgs;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:optionalArg(Z)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder optionalArg(final boolean isOptional)\n{\nthis.optionalArg = isOptional;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:hasArg()Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder hasArg()\n{\nreturn hasArg(true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:hasArg(Z)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder hasArg(final boolean hasArg)\n{\n// set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\nnumberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:build()Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option build()\n{\nif (opt == null && longOpt == null)\n{\nthrow new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n}\nreturn new Option(this);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 38,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.bug.BugCLI265Test.shouldParseConcatenatedShortOptions",
                            "test_body": "public void shouldParseConcatenatedShortOptions() throws Exception {\nString[] concatenatedShortOptions = new String[] { \"-t1\", \"-ab\" };\nfinal CommandLine commandLine = parser.parse(options, concatenatedShortOptions);\nassertTrue(commandLine.hasOption(\"t1\"));\nassertNull(commandLine.getOptionValue(\"t1\"));\nassertTrue(commandLine.hasOption(\"a\"));\nassertTrue(commandLine.hasOption(\"b\"));\nassertFalse(commandLine.hasOption(\"last\"));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nint length = str.length();\nif (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\n{\nstr = str.substring(1, length - 1);\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection<OptionGroup> getOptionGroups()\n{\nreturn new HashSet<OptionGroup>(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn Collections.unmodifiableList(requiredOpts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn shortOpts.get(opt);\n}\n\nreturn longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getMatchingOptions(Ljava/lang/String;)Ljava/util/List;",
                                    "method_body": "public List<String> getMatchingOptions(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nList<String> matchingOpts = new ArrayList<String>();\n\n// for a perfect match return the single option only\nif (longOpts.keySet().contains(opt))\n{\nreturn Collections.singletonList(opt);\n}\n\nfor (String longOpt : longOpts.keySet())\n{\nif (longOpt.startsWith(opt))\n{\nmatchingOpts.add(longOpt);\n}\n}\n\nreturn matchingOpts;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasShortOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasShortOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(Option opt)\n{\nreturn optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Lorg/apache/commons/cli/Option$Builder;)V",
                                    "method_body": "private Option(final Builder builder)\n{\nthis.argName = builder.argName;\nthis.description = builder.description;\nthis.longOpt = builder.longOpt;\nthis.numberOfArgs = builder.numberOfArgs;\nthis.opt = builder.opt;\nthis.optionalArg = builder.optionalArg;\nthis.required = builder.required;\nthis.type = builder.type;\nthis.valuesep = builder.valuesep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nreturn (opt == null) ? longOpt : opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn valuesep > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
                                    "method_body": "void addValueForProcessing(String value)\n{\nif (numberOfArgs == UNINITIALIZED)\n{\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n}\nprocessValue(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nchar sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == numberOfArgs - 1)\n{\nbreak;\n}\n\n// store\nadd(value.substring(0, index));\n\n// parse\nvalue = value.substring(index + 1);\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(String value)\n{\nif (!acceptsArg())\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n// store value\nvalues.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValuesList()Ljava/util/List;",
                                    "method_body": "public List<String> getValuesList()\n{\nreturn values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(Object o)\n{\nif (this == o)\n{\nreturn true;\n}\nif (o == null || getClass() != o.getClass())\n{\nreturn false;\n}\n\nOption option = (Option) o;\n\n\nif (opt != null ? !opt.equals(option.opt) : option.opt != null)\n{\nreturn false;\n}\nif (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nOption option = (Option) super.clone();\noption.values = new ArrayList<String>(values);\nreturn option;\n}\ncatch (CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:acceptsArg()Z",
                                    "method_body": "boolean acceptsArg()\n{\nreturn (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:builder(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public static Builder builder(final String opt)\n{\nreturn new Builder(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(String opt) throws IllegalArgumentException\n{\n// if opt is NULL do not check further\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nfor (char ch : opt.toCharArray())\n{\nif (!isValidChar(ch))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal \"\n+ \"character : '\" + ch + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments) throws ParseException\n{\nreturn parse(options, arguments, null);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties) throws ParseException\n{\nreturn parse(options, arguments, properties, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(Options options, String[] arguments, Properties properties, boolean stopAtNonOption)\nthrows ParseException\n{\nthis.options = options;\nthis.stopAtNonOption = stopAtNonOption;\nskipParsing = false;\ncurrentOption = null;\nexpectedOpts = new ArrayList(options.getRequiredOptions());\n\n// clear the data from the groups\nfor (OptionGroup group : options.getOptionGroups())\n{\ngroup.setSelected(null);\n}\n\ncmd = new CommandLine();\n\nif (arguments != null)\n{\nfor (String argument : arguments)\n{\nhandleToken(argument);\n}\n}\n\n// check the arguments of the last option\ncheckRequiredArgs();\n\n// add the default options\nhandleProperties(properties);\n\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleProperties(Ljava/util/Properties;)V",
                                    "method_body": "private void handleProperties(Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nOption opt = options.getOption(option);\nif (opt == null)\n{\nthrow new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n}\n\n// if the option is part of a group, check if another option of the group has been selected\nOptionGroup group = options.getOptionGroup(opt);\nboolean selected = group != null && group.getSelected() != null;\n\nif (!cmd.hasOption(option) && !selected)\n{\n// get the value from the properties\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\nopt.addValueForProcessing(value);\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the option to the CommandLine\ncontinue;\n}\n\nhandleOption(opt);\ncurrentOption = null;\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:checkRequiredOptions()V",
                                    "method_body": "private void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processed\nif (!expectedOpts.isEmpty())\n{\nthrow new MissingOptionException(expectedOpts);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:checkRequiredArgs()V",
                                    "method_body": "private void checkRequiredArgs() throws ParseException\n{\nif (currentOption != null && currentOption.requiresArg())\n{\nthrow new MissingArgumentException(currentOption);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleToken(Ljava/lang/String;)V",
                                    "method_body": "private void handleToken(String token) throws ParseException\n{\ncurrentToken = token;\n\nif (skipParsing)\n{\ncmd.addArg(token);\n}\nelse if (\"--\".equals(token))\n{\nskipParsing = true;\n}\nelse if (currentOption != null && currentOption.acceptsArg() && isArgument(token))\n{\ncurrentOption.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(token));\n}\nelse if (token.startsWith(\"--\"))\n{\nhandleLongOption(token);\n}\nelse if (token.startsWith(\"-\") && !\"-\".equals(token))\n{\nhandleShortAndLongOption(token);\n}\nelse\n{\nhandleUnknownToken(token);\n}\n\nif (currentOption != null && !currentOption.acceptsArg())\n{\ncurrentOption = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isArgument(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isArgument(String token)\n{\nreturn !isOption(token) || isNegativeNumber(token);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isOption(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isOption(String token)\n{\nreturn isLongOption(token) || isShortOption(token);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isShortOption(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isShortOption(String token)\n{\n// short options (-S, -SV, -S=V, -SV1=V2, -S1S2)\nif (!token.startsWith(\"-\") || token.length() == 1)\n{\nreturn false;\n}\n\n// remove leading \"-\" and \"=value\"\nint pos = token.indexOf(\"=\");\nString optName = pos == -1 ? token.substring(1) : token.substring(1, pos);\nreturn options.hasShortOption(optName);\n// check for several concatenated short options\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:isLongOption(Ljava/lang/String;)Z",
                                    "method_body": "private boolean isLongOption(String token)\n{\nif (!token.startsWith(\"-\") || token.length() == 1)\n{\nreturn false;\n}\n\nint pos = token.indexOf(\"=\");\nString t = pos == -1 ? token : token.substring(0, pos);\n\nif (!options.getMatchingOptions(t).isEmpty())\n{\n// long or partial long options (--L, -L, --L=V, -L=V, --l, --l=V)\nreturn true;\n}\nelse if (getLongPrefix(token) != null && !token.startsWith(\"--\"))\n{\n// -LV\nreturn true;\n}\n\nreturn false;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleShortAndLongOption(Ljava/lang/String;)V",
                                    "method_body": "private void handleShortAndLongOption(String token) throws ParseException\n{\nString t = Util.stripLeadingHyphens(token);\n\nint pos = t.indexOf('=');\n\nif (t.length() == 1)\n{\n// -S\nif (options.hasShortOption(t))\n{\nhandleOption(options.getOption(t));\n}\nelse\n{\nhandleUnknownToken(token);\n}\n}\nelse if (pos == -1)\n{\n// no equal sign found (-xxx)\nif (options.hasShortOption(t))\n{\nhandleOption(options.getOption(t));\n}\nelse if (!options.getMatchingOptions(t).isEmpty())\n{\n// -L or -l\nhandleLongOptionWithoutEqual(token);\n}\nelse\n{\n// look for a long prefix (-Xmx512m)\nString opt = getLongPrefix(t);\n\nif (opt != null && options.getOption(opt).acceptsArg())\n{\nhandleOption(options.getOption(opt));\ncurrentOption.addValueForProcessing(t.substring(opt.length()));\ncurrentOption = null;\n}\nelse if (isJavaProperty(t))\n{\n// -SV1 (-Dflag)\nhandleOption(options.getOption(t.substring(0, 1)));\ncurrentOption.addValueForProcessing(t.substring(1));\ncurrentOption = null;\n}\nelse\n{\n// -S1S2S3 or -S1S2V\nhandleConcatenatedOptions(token);\n}\n}\n}\nelse\n{\n// equal sign found (-xxx=yyy)\nString opt = t.substring(0, pos);\nString value = t.substring(pos + 1);\n\nif (opt.length() == 1)\n{\n// -S=V\nOption option = options.getOption(opt);\nif (option != null && option.acceptsArg())\n{\nhandleOption(option);\ncurrentOption.addValueForProcessing(value);\ncurrentOption = null;\n}\nelse\n{\nhandleUnknownToken(token);\n}\n}\nelse if (isJavaProperty(opt))\n{\n// -SV1=V2 (-Dkey=value)\nhandleOption(options.getOption(opt.substring(0, 1)));\ncurrentOption.addValueForProcessing(opt.substring(1));\ncurrentOption.addValueForProcessing(value);\ncurrentOption = null;\n}\nelse\n{\n// -L=V or -l=V\nhandleLongOptionWithEqual(token);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:getLongPrefix(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "private String getLongPrefix(String token)\n{\nString t = Util.stripLeadingHyphens(token);\n\nint i;\nString opt = null;\nfor (i = t.length() - 2; i > 1; i--)\n{\nString prefix = t.substring(0, i);\nif (options.hasLongOption(prefix))\n{\nopt = prefix;\nbreak;\n}\n}\n\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:handleOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void handleOption(Option option) throws ParseException\n{\n// check the previous option before handling the next one\ncheckRequiredArgs();\n\noption = (Option) option.clone();\n\nupdateRequiredOptions(option);\n\ncmd.addOption(option);\n\nif (option.hasArg())\n{\ncurrentOption = option;\n}\nelse\n{\ncurrentOption = null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.DefaultParser:updateRequiredOptions(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void updateRequiredOptions(Option option) throws AlreadySelectedException\n{\nif (option.isRequired())\n{\nexpectedOpts.remove(option.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected option of the group\nif (options.getOptionGroup(option) != null)\n{\nOptionGroup group = options.getOptionGroup(option);\n\nif (group.isRequired())\n{\nexpectedOpts.remove(group);\n}\n\ngroup.setSelected(option);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "protected CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(String opt)\n{\nString[] values = getOptionValues(opt);\n\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Ljava/lang/String;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(String opt)\n{\nList<String> values = new ArrayList<String>();\n\nfor (Option option : options)\n{\nif (opt.equals(option.getOpt()) || opt.equals(option.getLongOpt()))\n{\nvalues.addAll(option.getValuesList());\n}\n}\n\nreturn values.isEmpty() ? null : values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (Option option : options)\n{\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "protected void addOption(Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:<init>(Ljava/lang/String;)V",
                                    "method_body": "private Builder(final String opt) throws IllegalArgumentException\n{\nOptionValidator.validateOption(opt);\nthis.opt = opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:argName(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder argName(final String argName)\n{\nthis.argName = argName;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:numberOfArgs(I)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder numberOfArgs(final int numberOfArgs)\n{\nthis.numberOfArgs = numberOfArgs;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:optionalArg(Z)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder optionalArg(final boolean isOptional)\n{\nthis.optionalArg = isOptional;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:hasArg()Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder hasArg()\n{\nreturn hasArg(true);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:hasArg(Z)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder hasArg(final boolean hasArg)\n{\n// set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\nnumberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:build()Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option build()\n{\nif (opt == null && longOpt == null)\n{\nthrow new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n}\nreturn new Option(this);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 39,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.PatternOptionBuilderTest.testExistingFilePattern",
                            "test_body": "public void testExistingFilePattern() throws Exception\n{\nfinal Options options = PatternOptionBuilder.parsePattern(\"g<\");\nfinal CommandLineParser parser = new PosixParser();\nfinal CommandLine line = parser.parse(options, new String[] { \"-g\", \"src/test/resources/existing-readable.file\" });\nfinal Object parsedReadableFileStream = line.getOptionObject(\"g\");\nassertNotNull(\"option g not parsed\", parsedReadableFileStream);\nassertTrue(\"option g not FileInputStream\", parsedReadableFileStream instanceof FileInputStream);\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(final String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nfinal int length = str.length();\nif (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\n{\nstr = str.substring(1, length - 1);\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection<OptionGroup> getOptionGroups()\n{\nreturn new HashSet<OptionGroup>(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(final Option opt)\n{\nfinal String key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List<Option> helpOptions()\n{\nreturn new ArrayList<Option>(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn Collections.unmodifiableList(requiredOpts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn shortOpts.get(opt);\n}\n\nreturn longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(final Option opt)\n{\nreturn optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Lorg/apache/commons/cli/Option$Builder;)V",
                                    "method_body": "private Option(final Builder builder)\n{\nthis.argName = builder.argName;\nthis.description = builder.description;\nthis.longOpt = builder.longOpt;\nthis.numberOfArgs = builder.numberOfArgs;\nthis.opt = builder.opt;\nthis.optionalArg = builder.optionalArg;\nthis.required = builder.required;\nthis.type = builder.type;\nthis.valuesep = builder.valuesep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nreturn (opt == null) ? longOpt : opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getType()Ljava/lang/Object;",
                                    "method_body": "public Object getType()\n{\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn valuesep > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
                                    "method_body": "void addValueForProcessing(final String value)\n{\nif (numberOfArgs == UNINITIALIZED)\n{\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n}\nprocessValue(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nfinal char sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == numberOfArgs - 1)\n{\nbreak;\n}\n\n// store\nadd(value.substring(0, index));\n\n// parse\nvalue = value.substring(index + 1);\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(final String value)\n{\nif (!acceptsArg())\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n// store value\nvalues.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues() ? null : values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValuesList()Ljava/util/List;",
                                    "method_body": "public List<String> getValuesList()\n{\nreturn values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn values.isEmpty();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object o)\n{\nif (this == o)\n{\nreturn true;\n}\nif (o == null || getClass() != o.getClass())\n{\nreturn false;\n}\n\nfinal Option option = (Option) o;\n\nif (opt != null ? !opt.equals(option.opt) : option.opt != null)\n{\nreturn false;\n}\nif (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nfinal Option option = (Option) super.clone();\noption.values = new ArrayList<String>(values);\nreturn option;\n}\ncatch (final CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:acceptsArg()Z",
                                    "method_body": "boolean acceptsArg()\n{\nreturn (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:builder(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public static Builder builder(final String opt)\n{\nreturn new Builder(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(final String opt) throws IllegalArgumentException\n{\n// if opt is NULL do not check further\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nfinal char ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nfor (final char ch : opt.toCharArray())\n{\nif (!isValidChar(ch))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal \"\n+ \"character : '\" + ch + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(final char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(final char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "protected CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionObject(Ljava/lang/String;)Ljava/lang/Object;",
                                    "method_body": "public Object getOptionObject(final String opt)\n{\ntry\n{\nreturn getParsedOptionValue(opt);\n}\ncatch (final ParseException pe)\n{\nSystem.err.println(\"Exception found converting \" + opt + \" to desired type: \" + pe.getMessage());\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getParsedOptionValue(Lorg/apache/commons/cli/Option;)Ljava/lang/Object;",
                                    "method_body": "public Object getParsedOptionValue(final Option option) throws ParseException\n{\nif (option == null)\n{\nreturn null;\n}\nfinal String res = getOptionValue(option);\nif (res == null)\n{\nreturn null;\n}\nreturn TypeHandler.createValue(res, option.getType());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getParsedOptionValue(Ljava/lang/String;)Ljava/lang/Object;",
                                    "method_body": "public Object getParsedOptionValue(final String opt) throws ParseException\n{\nreturn getParsedOptionValue(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Lorg/apache/commons/cli/Option;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(final Option option)\n{\nif (option == null)\n{\nreturn null;\n}\nfinal String[] values = getOptionValues(option);\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Lorg/apache/commons/cli/Option;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(final Option option)\n{\nfinal List<String> values = new ArrayList<String>();\n\nfor (final Option processedOption : options)\n{\nif (processedOption.equals(option))\n{\nvalues.addAll(processedOption.getValuesList());\n}\n}\n\nreturn values.isEmpty() ? null : values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (final Option option : options)\n{\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "protected void addOption(final Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createValue(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static Object createValue(final String str, final Object obj) throws ParseException\n{\nreturn createValue(str, (Class<?>) obj);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createValue(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public static Object createValue(final String str, final Class<?> clazz) throws ParseException\n{\nif (PatternOptionBuilder.STRING_VALUE == clazz)\n{\nreturn str;\n}\nelse if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n{\nreturn createObject(str);\n}\nelse if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n{\nreturn createNumber(str);\n}\nelse if (PatternOptionBuilder.DATE_VALUE == clazz)\n{\nreturn createDate(str);\n}\nelse if (PatternOptionBuilder.CLASS_VALUE == clazz)\n{\nreturn createClass(str);\n}\nelse if (PatternOptionBuilder.FILE_VALUE == clazz)\n{\nreturn createFile(str);\n}\nelse if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n{\nreturn createFile(str);\n}\nelse if (PatternOptionBuilder.FILES_VALUE == clazz)\n{\nreturn createFiles(str);\n}\nelse if (PatternOptionBuilder.URL_VALUE == clazz)\n{\nreturn createURL(str);\n}\nelse\n{\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createFile(Ljava/lang/String;)Ljava/io/File;",
                                    "method_body": "public static File createFile(final String str)\n{\nreturn new File(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:<clinit>()V",
                                    "method_body": "public static final Class<String> STRING_VALUE = String.class;\n\n/** Object class */\npublic static final Class<Object> OBJECT_VALUE = Object.class;\n\n/** Number class */\npublic static final Class<Number> NUMBER_VALUE = Number.class;\n\n/** Date class */\npublic static final Class<Date> DATE_VALUE = Date.class;\n\n/** Class class */\npublic static final Class<?> CLASS_VALUE = Class.class;\n\n/// can we do this one??\n// is meant to check that the file exists, else it errors.\n// ie) it's for reading not writing.\n\n/** FileInputStream class */\npublic static final Class<FileInputStream> EXISTING_FILE_VALUE = FileInputStream.class;\n\n/** File class */\npublic static final Class<File> FILE_VALUE = File.class;\n\n/** File array class */\npublic static final Class<File[]> FILES_VALUE = File[].class;\n\n/** URL class */\npublic static final Class<URL> URL_VALUE = URL.class;\n\n/**\n* Retrieve the class that <code>ch</code> represents.\n*\n* @param ch the specified character\n* @return The class that <code>ch</code> represents\n*/\npublic static Object getValueClass(final char ch)\n{\nswitch (ch)\n{\ncase '@':\nreturn PatternOptionBuilder.OBJECT_VALUE;\ncase ':':\nreturn PatternOptionBuilder.STRING_VALUE;\ncase '%':\nreturn PatternOptionBuilder.NUMBER_VALUE;\ncase '+':\nreturn PatternOptionBuilder.CLASS_VALUE;\ncase '#':\nreturn PatternOptionBuilder.DATE_VALUE;\ncase '<':\nreturn PatternOptionBuilder.EXISTING_FILE_VALUE;\ncase '>':\nreturn PatternOptionBuilder.FILE_VALUE;\ncase '*':\nreturn PatternOptionBuilder.FILES_VALUE;\ncase '/':\nreturn PatternOptionBuilder.URL_VALUE;\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:getValueClass(C)Ljava/lang/Object;",
                                    "method_body": "public static Object getValueClass(final char ch)\n{\nswitch (ch)\n{\ncase '@':\nreturn PatternOptionBuilder.OBJECT_VALUE;\ncase ':':\nreturn PatternOptionBuilder.STRING_VALUE;\ncase '%':\nreturn PatternOptionBuilder.NUMBER_VALUE;\ncase '+':\nreturn PatternOptionBuilder.CLASS_VALUE;\ncase '#':\nreturn PatternOptionBuilder.DATE_VALUE;\ncase '<':\nreturn PatternOptionBuilder.EXISTING_FILE_VALUE;\ncase '>':\nreturn PatternOptionBuilder.FILE_VALUE;\ncase '*':\nreturn PatternOptionBuilder.FILES_VALUE;\ncase '/':\nreturn PatternOptionBuilder.URL_VALUE;\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:isValueCode(C)Z",
                                    "method_body": "public static boolean isValueCode(final char ch)\n{\nreturn ch == '@'\n|| ch == ':'\n|| ch == '%'\n|| ch == '+'\n|| ch == '#'\n|| ch == '<'\n|| ch == '>'\n|| ch == '*'\n|| ch == '/'\n|| ch == '!';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:parsePattern(Ljava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public static Options parsePattern(final String pattern)\n{\nchar opt = ' ';\nboolean required = false;\nClass<?> type = null;\n\nfinal Options options = new Options();\n\nfor (int i = 0; i < pattern.length(); i++)\n{\nfinal char ch = pattern.charAt(i);\n\n// a value code comes after an option and specifies\n// details about it\nif (!isValueCode(ch))\n{\nif (opt != ' ')\n{\nfinal Option option = Option.builder(String.valueOf(opt))\n.hasArg(type != null)\n.required(required)\n.type(type)\n.build();\n\n// we have a previous one to deal with\noptions.addOption(option);\nrequired = false;\ntype = null;\nopt = ' ';\n}\n\nopt = ch;\n}\nelse if (ch == '!')\n{\nrequired = true;\n}\nelse\n{\ntype = (Class<?>) getValueClass(ch);\n}\n}\n\nif (opt != ' ')\n{\nfinal Option option = Option.builder(String.valueOf(opt))\n.hasArg(type != null)\n.required(required)\n.type(type)\n.build();\n\n// we have a final one to deal with\noptions.addOption(option);\n}\n\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:<init>(Ljava/lang/String;)V",
                                    "method_body": "private Builder(final String opt) throws IllegalArgumentException\n{\nOptionValidator.validateOption(opt);\nthis.opt = opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:required(Z)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder required(final boolean required)\n{\nthis.required = required;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:type(Ljava/lang/Class;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder type(final Class<?> type)\n{\nthis.type = type;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:hasArg(Z)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder hasArg(final boolean hasArg)\n{\n// set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\nnumberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:build()Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option build()\n{\nif (opt == null && longOpt == null)\n{\nthrow new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n}\nreturn new Option(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions()\n{\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(final Options options, final String[] arguments) throws ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(final Options options, String[] arguments, final Properties properties, final boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (final Option opt : options.helpOptions())\n{\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (final OptionGroup group : options.getOptionGroups())\n{\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nfinal List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nfinal ListIterator<String> iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nfinal String t = iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nfinal String str = iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(final Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n{\nfinal String option = e.nextElement().toString();\n\nfinal Option opt = options.getOption(option);\nif (opt == null)\n{\nthrow new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n}\n\n// if the option is part of a group, check if another option of the group has been selected\nfinal OptionGroup group = options.getOptionGroup(opt);\nfinal boolean selected = group != null && group.getSelected() != null;\n\nif (!cmd.hasOption(option) && !selected)\n{\n// get the value from the properties instance\nfinal String value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (final RuntimeException exp) //NOPMD\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\ncontinue;\n}\n\ncmd.addOption(opt);\nupdateRequiredOptions(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(final Option opt, final ListIterator<String> iter) throws ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nfinal String str = iter.next();\n\n// found an Option, not an argument\nif (getOptions().hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n}\ncatch (final RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif (opt.getValues() == null && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(final String arg, final ListIterator<String> iter) throws ParseException\n{\nfinal boolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognizedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nfinal Option opt = (Option) getOptions().getOption(arg).clone();\n\n// update the required options and groups\nupdateRequiredOptions(opt);\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:updateRequiredOptions(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void updateRequiredOptions(final Option opt) throws ParseException\n{\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nfinal OptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nfinal Iterator<String> iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nfinal String token = iter.next();\n\n// single or double hyphen\nif (\"-\".equals(token) || \"--\".equals(token))\n{\ntokens.add(token);\n}\n\n// handle long option --foo or --foo=bar\nelse if (token.startsWith(\"--\"))\n{\nfinal int pos = token.indexOf('=');\nfinal String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\nfinal List<String> matchingOpts = options.getMatchingOptions(opt);\n\nif (matchingOpts.isEmpty())\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\nelse if (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(opt, matchingOpts);\n}\nelse\n{\ncurrentOption = options.getOption(matchingOpts.get(0));\n\ntokens.add(\"--\" + currentOption.getLongOpt());\nif (pos != -1)\n{\ntokens.add(token.substring(pos + 1));\n}\n}\n}\n\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2 || options.hasOption(token))\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (!options.getMatchingOptions(token).isEmpty())\n{\nfinal List<String> matchingOpts = options.getMatchingOptions(token);\nif (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(token, matchingOpts);\n}\nfinal Option opt = options.getOption(matchingOpts.get(0));\nprocessOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\n\ngobble(iter);\n}\n\nreturn tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(final Iterator<String> iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processNonOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processNonOptionToken(final String value, final boolean stopAtNonOption)\n{\nif (stopAtNonOption && (currentOption == null || !currentOption.hasArg()))\n{\neatTheRest = true;\ntokens.add(\"--\");\n}\n\ntokens.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(final String token, final boolean stopAtNonOption)\n{\nif (stopAtNonOption && !options.hasOption(token))\n{\neatTheRest = true;\n}\n\nif (options.hasOption(token))\n{\ncurrentOption = options.getOption(token);\n}\n\ntokens.add(token);\n}"
                                }
                            ]
                        },
                        {
                            "test_name": "org.apache.commons.cli.PatternOptionBuilderTest.testExistingFilePatternFileNotExist",
                            "test_body": "public void testExistingFilePatternFileNotExist() throws Exception {\nfinal Options options = PatternOptionBuilder.parsePattern(\"f<\");\nfinal CommandLineParser parser = new PosixParser();\nfinal CommandLine line = parser.parse(options, new String[] { \"-f\", \"non-existing.file\" });\nassertNull(\"option f parsed\", line.getOptionObject(\"f\"));\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingHyphens(final String str)\n{\nif (str == null)\n{\nreturn null;\n}\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Util:stripLeadingAndTrailingQuotes(Ljava/lang/String;)Ljava/lang/String;",
                                    "method_body": "static String stripLeadingAndTrailingQuotes(String str)\n{\nfinal int length = str.length();\nif (length > 1 && str.startsWith(\"\\\"\") && str.endsWith(\"\\\"\") && str.substring(1, length - 1).indexOf('\"') == -1)\n{\nstr = str.substring(1, length - 1);\n}\n\nreturn str;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroups()Ljava/util/Collection;",
                                    "method_body": "Collection<OptionGroup> getOptionGroups()\n{\nreturn new HashSet<OptionGroup>(optionGroups.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public Options addOption(final Option opt)\n{\nfinal String key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired())\n{\nif (requiredOpts.contains(key))\n{\nrequiredOpts.remove(requiredOpts.indexOf(key));\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
                                    "method_body": "List<Option> helpOptions()\n{\nreturn new ArrayList<Option>(shortOpts.values());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "public List getRequiredOptions()\n{\nreturn Collections.unmodifiableList(requiredOpts);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option getOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nif (shortOpts.containsKey(opt))\n{\nreturn shortOpts.get(opt);\n}\n\nreturn longOpts.get(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:hasOption(Ljava/lang/String;)Z",
                                    "method_body": "public boolean hasOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\n\nreturn shortOpts.containsKey(opt) || longOpts.containsKey(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Options:getOptionGroup(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/OptionGroup;",
                                    "method_body": "public OptionGroup getOptionGroup(final Option opt)\n{\nreturn optionGroups.get(opt.getKey());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:<init>(Lorg/apache/commons/cli/Option$Builder;)V",
                                    "method_body": "private Option(final Builder builder)\n{\nthis.argName = builder.argName;\nthis.description = builder.description;\nthis.longOpt = builder.longOpt;\nthis.numberOfArgs = builder.numberOfArgs;\nthis.opt = builder.opt;\nthis.optionalArg = builder.optionalArg;\nthis.required = builder.required;\nthis.type = builder.type;\nthis.valuesep = builder.valuesep;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
                                    "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nreturn (opt == null) ? longOpt : opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getOpt()Ljava/lang/String;",
                                    "method_body": "public String getOpt()\n{\nreturn opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getType()Ljava/lang/Object;",
                                    "method_body": "public Object getType()\n{\nreturn type;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
                                    "method_body": "public boolean hasLongOpt()\n{\nreturn longOpt != null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasArg()Z",
                                    "method_body": "public boolean hasArg()\n{\nreturn numberOfArgs > 0 || numberOfArgs == UNLIMITED_VALUES;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
                                    "method_body": "public boolean isRequired()\n{\nreturn required;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasValueSeparator()Z",
                                    "method_body": "public boolean hasValueSeparator()\n{\nreturn valuesep > 0;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:addValueForProcessing(Ljava/lang/String;)V",
                                    "method_body": "void addValueForProcessing(final String value)\n{\nif (numberOfArgs == UNINITIALIZED)\n{\nthrow new RuntimeException(\"NO_ARGS_ALLOWED\");\n}\nprocessValue(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:processValue(Ljava/lang/String;)V",
                                    "method_body": "private void processValue(String value)\n{\n// this Option has a separator character\nif (hasValueSeparator())\n{\n// get the separator character\nfinal char sep = getValueSeparator();\n\n// store the index for the value separator\nint index = value.indexOf(sep);\n\n// while there are more value separators\nwhile (index != -1)\n{\n// next value to be added\nif (values.size() == numberOfArgs - 1)\n{\nbreak;\n}\n\n// store\nadd(value.substring(0, index));\n\n// parse\nvalue = value.substring(index + 1);\n\n// get new index\nindex = value.indexOf(sep);\n}\n}\n\n// store the actual value or the last value that has been parsed\nadd(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:add(Ljava/lang/String;)V",
                                    "method_body": "private void add(final String value)\n{\nif (!acceptsArg())\n{\nthrow new RuntimeException(\"Cannot add value, list full.\");\n}\n\n// store value\nvalues.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValues()[Ljava/lang/String;",
                                    "method_body": "public String[] getValues()\n{\nreturn hasNoValues() ? null : values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:getValuesList()Ljava/util/List;",
                                    "method_body": "public List<String> getValuesList()\n{\nreturn values;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:hasNoValues()Z",
                                    "method_body": "private boolean hasNoValues()\n{\nreturn values.isEmpty();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:equals(Ljava/lang/Object;)Z",
                                    "method_body": "public boolean equals(final Object o)\n{\nif (this == o)\n{\nreturn true;\n}\nif (o == null || getClass() != o.getClass())\n{\nreturn false;\n}\n\nfinal Option option = (Option) o;\n\nif (opt != null ? !opt.equals(option.opt) : option.opt != null)\n{\nreturn false;\n}\nif (longOpt != null ? !longOpt.equals(option.longOpt) : option.longOpt != null)\n{\nreturn false;\n}\n\nreturn true;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clone()Ljava/lang/Object;",
                                    "method_body": "public Object clone()\n{\ntry\n{\nfinal Option option = (Option) super.clone();\noption.values = new ArrayList<String>(values);\nreturn option;\n}\ncatch (final CloneNotSupportedException cnse)\n{\nthrow new RuntimeException(\"A CloneNotSupportedException was thrown: \" + cnse.getMessage());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:clearValues()V",
                                    "method_body": "void clearValues()\n{\nvalues.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:acceptsArg()Z",
                                    "method_body": "boolean acceptsArg()\n{\nreturn (hasArg() || hasArgs() || hasOptionalArg()) && (numberOfArgs <= 0 || values.size() < numberOfArgs);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option:builder(Ljava/lang/String;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public static Builder builder(final String opt)\n{\nreturn new Builder(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
                                    "method_body": "static void validateOption(final String opt) throws IllegalArgumentException\n{\n// if opt is NULL do not check further\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nif (opt.length() == 1)\n{\nfinal char ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"Illegal option name '\" + ch + \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nfor (final char ch : opt.toCharArray())\n{\nif (!isValidChar(ch))\n{\nthrow new IllegalArgumentException(\"The option '\" + opt + \"' contains an illegal \"\n+ \"character : '\" + ch + \"'\");\n}\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
                                    "method_body": "private static boolean isValidOpt(final char c)\n{\nreturn isValidChar(c) || c == '?' || c == '@';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
                                    "method_body": "private static boolean isValidChar(final char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
                                    "method_body": "protected CommandLine()\n{\n// nothing to do\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionObject(Ljava/lang/String;)Ljava/lang/Object;",
                                    "method_body": "public Object getOptionObject(final String opt)\n{\ntry\n{\nreturn getParsedOptionValue(opt);\n}\ncatch (final ParseException pe)\n{\nSystem.err.println(\"Exception found converting \" + opt + \" to desired type: \" + pe.getMessage());\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getParsedOptionValue(Lorg/apache/commons/cli/Option;)Ljava/lang/Object;",
                                    "method_body": "public Object getParsedOptionValue(final Option option) throws ParseException\n{\nif (option == null)\n{\nreturn null;\n}\nfinal String res = getOptionValue(option);\nif (res == null)\n{\nreturn null;\n}\nreturn TypeHandler.createValue(res, option.getType());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getParsedOptionValue(Ljava/lang/String;)Ljava/lang/Object;",
                                    "method_body": "public Object getParsedOptionValue(final String opt) throws ParseException\n{\nreturn getParsedOptionValue(resolveOption(opt));\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValue(Lorg/apache/commons/cli/Option;)Ljava/lang/String;",
                                    "method_body": "public String getOptionValue(final Option option)\n{\nif (option == null)\n{\nreturn null;\n}\nfinal String[] values = getOptionValues(option);\nreturn (values == null) ? null : values[0];\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:getOptionValues(Lorg/apache/commons/cli/Option;)[Ljava/lang/String;",
                                    "method_body": "public String[] getOptionValues(final Option option)\n{\nfinal List<String> values = new ArrayList<String>();\n\nfor (final Option processedOption : options)\n{\nif (processedOption.equals(option))\n{\nvalues.addAll(processedOption.getValuesList());\n}\n}\n\nreturn values.isEmpty() ? null : values.toArray(new String[values.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
                                    "method_body": "private Option resolveOption(String opt)\n{\nopt = Util.stripLeadingHyphens(opt);\nfor (final Option option : options)\n{\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\n\nif (opt.equals(option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.CommandLine:addOption(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "protected void addOption(final Option opt)\n{\noptions.add(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createValue(Ljava/lang/String;Ljava/lang/Object;)Ljava/lang/Object;",
                                    "method_body": "public static Object createValue(final String str, final Object obj) throws ParseException\n{\nreturn createValue(str, (Class<?>) obj);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createValue(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public static Object createValue(final String str, final Class<?> clazz) throws ParseException\n{\nif (PatternOptionBuilder.STRING_VALUE == clazz)\n{\nreturn str;\n}\nelse if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n{\nreturn createObject(str);\n}\nelse if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n{\nreturn createNumber(str);\n}\nelse if (PatternOptionBuilder.DATE_VALUE == clazz)\n{\nreturn createDate(str);\n}\nelse if (PatternOptionBuilder.CLASS_VALUE == clazz)\n{\nreturn createClass(str);\n}\nelse if (PatternOptionBuilder.FILE_VALUE == clazz)\n{\nreturn createFile(str);\n}\nelse if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n{\nreturn createFile(str);\n}\nelse if (PatternOptionBuilder.FILES_VALUE == clazz)\n{\nreturn createFiles(str);\n}\nelse if (PatternOptionBuilder.URL_VALUE == clazz)\n{\nreturn createURL(str);\n}\nelse\n{\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createFile(Ljava/lang/String;)Ljava/io/File;",
                                    "method_body": "public static File createFile(final String str)\n{\nreturn new File(str);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:<clinit>()V",
                                    "method_body": "public static final Class<String> STRING_VALUE = String.class;\n\n/** Object class */\npublic static final Class<Object> OBJECT_VALUE = Object.class;\n\n/** Number class */\npublic static final Class<Number> NUMBER_VALUE = Number.class;\n\n/** Date class */\npublic static final Class<Date> DATE_VALUE = Date.class;\n\n/** Class class */\npublic static final Class<?> CLASS_VALUE = Class.class;\n\n/// can we do this one??\n// is meant to check that the file exists, else it errors.\n// ie) it's for reading not writing.\n\n/** FileInputStream class */\npublic static final Class<FileInputStream> EXISTING_FILE_VALUE = FileInputStream.class;\n\n/** File class */\npublic static final Class<File> FILE_VALUE = File.class;\n\n/** File array class */\npublic static final Class<File[]> FILES_VALUE = File[].class;\n\n/** URL class */\npublic static final Class<URL> URL_VALUE = URL.class;\n\n/**\n* Retrieve the class that <code>ch</code> represents.\n*\n* @param ch the specified character\n* @return The class that <code>ch</code> represents\n*/\npublic static Object getValueClass(final char ch)\n{\nswitch (ch)\n{\ncase '@':\nreturn PatternOptionBuilder.OBJECT_VALUE;\ncase ':':\nreturn PatternOptionBuilder.STRING_VALUE;\ncase '%':\nreturn PatternOptionBuilder.NUMBER_VALUE;\ncase '+':\nreturn PatternOptionBuilder.CLASS_VALUE;\ncase '#':\nreturn PatternOptionBuilder.DATE_VALUE;\ncase '<':\nreturn PatternOptionBuilder.EXISTING_FILE_VALUE;\ncase '>':\nreturn PatternOptionBuilder.FILE_VALUE;\ncase '*':\nreturn PatternOptionBuilder.FILES_VALUE;\ncase '/':\nreturn PatternOptionBuilder.URL_VALUE;\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:getValueClass(C)Ljava/lang/Object;",
                                    "method_body": "public static Object getValueClass(final char ch)\n{\nswitch (ch)\n{\ncase '@':\nreturn PatternOptionBuilder.OBJECT_VALUE;\ncase ':':\nreturn PatternOptionBuilder.STRING_VALUE;\ncase '%':\nreturn PatternOptionBuilder.NUMBER_VALUE;\ncase '+':\nreturn PatternOptionBuilder.CLASS_VALUE;\ncase '#':\nreturn PatternOptionBuilder.DATE_VALUE;\ncase '<':\nreturn PatternOptionBuilder.EXISTING_FILE_VALUE;\ncase '>':\nreturn PatternOptionBuilder.FILE_VALUE;\ncase '*':\nreturn PatternOptionBuilder.FILES_VALUE;\ncase '/':\nreturn PatternOptionBuilder.URL_VALUE;\n}\n\nreturn null;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:isValueCode(C)Z",
                                    "method_body": "public static boolean isValueCode(final char ch)\n{\nreturn ch == '@'\n|| ch == ':'\n|| ch == '%'\n|| ch == '+'\n|| ch == '#'\n|| ch == '<'\n|| ch == '>'\n|| ch == '*'\n|| ch == '/'\n|| ch == '!';\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:parsePattern(Ljava/lang/String;)Lorg/apache/commons/cli/Options;",
                                    "method_body": "public static Options parsePattern(final String pattern)\n{\nchar opt = ' ';\nboolean required = false;\nClass<?> type = null;\n\nfinal Options options = new Options();\n\nfor (int i = 0; i < pattern.length(); i++)\n{\nfinal char ch = pattern.charAt(i);\n\n// a value code comes after an option and specifies\n// details about it\nif (!isValueCode(ch))\n{\nif (opt != ' ')\n{\nfinal Option option = Option.builder(String.valueOf(opt))\n.hasArg(type != null)\n.required(required)\n.type(type)\n.build();\n\n// we have a previous one to deal with\noptions.addOption(option);\nrequired = false;\ntype = null;\nopt = ' ';\n}\n\nopt = ch;\n}\nelse if (ch == '!')\n{\nrequired = true;\n}\nelse\n{\ntype = (Class<?>) getValueClass(ch);\n}\n}\n\nif (opt != ' ')\n{\nfinal Option option = Option.builder(String.valueOf(opt))\n.hasArg(type != null)\n.required(required)\n.type(type)\n.build();\n\n// we have a final one to deal with\noptions.addOption(option);\n}\n\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:<init>(Ljava/lang/String;)V",
                                    "method_body": "private Builder(final String opt) throws IllegalArgumentException\n{\nOptionValidator.validateOption(opt);\nthis.opt = opt;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:required(Z)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder required(final boolean required)\n{\nthis.required = required;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:type(Ljava/lang/Class;)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder type(final Class<?> type)\n{\nthis.type = type;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:hasArg(Z)Lorg/apache/commons/cli/Option$Builder;",
                                    "method_body": "public Builder hasArg(final boolean hasArg)\n{\n// set to UNINITIALIZED when no arg is specified to be compatible with OptionBuilder\nnumberOfArgs = hasArg ? 1 : Option.UNINITIALIZED;\nreturn this;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Option$Builder:build()Lorg/apache/commons/cli/Option;",
                                    "method_body": "public Option build()\n{\nif (opt == null && longOpt == null)\n{\nthrow new IllegalArgumentException(\"Either opt or longOpt must be specified\");\n}\nreturn new Option(this);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:setOptions(Lorg/apache/commons/cli/Options;)V",
                                    "method_body": "protected void setOptions(final Options options)\n{\nthis.options = options;\nthis.requiredOptions = new ArrayList(options.getRequiredOptions());\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getOptions()Lorg/apache/commons/cli/Options;",
                                    "method_body": "protected Options getOptions()\n{\nreturn options;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:getRequiredOptions()Ljava/util/List;",
                                    "method_body": "protected List getRequiredOptions()\n{\nreturn requiredOptions;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(final Options options, final String[] arguments) throws ParseException\n{\nreturn parse(options, arguments, null, false);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
                                    "method_body": "public CommandLine parse(final Options options, String[] arguments, final Properties properties, final boolean stopAtNonOption)\nthrows ParseException\n{\n// clear out the data in options in case it's been used before (CLI-71)\nfor (final Option opt : options.helpOptions())\n{\nopt.clearValues();\n}\n\n// clear the data from the groups\nfor (final OptionGroup group : options.getOptionGroups())\n{\ngroup.setSelected(null);\n}\n\n// initialise members\nsetOptions(options);\n\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nfinal List<String> tokenList = Arrays.asList(flatten(getOptions(), arguments, stopAtNonOption));\n\nfinal ListIterator<String> iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nfinal String t = iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !getOptions().hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nfinal String str = iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
                                    "method_body": "protected void processProperties(final Properties properties) throws ParseException\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (final Enumeration<?> e = properties.propertyNames(); e.hasMoreElements();)\n{\nfinal String option = e.nextElement().toString();\n\nfinal Option opt = options.getOption(option);\nif (opt == null)\n{\nthrow new UnrecognizedOptionException(\"Default option wasn't defined\", option);\n}\n\n// if the option is part of a group, check if another option of the group has been selected\nfinal OptionGroup group = options.getOptionGroup(opt);\nfinal boolean selected = group != null && group.getSelected() != null;\n\nif (!cmd.hasOption(option) && !selected)\n{\n// get the value from the properties instance\nfinal String value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif (opt.getValues() == null || opt.getValues().length == 0)\n{\ntry\n{\nopt.addValueForProcessing(value);\n}\ncatch (final RuntimeException exp) //NOPMD\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\ncontinue;\n}\n\ncmd.addOption(opt);\nupdateRequiredOptions(opt);\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
                                    "method_body": "protected void checkRequiredOptions() throws MissingOptionException\n{\n// if there are required options that have not been processed\nif (!getRequiredOptions().isEmpty())\n{\nthrow new MissingOptionException(getRequiredOptions());\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processArgs(Lorg/apache/commons/cli/Option;Ljava/util/ListIterator;)V",
                                    "method_body": "public void processArgs(final Option opt, final ListIterator<String> iter) throws ParseException\n{\n// loop until an option is found\nwhile (iter.hasNext())\n{\nfinal String str = iter.next();\n\n// found an Option, not an argument\nif (getOptions().hasOption(str) && str.startsWith(\"-\"))\n{\niter.previous();\nbreak;\n}\n\n// found a value\ntry\n{\nopt.addValueForProcessing(Util.stripLeadingAndTrailingQuotes(str));\n}\ncatch (final RuntimeException exp)\n{\niter.previous();\nbreak;\n}\n}\n\nif (opt.getValues() == null && !opt.hasOptionalArg())\n{\nthrow new MissingArgumentException(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:processOption(Ljava/lang/String;Ljava/util/ListIterator;)V",
                                    "method_body": "protected void processOption(final String arg, final ListIterator<String> iter) throws ParseException\n{\nfinal boolean hasOption = getOptions().hasOption(arg);\n\n// if there is no option throw an UnrecognizedOptionException\nif (!hasOption)\n{\nthrow new UnrecognizedOptionException(\"Unrecognized option: \" + arg, arg);\n}\n\n// get the option represented by arg\nfinal Option opt = (Option) getOptions().getOption(arg).clone();\n\n// update the required options and groups\nupdateRequiredOptions(opt);\n\n// if the option takes an argument value\nif (opt.hasArg())\n{\nprocessArgs(opt, iter);\n}\n\n// set the option on the command line\ncmd.addOption(opt);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.Parser:updateRequiredOptions(Lorg/apache/commons/cli/Option;)V",
                                    "method_body": "private void updateRequiredOptions(final Option opt) throws ParseException\n{\n// if the option is a required option remove the option from\n// the requiredOptions list\nif (opt.isRequired())\n{\ngetRequiredOptions().remove(opt.getKey());\n}\n\n// if the option is in an OptionGroup make that option the selected\n// option of the group\nif (getOptions().getOptionGroup(opt) != null)\n{\nfinal OptionGroup group = getOptions().getOptionGroup(opt);\n\nif (group.isRequired())\n{\ngetRequiredOptions().remove(group);\n}\n\ngroup.setSelected(opt);\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:init()V",
                                    "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
                                    "method_body": "protected String[] flatten(final Options options, final String[] arguments, final boolean stopAtNonOption) throws ParseException\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nfinal Iterator<String> iter = Arrays.asList(arguments).iterator();\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\nfinal String token = iter.next();\n\n// single or double hyphen\nif (\"-\".equals(token) || \"--\".equals(token))\n{\ntokens.add(token);\n}\n\n// handle long option --foo or --foo=bar\nelse if (token.startsWith(\"--\"))\n{\nfinal int pos = token.indexOf('=');\nfinal String opt = pos == -1 ? token : token.substring(0, pos); // --foo\n\nfinal List<String> matchingOpts = options.getMatchingOptions(opt);\n\nif (matchingOpts.isEmpty())\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\nelse if (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(opt, matchingOpts);\n}\nelse\n{\ncurrentOption = options.getOption(matchingOpts.get(0));\n\ntokens.add(\"--\" + currentOption.getLongOpt());\nif (pos != -1)\n{\ntokens.add(token.substring(pos + 1));\n}\n}\n}\n\nelse if (token.startsWith(\"-\"))\n{\nif (token.length() == 2 || options.hasOption(token))\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (!options.getMatchingOptions(token).isEmpty())\n{\nfinal List<String> matchingOpts = options.getMatchingOptions(token);\nif (matchingOpts.size() > 1)\n{\nthrow new AmbiguousOptionException(token, matchingOpts);\n}\nfinal Option opt = options.getOption(matchingOpts.get(0));\nprocessOptionToken(\"-\" + opt.getLongOpt(), stopAtNonOption);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nprocessNonOptionToken(token, stopAtNonOption);\n}\n\ngobble(iter);\n}\n\nreturn tokens.toArray(new String[tokens.size()]);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:gobble(Ljava/util/Iterator;)V",
                                    "method_body": "private void gobble(final Iterator<String> iter)\n{\nif (eatTheRest)\n{\nwhile (iter.hasNext())\n{\ntokens.add(iter.next());\n}\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processNonOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processNonOptionToken(final String value, final boolean stopAtNonOption)\n{\nif (stopAtNonOption && (currentOption == null || !currentOption.hasArg()))\n{\neatTheRest = true;\ntokens.add(\"--\");\n}\n\ntokens.add(value);\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PosixParser:processOptionToken(Ljava/lang/String;Z)V",
                                    "method_body": "private void processOptionToken(final String token, final boolean stopAtNonOption)\n{\nif (stopAtNonOption && !options.hasOption(token))\n{\neatTheRest = true;\n}\n\nif (options.hasOption(token))\n{\ncurrentOption = options.getOption(token);\n}\n\ntokens.add(token);\n}"
                                }
                            ]
                        }
                    ]
                },
                {
                    "bug_id": 40,
                    "tests": [
                        {
                            "test_name": "org.apache.commons.cli.TypeHandlerTest.testCreateValueInteger_failure",
                            "test_body": "public void testCreateValueInteger_failure()\nthrows Exception\n{\nTypeHandler.createValue(\"just-a-string\", Integer.class);\n}\n",
                            "covered_methods": [
                                {
                                    "method_signature": "org.apache.commons.cli.TypeHandler:createValue(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
                                    "method_body": "public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\nif (PatternOptionBuilder.STRING_VALUE == clazz)\n{\nreturn (T) str;\n}\nelse if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n{\nreturn (T) createObject(str);\n}\nelse if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n{\nreturn (T) createNumber(str);\n}\nelse if (PatternOptionBuilder.DATE_VALUE == clazz)\n{\nreturn (T) createDate(str);\n}\nelse if (PatternOptionBuilder.CLASS_VALUE == clazz)\n{\nreturn (T) createClass(str);\n}\nelse if (PatternOptionBuilder.FILE_VALUE == clazz)\n{\nreturn (T) createFile(str);\n}\nelse if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n{\nreturn (T) openFile(str);\n}\nelse if (PatternOptionBuilder.FILES_VALUE == clazz)\n{\nreturn (T) createFiles(str);\n}\nelse if (PatternOptionBuilder.URL_VALUE == clazz)\n{\nreturn (T) createURL(str);\n}\nelse\n{\nreturn null;\n}\n}"
                                },
                                {
                                    "method_signature": "org.apache.commons.cli.PatternOptionBuilder:<clinit>()V",
                                    "method_body": "public static final Class<String> STRING_VALUE = String.class;\n\n/** Object class */\npublic static final Class<Object> OBJECT_VALUE = Object.class;\n\n/** Number class */\npublic static final Class<Number> NUMBER_VALUE = Number.class;\n\n/** Date class */\npublic static final Class<Date> DATE_VALUE = Date.class;\n\n/** Class class */\npublic static final Class<?> CLASS_VALUE = Class.class;\n\n/// can we do this one??\n// is meant to check that the file exists, else it errors.\n// ie) it's for reading not writing.\n\n/** FileInputStream class */\npublic static final Class<FileInputStream> EXISTING_FILE_VALUE = FileInputStream.class;\n\n/** File class */\npublic static final Class<File> FILE_VALUE = File.class;\n\n/** File array class */\npublic static final Class<File[]> FILES_VALUE = File[].class;\n\n/** URL class */\npublic static final Class<URL> URL_VALUE = URL.class;\n\n/**\n* Retrieve the class that <code>ch</code> represents.\n*\n* @param ch the specified character\n* @return The class that <code>ch</code> represents\n*/\npublic static Object getValueClass(final char ch)\n{\nswitch (ch)\n{\ncase '@':\nreturn PatternOptionBuilder.OBJECT_VALUE;\ncase ':':\nreturn PatternOptionBuilder.STRING_VALUE;\ncase '%':\nreturn PatternOptionBuilder.NUMBER_VALUE;\ncase '+':\nreturn PatternOptionBuilder.CLASS_VALUE;\ncase '#':\nreturn PatternOptionBuilder.DATE_VALUE;\ncase '<':\nreturn PatternOptionBuilder.EXISTING_FILE_VALUE;\ncase '>':\nreturn PatternOptionBuilder.FILE_VALUE;\ncase '*':\nreturn PatternOptionBuilder.FILES_VALUE;\ncase '/':\nreturn PatternOptionBuilder.URL_VALUE;\n}\n\nreturn null;\n}"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    ]
}