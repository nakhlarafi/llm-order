{
    "bug_id": 1,
    "test_id": 0,
    "test_name": "com.google.gson.functional.TypeVariableTest.testSingle",
    "test_body": "public void testSingle() throws Exception {\nGson gson = new Gson();\nBar bar1 = new Bar(\"someString\", 1);\nArrayList<Integer> arrayList = new ArrayList<Integer>();\narrayList.add(1);\narrayList.add(2);\nbar1.map.put(\"key1\", arrayList);\nbar1.map.put(\"key2\", new ArrayList<Integer>());\nString json = gson.toJson(bar1);\nSystem.out.println(json);\nBar bar2 = gson.fromJson(json, Bar.class);\nassertEquals(bar1, bar2);\n}\n",
    "stack_trace": "java.lang.UnsupportedOperationException: Expecting parameterized type, got class com.google.gson.functional.TypeVariableTest$Bar.\nAre you missing the use of TypeToken idiom?\nSee http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\nat com.google.gson.TypeInfoFactory.getActualType(TypeInfoFactory.java:97)\nat com.google.gson.TypeInfoFactory.getTypeInfoForField(TypeInfoFactory.java:54)\nat com.google.gson.ObjectNavigator.navigateClassFields(ObjectNavigator.java:156)\nat com.google.gson.ObjectNavigator.accept(ObjectNavigator.java:131)\nat com.google.gson.JsonSerializationContextDefault.serialize(JsonSerializationContextDefault.java:56)\nat com.google.gson.Gson.toJsonTree(Gson.java:231)\nat com.google.gson.Gson.toJson(Gson.java:271)\nat com.google.gson.Gson.toJson(Gson.java:251)\nat com.google.gson.functional.TypeVariableTest.testSingle(TypeVariableTest.java:41)",
    "covered_methods": [
        {
            "method_signature": "com.google.gson.ObjectNavigator:<init>(Lcom/google/gson/ObjectTypePair;Lcom/google/gson/ExclusionStrategy;)V",
            "method_body": "public void start(ObjectTypePair node);\n\npublic void end(ObjectTypePair node);\n\n/**\n* This is called before the object navigator starts visiting the current\n* object\n*/\nvoid startVisitingObject(Object node);\n\n/**\n* This is called to visit the current object if it is an array\n*/\nvoid visitArray(Object array, Type componentType);\n\n/**\n* This is called to visit an object field of the current object\n*/\nvoid visitObjectField(FieldAttributes f, Type typeOfF, Object obj);\n\n/**\n* This is called to visit an array field of the current object\n*/\nvoid visitArrayField(FieldAttributes f, Type typeOfF, Object obj);\n\n/**\n* This is called to visit an object using a custom handler\n*\n* @return true if a custom handler exists, false otherwise\n*/\npublic boolean visitUsingCustomHandler(ObjectTypePair objTypePair);\n\n/**\n* This is called to visit a field of the current object using a custom\n* handler\n*/\npublic boolean visitFieldUsingCustomHandler(FieldAttributes f, Type actualTypeOfField,\nObject parent);\n\n/**\n* Retrieve the current target\n*/\nObject getTarget();\n\nvoid visitPrimitive(Object primitive);\n}\n\nprivate final ExclusionStrategy exclusionStrategy;\nprivate final ObjectTypePair objTypePair;\n\n/**\n* @param objTypePair\n*          The object,type (fully genericized) being navigated\n* @param exclusionStrategy\n*          the concrete strategy object to be used to filter out fields of an\n*          object.\n*/\nObjectNavigator(ObjectTypePair objTypePair, ExclusionStrategy exclusionStrategy) {\nPreconditions.checkNotNull(exclusionStrategy);\n\nthis.objTypePair = objTypePair;\nthis.exclusionStrategy = exclusionStrategy;\n}",
            "method_id": 0,
            "loc": 63
        },
        {
            "method_signature": "com.google.gson.TypeInfoFactory:getActualType(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
            "method_body": "private static Type getActualType(\nType typeToEvaluate, Type parentType, Class<?> rawParentClass) {\nif (typeToEvaluate instanceof Class<?>) {\nreturn typeToEvaluate;\n} else if (typeToEvaluate instanceof ParameterizedType) {\nParameterizedType castedType = (ParameterizedType) typeToEvaluate;\nType owner = castedType.getOwnerType();\nType[] actualTypeParameters =\nextractRealTypes(castedType.getActualTypeArguments(), parentType, rawParentClass);\nType rawType = castedType.getRawType();\nreturn new ParameterizedTypeImpl(rawType, actualTypeParameters, owner);\n} else if (typeToEvaluate instanceof GenericArrayType) {\nGenericArrayType castedType = (GenericArrayType) typeToEvaluate;\nType componentType = castedType.getGenericComponentType();\nType actualType = getActualType(componentType, parentType, rawParentClass);\nif (componentType.equals(actualType)) {\nreturn castedType;\n}\nreturn actualType instanceof Class<?> ?\nTypeUtils.wrapWithArray(TypeUtils.toRawClass(actualType))\n: new GenericArrayTypeImpl(actualType);\n} else if (typeToEvaluate instanceof TypeVariable<?>) {\nif (parentType instanceof ParameterizedType) {\n// The class definition has the actual types used for the type variables.\n// Find the matching actual type for the Type Variable used for the field.\n// For example, class Foo<A> { A a; }\n// new Foo<Integer>(); defines the actual type of A to be Integer.\n// So, to find the type of the field a, we will have to look at the class'\n// actual type arguments.\nTypeVariable<?> fieldTypeVariable = (TypeVariable<?>) typeToEvaluate;\nTypeVariable<?>[] classTypeVariables = rawParentClass.getTypeParameters();\nParameterizedType objParameterizedType = (ParameterizedType) parentType;\nint indexOfActualTypeArgument = getIndex(classTypeVariables, fieldTypeVariable);\nType[] actualTypeArguments = objParameterizedType.getActualTypeArguments();\nreturn actualTypeArguments[indexOfActualTypeArgument];\n\n\n}\n\nthrow new UnsupportedOperationException(\"Expecting parameterized type, got \" + parentType\n+ \".\\n Are you missing the use of TypeToken idiom?\\n See \"\n+ \"http://sites.google.com/site/gson/gson-user-guide#TOC-Serializing-and-Deserializing-Gener\");\n} else if (typeToEvaluate instanceof WildcardType) {\nWildcardType castedType = (WildcardType) typeToEvaluate;\nreturn getActualType(castedType.getUpperBounds()[0], parentType, rawParentClass);\n} else {\nthrow new IllegalArgumentException(\"Type \\'\" + typeToEvaluate + \"\\' is not a Class, \"\n+ \"ParameterizedType, GenericArrayType or TypeVariable. Can't extract type.\");\n}\n}",
            "method_id": 1,
            "loc": 50
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters:createDefaultDeserializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
            "method_body": "private static ParameterizedTypeHandlerMap<JsonDeserializer<?>> createDefaultDeserializers() {\nParameterizedTypeHandlerMap<JsonDeserializer<?>> map =\nnew ParameterizedTypeHandlerMap<JsonDeserializer<?>>();\nmap.registerForTypeHierarchy(Enum.class, wrapDeserializer(ENUM_TYPE_ADAPTER));\nmap.register(URL.class, wrapDeserializer(URL_TYPE_ADAPTER));\nmap.register(URI.class, wrapDeserializer(URI_TYPE_ADAPTER));\nmap.register(UUID.class, wrapDeserializer(UUUID_TYPE_ADAPTER));\nmap.register(Locale.class, wrapDeserializer(LOCALE_TYPE_ADAPTER));\nmap.registerForTypeHierarchy(Collection.class, wrapDeserializer(COLLECTION_TYPE_ADAPTER));\nmap.registerForTypeHierarchy(Map.class, wrapDeserializer(MAP_TYPE_ADAPTER));\nmap.register(Date.class, wrapDeserializer(DATE_TYPE_ADAPTER));\nmap.register(java.sql.Date.class, wrapDeserializer(JAVA_SQL_DATE_TYPE_ADAPTER));\nmap.register(Timestamp.class, wrapDeserializer(TIMESTAMP_DESERIALIZER));\nmap.register(Time.class, wrapDeserializer(TIME_TYPE_ADAPTER));\nmap.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(BigDecimal.class, wrapDeserializer(BIG_DECIMAL_TYPE_ADAPTER));\nmap.register(BigInteger.class, wrapDeserializer(BIG_INTEGER_TYPE_ADAPTER));\n\n// Add primitive deserializers\nmap.register(Boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER));\nmap.register(boolean.class, wrapDeserializer(BOOLEAN_TYPE_ADAPTER));\nmap.register(Byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER));\nmap.register(byte.class, wrapDeserializer(BYTE_TYPE_ADAPTER));\nmap.register(Character.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER));\nmap.register(char.class, wrapDeserializer(CHARACTER_TYPE_ADAPTER));\nmap.register(Double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER));\nmap.register(double.class, wrapDeserializer(DOUBLE_TYPE_ADAPTER));\nmap.register(Float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER));\nmap.register(float.class, wrapDeserializer(FLOAT_TYPE_ADAPTER));\nmap.register(Integer.class, wrapDeserializer(INTEGER_TYPE_ADAPTER));\nmap.register(int.class, wrapDeserializer(INTEGER_TYPE_ADAPTER));\nmap.register(Long.class, wrapDeserializer(LONG_DESERIALIZER));\nmap.register(long.class, wrapDeserializer(LONG_DESERIALIZER));\nmap.register(Number.class, wrapDeserializer(NUMBER_TYPE_ADAPTER));\nmap.register(Short.class, wrapDeserializer(SHORT_TYPE_ADAPTER));\nmap.register(short.class, wrapDeserializer(SHORT_TYPE_ADAPTER));\nmap.register(String.class, wrapDeserializer(STRING_TYPE_ADAPTER));\n\nmap.makeUnmodifiable();\nreturn map;\n}",
            "method_id": 2,
            "loc": 42
        },
        {
            "method_signature": "com.google.gson.ObjectNavigator:accept(Lcom/google/gson/ObjectNavigator$Visitor;)V",
            "method_body": "public void accept(Visitor visitor) {\nTypeInfo objTypeInfo = new TypeInfo(objTypePair.type);\nif (exclusionStrategy.shouldSkipClass(objTypeInfo.getRawClass())) {\nreturn;\n}\nboolean visitedWithCustomHandler = visitor.visitUsingCustomHandler(objTypePair);\nif (!visitedWithCustomHandler) {\nObject obj = objTypePair.getObject();\nObject objectToVisit = (obj == null) ? visitor.getTarget() : obj;\nif (objectToVisit == null) {\nreturn;\n}\nobjTypePair.setObject(objectToVisit);\nvisitor.start(objTypePair);\ntry {\nif (objTypeInfo.isArray()) {\nvisitor.visitArray(objectToVisit, objTypePair.type);\n} else if (objTypeInfo.getActualType() == Object.class\n&& isPrimitiveOrString(objectToVisit)) {\n// TODO(Joel): this is only used for deserialization of \"primitives\"\n// we should rethink this!!!\nvisitor.visitPrimitive(objectToVisit);\nobjectToVisit = visitor.getTarget();\n} else {\nvisitor.startVisitingObject(objectToVisit);\nObjectTypePair currObjTypePair = objTypePair.toMoreSpecificType();\nClass<?> topLevelClass = new TypeInfo(currObjTypePair.type).getRawClass();\nfor (Class<?> curr = topLevelClass; curr != null && !curr.equals(Object.class); curr =\ncurr.getSuperclass()) {\nif (!curr.isSynthetic()) {\nnavigateClassFields(objectToVisit, curr, visitor);\n}\n}\n}\n} finally {\nvisitor.end(objTypePair);\n}\n}\n}",
            "method_id": 3,
            "loc": 39
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters:createDefaultSerializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
            "method_body": "private static ParameterizedTypeHandlerMap<JsonSerializer<?>> createDefaultSerializers() {\nParameterizedTypeHandlerMap<JsonSerializer<?>> map =\nnew ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n\nmap.registerForTypeHierarchy(Enum.class, ENUM_TYPE_ADAPTER);\nmap.register(URL.class, URL_TYPE_ADAPTER);\nmap.register(URI.class, URI_TYPE_ADAPTER);\nmap.register(UUID.class, UUUID_TYPE_ADAPTER);\nmap.register(Locale.class, LOCALE_TYPE_ADAPTER);\nmap.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\nmap.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\nmap.register(Date.class, DATE_TYPE_ADAPTER);\nmap.register(java.sql.Date.class, JAVA_SQL_DATE_TYPE_ADAPTER);\nmap.register(Timestamp.class, DATE_TYPE_ADAPTER);\nmap.register(Time.class, TIME_TYPE_ADAPTER);\nmap.register(Calendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(GregorianCalendar.class, GREGORIAN_CALENDAR_TYPE_ADAPTER);\nmap.register(BigDecimal.class, BIG_DECIMAL_TYPE_ADAPTER);\nmap.register(BigInteger.class, BIG_INTEGER_TYPE_ADAPTER);\n\n// Add primitive serializers\nmap.register(Boolean.class, BOOLEAN_TYPE_ADAPTER);\nmap.register(boolean.class, BOOLEAN_TYPE_ADAPTER);\nmap.register(Byte.class, BYTE_TYPE_ADAPTER);\nmap.register(byte.class, BYTE_TYPE_ADAPTER);\nmap.register(Character.class, CHARACTER_TYPE_ADAPTER);\nmap.register(char.class, CHARACTER_TYPE_ADAPTER);\nmap.register(Integer.class, INTEGER_TYPE_ADAPTER);\nmap.register(int.class, INTEGER_TYPE_ADAPTER);\nmap.register(Number.class, NUMBER_TYPE_ADAPTER);\nmap.register(Short.class, SHORT_TYPE_ADAPTER);\nmap.register(short.class, SHORT_TYPE_ADAPTER);\nmap.register(String.class, STRING_TYPE_ADAPTER);\n\nmap.makeUnmodifiable();\nreturn map;\n}",
            "method_id": 4,
            "loc": 37
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultSerializers(ZLcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/ParameterizedTypeHandlerMap;",
            "method_body": "static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers(\nboolean serializeSpecialFloatingPointValues, LongSerializationPolicy longSerializationPolicy) {\nParameterizedTypeHandlerMap<JsonSerializer<?>> serializers =\nnew ParameterizedTypeHandlerMap<JsonSerializer<?>>();\n\n// Double primitive\nDefaultTypeAdapters.DoubleSerializer doubleSerializer =\nnew DefaultTypeAdapters.DoubleSerializer(serializeSpecialFloatingPointValues);\nserializers.registerIfAbsent(Double.class, doubleSerializer);\nserializers.registerIfAbsent(double.class, doubleSerializer);\n\n// Float primitive\nDefaultTypeAdapters.FloatSerializer floatSerializer =\nnew DefaultTypeAdapters.FloatSerializer(serializeSpecialFloatingPointValues);\nserializers.registerIfAbsent(Float.class, floatSerializer);\nserializers.registerIfAbsent(float.class, floatSerializer);\n\n// Long primitive\nDefaultTypeAdapters.LongSerializer longSerializer =\nnew DefaultTypeAdapters.LongSerializer(longSerializationPolicy);\nserializers.registerIfAbsent(Long.class, longSerializer);\nserializers.registerIfAbsent(long.class, longSerializer);\n\nserializers.registerIfAbsent(DEFAULT_SERIALIZERS);\nreturn serializers;\n}",
            "method_id": 5,
            "loc": 26
        },
        {
            "method_signature": "com.google.gson.ObjectNavigator:navigateClassFields(Ljava/lang/Object;Ljava/lang/Class;Lcom/google/gson/ObjectNavigator$Visitor;)V",
            "method_body": "private void navigateClassFields(Object obj, Class<?> clazz, Visitor visitor) {\nField[] fields = clazz.getDeclaredFields();\nAccessibleObject.setAccessible(fields, true);\nfor (Field f : fields) {\nFieldAttributes fieldAttributes = new FieldAttributes(clazz, f);\nif (exclusionStrategy.shouldSkipField(fieldAttributes)\n|| exclusionStrategy.shouldSkipClass(fieldAttributes.getDeclaredClass())) {\ncontinue; // skip\n}\nTypeInfo fieldTypeInfo = TypeInfoFactory.getTypeInfoForField(f, objTypePair.type);\nType declaredTypeOfField = fieldTypeInfo.getActualType();\nboolean visitedWithCustomHandler =\nvisitor.visitFieldUsingCustomHandler(fieldAttributes, declaredTypeOfField, obj);\nif (!visitedWithCustomHandler) {\nif (fieldTypeInfo.isArray()) {\nvisitor.visitArrayField(fieldAttributes, declaredTypeOfField, obj);\n} else {\nvisitor.visitObjectField(fieldAttributes, declaredTypeOfField, obj);\n}\n}\n}\n}",
            "method_id": 6,
            "loc": 22
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerForTypeHierarchy(Lcom/google/gson/Pair;)V",
            "method_body": "public synchronized void registerForTypeHierarchy(Pair<Class<?>, T> pair) {\nif (!modifiable) {\nthrow new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n}\nint index = getIndexOfSpecificHandlerForTypeHierarchy(pair.first);\nif (index >= 0) {\nlogger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", pair.first);\ntypeHierarchyList.remove(index);\n}\nindex = getIndexOfAnOverriddenHandler(pair.first);\nif (index >= 0) {\nthrow new IllegalArgumentException(\"The specified type handler for type \" + pair.first\n+ \" hides the previously registered type hierarchy handler for \"\n+ typeHierarchyList.get(index).first + \". Gson does not allow this.\");\n}\n// We want stack behavior for adding to this list. A type adapter added subsequently should\n// override a previously registered one.\ntypeHierarchyList.add(0, pair);\n}",
            "method_id": 7,
            "loc": 19
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerIfAbsent(Lcom/google/gson/ParameterizedTypeHandlerMap;)V",
            "method_body": "public synchronized void registerIfAbsent(ParameterizedTypeHandlerMap<T> other) {\nif (!modifiable) {\nthrow new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n}\nfor (Map.Entry<Type, T> entry : other.map.entrySet()) {\nif (!map.containsKey(entry.getKey())) {\nregister(entry.getKey(), entry.getValue());\n}\n}\n// Quite important to traverse the typeHierarchyList from stack bottom first since\n// we want to register the handlers in the same order to preserve priority order\nfor (int i = other.typeHierarchyList.size()-1; i >= 0; --i) {\nPair<Class<?>, T> entry = other.typeHierarchyList.get(i);\nint index = getIndexOfSpecificHandlerForTypeHierarchy(entry.first);\nif (index < 0) {\nregisterForTypeHierarchy(entry);\n}\n}\n}",
            "method_id": 8,
            "loc": 19
        },
        {
            "method_signature": "com.google.gson.FieldAttributes:<clinit>()V",
            "method_body": "private static final String MAX_CACHE_PROPERTY_NAME =\n\"com.google.gson.annotation_cache_size_hint\";\n\nprivate static final Cache<Pair<Class<?>, String>, Collection<Annotation>> ANNOTATION_CACHE =\nnew LruCache<Pair<Class<?>,String>, Collection<Annotation>>(getMaxCacheSize());\n\nprivate final Class<?> declaringClazz;\nprivate final Field field;\nprivate final Class<?> declaredType;\nprivate final boolean isSynthetic;\nprivate final int modifiers;\nprivate final String name;\n\n// Fields used for lazy initialization\nprivate Type genericType;\nprivate Collection<Annotation> annotations;\n\n/**\n* Constructs a Field Attributes object from the {@code f}.",
            "method_id": 9,
            "loc": 19
        },
        {
            "method_signature": "com.google.gson.JsonSerializationVisitor:visitUsingCustomHandler(Lcom/google/gson/ObjectTypePair;)Z",
            "method_body": "public boolean visitUsingCustomHandler(ObjectTypePair objTypePair) {\ntry {\nObject obj = objTypePair.getObject();\nif (obj == null) {\nif (serializeNulls) {\nassignToRoot(JsonNull.createJsonNull());\n}\nreturn true;\n}\nJsonElement element = findAndInvokeCustomSerializer(objTypePair);\nif (element != null) {\nassignToRoot(element);\nreturn true;\n}\nreturn false;\n} catch (CircularReferenceException e) {\nthrow e.createDetailedException(null);\n}\n}",
            "method_id": 10,
            "loc": 19
        },
        {
            "method_signature": "com.google.gson.TypeUtils:toRawClass(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
            "method_body": "static Class<?> toRawClass(Type type) {\nif (type instanceof Class<?>) {\nreturn (Class<?>) type;\n} else if (type instanceof ParameterizedType) {\nParameterizedType actualType = (ParameterizedType)type;\nreturn toRawClass(actualType.getRawType());\n} else if (type instanceof GenericArrayType) {\nGenericArrayType actualType = (GenericArrayType) type;\nClass<?> rawClass = toRawClass(actualType.getGenericComponentType());\nreturn wrapWithArray(rawClass);\n} else if (type instanceof WildcardType) {\nWildcardType castedType = (WildcardType) type;\nreturn toRawClass(castedType.getUpperBounds()[0]);\n} else {\nthrow new IllegalArgumentException(\"Type \\'\" + type + \"\\' is not a Class, \"\n+ \"ParameterizedType, or GenericArrayType. Can't extract class.\");\n}\n}",
            "method_id": 11,
            "loc": 18
        },
        {
            "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/ExclusionStrategy;Lcom/google/gson/ExclusionStrategy;Lcom/google/gson/FieldNamingStrategy2;Lcom/google/gson/MappedObjectConstructor;ZLcom/google/gson/ParameterizedTypeHandlerMap;Lcom/google/gson/ParameterizedTypeHandlerMap;ZZZ)V",
            "method_body": "Gson(ExclusionStrategy serializationStrategy, ExclusionStrategy deserializationStrategy,\nFieldNamingStrategy2 fieldNamingPolicy, MappedObjectConstructor objectConstructor,\nboolean serializeNulls, ParameterizedTypeHandlerMap<JsonSerializer<?>> serializers,\nParameterizedTypeHandlerMap<JsonDeserializer<?>> deserializers,\nboolean generateNonExecutableGson, boolean htmlSafe, boolean prettyPrinting) {\nthis.serializationStrategy = serializationStrategy;\nthis.deserializationStrategy = deserializationStrategy;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.objectConstructor = objectConstructor;\nthis.serializeNulls = serializeNulls;\nthis.serializers = serializers;\nthis.deserializers = deserializers;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\n}",
            "method_id": 12,
            "loc": 16
        },
        {
            "method_signature": "com.google.gson.JsonSerializationVisitor:findAndInvokeCustomSerializer(Lcom/google/gson/ObjectTypePair;)Lcom/google/gson/JsonElement;",
            "method_body": "private JsonElement findAndInvokeCustomSerializer(ObjectTypePair objTypePair) {\nPair<JsonSerializer<?>,ObjectTypePair> pair = objTypePair.getMatchingHandler(serializers);\nif (pair == null) {\nreturn null;\n}\nJsonSerializer serializer = pair.first;\nobjTypePair = pair.second;\nstart(objTypePair);\ntry {\nJsonElement element =\nserializer.serialize(objTypePair.getObject(), objTypePair.getType(), context);\nreturn element == null ? JsonNull.createJsonNull() : element;\n} finally {\nend(objTypePair);\n}\n}",
            "method_id": 13,
            "loc": 16
        },
        {
            "method_signature": "com.google.gson.ObjectTypePair:getMatchingHandler(Lcom/google/gson/ParameterizedTypeHandlerMap;)Lcom/google/gson/Pair;",
            "method_body": "<HANDLER> Pair<HANDLER, ObjectTypePair> getMatchingHandler(\nParameterizedTypeHandlerMap<HANDLER> handlers) {\nHANDLER handler = null;\nif (!preserveType && obj != null) {\n// First try looking up the handler for the actual type\nObjectTypePair moreSpecificType = toMoreSpecificType();\nhandler = handlers.getHandlerFor(moreSpecificType.type);\nif (handler != null) {\nreturn new Pair<HANDLER, ObjectTypePair>(handler, moreSpecificType);\n}\n}\n// Try the specified type\nhandler = handlers.getHandlerFor(type);\nreturn handler == null ? null : new Pair<HANDLER, ObjectTypePair>(handler, this);\n}",
            "method_id": 14,
            "loc": 15
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters:createDefaultInstanceCreators()Lcom/google/gson/ParameterizedTypeHandlerMap;",
            "method_body": "private static ParameterizedTypeHandlerMap<InstanceCreator<?>> createDefaultInstanceCreators() {\nParameterizedTypeHandlerMap<InstanceCreator<?>> map =\nnew ParameterizedTypeHandlerMap<InstanceCreator<?>>();\nmap.registerForTypeHierarchy(Map.class, MAP_TYPE_ADAPTER);\n\n// Add Collection type instance creators\nmap.registerForTypeHierarchy(Collection.class, COLLECTION_TYPE_ADAPTER);\n\nmap.registerForTypeHierarchy(Set.class, HASH_SET_CREATOR);\nmap.registerForTypeHierarchy(SortedSet.class, TREE_SET_CREATOR);\nmap.register(Properties.class, PROPERTIES_CREATOR);\nmap.makeUnmodifiable();\nreturn map;\n}",
            "method_id": 15,
            "loc": 14
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getHandlerFor(Ljava/lang/reflect/Type;)Ljava/lang/Object;",
            "method_body": "public synchronized T getHandlerFor(Type type) {\nT handler = map.get(type);\nif (handler == null) {\nClass<?> rawClass = TypeUtils.toRawClass(type);\nif (rawClass != type) {\nhandler = getHandlerFor(rawClass);\n}\nif (handler == null) {\n// check if something registered for type hierarchy\nhandler = getHandlerForTypeHierarchy(rawClass);\n}\n}\nreturn handler;\n}",
            "method_id": 16,
            "loc": 14
        },
        {
            "method_signature": "com.google.gson.MemoryRefStack:contains(Lcom/google/gson/ObjectTypePair;)Z",
            "method_body": "public boolean contains(ObjectTypePair obj) {\nif (obj == null) {\nreturn false;\n}\n\nfor (ObjectTypePair stackObject : stack) {\nif (stackObject.getObject() == obj.getObject()\n&& stackObject.type.equals(obj.type) ) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 17,
            "loc": 13
        },
        {
            "method_signature": "com.google.gson.Gson:<clinit>()V",
            "method_body": "private static final String NULL_STRING = \"null\";\n\nstatic final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\n\n// Default instances of plug-ins\nstatic final AnonymousAndLocalClassExclusionStrategy DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY =\nnew AnonymousAndLocalClassExclusionStrategy();\nstatic final SyntheticFieldExclusionStrategy DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY =\nnew SyntheticFieldExclusionStrategy(true);\nstatic final ModifierBasedExclusionStrategy DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY =\nnew ModifierBasedExclusionStrategy(new int[] { Modifier.TRANSIENT, Modifier.STATIC });",
            "method_id": 18,
            "loc": 11
        },
        {
            "method_signature": "com.google.gson.JsonFieldNameValidator:<clinit>()V",
            "method_body": "private static final String COMMON_PATTERN = \"[a-zA-Z][a-zA-Z0-9\\\\ \\\\$_\\\\-]*$\";\n\nprivate static final Pattern JSON_FIELD_NAME_PATTERN =\nPattern.compile(\"(^\" + COMMON_PATTERN + \")|(^[\\\\$_]\" + COMMON_PATTERN + \")\");\n\n\n/**\n* Performs validation on the JSON field name to ensure it is a valid field name.\n*\n* @param fieldName the name of the field to validate\n* @return {@code fieldName} if it is a valid JSON field name",
            "method_id": 19,
            "loc": 11
        },
        {
            "method_signature": "com.google.gson.Gson:createExclusionStrategy(D)Lcom/google/gson/ExclusionStrategy;",
            "method_body": "private static ExclusionStrategy createExclusionStrategy(double version) {\nList<ExclusionStrategy> strategies = new LinkedList<ExclusionStrategy>();\nstrategies.add(DEFAULT_ANON_LOCAL_CLASS_EXCLUSION_STRATEGY);\nstrategies.add(DEFAULT_SYNTHETIC_FIELD_EXCLUSION_STRATEGY);\nstrategies.add(DEFAULT_MODIFIER_BASED_EXCLUSION_STRATEGY);\nif (version != VersionConstants.IGNORE_VERSIONS) {\nstrategies.add(new VersionExclusionStrategy(version));\n}\nreturn new DisjunctionExclusionStrategy(strategies);\n}",
            "method_id": 20,
            "loc": 10
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:<clinit>()V",
            "method_body": "private static final Logger logger =\nLogger.getLogger(ParameterizedTypeHandlerMap.class.getName());\nprivate final Map<Type, T> map = new HashMap<Type, T>();\nprivate final List<Pair<Class<?>, T>> typeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\nprivate boolean modifiable = true;\n\npublic synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) {\nPair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\nregisterForTypeHierarchy(pair);\n}",
            "method_id": 21,
            "loc": 10
        },
        {
            "method_signature": "com.google.gson.FieldAttributes:getMaxCacheSize()I",
            "method_body": "private static int getMaxCacheSize() {\nfinal int defaultMaxCacheSize = 2000;\ntry {\nString propertyValue = System.getProperty(\nMAX_CACHE_PROPERTY_NAME, String.valueOf(defaultMaxCacheSize));\nreturn Integer.parseInt(propertyValue);\n} catch (NumberFormatException e) {\nreturn defaultMaxCacheSize;\n}\n}",
            "method_id": 22,
            "loc": 10
        },
        {
            "method_signature": "com.google.gson.ObjectTypePair:toMoreSpecificType()Lcom/google/gson/ObjectTypePair;",
            "method_body": "ObjectTypePair toMoreSpecificType() {\nif (preserveType || obj == null) {\nreturn this;\n}\nType actualType = getActualTypeIfMoreSpecific(type, obj.getClass());\nif (actualType == type) {\nreturn this;\n}\nreturn new ObjectTypePair(obj, actualType, preserveType);\n}",
            "method_id": 23,
            "loc": 10
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters:<clinit>()V",
            "method_body": "private static final DefaultDateTypeAdapter DATE_TYPE_ADAPTER = new DefaultDateTypeAdapter();\nprivate static final DefaultJavaSqlDateTypeAdapter JAVA_SQL_DATE_TYPE_ADAPTER =\nnew DefaultJavaSqlDateTypeAdapter();\nprivate static final DefaultTimeTypeAdapter TIME_TYPE_ADAPTER =\nnew DefaultTimeTypeAdapter();\nprivate static final DefaultTimestampDeserializer TIMESTAMP_DESERIALIZER =\nnew DefaultTimestampDeserializer();\n\n@SuppressWarnings({ \"rawtypes\" })",
            "method_id": 24,
            "loc": 9
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getIndexOfAnOverriddenHandler(Ljava/lang/Class;)I",
            "method_body": "private int getIndexOfAnOverriddenHandler(Class<?> type) {\nfor (int i = typeHierarchyList.size()-1; i >= 0; --i) {\nPair<Class<?>, T> entry = typeHierarchyList.get(i);\nif (type.isAssignableFrom(entry.first)) {\nreturn i;\n}\n}\nreturn -1;\n}",
            "method_id": 25,
            "loc": 9
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:register(Ljava/lang/reflect/Type;Ljava/lang/Object;)V",
            "method_body": "public synchronized void register(Type typeOfT, T value) {\nif (!modifiable) {\nthrow new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n}\nif (hasSpecificHandlerFor(typeOfT)) {\nlogger.log(Level.WARNING, \"Overriding the existing type handler for {0}\", typeOfT);\n}\nmap.put(typeOfT, value);\n}",
            "method_id": 26,
            "loc": 9
        },
        {
            "method_signature": "com.google.gson.TypeUtils:isArray(Ljava/lang/reflect/Type;)Z",
            "method_body": "static boolean isArray(Type type) {\nif (type instanceof Class<?>) {\nreturn ((Class<?>)type).isArray();\n} else if (type instanceof GenericArrayType) {\nreturn true;\n} else {\nreturn false;\n}\n}",
            "method_id": 27,
            "loc": 9
        },
        {
            "method_signature": "com.google.gson.FieldAttributes:<init>(Ljava/lang/Class;Ljava/lang/reflect/Field;)V",
            "method_body": "FieldAttributes(final Class<?> declaringClazz, final Field f) {\nPreconditions.checkNotNull(declaringClazz);\nthis.declaringClazz = declaringClazz;\nname = f.getName();\ndeclaredType = f.getType();\nisSynthetic = f.isSynthetic();\nmodifiers = f.getModifiers();\nfield = f;\n}",
            "method_id": 28,
            "loc": 9
        },
        {
            "method_signature": "com.google.gson.JsonSerializationVisitor:<init>(Lcom/google/gson/ObjectNavigatorFactory;ZLcom/google/gson/ParameterizedTypeHandlerMap;Lcom/google/gson/JsonSerializationContext;Lcom/google/gson/MemoryRefStack;)V",
            "method_body": "JsonSerializationVisitor(ObjectNavigatorFactory factory, boolean serializeNulls,\nParameterizedTypeHandlerMap<JsonSerializer<?>> serializers, JsonSerializationContext context,\nMemoryRefStack ancestors) {\nthis.factory = factory;\nthis.serializeNulls = serializeNulls;\nthis.serializers = serializers;\nthis.context = context;\nthis.ancestors = ancestors;\n}",
            "method_id": 29,
            "loc": 9
        },
        {
            "method_signature": "com.google.gson.JsonSerializationVisitor:start(Lcom/google/gson/ObjectTypePair;)V",
            "method_body": "public void start(ObjectTypePair node) {\nif (node == null) {\nreturn;\n}\nif (ancestors.contains(node)) {\nthrow new CircularReferenceException(node);\n}\nancestors.push(node);\n}",
            "method_id": 30,
            "loc": 9
        },
        {
            "method_signature": "com.google.gson.Gson:toJsonTree(Ljava/lang/Object;Ljava/lang/reflect/Type;)Lcom/google/gson/JsonElement;",
            "method_body": "public JsonElement toJsonTree(Object src, Type typeOfSrc) {\nif (src == null) {\nreturn JsonNull.createJsonNull();\n}\nJsonSerializationContextDefault context = new JsonSerializationContextDefault(\ncreateDefaultObjectNavigatorFactory(serializationStrategy), serializeNulls, serializers);\nreturn context.serialize(src, typeOfSrc, true);\n}",
            "method_id": 31,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.ModifierBasedExclusionStrategy:<init>([I)V",
            "method_body": "public ModifierBasedExclusionStrategy(int... modifiers) {\nthis.modifiers = new HashSet<Integer>();\nif (modifiers != null) {\nfor (int modifier : modifiers) {\nthis.modifiers.add(modifier);\n}\n}\n}",
            "method_id": 32,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.ModifierBasedExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
            "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nfor (int modifier : modifiers) {\nif (f.hasModifier(modifier)) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 33,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.DisjunctionExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
            "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nfor (ExclusionStrategy strategy : strategies) {\nif (strategy.shouldSkipField(f)) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 34,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.DisjunctionExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
            "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nfor (ExclusionStrategy strategy : strategies) {\nif (strategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 35,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.MappedObjectConstructor:<clinit>()V",
            "method_body": "private static final Logger log = Logger.getLogger(MappedObjectConstructor.class.getName());\n\nprivate final ParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreatorMap;\n\npublic MappedObjectConstructor(\nParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\ninstanceCreatorMap = instanceCreators;\n}",
            "method_id": 36,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerIfAbsent(Ljava/lang/reflect/Type;Ljava/lang/Object;)V",
            "method_body": "public synchronized void registerIfAbsent(Type typeOfT, T value) {\nif (!modifiable) {\nthrow new IllegalStateException(\"Attempted to modify an unmodifiable map.\");\n}\nif (!map.containsKey(typeOfT)) {\nregister(typeOfT, value);\n}\n}",
            "method_id": 37,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getHandlerForTypeHierarchy(Ljava/lang/Class;)Ljava/lang/Object;",
            "method_body": "private T getHandlerForTypeHierarchy(Class<?> type) {\nfor (Pair<Class<?>, T> entry : typeHierarchyList) {\nif (entry.first.isAssignableFrom(type)) {\nreturn entry.second;\n}\n}\nreturn null;\n}",
            "method_id": 38,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:getIndexOfSpecificHandlerForTypeHierarchy(Ljava/lang/Class;)I",
            "method_body": "private synchronized int getIndexOfSpecificHandlerForTypeHierarchy(Class<?> type) {\nfor (int i = typeHierarchyList.size()-1; i >= 0; --i) {\nif (type.equals(typeHierarchyList.get(i).first)) {\nreturn i;\n}\n}\nreturn -1;\n}",
            "method_id": 39,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.LongSerializationPolicy$DefaultStrategy:<init>(Lcom/google/gson/LongSerializationPolicy$1;)V",
            "method_body": "JsonElement serialize(Long value);\n}\n\nprivate static class DefaultStrategy implements Strategy {\npublic JsonElement serialize(Long value) {\nreturn new JsonPrimitive(value);\n}\n}",
            "method_id": 40,
            "loc": 8
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:<init>()V",
            "method_body": "private static final Logger logger =\nprivate final Map<Type, T> map = new HashMap<Type, T>();\nprivate final List<Pair<Class<?>, T>> typeHierarchyList = new ArrayList<Pair<Class<?>, T>>();\nprivate boolean modifiable = true;\nPair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\nregisterForTypeHierarchy(pair);\n}",
            "method_id": 41,
            "loc": 7
        },
        {
            "method_signature": "com.google.gson.JsonSerializationContextDefault:<init>(Lcom/google/gson/ObjectNavigatorFactory;ZLcom/google/gson/ParameterizedTypeHandlerMap;)V",
            "method_body": "JsonSerializationContextDefault(ObjectNavigatorFactory factory, boolean serializeNulls,\nParameterizedTypeHandlerMap<JsonSerializer<?>> serializers) {\nthis.factory = factory;\nthis.serializeNulls = serializeNulls;\nthis.serializers = serializers;\nthis.ancestors = new MemoryRefStack();\n}",
            "method_id": 42,
            "loc": 7
        },
        {
            "method_signature": "com.google.gson.JsonSerializationContextDefault:serialize(Ljava/lang/Object;Ljava/lang/reflect/Type;Z)Lcom/google/gson/JsonElement;",
            "method_body": "public JsonElement serialize(Object src, Type typeOfSrc, boolean preserveType) {\nObjectNavigator on = factory.create(new ObjectTypePair(src, typeOfSrc, preserveType));\nJsonSerializationVisitor visitor =\nnew JsonSerializationVisitor(factory, serializeNulls, serializers, this, ancestors);\non.accept(visitor);\nreturn visitor.getJsonElement();\n}",
            "method_id": 43,
            "loc": 7
        },
        {
            "method_signature": "com.google.gson.Gson:<init>()V",
            "method_body": "public Gson() {\nthis(DEFAULT_EXCLUSION_STRATEGY, DEFAULT_EXCLUSION_STRATEGY, DEFAULT_NAMING_POLICY,\nnew MappedObjectConstructor(DefaultTypeAdapters.getDefaultInstanceCreators()),\nfalse, DefaultTypeAdapters.getDefaultSerializers(),\nDefaultTypeAdapters.getDefaultDeserializers(), DEFAULT_JSON_NON_EXECUTABLE, true, false);\n}",
            "method_id": 44,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;)Ljava/lang/String;",
            "method_body": "public String toJson(Object src) {\nif (src == null) {\nreturn serializeNulls ? NULL_STRING : \"\";\n}\nreturn toJson(src, src.getClass());\n}",
            "method_id": 45,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.JsonElement:<clinit>()V",
            "method_body": "private static final Escaper BASIC_ESCAPER = new Escaper(false);\n\n/**\n* provides check for verifying if this element is an array or not.\n*\n* @return true if this element is of type {@link JsonArray}, false otherwise.",
            "method_id": 46,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.SerializedNameAnnotationInterceptingNamingPolicy:<clinit>()V",
            "method_body": "private static final JsonFieldNameValidator fieldNameValidator = new JsonFieldNameValidator();\nprivate final FieldNamingStrategy2 delegate;\n\npublic SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) {\nthis.delegate = delegate;\n}",
            "method_id": 47,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.TypeInfoFactory:getTypeInfoForField(Ljava/lang/reflect/Field;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeInfo;",
            "method_body": "public static TypeInfo getTypeInfoForField(Field f, Type typeDefiningF) {\nClass<?> classDefiningF = TypeUtils.toRawClass(typeDefiningF);\nType type = f.getGenericType();\nType actualType = getActualType(type, typeDefiningF, classDefiningF);\nreturn new TypeInfo(actualType);\n}",
            "method_id": 48,
            "loc": 6
        },
        {
            "method_signature": "com.google.gson.Preconditions:checkArgument(Z)V",
            "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException(\"condition failed: \" + condition);\n}\n}",
            "method_id": 49,
            "loc": 5
        },
        {
            "method_signature": "com.google.gson.Gson:toJson(Ljava/lang/Object;Ljava/lang/reflect/Type;)Ljava/lang/String;",
            "method_body": "public String toJson(Object src, Type typeOfSrc) {\nStringWriter writer = new StringWriter();\ntoJson(toJsonTree(src, typeOfSrc), writer);\nreturn writer.toString();\n}",
            "method_id": 50,
            "loc": 5
        },
        {
            "method_signature": "com.google.gson.ObjectNavigatorFactory:<init>(Lcom/google/gson/ExclusionStrategy;Lcom/google/gson/FieldNamingStrategy2;)V",
            "method_body": "public ObjectNavigatorFactory(ExclusionStrategy strategy, FieldNamingStrategy2 fieldNamingPolicy) {\nPreconditions.checkNotNull(fieldNamingPolicy);\nthis.strategy = (strategy == null ? new NullExclusionStrategy() : strategy);\nthis.fieldNamingPolicy = fieldNamingPolicy;\n}",
            "method_id": 51,
            "loc": 5
        },
        {
            "method_signature": "com.google.gson.MemoryRefStack:push(Lcom/google/gson/ObjectTypePair;)Lcom/google/gson/ObjectTypePair;",
            "method_body": "public ObjectTypePair push(ObjectTypePair obj) {\nPreconditions.checkNotNull(obj);\n\nreturn stack.push(obj);\n}",
            "method_id": 52,
            "loc": 5
        },
        {
            "method_signature": "com.google.gson.ObjectTypePair:<init>(Ljava/lang/Object;Ljava/lang/reflect/Type;Z)V",
            "method_body": "ObjectTypePair(Object obj, Type type, boolean preserveType) {\nthis.obj = obj;\nthis.type = type;\nthis.preserveType = preserveType;\n}",
            "method_id": 53,
            "loc": 5
        },
        {
            "method_signature": "com.google.gson.JsonSerializationVisitor:end(Lcom/google/gson/ObjectTypePair;)V",
            "method_body": "public void end(ObjectTypePair node) {\nif (node != null) {\nancestors.pop();\n}\n}",
            "method_id": 54,
            "loc": 5
        },
        {
            "method_signature": "com.google.gson.MemoryRefStack:<init>()V",
            "method_body": "private final Stack<ObjectTypePair> stack = new Stack<ObjectTypePair>();\nPreconditions.checkNotNull(obj);\nreturn stack.push(obj);\n}",
            "method_id": 55,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.AnonymousAndLocalClassExclusionStrategy:isAnonymousOrLocal(Ljava/lang/Class;)Z",
            "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}",
            "method_id": 56,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.DisjunctionExclusionStrategy:<init>(Ljava/util/Collection;)V",
            "method_body": "public DisjunctionExclusionStrategy(Collection<ExclusionStrategy> strategies) {\nPreconditions.checkNotNull(strategies);\nthis.strategies = strategies;\n}",
            "method_id": 57,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.MappedObjectConstructor:<init>(Lcom/google/gson/ParameterizedTypeHandlerMap;)V",
            "method_body": "public MappedObjectConstructor(\nParameterizedTypeHandlerMap<InstanceCreator<?>> instanceCreators) {\ninstanceCreatorMap = instanceCreators;\n}",
            "method_id": 58,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:registerForTypeHierarchy(Ljava/lang/Class;Ljava/lang/Object;)V",
            "method_body": "public synchronized void registerForTypeHierarchy(Class<?> typeOfT, T value) {\nPair<Class<?>, T> pair = new Pair<Class<?>, T>(typeOfT, value);\nregisterForTypeHierarchy(pair);\n}",
            "method_id": 59,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
            "method_body": "Pair(FIRST first, SECOND second) {\nthis.first = first;\nthis.second = second;\n}",
            "method_id": 60,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.JsonDeserializerExceptionWrapper:<init>(Lcom/google/gson/JsonDeserializer;)V",
            "method_body": "JsonDeserializerExceptionWrapper(JsonDeserializer<T> delegate) {\nPreconditions.checkNotNull(delegate);\nthis.delegate = delegate;\n}",
            "method_id": 61,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.TypeInfo:<init>(Ljava/lang/reflect/Type;)V",
            "method_body": "TypeInfo(Type actualType) {\nthis.actualType = actualType;\nrawClass = TypeUtils.toRawClass(actualType);\n}",
            "method_id": 62,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.LruCache:<init>(I)V",
            "method_body": "LruCache(int maxCapacity) {\nsuper(maxCapacity, 0.7F, true);\nthis.maxCapacity = maxCapacity;\n}",
            "method_id": 63,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.JsonSerializationVisitor:assignToRoot(Lcom/google/gson/JsonElement;)V",
            "method_body": "private void assignToRoot(JsonElement newRoot) {\nPreconditions.checkNotNull(newRoot);\nroot = newRoot;\n}",
            "method_id": 64,
            "loc": 4
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultSerializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
            "method_body": "static ParameterizedTypeHandlerMap<JsonSerializer<?>> getDefaultSerializers() {\nreturn getDefaultSerializers(false, LongSerializationPolicy.DEFAULT);\n}",
            "method_id": 65,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.Preconditions:checkNotNull(Ljava/lang/Object;)V",
            "method_body": "public static void checkNotNull(Object obj) {\ncheckArgument(obj != null);\n}",
            "method_id": 66,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.Escaper:<init>(Z)V",
            "method_body": "Escaper(boolean escapeHtmlCharacters) {\nthis.escapeHtmlCharacters = escapeHtmlCharacters;\n}",
            "method_id": 67,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.Escaper:<clinit>()V",
            "method_body": "private static final char[] HEX_CHARS = {\n'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'\n};",
            "method_id": 68,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.JsonObject:<init>()V",
            "method_body": "public JsonObject() {\nmembers = new LinkedHashMap<String, JsonElement>();\n}",
            "method_id": 69,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.Gson:createDefaultObjectNavigatorFactory(Lcom/google/gson/ExclusionStrategy;)Lcom/google/gson/ObjectNavigatorFactory;",
            "method_body": "private ObjectNavigatorFactory createDefaultObjectNavigatorFactory(ExclusionStrategy strategy) {\nreturn new ObjectNavigatorFactory(strategy, fieldNamingPolicy);\n}",
            "method_id": 70,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.AnonymousAndLocalClassExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
            "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nreturn isAnonymousOrLocal(f.getDeclaredClass());\n}",
            "method_id": 71,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.AnonymousAndLocalClassExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
            "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nreturn isAnonymousOrLocal(clazz);\n}",
            "method_id": 72,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.SyntheticFieldExclusionStrategy:<init>(Z)V",
            "method_body": "SyntheticFieldExclusionStrategy(boolean skipSyntheticFields) {\nthis.skipSyntheticFields = skipSyntheticFields;\n}",
            "method_id": 73,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.SyntheticFieldExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
            "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nreturn false;\n}",
            "method_id": 74,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.SyntheticFieldExclusionStrategy:shouldSkipField(Lcom/google/gson/FieldAttributes;)Z",
            "method_body": "public boolean shouldSkipField(FieldAttributes f) {\nreturn skipSyntheticFields && f.isSynthetic();\n}",
            "method_id": 75,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.ModifierBasedExclusionStrategy:shouldSkipClass(Ljava/lang/Class;)Z",
            "method_body": "public boolean shouldSkipClass(Class<?> clazz) {\nreturn false;\n}",
            "method_id": 76,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.SerializedNameAnnotationInterceptingNamingPolicy:<init>(Lcom/google/gson/FieldNamingStrategy2;)V",
            "method_body": "public SerializedNameAnnotationInterceptingNamingPolicy(FieldNamingStrategy2 delegate) {\nthis.delegate = delegate;\n}",
            "method_id": 77,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters:wrapDeserializer(Lcom/google/gson/JsonDeserializer;)Lcom/google/gson/JsonDeserializer;",
            "method_body": "private static JsonDeserializer<?> wrapDeserializer(JsonDeserializer<?> deserializer) {\nreturn new JsonDeserializerExceptionWrapper(deserializer);\n}",
            "method_id": 78,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultDeserializers()Lcom/google/gson/ParameterizedTypeHandlerMap;",
            "method_body": "static ParameterizedTypeHandlerMap<JsonDeserializer<?>> getDefaultDeserializers() {\nreturn DEFAULT_DESERIALIZERS;\n}",
            "method_id": 79,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters:getDefaultInstanceCreators()Lcom/google/gson/ParameterizedTypeHandlerMap;",
            "method_body": "static ParameterizedTypeHandlerMap<InstanceCreator<?>> getDefaultInstanceCreators() {\nreturn DEFAULT_INSTANCE_CREATORS;\n}",
            "method_id": 80,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters$DefaultDateTypeAdapter:<init>()V",
            "method_body": "DefaultDateTypeAdapter() {\nthis.format = DateFormat.getDateTimeInstance();\n}",
            "method_id": 81,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters$DefaultJavaSqlDateTypeAdapter:<init>()V",
            "method_body": "DefaultJavaSqlDateTypeAdapter() {\nthis.format = new SimpleDateFormat(\"MMM d, yyyy\");\n}",
            "method_id": 82,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters$DefaultTimeTypeAdapter:<init>()V",
            "method_body": "DefaultTimeTypeAdapter() {\nthis.format = new SimpleDateFormat(\"hh:mm:ss a\");\n}",
            "method_id": 83,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:makeUnmodifiable()V",
            "method_body": "public synchronized void makeUnmodifiable() {\nmodifiable = false;\n}",
            "method_id": 84,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.ParameterizedTypeHandlerMap:hasSpecificHandlerFor(Ljava/lang/reflect/Type;)Z",
            "method_body": "public synchronized boolean hasSpecificHandlerFor(Type type) {\nreturn map.containsKey(type);\n}",
            "method_id": 85,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.LongSerializationPolicy:<init>(Ljava/lang/String;ILcom/google/gson/LongSerializationPolicy$Strategy;)V",
            "method_body": "private LongSerializationPolicy(Strategy strategy) {\nthis.strategy = strategy;\n}",
            "method_id": 86,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters$DoubleSerializer:<init>(Z)V",
            "method_body": "DoubleSerializer(boolean serializeSpecialDoubleValues) {\nthis.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues;\n}",
            "method_id": 87,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters$FloatSerializer:<init>(Z)V",
            "method_body": "FloatSerializer(boolean serializeSpecialDoubleValues) {\nthis.serializeSpecialFloatingPointValues = serializeSpecialDoubleValues;\n}",
            "method_id": 88,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.DefaultTypeAdapters$LongSerializer:<init>(Lcom/google/gson/LongSerializationPolicy;)V",
            "method_body": "private LongSerializer(LongSerializationPolicy longSerializationPolicy) {\nthis.longSerializationPolicy = longSerializationPolicy;\n}",
            "method_id": 89,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.TypeInfo:getActualType()Ljava/lang/reflect/Type;",
            "method_body": "public final Type getActualType() {\nreturn actualType;\n}",
            "method_id": 90,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.TypeInfo:getRawClass()Ljava/lang/Class;",
            "method_body": "public final Class<?> getRawClass() {\nreturn rawClass;\n}",
            "method_id": 91,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.TypeInfo:isArray()Z",
            "method_body": "public final boolean isArray() {\nreturn TypeUtils.isArray(rawClass);\n}",
            "method_id": 92,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.FieldAttributes:getDeclaredClass()Ljava/lang/Class;",
            "method_body": "public Class<?> getDeclaredClass() {\nreturn declaredType;\n}",
            "method_id": 93,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.FieldAttributes:hasModifier(I)Z",
            "method_body": "public boolean hasModifier(int modifier) {\nreturn (modifiers & modifier) != 0;\n}",
            "method_id": 94,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.FieldAttributes:isSynthetic()Z",
            "method_body": "boolean isSynthetic() {\nreturn isSynthetic;\n}",
            "method_id": 95,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.ObjectNavigatorFactory:create(Lcom/google/gson/ObjectTypePair;)Lcom/google/gson/ObjectNavigator;",
            "method_body": "public ObjectNavigator create(ObjectTypePair objTypePair) {\nreturn new ObjectNavigator(objTypePair, strategy);\n}",
            "method_id": 96,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.MemoryRefStack:pop()Lcom/google/gson/ObjectTypePair;",
            "method_body": "public ObjectTypePair pop() {\nreturn stack.pop();\n}",
            "method_id": 97,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.ObjectTypePair:getObject()Ljava/lang/Object;",
            "method_body": "Object getObject() {\nreturn obj;\n}",
            "method_id": 98,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.ObjectTypePair:setObject(Ljava/lang/Object;)V",
            "method_body": "void setObject(Object obj) {\nthis.obj = obj;\n}",
            "method_id": 99,
            "loc": 3
        },
        {
            "method_signature": "com.google.gson.JsonSerializationVisitor:startVisitingObject(Ljava/lang/Object;)V",
            "method_body": "public void startVisitingObject(Object node) {\nassignToRoot(new JsonObject());\n}",
            "method_id": 100,
            "loc": 3
        }
    ]
}