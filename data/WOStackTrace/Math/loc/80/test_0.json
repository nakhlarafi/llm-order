{
    "bug_id": 80,
    "test_id": 0,
    "test_name": "org.apache.commons.math.linear.EigenDecompositionImplTest.testMathpbx02",
    "test_body": "public void testMathpbx02() {\ndouble[] mainTridiagonal = {\n7484.860960227216, 18405.28129035345, 13855.225609560746,\n10016.708722343366, 559.8117399576674, 6750.190788301587, \n71.21428769782159\n};\ndouble[] secondaryTridiagonal = {\n-4175.088570476366,1975.7955858241994,5193.178422374075, \n1995.286659169179,75.34535882933804,-234.0808002076056\n};\n// the reference values have been computed using routine DSTEMR\n// from the fortran library LAPACK version 3.2.1\ndouble[] refEigenValues = {\n20654.744890306974412,16828.208208485466457,\n6893.155912634994820,6757.083016675340332,\n5887.799885688558788,64.309089923240379,\n57.992628792736340\n};\nRealVector[] refEigenVectors = {\nnew ArrayRealVector(new double[] {-0.270356342026904, 0.852811091326997, 0.399639490702077, 0.198794657813990, 0.019739323307666, 0.000106983022327, -0.000001216636321}),\nnew ArrayRealVector(new double[] {0.179995273578326,-0.402807848153042,0.701870993525734,0.555058211014888,0.068079148898236,0.000509139115227,-0.000007112235617}),\nnew ArrayRealVector(new double[] {-0.399582721284727,-0.056629954519333,-0.514406488522827,0.711168164518580,0.225548081276367,0.125943999652923,-0.004321507456014}),\nnew ArrayRealVector(new double[] {0.058515721572821,0.010200130057739,0.063516274916536,-0.090696087449378,-0.017148420432597,0.991318870265707,-0.034707338554096}),\nnew ArrayRealVector(new double[] {0.855205995537564,0.327134656629775,-0.265382397060548,0.282690729026706,0.105736068025572,-0.009138126622039,0.000367751821196}),\nnew ArrayRealVector(new double[] {-0.002913069901144,-0.005177515777101,0.041906334478672,-0.109315918416258,0.436192305456741,0.026307315639535,0.891797507436344}),\nnew ArrayRealVector(new double[] {-0.005738311176435,-0.010207611670378,0.082662420517928,-0.215733886094368,0.861606487840411,-0.025478530652759,-0.451080697503958})\n};\n// the following line triggers the exception\nEigenDecomposition decomposition =\nnew EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, MathUtils.SAFE_MIN);\ndouble[] eigenValues = decomposition.getRealEigenvalues();\nfor (int i = 0; i < refEigenValues.length; ++i) {\nassertEquals(refEigenValues[i], eigenValues[i], 1.0e-3);\nif (refEigenVectors[i].dotProduct(decomposition.getEigenvector(i)) < 0) {\nassertEquals(0, refEigenVectors[i].add(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n} else {\nassertEquals(0, refEigenVectors[i].subtract(decomposition.getEigenvector(i)).getNorm(), 1.0e-5);\n}\n}\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<16828.208208485466> but was:<20654.74511575945>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:120)\nat junit.framework.Assert.assertEquals(Assert.java:129)\nat junit.framework.TestCase.assertEquals(TestCase.java:288)\nat org.apache.commons.math.linear.EigenDecompositionImplTest.testMathpbx02(EigenDecompositionImplTest.java:181)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:computeShiftIncrement(III)V",
            "method_body": "private void computeShiftIncrement(final int start, final int end, final int deflated) {\n\nfinal double cnst1 = 0.563;\nfinal double cnst2 = 1.010;\nfinal double cnst3 = 1.05;\n\n// a negative dMin forces the shift to take that absolute value\n// tType records the type of shift.\nif (dMin <= 0.0) {\ntau = -dMin;\ntType = -1;\nreturn;\n}\n\nint nn = 4 * end + pingPong - 1;\nswitch (deflated) {\n\ncase 0 : // no realEigenvalues deflated.\nif (dMin == dN || dMin == dN1) {\n\ndouble b1 = Math.sqrt(work[nn - 3]) * Math.sqrt(work[nn - 5]);\ndouble b2 = Math.sqrt(work[nn - 7]) * Math.sqrt(work[nn - 9]);\ndouble a2 = work[nn - 7] + work[nn - 5];\n\nif (dMin == dN && dMin1 == dN1) {\n// cases 2 and 3.\nfinal double gap2 = dMin2 - a2 - dMin2 * 0.25;\nfinal double gap1 = a2 - dN - ((gap2 > 0.0 && gap2 > b2) ? (b2 / gap2) * b2 : (b1 + b2));\nif (gap1 > 0.0 && gap1 > b1) {\ntau   = Math.max(dN - (b1 / gap1) * b1, 0.5 * dMin);\ntType = -2;\n} else {\ndouble s = 0.0;\nif (dN > b1) {\ns = dN - b1;\n}\nif (a2 > (b1 + b2)) {\ns = Math.min(s, a2 - (b1 + b2));\n}\ntau   = Math.max(s, 0.333 * dMin);\ntType = -3;\n}\n} else {\n// case 4.\ntType = -4;\ndouble s = 0.25 * dMin;\ndouble gam;\nint np;\nif (dMin == dN) {\ngam = dN;\na2 = 0.0;\nif (work[nn - 5]  >  work[nn - 7]) {\nreturn;\n}\nb2 = work[nn - 5] / work[nn - 7];\nnp = nn - 9;\n} else {\nnp = nn - 2 * pingPong;\nb2 = work[np - 2];\ngam = dN1;\nif (work[np - 4]  >  work[np - 2]) {\nreturn;\n}\na2 = work[np - 4] / work[np - 2];\nif (work[nn - 9]  >  work[nn - 11]) {\nreturn;\n}\nb2 = work[nn - 9] / work[nn - 11];\nnp = nn - 13;\n}\n\n// approximate contribution to norm squared from i < nn-1.\na2 = a2 + b2;\nfor (int i4 = np; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\nif(b2 == 0.0) {\nbreak;\n}\nb1 = b2;\nif (work[i4]  >  work[i4 - 2]) {\nreturn;\n}\nb2 = b2 * (work[i4] / work[i4 - 2]);\na2 = a2 + b2;\nif (100 * Math.max(b2, b1) < a2 || cnst1 < a2) {\nbreak;\n}\n}\na2 = cnst3 * a2;\n\n// rayleigh quotient residual bound.\nif (a2 < cnst1) {\ns = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n}\ntau = s;\n\n}\n} else if (dMin == dN2) {\n\n// case 5.\ntType = -5;\ndouble s = 0.25 * dMin;\n\n// compute contribution to norm squared from i > nn-2.\nfinal int np = nn - 2 * pingPong;\ndouble b1 = work[np - 2];\ndouble b2 = work[np - 6];\nfinal double gam = dN2;\nif (work[np - 8] > b2 || work[np - 4] > b1) {\nreturn;\n}\ndouble a2 = (work[np - 8] / b2) * (1 + work[np - 4] / b1);\n\n// approximate contribution to norm squared from i < nn-2.\nif (end - start > 3) {\nb2 = work[nn - 13] / work[nn - 15];\na2 = a2 + b2;\nfor (int i4 = nn - 17; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\nif (b2 == 0.0) {\nbreak;\n}\nb1 = b2;\nif (work[i4]  >  work[i4 - 2]) {\nreturn;\n}\nb2 = b2 * (work[i4] / work[i4 - 2]);\na2 = a2 + b2;\nif (100 * Math.max(b2, b1) < a2 || cnst1 < a2)  {\nbreak;\n}\n}\na2 = cnst3 * a2;\n}\n\nif (a2 < cnst1) {\ntau = gam * (1 - Math.sqrt(a2)) / (1 + a2);\n} else {\ntau = s;\n}\n\n} else {\n\n// case 6, no information to guide us.\nif (tType == -6) {\ng += 0.333 * (1 - g);\n} else if (tType == -18) {\ng = 0.25 * 0.333;\n} else {\ng = 0.25;\n}\ntau   = g * dMin;\ntType = -6;\n\n}\nbreak;\n\ncase 1 : // one eigenvalue just deflated. use dMin1, dN1 for dMin and dN.\nif (dMin1 == dN1 && dMin2 == dN2) {\n\n// cases 7 and 8.\ntType = -7;\ndouble s = 0.333 * dMin1;\nif (work[nn - 5] > work[nn - 7]) {\nreturn;\n}\ndouble b1 = work[nn - 5] / work[nn - 7];\ndouble b2 = b1;\nif (b2 != 0.0) {\nfor (int i4 = 4 * end - 10 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\nfinal double oldB1 = b1;\nif (work[i4] > work[i4 - 2]) {\nreturn;\n}\nb1 = b1 * (work[i4] / work[i4 - 2]);\nb2 = b2 + b1;\nif (100 * Math.max(b1, oldB1) < b2) {\nbreak;\n}\n}\n}\nb2 = Math.sqrt(cnst3 * b2);\nfinal double a2 = dMin1 / (1 + b2 * b2);\nfinal double gap2 = 0.5 * dMin2 - a2;\nif (gap2 > 0.0 && gap2 > b2 * a2) {\ntau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n} else {\ntau = Math.max(s, a2 * (1 - cnst2 * b2));\ntType = -8;\n}\n} else {\n\n// case 9.\ntau = 0.25 * dMin1;\nif (dMin1 == dN1) {\ntau = 0.5 * dMin1;\n}\ntType = -9;\n}\nbreak;\n\ncase 2 : // two realEigenvalues deflated. use dMin2, dN2 for dMin and dN.\n\n// cases 10 and 11.\nif (dMin2 == dN2 && 2 * work[nn - 5] < work[nn - 7]) {\ntType = -10;\nfinal double s = 0.333 * dMin2;\nif (work[nn - 5] > work[nn - 7]) {\nreturn;\n}\ndouble b1 = work[nn - 5] / work[nn - 7];\ndouble b2 = b1;\nif (b2 != 0.0){\nfor (int i4 = 4 * end - 9 + pingPong; i4 >= 4 * start + 2 + pingPong; i4 -= 4) {\nif (work[i4] > work[i4 - 2]) {\nreturn;\n}\nb1 *= work[i4] / work[i4 - 2];\nb2 += b1;\nif (100 * b1 < b2) {\nbreak;\n}\n}\n}\nb2 = Math.sqrt(cnst3 * b2);\nfinal double a2 = dMin2 / (1 + b2 * b2);\nfinal double gap2 = work[nn - 7] + work[nn - 9] -\nMath.sqrt(work[nn - 11]) * Math.sqrt(work[nn - 9]) - a2;\nif (gap2 > 0.0 && gap2 > b2 * a2) {\ntau = Math.max(s, a2 * (1 - cnst2 * a2 * (b2 / gap2) * b2));\n} else {\ntau = Math.max(s, a2 * (1 - cnst2 * b2));\n}\n} else {\ntau   = 0.25 * dMin2;\ntType = -11;\n}\nbreak;\n\ndefault : // case 12, more than two realEigenvalues deflated. no information.\ntau   = 0.0;\ntType = -12;\n}\n\n}",
            "method_id": 0,
            "loc": 243
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:goodStep(II)I",
            "method_body": "private int goodStep(final int start, final int end) {\n\ng = 0.0;\n\n// step 1: accepting realEigenvalues\nint deflatedEnd = end;\nfor (boolean deflating = true; deflating;) {\n\nif (start >= deflatedEnd) {\n// the array has been completely deflated\nreturn deflatedEnd;\n}\n\nfinal int k = 4 * deflatedEnd + pingPong - 1;\n\nif ((start == deflatedEnd - 1) ||\n((start != deflatedEnd - 2) &&\n((work[k - 5] <= TOLERANCE_2 * (sigma + work[k - 3])) ||\n(work[k - 2 * pingPong - 4] <= TOLERANCE_2 * work[k - 7])))) {\n\n// one eigenvalue found, deflate array\nwork[4 * deflatedEnd - 4] = sigma + work[4 * deflatedEnd - 4 + pingPong];\ndeflatedEnd -= 1;\n\n} else if ((start == deflatedEnd - 2) ||\n(work[k - 9] <= TOLERANCE_2 * sigma) ||\n(work[k - 2 * pingPong - 8] <= TOLERANCE_2 * work[k - 11])) {\n\n// two realEigenvalues found, deflate array\nif (work[k - 3] > work[k - 7]) {\nfinal double tmp = work[k - 3];\nwork[k - 3] = work[k - 7];\nwork[k - 7] = tmp;\n}\n\nif (work[k - 5] > TOLERANCE_2 * work[k - 3]) {\ndouble t = 0.5 * ((work[k - 7] - work[k - 3]) + work[k - 5]);\ndouble s = work[k - 3] * (work[k - 5] / t);\nif (s <= t) {\ns = work[k - 3] * work[k - 5] / (t * (1 + Math.sqrt(1 + s / t)));\n} else {\ns = work[k - 3] * work[k - 5] / (t + Math.sqrt(t * (t + s)));\n}\nt = work[k - 7] + (s + work[k - 5]);\nwork[k - 3] *= work[k - 7] / t;\nwork[k - 7]  = t;\n}\nwork[4 * deflatedEnd - 8] = sigma + work[k - 7];\nwork[4 * deflatedEnd - 4] = sigma + work[k - 3];\ndeflatedEnd -= 2;\n} else {\n\n// no more realEigenvalues found, we need to iterate\ndeflating = false;\n\n}\n\n}\n\nfinal int l = 4 * deflatedEnd + pingPong - 1;\n\n// step 2: flip array if needed\nif ((dMin <= 0) || (deflatedEnd < end)) {\nif (flipIfWarranted(deflatedEnd, 1)) {\ndMin2 = Math.min(dMin2, work[l - 1]);\nwork[l - 1] =\nMath.min(work[l - 1],\nMath.min(work[3 + pingPong], work[7 + pingPong]));\nwork[l - 2 * pingPong] =\nMath.min(work[l - 2 * pingPong],\nMath.min(work[6 + pingPong], work[6 + pingPong]));\nqMax  = Math.max(qMax, Math.max(work[3 + pingPong], work[7 + pingPong]));\ndMin  = -0.0;\n}\n}\n\nif ((dMin < 0) ||\n(MathUtils.SAFE_MIN * qMax < Math.min(work[l - 1],\nMath.min(work[l - 9],\ndMin2 + work[l - 2 * pingPong])))) {\n// step 3: choose a shift\ncomputeShiftIncrement(start, deflatedEnd, end - deflatedEnd);\n\n// step 4a: dqds\nfor (boolean loop = true; loop;) {\n\n// perform one dqds step with the chosen shift\ndqds(start, deflatedEnd);\n\n// check result of the dqds step\nif ((dMin >= 0) && (dMin1 > 0)) {\n// the shift was good\nupdateSigma(tau);\nreturn deflatedEnd;\n} else if ((dMin < 0.0) &&\n(dMin1 > 0.0) &&\n(work[4 * deflatedEnd - 5 - pingPong] < TOLERANCE * (sigma + dN1)) &&\n(Math.abs(dN) < TOLERANCE * sigma)) {\n// convergence hidden by negative DN.\nwork[4 * deflatedEnd - 3 - pingPong] = 0.0;\ndMin = 0.0;\nupdateSigma(tau);\nreturn deflatedEnd;\n} else if (dMin < 0.0) {\n// tau too big. Select new tau and try again.\nif (tType < -22) {\n// failed twice. Play it safe.\ntau = 0.0;\n} else if (dMin1 > 0.0) {\n// late failure. Gives excellent shift.\ntau = (tau + dMin) * (1.0 - 2.0 * MathUtils.EPSILON);\ntType -= 11;\n} else {\n// early failure. Divide by 4.\ntau *= 0.25;\ntType -= 12;\n}\n} else if (Double.isNaN(dMin)) {\ntau = 0.0;\n} else {\n// possible underflow. Play it safe.\nloop = false;\n}\n}\n\n}\n\n// perform a dqd step (i.e. no shift)\ndqd(start, deflatedEnd);\n\nreturn deflatedEnd;\n\n}",
            "method_id": 1,
            "loc": 133
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:processGeneralBlock(I)V",
            "method_body": "private void processGeneralBlock(final int n)\nthrows InvalidMatrixException {\n\n// check decomposed matrix data range\ndouble sumOffDiag = 0;\nfor (int i = 0; i < n - 1; ++i) {\nfinal int fourI = 4 * i;\nfinal double ei = work[fourI + 2];\nsumOffDiag += ei;\n}\n\nif (sumOffDiag == 0) {\n// matrix is already diagonal\nreturn;\n}\n\n// initial checks for splits (see Parlett & Marques section 3.3)\nflipIfWarranted(n, 2);\n\n// two iterations with Li's test for initial splits\ninitialSplits(n);\n\n// initialize parameters used by goodStep\ntType = 0;\ndMin1 = 0;\ndMin2 = 0;\ndN    = 0;\ndN1   = 0;\ndN2   = 0;\ntau   = 0;\n\n// process split segments\nint i0 = 0;\nint n0 = n;\nwhile (n0 > 0) {\n\n// retrieve shift that was temporarily stored as a negative off-diagonal element\nsigma    = (n0 == n) ? 0 : -work[4 * n0 - 2];\nsigmaLow = 0;\n\n// find start of a new split segment to process\ndouble offDiagMin = (i0 == n0) ? 0 : work[4 * n0 - 6];\ndouble offDiagMax = 0;\ndouble diagMax    = work[4 * n0 - 4];\ndouble diagMin    = diagMax;\ni0 = 0;\nfor (int i = 4 * (n0 - 2); i >= 0; i -= 4) {\nif (work[i + 2] <= 0) {\ni0 = 1 + i / 4;\nbreak;\n}\nif (diagMin >= 4 * offDiagMax) {\ndiagMin    = Math.min(diagMin, work[i + 4]);\noffDiagMax = Math.max(offDiagMax, work[i + 2]);\n}\ndiagMax    = Math.max(diagMax, work[i] + work[i + 2]);\noffDiagMin = Math.min(offDiagMin, work[i + 2]);\n}\nwork[4 * n0 - 2] = offDiagMin;\n\n// lower bound of Gershgorin disk\ndMin = -Math.max(0, diagMin - 2 * Math.sqrt(diagMin * offDiagMax));\n\npingPong = 0;\nint maxIter = 30 * (n0 - i0);\nfor (int k = 0; i0 < n0; ++k) {\nif (k >= maxIter) {\nthrow new InvalidMatrixException(new MaxIterationsExceededException(maxIter));\n}\n\n// perform one step\nn0 = goodStep(i0, n0);\npingPong = 1 - pingPong;\n\n// check for new splits after \"ping\" steps\n// when the last elements of qd array are very small\nif ((pingPong == 0) && (n0 - i0 > 3) &&\n(work[4 * n0 - 1] <= TOLERANCE_2 * diagMax) &&\n(work[4 * n0 - 2] <= TOLERANCE_2 * sigma)) {\nint split  = i0 - 1;\ndiagMax    = work[4 * i0];\noffDiagMin = work[4 * i0 + 2];\ndouble previousEMin = work[4 * i0 + 3];\nfor (int i = 4 * i0; i < 4 * n0 - 16; i += 4) {\nif ((work[i + 3] <= TOLERANCE_2 * work[i]) ||\n(work[i + 2] <= TOLERANCE_2 * sigma)) {\n// insert a split\nwork[i + 2]  = -sigma;\nsplit        = i / 4;\ndiagMax      = 0;\noffDiagMin   = work[i + 6];\npreviousEMin = work[i + 7];\n} else {\ndiagMax      = Math.max(diagMax, work[i + 4]);\noffDiagMin   = Math.min(offDiagMin, work[i + 2]);\npreviousEMin = Math.min(previousEMin, work[i + 3]);\n}\n}\nwork[4 * n0 - 2] = offDiagMin;\nwork[4 * n0 - 1] = previousEMin;\ni0 = split + 1;\n}\n}\n\n}\n\n}",
            "method_id": 2,
            "loc": 107
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:dqd(II)V",
            "method_body": "private void dqd(final int start, final int end) {\n\neMin = work[4 * start + pingPong + 4];\ndouble d = work[4 * start + pingPong];\ndMin = d;\n\nif (pingPong == 0) {\nfor (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\nwork[j4 - 2] = d + work[j4 - 1];\nif (work[j4 - 2] == 0.0) {\nwork[j4] = 0.0;\nd = work[j4 + 1];\ndMin = d;\neMin = 0.0;\n} else if ((MathUtils.SAFE_MIN * work[j4 + 1] < work[j4 - 2]) &&\n(MathUtils.SAFE_MIN * work[j4 - 2] < work[j4 + 1])) {\nfinal double tmp = work[j4 + 1] / work[j4 - 2];\nwork[j4] = work[j4 - 1] * tmp;\nd *= tmp;\n} else {\nwork[j4] = work[j4 + 1] * (work[j4 - 1] / work[j4 - 2]);\nd *= work[j4 + 1] / work[j4 - 2];\n}\ndMin = Math.min(dMin, d);\neMin = Math.min(eMin, work[j4]);\n}\n} else {\nfor (int j4 = 4 * start + 3; j4 < 4 * (end - 3); j4 += 4) {\nwork[j4 - 3] = d + work[j4];\nif (work[j4 - 3] == 0.0) {\nwork[j4 - 1] = 0.0;\nd = work[j4 + 2];\ndMin = d;\neMin = 0.0;\n} else if ((MathUtils.SAFE_MIN * work[j4 + 2] < work[j4 - 3]) &&\n(MathUtils.SAFE_MIN * work[j4 - 3] < work[j4 + 2])) {\nfinal double tmp = work[j4 + 2] / work[j4 - 3];\nwork[j4 - 1] = work[j4] * tmp;\nd *= tmp;\n} else {\nwork[j4 - 1] = work[j4 + 2] * (work[j4] / work[j4 - 3]);\nd *= work[j4 + 2] / work[j4 - 3];\n}\ndMin = Math.min(dMin, d);\neMin = Math.min(eMin, work[j4 - 1]);\n}\n}\n\n// Unroll last two steps\ndN2   = d;\ndMin2 = dMin;\nint j4 = 4 * (end - 2) - pingPong - 1;\nint j4p2 = j4 + 2 * pingPong - 1;\nwork[j4 - 2] = dN2 + work[j4p2];\nif (work[j4 - 2] == 0.0) {\nwork[j4] = 0.0;\ndN1  = work[j4p2 + 2];\ndMin = dN1;\neMin = 0.0;\n} else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n(MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\nfinal double tmp = work[j4p2 + 2] / work[j4 - 2];\nwork[j4] = work[j4p2] * tmp;\ndN1 = dN2 * tmp;\n} else {\nwork[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\ndN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]);\n}\ndMin = Math.min(dMin, dN1);\n\ndMin1 = dMin;\nj4 = j4 + 4;\nj4p2 = j4 + 2 * pingPong - 1;\nwork[j4 - 2] = dN1 + work[j4p2];\nif (work[j4 - 2] == 0.0) {\nwork[j4] = 0.0;\ndN   = work[j4p2 + 2];\ndMin = dN;\neMin = 0.0;\n} else if ((MathUtils.SAFE_MIN * work[j4p2 + 2] < work[j4 - 2]) &&\n(MathUtils.SAFE_MIN * work[j4 - 2] < work[j4p2 + 2])) {\nfinal double tmp = work[j4p2 + 2] / work[j4 - 2];\nwork[j4] = work[j4p2] * tmp;\ndN = dN1 * tmp;\n} else {\nwork[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\ndN = work[j4p2 + 2] * (dN1 / work[j4 - 2]);\n}\ndMin = Math.min(dMin, dN);\n\nwork[j4 + 2] = dN;\nwork[4 * end - pingPong - 1] = eMin;\n\n}",
            "method_id": 3,
            "loc": 94
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:findEigenvalues()V",
            "method_body": "private void findEigenvalues()\nthrows InvalidMatrixException {\n\n// compute splitting points\nList<Integer> splitIndices = computeSplits();\n\n// find realEigenvalues in each block\nrealEigenvalues = new double[main.length];\nimagEigenvalues = new double[main.length];\nint begin = 0;\nfor (final int end : splitIndices) {\nfinal int n = end - begin;\nswitch (n) {\n\ncase 1:\n// apply dedicated method for dimension 1\nprocess1RowBlock(begin);\nbreak;\n\ncase 2:\n// apply dedicated method for dimension 2\nprocess2RowsBlock(begin);\nbreak;\n\ncase 3:\n// apply dedicated method for dimension 3\nprocess3RowsBlock(begin);\nbreak;\n\ndefault:\n\n// choose an initial shift for LDL<sup>T</sup> decomposition\nfinal double[] range       = eigenvaluesRange(begin, n);\nfinal double oneFourth     = 0.25 * (3 * range[0] + range[1]);\nfinal int oneFourthCount   = countEigenValues(oneFourth, begin, n);\nfinal double threeFourth   = 0.25 * (range[0] + 3 * range[1]);\nfinal int threeFourthCount = countEigenValues(threeFourth, begin, n);\nfinal boolean chooseLeft   = (oneFourthCount - 1) >= (n - threeFourthCount);\nfinal double lambda        = chooseLeft ? range[0] : range[1];\n\ntau = (range[1] - range[0]) * MathUtils.EPSILON * n + 2 * minPivot;\n\n// decompose T-&lambda;I as LDL<sup>T</sup>\nldlTDecomposition(lambda, begin, n);\n\n// apply general dqd/dqds method\nprocessGeneralBlock(n);\n\n// extract realEigenvalues\nif (chooseLeft) {\nfor (int i = 0; i < n; ++i) {\nrealEigenvalues[begin + i] = lambda + work[4 * i];\n}\n} else {\nfor (int i = 0; i < n; ++i) {\nrealEigenvalues[begin + i] = lambda - work[4 * i];\n}\n}\n\n}\nbegin = end;\n}\n\n// sort the realEigenvalues in decreasing order\nArrays.sort(realEigenvalues);\nint j = realEigenvalues.length - 1;\nfor (int i = 0; i < j; ++i) {\nfinal double tmp = realEigenvalues[i];\nrealEigenvalues[i] = realEigenvalues[j];\nrealEigenvalues[j] = tmp;\n--j;\n}\n\n}",
            "method_id": 4,
            "loc": 74
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:eigenvaluesRange(II)[D",
            "method_body": "private double[] eigenvaluesRange(final int index, final int n) {\n\n// find the bounds of the spectra of the local block\nfinal int lowerStart = 4 * main.length;\nfinal int upperStart = 5 * main.length;\ndouble lower = Double.POSITIVE_INFINITY;\ndouble upper = Double.NEGATIVE_INFINITY;\nfor (int i = 0; i < n; ++i) {\nlower = Math.min(lower, work[lowerStart + index +i]);\nupper = Math.max(upper, work[upperStart + index +i]);\n}\n\n// set thresholds\nfinal double tNorm = Math.max(Math.abs(lower), Math.abs(upper));\nfinal double relativeTolerance = Math.sqrt(MathUtils.EPSILON);\nfinal double absoluteTolerance = 4 * minPivot;\nfinal int maxIter =\n2 + (int) ((Math.log(tNorm + minPivot) - Math.log(minPivot)) / Math.log(2.0));\nfinal double margin = 2 * (tNorm * MathUtils.EPSILON * n + 2 * minPivot);\n\n// search lower eigenvalue\ndouble left  = lower - margin;\ndouble right = upper + margin;\nfor (int i = 0; i < maxIter; ++i) {\n\nfinal double range = right - left;\nif ((range < absoluteTolerance) ||\n(range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n// search has converged\nbreak;\n}\n\nfinal double middle = 0.5 * (left + right);\nif (countEigenValues(middle, index, n) >= 1) {\nright = middle;\n} else {\nleft = middle;\n}\n\n}\nlower = Math.max(lower, left - 100 * MathUtils.EPSILON * Math.abs(left));\n\n// search upper eigenvalue\nleft  = lower - margin;\nright = upper + margin;\nfor (int i = 0; i < maxIter; ++i) {\n\nfinal double range = right - left;\nif ((range < absoluteTolerance) ||\n(range < relativeTolerance * Math.max(Math.abs(left), Math.abs(right)))) {\n// search has converged\nbreak;\n}\n\nfinal double middle = 0.5 * (left + right);\nif (countEigenValues(middle, index, n) >= n) {\nright = middle;\n} else {\nleft = middle;\n}\n\n}\nupper = Math.min(upper, right + 100 * MathUtils.EPSILON * Math.abs(right));\n\nreturn new double[] { lower, upper };\n\n}",
            "method_id": 5,
            "loc": 67
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:findEigenvector(D[D[D)Lorg/apache/commons/math/linear/ArrayRealVector;",
            "method_body": "private ArrayRealVector findEigenvector(final double eigenvalue,\nfinal double[] d, final double[] l) {\n\n// compute the LDLt and UDUt decompositions of the\n// perfectly shifted tridiagonal matrix\nfinal int m = main.length;\nstationaryQuotientDifferenceWithShift(d, l, eigenvalue);\nprogressiveQuotientDifferenceWithShift(d, l, eigenvalue);\n\n// select the twist index leading to\n// the least diagonal element in the twisted factorization\nint r = m - 1;\ndouble minG = Math.abs(work[6 * r] + work[6 * r + 3] + eigenvalue);\nint sixI = 0;\nfor (int i = 0; i < m - 1; ++i) {\nfinal double absG = Math.abs(work[sixI] + d[i] * work[sixI + 9] / work[sixI + 10]);\nif (absG < minG) {\nr = i;\nminG = absG;\n}\nsixI += 6;\n}\n\n// solve the singular system by ignoring the equation\n// at twist index and propagating upwards and downwards\ndouble[] eigenvector = new double[m];\ndouble n2 = 1;\neigenvector[r] = 1;\ndouble z = 1;\nfor (int i = r - 1; i >= 0; --i) {\nz *= -work[6 * i + 2];\neigenvector[i] = z;\nn2 += z * z;\n}\nz = 1;\nfor (int i = r + 1; i < m; ++i) {\nz *= -work[6 * i - 1];\neigenvector[i] = z;\nn2 += z * z;\n}\n\n// normalize vector\nfinal double inv = 1.0 / Math.sqrt(n2);\nfor (int i = 0; i < m; ++i) {\neigenvector[i] *= inv;\n}\n\nreturn (transformer == null) ?\nnew ArrayRealVector(eigenvector, false) :\nnew ArrayRealVector(transformer.getQ().operate(eigenvector), false);\n\n}",
            "method_id": 6,
            "loc": 52
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:dqds(II)V",
            "method_body": "private void dqds(final int start, final int end) {\n\neMin = work[4 * start + pingPong + 4];\ndouble d = work[4 * start + pingPong] - tau;\ndMin = d;\ndMin1 = -work[4 * start + pingPong];\n\nif (pingPong == 0) {\nfor (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\nwork[j4 - 2] = d + work[j4 - 1];\nfinal double tmp = work[j4 + 1] / work[j4 - 2];\nd = d * tmp - tau;\ndMin = Math.min(dMin, d);\nwork[j4] = work[j4 - 1] * tmp;\neMin = Math.min(work[j4], eMin);\n}\n} else {\nfor (int j4 = 4 * start + 3; j4 <= 4 * (end - 3); j4 += 4) {\nwork[j4 - 3] = d + work[j4];\nfinal double tmp = work[j4 + 2] / work[j4 - 3];\nd = d * tmp - tau;\ndMin = Math.min(dMin, d);\nwork[j4 - 1] = work[j4] * tmp;\neMin = Math.min(work[j4 - 1], eMin);\n}\n}\n\n// unroll last two steps.\ndN2 = d;\ndMin2 = dMin;\nint j4 = 4 * (end - 2) - pingPong - 1;\nint j4p2 = j4 + 2 * pingPong - 1;\nwork[j4 - 2] = dN2 + work[j4p2];\nwork[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\ndN1 = work[j4p2 + 2] * (dN2 / work[j4 - 2]) - tau;\ndMin = Math.min(dMin, dN1);\n\ndMin1 = dMin;\nj4 = j4 + 4;\nj4p2 = j4 + 2 * pingPong - 1;\nwork[j4 - 2] = dN1 + work[j4p2];\nwork[j4] = work[j4p2 + 2] * (work[j4p2] / work[j4 - 2]);\ndN = work[j4p2 + 2] * (dN1 / work[j4 - 2]) - tau;\ndMin = Math.min(dMin, dN);\n\nwork[j4 + 2] = dN;\nwork[4 * end - pingPong - 1] = eMin;\n\n}",
            "method_id": 7,
            "loc": 49
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:initialSplits(I)V",
            "method_body": "private void initialSplits(final int n) {\n\npingPong = 0;\nfor (int k = 0; k < 2; ++k) {\n\n// apply Li's reverse test\ndouble d = work[4 * (n - 1) + pingPong];\nfor (int i = 4 * (n - 2) + pingPong; i >= 0; i -= 4) {\nif (work[i + 2] <= TOLERANCE_2 * d) {\nwork[i + 2] = -0.0;\nd = work[i];\n} else {\nd *= work[i] / (d + work[i + 2]);\n}\n}\n\n// apply dqd plus Li's forward test.\nd = work[pingPong];\nfor (int i = 2 + pingPong; i < 4 * n - 2; i += 4) {\nfinal int j = i - 2 * pingPong - 1;\nwork[j] = d + work[i];\nif (work[i] <= TOLERANCE_2 * d) {\nwork[i]     = -0.0;\nwork[j]     = d;\nwork[j + 2] = 0.0;\nd = work[i + 2];\n} else if ((MathUtils.SAFE_MIN * work[i + 2] < work[j]) &&\n(MathUtils.SAFE_MIN * work[j] < work[i + 2])) {\nfinal double tmp = work[i + 2] / work[j];\nwork[j + 2] = work[i] * tmp;\nd *= tmp;\n} else {\nwork[j + 2] = work[i + 2] * (work[i] / work[j]);\nd *= work[i + 2] / work[j];\n}\n}\nwork[4 * n - 3 - pingPong] = d;\n\n// from ping to pong\npingPong = 1 - pingPong;\n\n}\n\n}",
            "method_id": 8,
            "loc": 44
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:computeGershgorinCircles()V",
            "method_body": "private void computeGershgorinCircles() {\n\nfinal int m     = main.length;\nfinal int lowerStart = 4 * m;\nfinal int upperStart = 5 * m;\nlowerSpectra = Double.POSITIVE_INFINITY;\nupperSpectra = Double.NEGATIVE_INFINITY;\ndouble eMax = 0;\n\ndouble eCurrent = 0;\nfor (int i = 0; i < m - 1; ++i) {\n\nfinal double dCurrent = main[i];\nfinal double ePrevious = eCurrent;\neCurrent = Math.abs(secondary[i]);\neMax = Math.max(eMax, eCurrent);\nfinal double radius = ePrevious + eCurrent;\n\nfinal double lower = dCurrent - radius;\nwork[lowerStart + i] = lower;\nlowerSpectra = Math.min(lowerSpectra, lower);\n\nfinal double upper = dCurrent + radius;\nwork[upperStart + i] = upper;\nupperSpectra = Math.max(upperSpectra, upper);\n\n}\n\nfinal double dCurrent = main[m - 1];\nfinal double lower = dCurrent - eCurrent;\nwork[lowerStart + m - 1] = lower;\nlowerSpectra = Math.min(lowerSpectra, lower);\nfinal double upper = dCurrent + eCurrent;\nwork[upperStart + m - 1] = upper;\nupperSpectra = Math.max(upperSpectra, upper);\nminPivot = MathUtils.SAFE_MIN * Math.max(1.0, eMax * eMax);\n\n}",
            "method_id": 9,
            "loc": 38
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:setSubMatrix([[DII)V",
            "method_body": "public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\nthrows MatrixIndexException {\nif (data == null) {\nif (row > 0) {\nthrow MathRuntimeException.createIllegalStateException(\n\"first {0} rows are not initialized yet\",\nrow);\n}\nif (column > 0) {\nthrow MathRuntimeException.createIllegalStateException(\n\"first {0} columns are not initialized yet\",\ncolumn);\n}\nfinal int nRows = subMatrix.length;\nif (nRows == 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n}\n\nfinal int nCols = subMatrix[0].length;\nif (nCols == 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n}\ndata = new double[subMatrix.length][nCols];\nfor (int i = 0; i < data.length; ++i) {\nif (subMatrix[i].length != nCols) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"some rows have length {0} while others have length {1}\",\nnCols, subMatrix[i].length);\n}\nSystem.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n}\n} else {\nsuper.setSubMatrix(subMatrix, row, column);\n}\n\n}",
            "method_id": 10,
            "loc": 36
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:findEigenVectors()V",
            "method_body": "private void findEigenVectors() {\n\nfinal int m = main.length;\neigenvectors = new ArrayRealVector[m];\n\n// perform an initial non-shifted LDLt decomposition\nfinal double[] d = new double[m];\nfinal double[] l = new double[m - 1];\n// avoid zero divide on indefinite matrix\nfinal double mu = realEigenvalues[m-1] <= 0 && realEigenvalues[0] > 0 ? 0.5-realEigenvalues[m-1] : 0;\ndouble di = main[0]+mu;\nd[0] = di;\nfor (int i = 1; i < m; ++i) {\nfinal double eiM1  = secondary[i - 1];\nfinal double ratio = eiM1 / di;\ndi       = main[i] - eiM1 * ratio + mu;\nl[i - 1] = ratio;\nd[i]     = di;\n}\n\n// compute eigenvectors\nfor (int i = 0; i < m; ++i) {\neigenvectors[i] = findEigenvector(realEigenvalues[i]+mu, d, l);\n}\n\n}",
            "method_id": 11,
            "loc": 26
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>([[DZ)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\nthrows IllegalArgumentException, NullPointerException {\nif (copyArray) {\ncopyIn(d);\n} else {\nif (d == null) {\nthrow new NullPointerException();\n}\nfinal int nRows = d.length;\nif (nRows == 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one row\");\n}\nfinal int nCols = d[0].length;\nif (nCols == 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\"matrix must have at least one column\");\n}\nfor (int r = 1; r < nRows; r++) {\nif (d[r].length != nCols) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"some rows have length {0} while others have length {1}\",\nnCols, d[r].length);\n}\n}\ndata = d;\n}\n}",
            "method_id": 12,
            "loc": 26
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:multiply(Lorg/apache/commons/math/linear/Array2DRowRealMatrix;)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\nthrows IllegalArgumentException {\n\n// safety check\nMatrixUtils.checkMultiplicationCompatible(this, m);\n\nfinal int nRows = this.getRowDimension();\nfinal int nCols = m.getColumnDimension();\nfinal int nSum = this.getColumnDimension();\nfinal double[][] outData = new double[nRows][nCols];\nfor (int row = 0; row < nRows; row++) {\nfinal double[] dataRow    = data[row];\nfinal double[] outDataRow = outData[row];\nfor (int col = 0; col < nCols; col++) {\ndouble sum = 0;\nfor (int i = 0; i < nSum; i++) {\nsum += dataRow[i] * m.data[i][col];\n}\noutDataRow[col] = sum;\n}\n}\n\nreturn new Array2DRowRealMatrix(outData, false);\n\n}",
            "method_id": 13,
            "loc": 25
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:computeSplits()Ljava/util/List;",
            "method_body": "private List<Integer> computeSplits() {\n\nfinal List<Integer> list = new ArrayList<Integer>();\n\n// splitting preserving relative accuracy\ndouble absDCurrent = Math.abs(main[0]);\nfor (int i = 0; i < secondary.length; ++i) {\nfinal double absDPrevious = absDCurrent;\nabsDCurrent = Math.abs(main[i + 1]);\nfinal double max = splitTolerance * Math.sqrt(absDPrevious * absDCurrent);\nif (Math.abs(secondary[i]) <= max) {\nlist.add(i + 1);\nsecondary[i] = 0;\nsquaredSecondary[i] = 0;\n}\n}\n\nlist.add(secondary.length + 1);\nreturn list;\n\n}",
            "method_id": 14,
            "loc": 21
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:stationaryQuotientDifferenceWithShift([D[DD)V",
            "method_body": "private void stationaryQuotientDifferenceWithShift(final double[] d, final double[] l,\nfinal double lambda) {\nfinal int nM1 = d.length - 1;\ndouble si = -lambda;\nint sixI = 0;\nfor (int i = 0; i < nM1; ++i) {\nfinal double di   = d[i];\nfinal double li   = l[i];\nfinal double diP1 = di + si;\nfinal double liP1 = li * di / diP1;\nwork[sixI]        = si;\nwork[sixI + 1]    = diP1;\nwork[sixI + 2]    = liP1;\nsi = li * liP1 * si - lambda;\nsixI += 6;\n}\nwork[6 * nM1 + 1] = d[nM1] + si;\nwork[6 * nM1]     = si;\n}",
            "method_id": 15,
            "loc": 19
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:progressiveQuotientDifferenceWithShift([D[DD)V",
            "method_body": "private void progressiveQuotientDifferenceWithShift(final double[] d, final double[] l,\nfinal double lambda) {\nfinal int nM1 = d.length - 1;\ndouble pi = d[nM1] - lambda;\nint sixI = 6 * (nM1 - 1);\nfor (int i = nM1 - 1; i >= 0; --i) {\nfinal double di   = d[i];\nfinal double li   = l[i];\nfinal double diP1 = di * li * li + pi;\nfinal double t    = di / diP1;\nwork[sixI +  9]   = pi;\nwork[sixI + 10]   = diP1;\nwork[sixI +  5]   = li * t;\npi = pi * t - lambda;\nsixI -= 6;\n}\nwork[3] = pi;\nwork[4] = pi;\n}",
            "method_id": 16,
            "loc": 19
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:<init>([D[DD)V",
            "method_body": "public EigenDecompositionImpl(final double[] main, double[] secondary,\nfinal double splitTolerance)\nthrows InvalidMatrixException {\n\nthis.main      = main.clone();\nthis.secondary = secondary.clone();\ntransformer    = null;\n\n// pre-compute some elements\nsquaredSecondary = new double[secondary.length];\nfor (int i = 0; i < squaredSecondary.length; ++i) {\nfinal double s = secondary[i];\nsquaredSecondary[i] = s * s;\n}\n\nthis.splitTolerance = splitTolerance;\ndecompose();\n\n}",
            "method_id": 17,
            "loc": 19
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:transpose()Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public RealMatrix transpose() {\n\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n/** {@inheritDoc} */\n@Override\npublic void visit(final int row, final int column, final double value) {\nout.setEntry(column, row, value);\n}\n\n});\n\nreturn out;\n\n}",
            "method_id": 18,
            "loc": 18
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix$5:visit(IID)V",
            "method_body": "public RealMatrix transpose() {\n\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n/** {@inheritDoc} */\n@Override\npublic void visit(final int row, final int column, final double value) {\nout.setEntry(column, row, value);\n}\n\n});\n\nreturn out;\n\n}",
            "method_id": 19,
            "loc": 18
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:decompose()V",
            "method_body": "private void decompose() {\n\ncachedV  = null;\ncachedD  = null;\ncachedVt = null;\nwork     = new double[6 * main.length];\n\n// compute the Gershgorin circles\ncomputeGershgorinCircles();\n\n// find all the realEigenvalues\nfindEigenvalues();\n\n// we will search for eigenvectors only if required\neigenvectors = null;\n\n}",
            "method_id": 20,
            "loc": 17
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:flipIfWarranted(II)Z",
            "method_body": "private boolean flipIfWarranted(final int n, final int step) {\nif (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// flip array\nint j = 4 * n - 1;\nfor (int i = 0; i < j; i += 4) {\nfor (int k = 0; k < 4; k += step) {\nfinal double tmp = work[i + k];\nwork[i + k] = work[j - k];\nwork[j - k] = tmp;\n}\nj -= 4;\n}\nreturn true;\n}\nreturn false;\n}",
            "method_id": 21,
            "loc": 16
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:updateSigma(D)V",
            "method_body": "private void updateSigma(final double shift) {\n// BEWARE: do NOT attempt to simplify the following statements\n// the expressions below take care to accumulate the part of sigma\n// that does not fit within a double variable into sigmaLow\nif (shift < sigma) {\nsigmaLow += shift;\nfinal double t = sigma + sigmaLow;\nsigmaLow -= t - sigma;\nsigma = t;\n} else {\nfinal double t = sigma + shift;\nsigmaLow += sigma - (t - shift);\nsigma = t;\n}\n}",
            "method_id": 22,
            "loc": 15
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:<init>(II)V",
            "method_body": "protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\nthrows IllegalArgumentException {\nif (rowDimension <= 0 ) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"invalid row dimension {0} (must be positive)\",\nrowDimension);\n}\nif (columnDimension <= 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"invalid column dimension {0} (must be positive)\",\ncolumnDimension);\n}\nlu = null;\n}",
            "method_id": 23,
            "loc": 14
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:subtract(Lorg/apache/commons/math/linear/RealVector;)Lorg/apache/commons/math/linear/RealVector;",
            "method_body": "public RealVector subtract(RealVector v)\nthrows IllegalArgumentException {\ntry {\nreturn subtract((ArrayRealVector) v);\n} catch (ClassCastException cce) {\ncheckVectorDimensions(v);\ndouble[] out = new double[data.length];\nfor (int i = 0; i < data.length; i++) {\nout[i] = data[i] - v.getEntry(i);\n}\nreturn new ArrayRealVector(out);\n}\n}",
            "method_id": 24,
            "loc": 13
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:walkInRowOrder(Lorg/apache/commons/math/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\nthrows MatrixVisitorException {\nfinal int rows    = getRowDimension();\nfinal int columns = getColumnDimension();\nvisitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\nfor (int i = 0; i < rows; ++i) {\nfinal double[] rowI = data[i];\nfor (int j = 0; j < columns; ++j) {\nvisitor.visit(i, j, rowI[j]);\n}\n}\nreturn visitor.end();\n}",
            "method_id": 25,
            "loc": 13
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:dotProduct(Lorg/apache/commons/math/linear/RealVector;)D",
            "method_body": "public double dotProduct(RealVector v)\nthrows IllegalArgumentException {\ntry {\nreturn dotProduct((ArrayRealVector) v);\n} catch (ClassCastException cce) {\ncheckVectorDimensions(v);\ndouble dot = 0;\nfor (int i = 0; i < data.length; i++) {\ndot += data[i] * v.getEntry(i);\n}\nreturn dot;\n}\n}",
            "method_id": 26,
            "loc": 13
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:ldlTDecomposition(DII)V",
            "method_body": "private void ldlTDecomposition(final double lambda, final int index, final int n) {\ndouble di = main[index] - lambda;\nwork[0] = Math.abs(di);\nfor (int i = 1; i < n; ++i) {\nfinal int    fourI = 4 * i;\nfinal double eiM1  = secondary[index + i - 1];\nfinal double ratio = eiM1 / di;\nwork[fourI - 2] = ratio * ratio * Math.abs(di);\ndi = (main[index + i] - lambda) - eiM1 * ratio;\nwork[fourI] = Math.abs(di);\n}\n}",
            "method_id": 27,
            "loc": 12
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:countEigenValues(DII)I",
            "method_body": "private int countEigenValues(final double t, final int index, final int n) {\ndouble ratio = main[index] - t;\nint count = (ratio > 0) ? 0 : 1;\nfor (int i = 1; i < n; ++i) {\nratio = main[index + i] - squaredSecondary[index + i - 1] / ratio - t;\nif (ratio <= 0) {\n++count;\n}\n}\nreturn count;\n}",
            "method_id": 28,
            "loc": 11
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:<init>([DZ)V",
            "method_body": "public ArrayRealVector(double[] d, boolean copyArray)\nthrows NullPointerException, IllegalArgumentException {\nif (d == null) {\nthrow new NullPointerException();\n}\nif (d.length == 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\"vector must have at least one element\");\n}\ndata = copyArray ? d.clone() :  d;\n}",
            "method_id": 29,
            "loc": 10
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:setEntry(IID)V",
            "method_body": "public void setEntry(final int row, final int column, final double value)\nthrows MatrixIndexException {\ntry {\ndata[row][column] = value;\n} catch (ArrayIndexOutOfBoundsException e) {\nthrow new MatrixIndexException(\n\"no entry at indices ({0}, {1}) in a {2}x{3} matrix\",\nrow, column, getRowDimension(), getColumnDimension());\n}\n}",
            "method_id": 30,
            "loc": 10
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:checkMultiplicationCompatible(Lorg/apache/commons/math/linear/AnyMatrix;Lorg/apache/commons/math/linear/AnyMatrix;)V",
            "method_body": "public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\nthrows IllegalArgumentException {\nif (left.getColumnDimension() != right.getRowDimension()) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\nleft.getRowDimension(), left.getColumnDimension(),\nright.getRowDimension(), right.getColumnDimension());\n}\n}",
            "method_id": 31,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:subtract([D)Lorg/apache/commons/math/linear/RealVector;",
            "method_body": "public RealVector subtract(double[] v)\nthrows IllegalArgumentException {\ncheckVectorDimensions(v.length);\ndouble[] out = new double[data.length];\nfor (int i = 0; i < data.length; i++) {\nout[i] = data[i] - v[i];\n}\nreturn new ArrayRealVector(out);\n}",
            "method_id": 32,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix$5:<init>(Lorg/apache/commons/math/linear/AbstractRealMatrix;Lorg/apache/commons/math/linear/RealMatrix;)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 33,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:dotProduct([D)D",
            "method_body": "public double dotProduct(double[] v)\nthrows IllegalArgumentException {\ncheckVectorDimensions(v.length);\ndouble dot = 0;\nfor (int i = 0; i < data.length; i++) {\ndot += data[i] * v[i];\n}\nreturn dot;\n}",
            "method_id": 34,
            "loc": 9
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:multiply(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public RealMatrix multiply(final RealMatrix m)\nthrows IllegalArgumentException {\ntry {\nreturn multiply((Array2DRowRealMatrix) m);\n} catch (ClassCastException cce) {\nreturn super.multiply(m);\n}\n}",
            "method_id": 35,
            "loc": 8
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:checkVectorDimensions(I)V",
            "method_body": "protected void checkVectorDimensions(int n)\nthrows IllegalArgumentException {\nif (data.length != n) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"vector length mismatch: got {0} but expected {1}\",\ndata.length, n);\n}\n}",
            "method_id": 36,
            "loc": 8
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:getNorm()D",
            "method_body": "public double getNorm() {\ndouble sum = 0;\nfor (double a : data) {\nsum += a * a;\n}\nreturn Math.sqrt(sum);\n}",
            "method_id": 37,
            "loc": 7
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:getEigenvector(I)Lorg/apache/commons/math/linear/RealVector;",
            "method_body": "public RealVector getEigenvector(final int i)\nthrows InvalidMatrixException, ArrayIndexOutOfBoundsException {\nif (eigenvectors == null) {\nfindEigenVectors();\n}\nreturn eigenvectors[i].copy();\n}",
            "method_id": 38,
            "loc": 7
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension, final int columnDimension)\nthrows IllegalArgumentException {\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 39,
            "loc": 5
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:createMatrix(II)Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public RealMatrix createMatrix(final int rowDimension, final int columnDimension)\nthrows IllegalArgumentException {\nreturn new Array2DRowRealMatrix(rowDimension, columnDimension);\n}",
            "method_id": 40,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.math.linear.EigenDecompositionImpl:getRealEigenvalues()[D",
            "method_body": "public double[] getRealEigenvalues()\nthrows InvalidMatrixException {\nreturn realEigenvalues.clone();\n}",
            "method_id": 41,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>([[D)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d)\nthrows IllegalArgumentException, NullPointerException {\ncopyIn(d);\n}",
            "method_id": 42,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:dotProduct(Lorg/apache/commons/math/linear/ArrayRealVector;)D",
            "method_body": "public double dotProduct(ArrayRealVector v)\nthrows IllegalArgumentException {\nreturn dotProduct(v.data);\n}",
            "method_id": 43,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:createRealMatrix([[D)Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealMatrix(double[][] data) {\nreturn (data.length * data[0].length <= 4096) ?\nnew Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n}",
            "method_id": 44,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:subtract(Lorg/apache/commons/math/linear/ArrayRealVector;)Lorg/apache/commons/math/linear/ArrayRealVector;",
            "method_body": "public ArrayRealVector subtract(ArrayRealVector v)\nthrows IllegalArgumentException {\nreturn (ArrayRealVector) subtract(v.data);\n}",
            "method_id": 45,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:walkInOptimizedOrder(Lorg/apache/commons/math/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\nthrows MatrixVisitorException {\nreturn walkInRowOrder(visitor);\n}",
            "method_id": 46,
            "loc": 4
        },
        {
            "method_signature": "org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor:end()D",
            "method_body": "public double end() {\nreturn 0;\n}",
            "method_id": 47,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:<init>(Lorg/apache/commons/math/linear/ArrayRealVector;Z)V",
            "method_body": "public ArrayRealVector(ArrayRealVector v, boolean deep) {\ndata = deep ? v.data.clone() : v.data;\n}",
            "method_id": 48,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:<init>([D)V",
            "method_body": "public ArrayRealVector(double[] d) {\ndata = d.clone();\n}",
            "method_id": 49,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:copy()Lorg/apache/commons/math/linear/RealVector;",
            "method_body": "public RealVector copy() {\nreturn new ArrayRealVector(this, true);\n}",
            "method_id": 50,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:copyIn([[D)V",
            "method_body": "private void copyIn(final double[][] in) {\nsetSubMatrix(in, 0, 0);\n}",
            "method_id": 51,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n}",
            "method_id": 52,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn (data == null) ? 0 : data.length;\n}",
            "method_id": 53,
            "loc": 3
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:<init>()V",
            "method_body": "protected AbstractRealMatrix() {\nlu = null;\n}",
            "method_id": 54,
            "loc": 3
        }
    ]
}