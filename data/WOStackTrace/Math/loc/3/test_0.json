{
    "bug_id": 3,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.util.MathArraysTest.testLinearCombinationWithSingleElementArray",
    "test_body": "public void testLinearCombinationWithSingleElementArray() {\nfinal double[] a = { 1.23456789 };\nfinal double[] b = { 98765432.1 };\nAssert.assertEquals(a[0] * b[0], MathArrays.linearCombination(a, b), 0d);\n}\n",
    "stack_trace": "java.lang.ArrayIndexOutOfBoundsException: 1\nat org.apache.commons.math3.util.MathArrays.linearCombination(MathArrays.java:846)\nat org.apache.commons.math3.util.MathArraysTest.testLinearCombinationWithSingleElementArray(MathArraysTest.java:591)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:linearCombination([D[D)D",
            "method_body": "public static double linearCombination(final double[] a, final double[] b)\nthrows DimensionMismatchException {\nfinal int len = a.length;\nif (len != b.length) {\nthrow new DimensionMismatchException(len, b.length);\n}\n\n// Revert to scalar multiplication.\n\nfinal double[] prodHigh = new double[len];\ndouble prodLowSum = 0;\n\nfor (int i = 0; i < len; i++) {\nfinal double ai = a[i];\nfinal double ca = SPLIT_FACTOR * ai;\nfinal double aHigh = ca - (ca - ai);\nfinal double aLow = ai - aHigh;\n\nfinal double bi = b[i];\nfinal double cb = SPLIT_FACTOR * bi;\nfinal double bHigh = cb - (cb - bi);\nfinal double bLow = bi - bHigh;\nprodHigh[i] = ai * bi;\nfinal double prodLow = aLow * bLow - (((prodHigh[i] -\naHigh * bHigh) -\naLow * bHigh) -\naHigh * bLow);\nprodLowSum += prodLow;\n}\n\n\nfinal double prodHighCur = prodHigh[0];\ndouble prodHighNext = prodHigh[1];\ndouble sHighPrev = prodHighCur + prodHighNext;\ndouble sPrime = sHighPrev - prodHighNext;\ndouble sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\nfinal int lenMinusOne = len - 1;\nfor (int i = 1; i < lenMinusOne; i++) {\nprodHighNext = prodHigh[i + 1];\nfinal double sHighCur = sHighPrev + prodHighNext;\nsPrime = sHighCur - prodHighNext;\nsLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\nsHighPrev = sHighCur;\n}\n\ndouble result = sHighPrev + (prodLowSum + sLowSum);\n\nif (Double.isNaN(result)) {\n// either we have split infinite numbers or some coefficients were NaNs,\n// just rely on the naive implementation and let IEEE754 handle this\nresult = 0;\nfor (int i = 0; i < len; ++i) {\nresult += a[i] * b[i];\n}\n}\n\nreturn result;\n}",
            "method_id": 0,
            "loc": 59
        }
    ]
}