{
    "bug_id": 73,
    "test_id": 0,
    "test_name": "org.jsoup.helper.W3CDomTest.namespacePreservation",
    "test_body": "public void namespacePreservation() throws IOException {\nFile in = ParseTest.getFile(\"/htmltests/namespaces.xhtml\");\norg.jsoup.nodes.Document jsoupDoc;\njsoupDoc = Jsoup.parse(in, \"UTF-8\");\nDocument doc;\norg.jsoup.helper.W3CDom jDom = new org.jsoup.helper.W3CDom();\ndoc = jDom.fromJsoup(jsoupDoc);\nNode htmlEl = doc.getChildNodes().item(0);\nassertEquals(\"http://www.w3.org/1999/xhtml\", htmlEl.getNamespaceURI());\nassertEquals(\"html\", htmlEl.getLocalName());\nassertEquals(\"html\", htmlEl.getNodeName());\n// inherits default namespace\nNode head = htmlEl.getFirstChild();\nassertEquals(\"http://www.w3.org/1999/xhtml\", head.getNamespaceURI());\nassertEquals(\"head\", head.getLocalName());\nassertEquals(\"head\", head.getNodeName());\nNode epubTitle = htmlEl.getChildNodes().item(2).getChildNodes().item(3);\nassertEquals(\"Check\", epubTitle.getTextContent());\nassertEquals(\"http://www.idpf.org/2007/ops\", epubTitle.getNamespaceURI());\nassertEquals(\"title\", epubTitle.getLocalName());\nassertEquals(\"epub:title\", epubTitle.getNodeName());\nNode xSection = epubTitle.getNextSibling().getNextSibling();\nassertEquals(\"urn:test\", xSection.getNamespaceURI());\nassertEquals(\"section\", xSection.getLocalName());\nassertEquals(\"x:section\", xSection.getNodeName());\n// https://github.com/jhy/jsoup/issues/977\n// does not keep last set namespace\nNode svg = xSection.getNextSibling().getNextSibling();\nassertEquals(\"http://www.w3.org/2000/svg\", svg.getNamespaceURI());\nassertEquals(\"svg\", svg.getLocalName());\nassertEquals(\"svg\", svg.getNodeName());\nNode path = svg.getChildNodes().item(1);\nassertEquals(\"http://www.w3.org/2000/svg\", path.getNamespaceURI());\nassertEquals(\"path\", path.getLocalName());\nassertEquals(\"path\", path.getNodeName());\nNode clip = path.getChildNodes().item(1);\nassertEquals(\"http://example.com/clip\", clip.getNamespaceURI());\nassertEquals(\"clip\", clip.getLocalName());\nassertEquals(\"clip\", clip.getNodeName());\nassertEquals(\"456\", clip.getTextContent());\nNode picture = svg.getNextSibling().getNextSibling();\nassertEquals(\"http://www.w3.org/1999/xhtml\", picture.getNamespaceURI());\nassertEquals(\"picture\", picture.getLocalName());\nassertEquals(\"picture\", picture.getNodeName());\nNode img = picture.getFirstChild();\nassertEquals(\"http://www.w3.org/1999/xhtml\", img.getNamespaceURI());\nassertEquals(\"img\", img.getLocalName());\nassertEquals(\"img\", img.getNodeName());\n}\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.helper.W3CDom$W3CBuilder:copyAttributes(Lorg/jsoup/nodes/Node;Lorg/w3c/dom/Element;)V",
            "method_body": "private void copyAttributes(org.jsoup.nodes.Node source, Element el) {\nfor (Attribute attribute : source.attributes()) {\n// valid xml attribute names are: ^[a-zA-Z_:][-a-zA-Z0-9_:.]\nString key = attribute.getKey().replaceAll(\"[^-a-zA-Z0-9_:.]\", \"\");\nif (key.matches(\"[a-zA-Z_:][-a-zA-Z0-9_:.]*\"))\nel.setAttribute(key, attribute.getValue());\n}\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.jsoup.helper.W3CDom:convert(Lorg/jsoup/nodes/Document;Lorg/w3c/dom/Document;)V",
            "method_body": "public void convert(org.jsoup.nodes.Document in, Document out) {\nif (!StringUtil.isBlank(in.location()))\nout.setDocumentURI(in.location());\n\norg.jsoup.nodes.Element rootEl = in.child(0); // skip the #root node\nNodeTraversor.traverse(new W3CBuilder(out), rootEl);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.jsoup.helper.W3CDom:fromJsoup(Lorg/jsoup/nodes/Document;)Lorg/w3c/dom/Document;",
            "method_body": "public Document fromJsoup(org.jsoup.nodes.Document in) {\nValidate.notNull(in);\nDocumentBuilder builder;\ntry {\n//set the factory to be namespace-aware\nfactory.setNamespaceAware(true);\nbuilder = factory.newDocumentBuilder();\nDocument out = builder.newDocument();\nconvert(in, out);\nreturn out;\n} catch (ParserConfigurationException e) {\nthrow new IllegalStateException(e);\n}\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes$1:next()Lorg/jsoup/nodes/Attribute;",
            "method_body": "public Iterator<Attribute> iterator() {\nreturn new Iterator<Attribute>() {\nint i = 0;\n\n@Override\npublic boolean hasNext() {\nreturn i < size;\n}\n\n@Override\npublic Attribute next() {\nfinal Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\ni++;\nreturn attr;\n}\n\n@Override\npublic void remove() {\nAttributes.this.remove(--i); // next() advanced, so rewind\n}\n};\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes$1:hasNext()Z",
            "method_body": "public Iterator<Attribute> iterator() {\nreturn new Iterator<Attribute>() {\nint i = 0;\n\n@Override\npublic boolean hasNext() {\nreturn i < size;\n}\n\n@Override\npublic Attribute next() {\nfinal Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\ni++;\nreturn attr;\n}\n\n@Override\npublic void remove() {\nAttributes.this.remove(--i); // next() advanced, so rewind\n}\n};\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.jsoup.internal.ConstrainableInputStream:expired()Z",
            "method_body": "private boolean expired() {\nif (timeout == 0)\nreturn false;\n\nfinal long now = System.nanoTime();\nfinal long dur = now - startTime;\nreturn (dur > timeout);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.jsoup.internal.ConstrainableInputStream:reset()V",
            "method_body": "public void reset() throws IOException {\nsuper.reset();\nremaining = maxSize - markpos;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.jsoup.internal.ConstrainableInputStream:read([BII)I",
            "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (interrupted || capped && remaining <= 0)\nreturn -1;\nif (Thread.interrupted()) {\n// interrupted latches, because parse() may call twice (and we still want the thread interupt to clear)\ninterrupted = true;\nreturn -1;\n}\nif (expired())\nthrow new SocketTimeoutException(\"Read timeout\");\n\nif (capped && len > remaining)\nlen = remaining; // don't read more than desired, even if available\n\ntry {\nfinal int read = super.read(b, off, len);\nremaining -= read;\nreturn read;\n} catch (SocketTimeoutException e) {\nreturn 0;\n}\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.jsoup.internal.ConstrainableInputStream:wrap(Ljava/io/InputStream;II)Lorg/jsoup/internal/ConstrainableInputStream;",
            "method_body": "public static ConstrainableInputStream wrap(InputStream in, int bufferSize, int maxSize) {\nreturn in instanceof ConstrainableInputStream\n? (ConstrainableInputStream) in\n: new ConstrainableInputStream(in, bufferSize, maxSize);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.jsoup.internal.ConstrainableInputStream:<init>(Ljava/io/InputStream;II)V",
            "method_body": "private static final int DefaultSize = 1024 * 32;\n\nprivate final boolean capped;\nprivate final int maxSize;\nprivate long startTime;\nprivate long timeout = 0; // optional max time of request\nprivate int remaining;\nprivate boolean interrupted;\n\nprivate ConstrainableInputStream(InputStream in, int bufferSize, int maxSize) {\nsuper(in, bufferSize);\nValidate.isTrue(maxSize >= 0);\nthis.maxSize = maxSize;\nremaining = maxSize;\ncapped = maxSize != 0;\nstartTime = System.nanoTime();\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.jsoup.helper.DataUtil:detectCharsetFromBom(Ljava/nio/ByteBuffer;)Lorg/jsoup/helper/DataUtil$BomCharset;",
            "method_body": "private static BomCharset detectCharsetFromBom(final ByteBuffer byteData) {\nfinal Buffer buffer = byteData; // .mark and rewind used to return Buffer, now ByteBuffer, so cast for backward compat\nbuffer.mark();\nbyte[] bom = new byte[4];\nif (byteData.remaining() >= bom.length) {\nbyteData.get(bom);\nbuffer.rewind();\n}\nif (bom[0] == 0x00 && bom[1] == 0x00 && bom[2] == (byte) 0xFE && bom[3] == (byte) 0xFF || // BE\nbom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE && bom[2] == 0x00 && bom[3] == 0x00) { // LE\nreturn new BomCharset(\"UTF-32\", 0); // and I hope it's on your system\n} else if (bom[0] == (byte) 0xFE && bom[1] == (byte) 0xFF || // BE\nbom[0] == (byte) 0xFF && bom[1] == (byte) 0xFE) {\nreturn new BomCharset(\"UTF-16\", 0); // in all Javas\n} else if (bom[0] == (byte) 0xEF && bom[1] == (byte) 0xBB && bom[2] == (byte) 0xBF) {\nreturn new BomCharset(\"UTF-8\", 3); // in all Javas\n// 16 and 32 decoders consume the BOM to determine be/le; utf-8 should be consumed here\n}\nreturn null;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.jsoup.helper.DataUtil:readToByteBuffer(Ljava/io/InputStream;I)Ljava/nio/ByteBuffer;",
            "method_body": "public static ByteBuffer readToByteBuffer(InputStream inStream, int maxSize) throws IOException {\nValidate.isTrue(maxSize >= 0, \"maxSize must be 0 (unlimited) or larger\");\nfinal ConstrainableInputStream input = ConstrainableInputStream.wrap(inStream, bufferSize, maxSize);\nreturn input.readToByteBuffer(maxSize);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.jsoup.helper.DataUtil:parseInputStream(Ljava/io/InputStream;Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/parser/Parser;)Lorg/jsoup/nodes/Document;",
            "method_body": "static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {\nif (input == null) // empty body\nreturn new Document(baseUri);\ninput = ConstrainableInputStream.wrap(input, bufferSize, 0);\n\nDocument doc = null;\nboolean fullyRead = false;\n\n// read the start of the stream and look for a BOM or meta charset\ninput.mark(firstReadBufferSize);\nByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed\nfullyRead = input.read() == -1;\ninput.reset();\n\n// look for BOM - overrides any other header or input\nBomCharset bomCharset = detectCharsetFromBom(firstBytes);\nif (bomCharset != null) {\ncharsetName = bomCharset.charset;\ninput.skip(bomCharset.offset);\n}\n\nif (charsetName == null) { // determine from meta. safe first parse as UTF-8\nString docData = Charset.forName(defaultCharset).decode(firstBytes).toString();\ndoc = parser.parseInput(docData, baseUri);\n\n// look for <meta http-equiv=\"Content-Type\" content=\"text/html;charset=gb2312\"> or HTML5 <meta charset=\"gb2312\">\nElements metaElements = doc.select(\"meta[http-equiv=content-type], meta[charset]\");\nString foundCharset = null; // if not found, will keep utf-8 as best attempt\nfor (Element meta : metaElements) {\nif (meta.hasAttr(\"http-equiv\"))\nfoundCharset = getCharsetFromContentType(meta.attr(\"content\"));\nif (foundCharset == null && meta.hasAttr(\"charset\"))\nfoundCharset = meta.attr(\"charset\");\nif (foundCharset != null)\nbreak;\n}\n\n// look for <?xml encoding='ISO-8859-1'?>\nif (foundCharset == null && doc.childNodeSize() > 0 && doc.childNode(0) instanceof XmlDeclaration) {\nXmlDeclaration prolog = (XmlDeclaration) doc.childNode(0);\nif (prolog.name().equals(\"xml\"))\nfoundCharset = prolog.attr(\"encoding\");\n}\nfoundCharset = validateCharset(foundCharset);\nif (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)\nfoundCharset = foundCharset.trim().replaceAll(\"[\\\"']\", \"\");\ncharsetName = foundCharset;\ndoc = null;\n} else if (!fullyRead) {\ndoc = null;\n}\n} else { // specified by content type header (or by user on file load)\nValidate.notEmpty(charsetName, \"Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML\");\n}\nif (doc == null) {\nif (charsetName == null)\ncharsetName = defaultCharset;\nBufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);\ndoc = parser.parseInput(reader, baseUri);\ndoc.outputSettings().charset(charsetName);\n}\ninput.close();\nreturn doc;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.jsoup.helper.DataUtil:load(Ljava/io/File;Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Document;",
            "method_body": "public static Document load(File in, String charsetName, String baseUri) throws IOException {\nreturn parseInputStream(new FileInputStream(in), charsetName, baseUri, Parser.htmlParser());\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.jsoup.helper.DataUtil:<clinit>()V",
            "method_body": "private static final Pattern charsetPattern = Pattern.compile(\"(?i)\\\\bcharset=\\\\s*(?:[\\\"'])?([^\\\\s,;\\\"']*)\");\nstatic final String defaultCharset = \"UTF-8\"; // used if not found in header or meta charset\nprivate static final int firstReadBufferSize = 1024 * 5;\nstatic final int bufferSize = 1024 * 32;\nprivate static final char[] mimeBoundaryChars =\n\"-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\".toCharArray();\nstatic final int boundaryLength = 32;\n\nprivate DataUtil() {}",
            "method_id": 14
        },
        {
            "method_signature": "org.jsoup.nodes.Attribute:getValue()Ljava/lang/String;",
            "method_body": "public String getValue() {\nreturn val;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.jsoup.nodes.Attribute:getKey()Ljava/lang/String;",
            "method_body": "public String getKey() {\nreturn key;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.jsoup.nodes.Attribute:<clinit>()V",
            "method_body": "private static final String[] booleanAttributes = {\n\"allowfullscreen\", \"async\", \"autofocus\", \"checked\", \"compact\", \"declare\", \"default\", \"defer\", \"disabled\",\n\"formnovalidate\", \"hidden\", \"inert\", \"ismap\", \"itemscope\", \"multiple\", \"muted\", \"nohref\", \"noresize\",\n\"noshade\", \"novalidate\", \"nowrap\", \"open\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\",\n\"sortable\", \"truespeed\", \"typemustmatch\"\n};",
            "method_id": 17
        },
        {
            "method_signature": "org.jsoup.nodes.Attribute:<init>(Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/nodes/Attributes;)V",
            "method_body": "public Attribute(String key, String val, Attributes parent) {\nValidate.notNull(key);\nthis.key = key.trim();\nValidate.notEmpty(key); // trimming could potentially make empty, so validate here\nthis.val = val;\nthis.parent = parent;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.jsoup.select.NodeTraversor:traverse(Lorg/jsoup/select/NodeVisitor;Lorg/jsoup/nodes/Node;)V",
            "method_body": "public static void traverse(NodeVisitor visitor, Node root) {\nNode node = root;\nint depth = 0;\n\nwhile (node != null) {\nvisitor.head(node, depth);\nif (node.childNodeSize() > 0) {\nnode = node.childNode(0);\ndepth++;\n} else {\nwhile (node.nextSibling() == null && depth > 0) {\nvisitor.tail(node, depth);\nnode = node.parentNode();\ndepth--;\n}\nvisitor.tail(node, depth);\nif (node == root)\nbreak;\nnode = node.nextSibling();\n}\n}\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.jsoup.parser.Token$EOF:reset()Lorg/jsoup/parser/Token;",
            "method_body": "Token reset() {\nreturn this;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.jsoup.parser.Token$EOF:<init>()V",
            "method_body": "EOF() {\ntype = Token.TokenType.EOF;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.jsoup.nodes.Comment:<init>(Ljava/lang/String;)V",
            "method_body": "public Comment(String data) {\nvalue = data;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.jsoup.nodes.DataNode:getWholeData()Ljava/lang/String;",
            "method_body": "public String getWholeData() {\nreturn coreValue();\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.jsoup.nodes.DataNode:nodeName()Ljava/lang/String;",
            "method_body": "public String nodeName() {\nreturn \"#data\";\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.jsoup.nodes.DataNode:<init>(Ljava/lang/String;)V",
            "method_body": "public DataNode(String data) {\nvalue = data;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:getWholeText()Ljava/lang/String;",
            "method_body": "public String getWholeText() {\nreturn coreValue();\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:nodeName()Ljava/lang/String;",
            "method_body": "public String nodeName() {\nreturn \"#text\";\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:<init>(Ljava/lang/String;)V",
            "method_body": "public TextNode(String text) {\nvalue = text;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.jsoup.nodes.LeafNode:childNodeSize()I",
            "method_body": "public int childNodeSize() {\nreturn 0;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.jsoup.nodes.LeafNode:coreValue()Ljava/lang/String;",
            "method_body": "String coreValue() {\nreturn attr(nodeName());\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.jsoup.nodes.LeafNode:hasAttributes()Z",
            "method_body": "protected final boolean hasAttributes() {\nreturn value instanceof Attributes;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$Constants:<clinit>()V",
            "method_body": "static final String[] Formatters = new String[]{\"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};\nstatic final String[] Formatters = new String[]{\"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\"};",
            "method_id": 32
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:inSorted(Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "public static boolean inSorted(String needle, String[] haystack) {\nreturn Arrays.binarySearch(haystack, needle) >= 0;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:in(Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "public static boolean in(final String needle, final String... haystack) {\nfinal int len = haystack.length;\nfor (int i = 0; i < len; i++) {\nif (haystack[i].equals(needle))\nreturn true;\n}\nreturn false;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:isWhitespace(I)Z",
            "method_body": "public static boolean isWhitespace(int c){\nreturn c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r';\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:<clinit>()V",
            "method_body": "private static final int MaxCachedBuilderSize = 8 * 1024;\nprivate static final ThreadLocal<StringBuilder> stringLocal = new ThreadLocal<StringBuilder>(){\n@Override\nprotected StringBuilder initialValue() {\nreturn new StringBuilder(MaxCachedBuilderSize);\n}\n};",
            "method_id": 36
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$24:<clinit>()V",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\ntb.insert(t.asCharacter());\nreturn true;\n}\nswitch (t.type) {\ncase Comment:\ntb.insert(t.asComment());\nbreak;\ncase Doctype:\ntb.error(this);\nreturn false;\ncase StartTag:\nToken.StartTag start = t.asStartTag();\nString name = start.normalName();\nif (name.equals(\"html\")) {\nreturn InBody.process(t, tb);\n} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\nElement el = tb.insertEmpty(start);\n// jsoup special: update base the frist time it is seen\nif (name.equals(\"base\") && el.hasAttr(\"href\"))\ntb.maybeSetBaseUri(el);\n} else if (name.equals(\"meta\")) {\nElement meta = tb.insertEmpty(start);\n// todo: charset switches\n} else if (name.equals(\"title\")) {\nhandleRcData(start, tb);\n} else if (StringUtil.in(name, \"noframes\", \"style\")) {\nhandleRawtext(start, tb);\n} else if (name.equals(\"noscript\")) {\n// else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)\ntb.insert(start);\ntb.transition(InHeadNoscript);\n} else if (name.equals(\"script\")) {\n// skips some script rules as won't execute them\n\ntb.tokeniser.transition(TokeniserState.ScriptData);\ntb.markInsertionMode();\ntb.transition(Text);\ntb.insert(start);\n} else if (name.equals(\"head\")) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\nbreak;\ncase EndTag:\nToken.EndTag end = t.asEndTag();\nname = end.normalName();\nif (name.equals(\"head\")) {\ntb.pop();\ntb.transition(AfterHead);\n} else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\nreturn anythingElse(t, tb);\n} else {\ntb.error(this);\nreturn false;\n}\nbreak;\ndefault:\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.jsoup.nodes.Element$NodeList:onContentsChanged()V",
            "method_body": "public void onContentsChanged() {\nowner.nodelistChanged();\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.jsoup.nodes.Element$NodeList:<init>(Lorg/jsoup/nodes/Element;I)V",
            "method_body": "NodeList(Element owner, int initialCapacity) {\nsuper(initialCapacity);\nthis.owner = owner;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.jsoup.helper.ChangeNotifyingArrayList:add(Ljava/lang/Object;)Z",
            "method_body": "public boolean add(E e) {\nonContentsChanged();\nreturn super.add(e);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.jsoup.helper.ChangeNotifyingArrayList:<init>(I)V",
            "method_body": "public ChangeNotifyingArrayList(int initialCapacity) {\nsuper(initialCapacity);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$21:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (t.isComment()) {\ntb.insert(t.asComment());\n} else if (t.isDoctype() || isWhitespace(t) || (t.isStartTag() && t.asStartTag().normalName().equals(\"html\"))) {\nreturn tb.process(t, InBody);\n} else if (t.isEOF()) {\n// nice work chuck\n} else {\ntb.error(this);\ntb.transition(InBody);\nreturn tb.process(t);\n}\nreturn true;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$18:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\nreturn tb.process(t, InBody);\n} else if (t.isComment()) {\ntb.insert(t.asComment()); // into html node\n} else if (t.isDoctype()) {\ntb.error(this);\nreturn false;\n} else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\nreturn tb.process(t, InBody);\n} else if (t.isEndTag() && t.asEndTag().normalName().equals(\"html\")) {\nif (tb.isFragmentParsing()) {\ntb.error(this);\nreturn false;\n} else {\ntb.transition(AfterAfterBody);\n}\n} else if (t.isEOF()) {\n// chillax! we're done\n} else {\ntb.error(this);\ntb.transition(InBody);\nreturn tb.process(t);\n}\nreturn true;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$8:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (t.isCharacter()) {\ntb.insert(t.asCharacter());\n} else if (t.isEOF()) {\ntb.error(this);\n// if current node is script: already started\ntb.pop();\ntb.transition(tb.originalState());\nreturn tb.process(t);\n} else if (t.isEndTag()) {\n// if: An end tag whose tag name is \"script\" -- scripting nesting level, if evaluating scripts\ntb.pop();\ntb.transition(tb.originalState());\n}\nreturn true;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$7:anyOtherEndTag(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean anyOtherEndTag(Token t, HtmlTreeBuilder tb) {\nString name = tb.settings.normalizeTag(t.asEndTag().name()); // matches with case sensitivity if enabled\nArrayList<Element> stack = tb.getStack();\nfor (int pos = stack.size() -1; pos >= 0; pos--) {\nElement node = stack.get(pos);\nif (node.nodeName().equals(name)) {\ntb.generateImpliedEndTags(name);\nif (!name.equals(tb.currentElement().nodeName()))\ntb.error(this);\ntb.popStackToClose(name);\nbreak;\n} else {\nif (tb.isSpecial(node)) {\ntb.error(this);\nreturn false;\n}\n}\n}\nreturn true;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$7:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nswitch (t.type) {\ncase Character: {\nToken.Character c = t.asCharacter();\nif (c.getData().equals(nullString)) {\n// todo confirm that check\ntb.error(this);\nreturn false;\n} else if (tb.framesetOk() && isWhitespace(c)) { // don't check if whitespace if frames already closed\ntb.reconstructFormattingElements();\ntb.insert(c);\n} else {\ntb.reconstructFormattingElements();\ntb.insert(c);\ntb.framesetOk(false);\n}\nbreak;\n}\ncase Comment: {\ntb.insert(t.asComment());\nbreak;\n}\ncase Doctype: {\ntb.error(this);\nreturn false;\n}\ncase StartTag:\nToken.StartTag startTag = t.asStartTag();\n// todo - refactor to a switch statement\nString name = startTag.normalName();\nif (name.equals(\"a\")) {\nif (tb.getActiveFormattingElement(\"a\") != null) {\ntb.error(this);\ntb.processEndTag(\"a\");\n\n// still on stack?\nElement remainingA = tb.getFromStack(\"a\");\nif (remainingA != null) {\ntb.removeFromActiveFormattingElements(remainingA);\ntb.removeFromStack(remainingA);\n}\n}\ntb.reconstructFormattingElements();\nElement a = tb.insert(startTag);\ntb.pushActiveFormattingElements(a);\n} else if (StringUtil.inSorted(name, Constants.InBodyStartEmptyFormatters)) {\ntb.reconstructFormattingElements();\ntb.insertEmpty(startTag);\ntb.framesetOk(false);\n} else if (StringUtil.inSorted(name, Constants.InBodyStartPClosers)) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\n} else if (name.equals(\"span\")) {\n// same as final else, but short circuits lots of checks\ntb.reconstructFormattingElements();\ntb.insert(startTag);\n} else if (name.equals(\"li\")) {\ntb.framesetOk(false);\nArrayList<Element> stack = tb.getStack();\nfor (int i = stack.size() - 1; i > 0; i--) {\nElement el = stack.get(i);\nif (el.nodeName().equals(\"li\")) {\ntb.processEndTag(\"li\");\nbreak;\n}\nif (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\nbreak;\n}\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\n} else if (name.equals(\"html\")) {\ntb.error(this);\n// merge attributes onto real html\nElement html = tb.getStack().get(0);\nfor (Attribute attribute : startTag.getAttributes()) {\nif (!html.hasAttr(attribute.getKey()))\nhtml.attributes().put(attribute);\n}\n} else if (StringUtil.inSorted(name, Constants.InBodyStartToHead)) {\nreturn tb.process(t, InHead);\n} else if (name.equals(\"body\")) {\ntb.error(this);\nArrayList<Element> stack = tb.getStack();\nif (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n// only in fragment case\nreturn false; // ignore\n} else {\ntb.framesetOk(false);\nElement body = stack.get(1);\nfor (Attribute attribute : startTag.getAttributes()) {\nif (!body.hasAttr(attribute.getKey()))\nbody.attributes().put(attribute);\n}\n}\n} else if (name.equals(\"frameset\")) {\ntb.error(this);\nArrayList<Element> stack = tb.getStack();\nif (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) {\n// only in fragment case\nreturn false; // ignore\n} else if (!tb.framesetOk()) {\nreturn false; // ignore frameset\n} else {\nElement second = stack.get(1);\nif (second.parent() != null)\nsecond.remove();\n// pop up to html element\nwhile (stack.size() > 1)\nstack.remove(stack.size()-1);\ntb.insert(startTag);\ntb.transition(InFrameset);\n}\n} else if (StringUtil.inSorted(name, Constants.Headings)) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\nif (StringUtil.inSorted(tb.currentElement().nodeName(), Constants.Headings)) {\ntb.error(this);\ntb.pop();\n}\ntb.insert(startTag);\n} else if (StringUtil.inSorted(name, Constants.InBodyStartPreListing)) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\n// todo: ignore LF if next token\ntb.framesetOk(false);\n} else if (name.equals(\"form\")) {\nif (tb.getFormElement() != null) {\ntb.error(this);\nreturn false;\n}\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insertForm(startTag, true);\n} else if (StringUtil.inSorted(name, Constants.DdDt)) {\ntb.framesetOk(false);\nArrayList<Element> stack = tb.getStack();\nfor (int i = stack.size() - 1; i > 0; i--) {\nElement el = stack.get(i);\nif (StringUtil.inSorted(el.nodeName(), Constants.DdDt)) {\ntb.processEndTag(el.nodeName());\nbreak;\n}\nif (tb.isSpecial(el) && !StringUtil.inSorted(el.nodeName(), Constants.InBodyStartLiBreakers))\nbreak;\n}\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\n} else if (name.equals(\"plaintext\")) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\ntb.tokeniser.transition(TokeniserState.PLAINTEXT); // once in, never gets out\n} else if (name.equals(\"button\")) {\nif (tb.inButtonScope(\"button\")) {\n// close and reprocess\ntb.error(this);\ntb.processEndTag(\"button\");\ntb.process(startTag);\n} else {\ntb.reconstructFormattingElements();\ntb.insert(startTag);\ntb.framesetOk(false);\n}\n} else if (StringUtil.inSorted(name, Constants.Formatters)) {\ntb.reconstructFormattingElements();\nElement el = tb.insert(startTag);\ntb.pushActiveFormattingElements(el);\n} else if (name.equals(\"nobr\")) {\ntb.reconstructFormattingElements();\nif (tb.inScope(\"nobr\")) {\ntb.error(this);\ntb.processEndTag(\"nobr\");\ntb.reconstructFormattingElements();\n}\nElement el = tb.insert(startTag);\ntb.pushActiveFormattingElements(el);\n} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\ntb.reconstructFormattingElements();\ntb.insert(startTag);\ntb.insertMarkerToFormattingElements();\ntb.framesetOk(false);\n} else if (name.equals(\"table\")) {\nif (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insert(startTag);\ntb.framesetOk(false);\ntb.transition(InTable);\n} else if (name.equals(\"input\")) {\ntb.reconstructFormattingElements();\nElement el = tb.insertEmpty(startTag);\nif (!el.attr(\"type\").equalsIgnoreCase(\"hidden\"))\ntb.framesetOk(false);\n} else if (StringUtil.inSorted(name, Constants.InBodyStartMedia)) {\ntb.insertEmpty(startTag);\n} else if (name.equals(\"hr\")) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.insertEmpty(startTag);\ntb.framesetOk(false);\n} else if (name.equals(\"image\")) {\nif (tb.getFromStack(\"svg\") == null)\nreturn tb.process(startTag.name(\"img\")); // change <image> to <img>, unless in svg\nelse\ntb.insert(startTag);\n} else if (name.equals(\"isindex\")) {\n// how much do we care about the early 90s?\ntb.error(this);\nif (tb.getFormElement() != null)\nreturn false;\n\ntb.processStartTag(\"form\");\nif (startTag.attributes.hasKey(\"action\")) {\nElement form = tb.getFormElement();\nform.attr(\"action\", startTag.attributes.get(\"action\"));\n}\ntb.processStartTag(\"hr\");\ntb.processStartTag(\"label\");\n// hope you like english.\nString prompt = startTag.attributes.hasKey(\"prompt\") ?\nstartTag.attributes.get(\"prompt\") :\n\"This is a searchable index. Enter search keywords: \";\n\ntb.process(new Token.Character().data(prompt));\n\n// input\nAttributes inputAttribs = new Attributes();\nfor (Attribute attr : startTag.attributes) {\nif (!StringUtil.inSorted(attr.getKey(), Constants.InBodyStartInputAttribs))\ninputAttribs.put(attr);\n}\ninputAttribs.put(\"name\", \"isindex\");\ntb.processStartTag(\"input\", inputAttribs);\ntb.processEndTag(\"label\");\ntb.processStartTag(\"hr\");\ntb.processEndTag(\"form\");\n} else if (name.equals(\"textarea\")) {\ntb.insert(startTag);\n// todo: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\ntb.tokeniser.transition(TokeniserState.Rcdata);\ntb.markInsertionMode();\ntb.framesetOk(false);\ntb.transition(Text);\n} else if (name.equals(\"xmp\")) {\nif (tb.inButtonScope(\"p\")) {\ntb.processEndTag(\"p\");\n}\ntb.reconstructFormattingElements();\ntb.framesetOk(false);\nhandleRawtext(startTag, tb);\n} else if (name.equals(\"iframe\")) {\ntb.framesetOk(false);\nhandleRawtext(startTag, tb);\n} else if (name.equals(\"noembed\")) {\n// also handle noscript if script enabled\nhandleRawtext(startTag, tb);\n} else if (name.equals(\"select\")) {\ntb.reconstructFormattingElements();\ntb.insert(startTag);\ntb.framesetOk(false);\n\nHtmlTreeBuilderState state = tb.state();\nif (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell))\ntb.transition(InSelectInTable);\nelse\ntb.transition(InSelect);\n} else if (StringUtil.inSorted(name, Constants.InBodyStartOptions)) {\nif (tb.currentElement().nodeName().equals(\"option\"))\ntb.processEndTag(\"option\");\ntb.reconstructFormattingElements();\ntb.insert(startTag);\n} else if (StringUtil.inSorted(name, Constants.InBodyStartRuby)) {\nif (tb.inScope(\"ruby\")) {\ntb.generateImpliedEndTags();\nif (!tb.currentElement().nodeName().equals(\"ruby\")) {\ntb.error(this);\ntb.popStackToBefore(\"ruby\"); // i.e. close up to but not include name\n}\ntb.insert(startTag);\n}\n} else if (name.equals(\"math\")) {\ntb.reconstructFormattingElements();\n// todo: handle A start tag whose tag name is \"math\" (i.e. foreign, mathml)\ntb.insert(startTag);\n} else if (name.equals(\"svg\")) {\ntb.reconstructFormattingElements();\n// todo: handle A start tag whose tag name is \"svg\" (xlink, svg)\ntb.insert(startTag);\n} else if (StringUtil.inSorted(name, Constants.InBodyStartDrop)) {\ntb.error(this);\nreturn false;\n} else {\ntb.reconstructFormattingElements();\ntb.insert(startTag);\n}\nbreak;\n\ncase EndTag:\nToken.EndTag endTag = t.asEndTag();\nname = endTag.normalName();\nif (StringUtil.inSorted(name, Constants.InBodyEndAdoptionFormatters)) {\n// Adoption Agency Algorithm.\nfor (int i = 0; i < 8; i++) {\nElement formatEl = tb.getActiveFormattingElement(name);\nif (formatEl == null)\nreturn anyOtherEndTag(t, tb);\nelse if (!tb.onStack(formatEl)) {\ntb.error(this);\ntb.removeFromActiveFormattingElements(formatEl);\nreturn true;\n} else if (!tb.inScope(formatEl.nodeName())) {\ntb.error(this);\nreturn false;\n} else if (tb.currentElement() != formatEl)\ntb.error(this);\n\nElement furthestBlock = null;\nElement commonAncestor = null;\nboolean seenFormattingElement = false;\nArrayList<Element> stack = tb.getStack();\n// the spec doesn't limit to < 64, but in degenerate cases (9000+ stack depth) this prevents\n// run-aways\nfinal int stackSize = stack.size();\nfor (int si = 0; si < stackSize && si < 64; si++) {\nElement el = stack.get(si);\nif (el == formatEl) {\ncommonAncestor = stack.get(si - 1);\nseenFormattingElement = true;\n} else if (seenFormattingElement && tb.isSpecial(el)) {\nfurthestBlock = el;\nbreak;\n}\n}\nif (furthestBlock == null) {\ntb.popStackToClose(formatEl.nodeName());\ntb.removeFromActiveFormattingElements(formatEl);\nreturn true;\n}\n\n// todo: Let a bookmark note the position of the formatting element in the list of active formatting elements relative to the elements on either side of it in the list.\n// does that mean: int pos of format el in list?\nElement node = furthestBlock;\nElement lastNode = furthestBlock;\nfor (int j = 0; j < 3; j++) {\nif (tb.onStack(node))\nnode = tb.aboveOnStack(node);\nif (!tb.isInActiveFormattingElements(node)) { // note no bookmark check\ntb.removeFromStack(node);\ncontinue;\n} else if (node == formatEl)\nbreak;\n\nElement replacement = new Element(Tag.valueOf(node.nodeName(), ParseSettings.preserveCase), tb.getBaseUri());\n// case will follow the original node (so honours ParseSettings)\ntb.replaceActiveFormattingElement(node, replacement);\ntb.replaceOnStack(node, replacement);\nnode = replacement;\n\nif (lastNode == furthestBlock) {\n// todo: move the aforementioned bookmark to be immediately after the new node in the list of active formatting elements.\n// not getting how this bookmark both straddles the element above, but is inbetween here...\n}\nif (lastNode.parent() != null)\nlastNode.remove();\nnode.appendChild(lastNode);\n\nlastNode = node;\n}\n\nif (StringUtil.inSorted(commonAncestor.nodeName(), Constants.InBodyEndTableFosters)) {\nif (lastNode.parent() != null)\nlastNode.remove();\ntb.insertInFosterParent(lastNode);\n} else {\nif (lastNode.parent() != null)\nlastNode.remove();\ncommonAncestor.appendChild(lastNode);\n}\n\nElement adopter = new Element(formatEl.tag(), tb.getBaseUri());\nadopter.attributes().addAll(formatEl.attributes());\nNode[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodeSize()]);\nfor (Node childNode : childNodes) {\nadopter.appendChild(childNode); // append will reparent. thus the clone to avoid concurrent mod.\n}\nfurthestBlock.appendChild(adopter);\ntb.removeFromActiveFormattingElements(formatEl);\n// todo: insert the new element into the list of active formatting elements at the position of the aforementioned bookmark.\ntb.removeFromStack(formatEl);\ntb.insertOnStackAfter(furthestBlock, adopter);\n}\n} else if (StringUtil.inSorted(name, Constants.InBodyEndClosers)) {\nif (!tb.inScope(name)) {\n// nothing to close\ntb.error(this);\nreturn false;\n} else {\ntb.generateImpliedEndTags();\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(name);\n}\n} else if (name.equals(\"span\")) {\n// same as final fall through, but saves short circuit\nreturn anyOtherEndTag(t, tb);\n} else if (name.equals(\"li\")) {\nif (!tb.inListItemScope(name)) {\ntb.error(this);\nreturn false;\n} else {\ntb.generateImpliedEndTags(name);\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(name);\n}\n} else if (name.equals(\"body\")) {\nif (!tb.inScope(\"body\")) {\ntb.error(this);\nreturn false;\n} else {\n// todo: error if stack contains something not dd, dt, li, optgroup, option, p, rp, rt, tbody, td, tfoot, th, thead, tr, body, html\ntb.transition(AfterBody);\n}\n} else if (name.equals(\"html\")) {\nboolean notIgnored = tb.processEndTag(\"body\");\nif (notIgnored)\nreturn tb.process(endTag);\n} else if (name.equals(\"form\")) {\nElement currentForm = tb.getFormElement();\ntb.setFormElement(null);\nif (currentForm == null || !tb.inScope(name)) {\ntb.error(this);\nreturn false;\n} else {\ntb.generateImpliedEndTags();\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\n// remove currentForm from stack. will shift anything under up.\ntb.removeFromStack(currentForm);\n}\n} else if (name.equals(\"p\")) {\nif (!tb.inButtonScope(name)) {\ntb.error(this);\ntb.processStartTag(name); // if no p to close, creates an empty <p></p>\nreturn tb.process(endTag);\n} else {\ntb.generateImpliedEndTags(name);\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(name);\n}\n} else if (StringUtil.inSorted(name, Constants.DdDt)) {\nif (!tb.inScope(name)) {\ntb.error(this);\nreturn false;\n} else {\ntb.generateImpliedEndTags(name);\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(name);\n}\n} else if (StringUtil.inSorted(name, Constants.Headings)) {\nif (!tb.inScope(Constants.Headings)) {\ntb.error(this);\nreturn false;\n} else {\ntb.generateImpliedEndTags(name);\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(Constants.Headings);\n}\n} else if (name.equals(\"sarcasm\")) {\n// *sigh*\nreturn anyOtherEndTag(t, tb);\n} else if (StringUtil.inSorted(name, Constants.InBodyStartApplets)) {\nif (!tb.inScope(\"name\")) {\nif (!tb.inScope(name)) {\ntb.error(this);\nreturn false;\n}\ntb.generateImpliedEndTags();\nif (!tb.currentElement().nodeName().equals(name))\ntb.error(this);\ntb.popStackToClose(name);\ntb.clearFormattingElementsToLastMarker();\n}\n} else if (name.equals(\"br\")) {\ntb.error(this);\ntb.processStartTag(\"br\");\nreturn false;\n} else {\nreturn anyOtherEndTag(t, tb);\n}\n\nbreak;\ncase EOF:\n// todo: error if stack contains something not dd, dt, li, p, tbody, td, tfoot, th, thead, tr, body, html\n// stop parsing\nbreak;\n}\nreturn true;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$6:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\ntb.insert(t.asCharacter());\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (t.isDoctype()) {\ntb.error(this);\n} else if (t.isStartTag()) {\nToken.StartTag startTag = t.asStartTag();\nString name = startTag.normalName();\nif (name.equals(\"html\")) {\nreturn tb.process(t, InBody);\n} else if (name.equals(\"body\")) {\ntb.insert(startTag);\ntb.framesetOk(false);\ntb.transition(InBody);\n} else if (name.equals(\"frameset\")) {\ntb.insert(startTag);\ntb.transition(InFrameset);\n} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\")) {\ntb.error(this);\nElement head = tb.getHeadElement();\ntb.push(head);\ntb.process(t, InHead);\ntb.removeFromStack(head);\n} else if (name.equals(\"head\")) {\ntb.error(this);\nreturn false;\n} else {\nanythingElse(t, tb);\n}\n} else if (t.isEndTag()) {\nif (StringUtil.in(t.asEndTag().normalName(), \"body\", \"html\")) {\nanythingElse(t, tb);\n} else {\ntb.error(this);\nreturn false;\n}\n} else {\nanythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$4:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\ntb.insert(t.asCharacter());\nreturn true;\n}\nswitch (t.type) {\ncase Comment:\ntb.insert(t.asComment());\nbreak;\ncase Doctype:\ntb.error(this);\nreturn false;\ncase StartTag:\nToken.StartTag start = t.asStartTag();\nString name = start.normalName();\nif (name.equals(\"html\")) {\nreturn InBody.process(t, tb);\n} else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\")) {\nElement el = tb.insertEmpty(start);\n// jsoup special: update base the frist time it is seen\nif (name.equals(\"base\") && el.hasAttr(\"href\"))\ntb.maybeSetBaseUri(el);\n} else if (name.equals(\"meta\")) {\nElement meta = tb.insertEmpty(start);\n// todo: charset switches\n} else if (name.equals(\"title\")) {\nhandleRcData(start, tb);\n} else if (StringUtil.in(name, \"noframes\", \"style\")) {\nhandleRawtext(start, tb);\n} else if (name.equals(\"noscript\")) {\n// else if noscript && scripting flag = true: rawtext (jsoup doesn't run script, to handle as noscript)\ntb.insert(start);\ntb.transition(InHeadNoscript);\n} else if (name.equals(\"script\")) {\n// skips some script rules as won't execute them\n\ntb.tokeniser.transition(TokeniserState.ScriptData);\ntb.markInsertionMode();\ntb.transition(Text);\ntb.insert(start);\n} else if (name.equals(\"head\")) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\nbreak;\ncase EndTag:\nToken.EndTag end = t.asEndTag();\nname = end.normalName();\nif (name.equals(\"head\")) {\ntb.pop();\ntb.transition(AfterHead);\n} else if (StringUtil.in(name, \"body\", \"html\", \"br\")) {\nreturn anythingElse(t, tb);\n} else {\ntb.error(this);\nreturn false;\n}\nbreak;\ndefault:\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$3:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\nreturn true;\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (t.isDoctype()) {\ntb.error(this);\nreturn false;\n} else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\nreturn InBody.process(t, tb); // does not transition\n} else if (t.isStartTag() && t.asStartTag().normalName().equals(\"head\")) {\nElement head = tb.insert(t.asStartTag());\ntb.setHeadElement(head);\ntb.transition(InHead);\n} else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\ntb.processStartTag(\"head\");\nreturn tb.process(t);\n} else if (t.isEndTag()) {\ntb.error(this);\nreturn false;\n} else {\ntb.processStartTag(\"head\");\nreturn tb.process(t);\n}\nreturn true;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$2:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (t.isDoctype()) {\ntb.error(this);\nreturn false;\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (isWhitespace(t)) {\nreturn true; // ignore whitespace\n} else if (t.isStartTag() && t.asStartTag().normalName().equals(\"html\")) {\ntb.insert(t.asStartTag());\ntb.transition(BeforeHead);\n} else if (t.isEndTag() && (StringUtil.in(t.asEndTag().normalName(), \"head\", \"body\", \"html\", \"br\"))) {\nreturn anythingElse(t, tb);\n} else if (t.isEndTag()) {\ntb.error(this);\nreturn false;\n} else {\nreturn anythingElse(t, tb);\n}\nreturn true;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState$1:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilder;)Z",
            "method_body": "boolean process(Token t, HtmlTreeBuilder tb) {\nif (isWhitespace(t)) {\nreturn true; // ignore whitespace\n} else if (t.isComment()) {\ntb.insert(t.asComment());\n} else if (t.isDoctype()) {\n// todo: parse error check on expected doctypes\n// todo: quirk state check on doctype ids\nToken.Doctype d = t.asDoctype();\nDocumentType doctype = new DocumentType(\ntb.settings.normalizeTag(d.getName()), d.getPublicIdentifier(), d.getSystemIdentifier());\ndoctype.setPubSysKey(d.getPubSysKey());\ntb.getDocument().appendChild(doctype);\nif (d.isForceQuirks())\ntb.getDocument().quirksMode(Document.QuirksMode.quirks);\ntb.transition(BeforeHtml);\n} else {\n// todo: check not iframe srcdoc\ntb.transition(BeforeHtml);\nreturn tb.process(t); // re-process token\n}\nreturn true;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState:handleRawtext(Lorg/jsoup/parser/Token$StartTag;Lorg/jsoup/parser/HtmlTreeBuilder;)V",
            "method_body": "private static void handleRawtext(Token.StartTag startTag, HtmlTreeBuilder tb) {\ntb.tokeniser.transition(TokeniserState.Rawtext);\ntb.markInsertionMode();\ntb.transition(Text);\ntb.insert(startTag);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState:handleRcData(Lorg/jsoup/parser/Token$StartTag;Lorg/jsoup/parser/HtmlTreeBuilder;)V",
            "method_body": "private static void handleRcData(Token.StartTag startTag, HtmlTreeBuilder tb) {\ntb.tokeniser.transition(TokeniserState.Rcdata);\ntb.markInsertionMode();\ntb.transition(Text);\ntb.insert(startTag);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState:isWhitespace(Ljava/lang/String;)Z",
            "method_body": "private static boolean isWhitespace(String data) {\n// todo: this checks more than spec - \"\\t\", \"\\n\", \"\\f\", \"\\r\", \" \"\nfor (int i = 0; i < data.length(); i++) {\nchar c = data.charAt(i);\nif (!StringUtil.isWhitespace(c))\nreturn false;\n}\nreturn true;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilderState:isWhitespace(Lorg/jsoup/parser/Token;)Z",
            "method_body": "abstract boolean process(Token t, HtmlTreeBuilder tb);\n\nprivate static boolean isWhitespace(Token t) {\nif (t.isCharacter()) {\nString data = t.asCharacter().getData();\nreturn isWhitespace(data);\n}\nreturn false;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.jsoup.parser.Token$Comment:getData()Ljava/lang/String;",
            "method_body": "String getData() {\nreturn data.toString();\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.jsoup.parser.Token$Comment:reset()Lorg/jsoup/parser/Token;",
            "method_body": "Token reset() {\nreset(data);\nbogus = false;\nreturn this;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.jsoup.parser.Token$Comment:<init>()V",
            "method_body": "final StringBuilder data = new StringBuilder();\nboolean bogus = false;\n\n@Override\nToken reset() {\nreset(data);\nbogus = false;\nreturn this;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.jsoup.parser.Token$Doctype:<init>()V",
            "method_body": "Doctype() {\ntype = TokenType.Doctype;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:getData()Ljava/lang/String;",
            "method_body": "String getData() {\nreturn data;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:data(Ljava/lang/String;)Lorg/jsoup/parser/Token$Character;",
            "method_body": "Character data(String data) {\nthis.data = data;\nreturn this;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:reset()Lorg/jsoup/parser/Token;",
            "method_body": "Token reset() {\ndata = null;\nreturn this;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:<init>()V",
            "method_body": "Character() {\nsuper();\ntype = TokenType.Character;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$43:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\n// todo: handle bogus comment starting from eof. when does that trigger?\n// rewind to capture character that lead us here\nr.unconsume();\nToken.Comment comment = new Token.Comment();\ncomment.bogus = true;\ncomment.data.append(r.consumeTo('>'));\n// todo: replace nullChar with replaceChar\nt.emit(comment);\nt.advanceTransition(Data);\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$42:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\ncase '>':\nt.tagPending.selfClosing = true;\nt.emitTagPending();\nt.transition(Data);\nbreak;\ncase eof:\nt.eofError(this);\nt.transition(Data);\nbreak;\ndefault:\nt.error(this);\nr.unconsume();\nt.transition(BeforeAttributeName);\n}\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$41:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\ncase '\\t':\ncase '\\n':\ncase '\\r':\ncase '\\f':\ncase ' ':\nt.transition(BeforeAttributeName);\nbreak;\ncase '/':\nt.transition(SelfClosingStartTag);\nbreak;\ncase '>':\nt.emitTagPending();\nt.transition(Data);\nbreak;\ncase eof:\nt.eofError(this);\nt.transition(Data);\nbreak;\ndefault:\nt.error(this);\nr.unconsume();\nt.transition(BeforeAttributeName);\n}\n\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$38:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nString value = r.consumeToAny(attributeDoubleValueCharsSorted);\nif (value.length() > 0)\nt.tagPending.appendAttributeValue(value);\nelse\nt.tagPending.setEmptyAttributeValue();\n\nchar c = r.consume();\nswitch (c) {\ncase '\"':\nt.transition(AfterAttributeValue_quoted);\nbreak;\ncase '&':\nint[] ref = t.consumeCharacterReference('\"', true);\nif (ref != null)\nt.tagPending.appendAttributeValue(ref);\nelse\nt.tagPending.appendAttributeValue('&');\nbreak;\ncase nullChar:\nt.error(this);\nt.tagPending.appendAttributeValue(replacementChar);\nbreak;\ncase eof:\nt.eofError(this);\nt.transition(Data);\nbreak;\ndefault: // hit end of buffer in first read, still in attribute\nt.tagPending.appendAttributeValue(c);\n}\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$37:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\ncase '\\t':\ncase '\\n':\ncase '\\r':\ncase '\\f':\ncase ' ':\n// ignore\nbreak;\ncase '\"':\nt.transition(AttributeValue_doubleQuoted);\nbreak;\ncase '&':\nr.unconsume();\nt.transition(AttributeValue_unquoted);\nbreak;\ncase '\\'':\nt.transition(AttributeValue_singleQuoted);\nbreak;\ncase nullChar:\nt.error(this);\nt.tagPending.appendAttributeValue(replacementChar);\nt.transition(AttributeValue_unquoted);\nbreak;\ncase eof:\nt.eofError(this);\nt.emitTagPending();\nt.transition(Data);\nbreak;\ncase '>':\nt.error(this);\nt.emitTagPending();\nt.transition(Data);\nbreak;\ncase '<':\ncase '=':\ncase '`':\nt.error(this);\nt.tagPending.appendAttributeValue(c);\nt.transition(AttributeValue_unquoted);\nbreak;\ndefault:\nr.unconsume();\nt.transition(AttributeValue_unquoted);\n}\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$35:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nString name = r.consumeToAnySorted(attributeNameCharsSorted);\nt.tagPending.appendAttributeName(name);\n\nchar c = r.consume();\nswitch (c) {\ncase '\\t':\ncase '\\n':\ncase '\\r':\ncase '\\f':\ncase ' ':\nt.transition(AfterAttributeName);\nbreak;\ncase '/':\nt.transition(SelfClosingStartTag);\nbreak;\ncase '=':\nt.transition(BeforeAttributeValue);\nbreak;\ncase '>':\nt.emitTagPending();\nt.transition(Data);\nbreak;\ncase nullChar:\nt.error(this);\nt.tagPending.appendAttributeName(replacementChar);\nbreak;\ncase eof:\nt.eofError(this);\nt.transition(Data);\nbreak;\ncase '\"':\ncase '\\'':\ncase '<':\nt.error(this);\nt.tagPending.appendAttributeName(c);\nbreak;\ndefault: // buffer underrun\nt.tagPending.appendAttributeName(c);\n}\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$34:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nchar c = r.consume();\nswitch (c) {\ncase '\\t':\ncase '\\n':\ncase '\\r':\ncase '\\f':\ncase ' ':\nbreak; // ignore whitespace\ncase '/':\nt.transition(SelfClosingStartTag);\nbreak;\ncase '>':\nt.emitTagPending();\nt.transition(Data);\nbreak;\ncase nullChar:\nt.error(this);\nt.tagPending.newAttribute();\nr.unconsume();\nt.transition(AttributeName);\nbreak;\ncase eof:\nt.eofError(this);\nt.transition(Data);\nbreak;\ncase '\"':\ncase '\\'':\ncase '<':\ncase '=':\nt.error(this);\nt.tagPending.newAttribute();\nt.tagPending.appendAttributeName(c);\nt.transition(AttributeName);\nbreak;\ndefault: // A-Z, anything else\nt.tagPending.newAttribute();\nr.unconsume();\nt.transition(AttributeName);\n}\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$16:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nhandleDataEndTag(t, r, Rawtext);\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$15:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nreadEndTag(t, r, RawtextEndTagName, Rawtext);\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$14:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.matches('/')) {\nt.createTempBuffer();\nt.advanceTransition(RawtextEndTagOpen);\n} else {\nt.emit('<');\nt.transition(Rawtext);\n}\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$13:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.matchesLetter()) {\nString name = r.consumeLetterSequence();\nt.tagPending.appendTagName(name);\nt.dataBuffer.append(name);\nreturn;\n}\n\nchar c = r.consume();\nswitch (c) {\ncase '\\t':\ncase '\\n':\ncase '\\r':\ncase '\\f':\ncase ' ':\nif (t.isAppropriateEndTagToken())\nt.transition(BeforeAttributeName);\nelse\nanythingElse(t, r);\nbreak;\ncase '/':\nif (t.isAppropriateEndTagToken())\nt.transition(SelfClosingStartTag);\nelse\nanythingElse(t, r);\nbreak;\ncase '>':\nif (t.isAppropriateEndTagToken()) {\nt.emitTagPending();\nt.transition(Data);\n}\nelse\nanythingElse(t, r);\nbreak;\ndefault:\nanythingElse(t, r);\n}\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$12:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.matchesLetter()) {\nt.createTagPending(false);\nt.tagPending.appendTagName(r.current());\nt.dataBuffer.append(r.current());\nt.advanceTransition(RCDATAEndTagName);\n} else {\nt.emit(\"</\");\nt.transition(Rcdata);\n}\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$11:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.matches('/')) {\nt.createTempBuffer();\nt.advanceTransition(RCDATAEndTagOpen);\n} else if (r.matchesLetter() && t.appropriateEndTagName() != null && !r.containsIgnoreCase(\"</\" + t.appropriateEndTagName())) {\n// diverge from spec: got a start tag, but there's no appropriate end tag (</title>), so rather than\n// consuming to EOF; break out here\nt.tagPending = t.createTagPending(false).name(t.appropriateEndTagName());\nt.emitTagPending();\nr.unconsume(); // undo \"<\"\nt.transition(Data);\n} else {\nt.emit(\"<\");\nt.transition(Rcdata);\n}\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$10:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\n// previous TagOpen state did NOT consume, will have a letter char in current\n//String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\nString tagName = r.consumeTagName();\nt.tagPending.appendTagName(tagName);\n\nchar c = r.consume();\nswitch (c) {\ncase '\\t':\ncase '\\n':\ncase '\\r':\ncase '\\f':\ncase ' ':\nt.transition(BeforeAttributeName);\nbreak;\ncase '/':\nt.transition(SelfClosingStartTag);\nbreak;\ncase '>':\nt.emitTagPending();\nt.transition(Data);\nbreak;\ncase nullChar: // replacement\nt.tagPending.appendTagName(replacementStr);\nbreak;\ncase eof: // should emit pending tag?\nt.eofError(this);\nt.transition(Data);\nbreak;\ndefault: // buffer underrun\nt.tagPending.appendTagName(c);\n}\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$9:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.isEmpty()) {\nt.eofError(this);\nt.emit(\"</\");\nt.transition(Data);\n} else if (r.matchesLetter()) {\nt.createTagPending(false);\nt.transition(TagName);\n} else if (r.matches('>')) {\nt.error(this);\nt.advanceTransition(Data);\n} else {\nt.error(this);\nt.advanceTransition(BogusComment);\n}\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$8:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\ncase '!':\nt.advanceTransition(MarkupDeclarationOpen);\nbreak;\ncase '/':\nt.advanceTransition(EndTagOpen);\nbreak;\ncase '?':\nt.advanceTransition(BogusComment);\nbreak;\ndefault:\nif (r.matchesLetter()) {\nt.createTagPending(true);\nt.transition(TagName);\n} else {\nt.error(this);\nt.emit('<'); // char that got us here\nt.transition(Data);\n}\nbreak;\n}\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$5:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nreadData(t, r, this, RawtextLessthanSign);\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$3:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\ncase '&':\nt.advanceTransition(CharacterReferenceInRcdata);\nbreak;\ncase '<':\nt.advanceTransition(RcdataLessthanSign);\nbreak;\ncase nullChar:\nt.error(this);\nr.advance();\nt.emit(replacementChar);\nbreak;\ncase eof:\nt.emit(new Token.EOF());\nbreak;\ndefault:\nString data = r.consumeToAny('&', '<', nullChar);\nt.emit(data);\nbreak;\n}\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$1:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\ncase '&':\nt.advanceTransition(CharacterReferenceInData);\nbreak;\ncase '<':\nt.advanceTransition(TagOpen);\nbreak;\ncase nullChar:\nt.error(this); // NOT replacement character (oddly?)\nt.emit(r.consume());\nbreak;\ncase eof:\nt.emit(new Token.EOF());\nbreak;\ndefault:\nString data = r.consumeData();\nt.emit(data);\nbreak;\n}\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState:readEndTag(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;Lorg/jsoup/parser/TokeniserState;Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "private static void readEndTag(Tokeniser t, CharacterReader r, TokeniserState a, TokeniserState b) {\nif (r.matchesLetter()) {\nt.createTagPending(false);\nt.transition(a);\n} else {\nt.emit(\"</\");\nt.transition(b);\n}\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState:readData(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;Lorg/jsoup/parser/TokeniserState;Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "private static void readData(Tokeniser t, CharacterReader r, TokeniserState current, TokeniserState advance) {\nswitch (r.current()) {\ncase '<':\nt.advanceTransition(advance);\nbreak;\ncase nullChar:\nt.error(current);\nr.advance();\nt.emit(replacementChar);\nbreak;\ncase eof:\nt.emit(new Token.EOF());\nbreak;\ndefault:\nString data = r.consumeToAny('<', nullChar); // todo - why hunt for null here? Just consumeTo'<'?\nt.emit(data);\nbreak;\n}\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState:handleDataEndTag(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "private static void handleDataEndTag(Tokeniser t, CharacterReader r, TokeniserState elseTransition) {\nif (r.matchesLetter()) {\nString name = r.consumeLetterSequence();\nt.tagPending.appendTagName(name);\nt.dataBuffer.append(name);\nreturn;\n}\n\nboolean needsExitTransition = false;\nif (t.isAppropriateEndTagToken() && !r.isEmpty()) {\nchar c = r.consume();\nswitch (c) {\ncase '\\t':\ncase '\\n':\ncase '\\r':\ncase '\\f':\ncase ' ':\nt.transition(BeforeAttributeName);\nbreak;\ncase '/':\nt.transition(SelfClosingStartTag);\nbreak;\ncase '>':\nt.emitTagPending();\nt.transition(Data);\nbreak;\ndefault:\nt.dataBuffer.append(c);\nneedsExitTransition = true;\n}\n} else {\nneedsExitTransition = true;\n}\n\nif (needsExitTransition) {\nt.emit(\"</\" + t.dataBuffer.toString());\nt.transition(elseTransition);\n}\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState:<clinit>()V",
            "method_body": "static final char[] attributeValueUnquoted = new char[]{nullChar, '\\t', '\\n', '\\f', '\\r', ' ', '\"', '&', '\\'', '<', '=', '>', '`'};\nstatic final char[] attributeValueUnquoted = new char[]{nullChar, '\\t', '\\n', '\\f', '\\r', ' ', '\"', '&', '\\'', '<', '=', '>', '`'};",
            "method_id": 86
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:isAppropriateEndTagToken()Z",
            "method_body": "boolean isAppropriateEndTagToken() {\nreturn lastStartTag != null && tagPending.name().equalsIgnoreCase(lastStartTag);\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:createTempBuffer()V",
            "method_body": "void createTempBuffer() {\nToken.reset(dataBuffer);\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emitTagPending()V",
            "method_body": "void emitTagPending() {\ntagPending.finaliseTag();\nemit(tagPending);\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:createTagPending(Z)Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Token.Tag createTagPending(boolean start) {\ntagPending = start ? startPending.reset() : endPending.reset();\nreturn tagPending;\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:advanceTransition(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void advanceTransition(TokeniserState state) {\nreader.advance();\nthis.state = state;\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:transition(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void transition(TokeniserState state) {\nthis.state = state;\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Ljava/lang/String;)V",
            "method_body": "void emit(final String str) {\n// buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n// does not set isEmitPending; read checks that\nif (charsString == null) {\ncharsString = str;\n}\nelse {\nif (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read\ncharsBuilder.append(charsString);\n}\ncharsBuilder.append(str);\n}\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Lorg/jsoup/parser/Token;)V",
            "method_body": "void emit(Token token) {\nValidate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\nemitPending = token;\nisEmitPending = true;\n\nif (token.type == Token.TokenType.StartTag) {\nToken.StartTag startTag = (Token.StartTag) token;\nlastStartTag = startTag.tagName;\n} else if (token.type == Token.TokenType.EndTag) {\nToken.EndTag endTag = (Token.EndTag) token;\nif (endTag.attributes != null)\nerror(\"Attributes incorrectly present on end tag\");\n}\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:read()Lorg/jsoup/parser/Token;",
            "method_body": "Token read() {\nwhile (!isEmitPending)\nstate.read(this, reader);\n\n// if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\nif (charsBuilder.length() > 0) {\nString str = charsBuilder.toString();\ncharsBuilder.delete(0, charsBuilder.length());\ncharsString = null;\nreturn charPending.data(str);\n} else if (charsString != null) {\nToken token = charPending.data(charsString);\ncharsString = null;\nreturn token;\n} else {\nisEmitPending = false;\nreturn emitPending;\n}\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:<clinit>()V",
            "method_body": "static final char replacementChar = '\\uFFFD'; // replaces null character\nprivate static final char[] notCharRefCharsSorted = new char[]{'\\t', '\\n', '\\r', '\\f', ' ', '<', '&'};",
            "method_id": 96
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:<init>(Lorg/jsoup/parser/CharacterReader;Lorg/jsoup/parser/ParseErrorList;)V",
            "method_body": "final private int[] codepointHolder = new int[1]; // holder to not have to keep creating arrays\nfinal private int[] multipointHolder = new int[2];\nint[] consumeCharacterReference(Character additionalAllowedCharacter, boolean inAttribute) {\nif (reader.isEmpty())\nreturn null;\nif (additionalAllowedCharacter != null && additionalAllowedCharacter == reader.current())\nreturn null;\nif (reader.matchesAnySorted(notCharRefCharsSorted))\nreturn null;\n\nfinal int[] codeRef = codepointHolder;\nreader.mark();\nif (reader.matchConsume(\"#\")) { // numbered\nboolean isHexMode = reader.matchConsumeIgnoreCase(\"X\");\nString numRef = isHexMode ? reader.consumeHexSequence() : reader.consumeDigitSequence();\nif (numRef.length() == 0) { // didn't match anything\ncharacterReferenceError(\"numeric reference with no numerals\");\nreader.rewindToMark();\nreturn null;\n}\nif (!reader.matchConsume(\";\"))\ncharacterReferenceError(\"missing semicolon\"); // missing semi\nint charval = -1;\ntry {\nint base = isHexMode ? 16 : 10;\ncharval = Integer.valueOf(numRef, base);\n} catch (NumberFormatException ignored) {\n} // skip\nif (charval == -1 || (charval >= 0xD800 && charval <= 0xDFFF) || charval > 0x10FFFF) {\ncharacterReferenceError(\"character outside of valid range\");\ncodeRef[0] = replacementChar;\nreturn codeRef;\n} else {\n// todo: implement number replacement table\n// todo: check for extra illegal unicode points as parse errors\ncodeRef[0] = charval;\nreturn codeRef;\n}\n} else { // named\n// get as many letters as possible, and look for matching entities.\nString nameRef = reader.consumeLetterThenDigitSequence();\nboolean looksLegit = reader.matches(';');\n// found if a base named entity without a ;, or an extended entity with the ;.\nboolean found = (Entities.isBaseNamedEntity(nameRef) || (Entities.isNamedEntity(nameRef) && looksLegit));\n\nif (!found) {\nreader.rewindToMark();\nif (looksLegit) // named with semicolon\ncharacterReferenceError(String.format(\"invalid named referenece '%s'\", nameRef));\nreturn null;\n}\nif (inAttribute && (reader.matchesLetter() || reader.matchesDigit() || reader.matchesAny('=', '-', '_'))) {\n// don't want that to match\nreader.rewindToMark();\nreturn null;\n}\nif (!reader.matchConsume(\";\"))\ncharacterReferenceError(\"missing semicolon\"); // missing semi\nint numChars = Entities.codepointsForName(nameRef, multipointHolder);\nif (numChars == 1) {\ncodeRef[0] = multipointHolder[0];\nreturn codeRef;\n} else if (numChars ==2) {\nreturn multipointHolder;\n} else {\nValidate.fail(\"Unexpected characters returned for \" + nameRef);\nreturn multipointHolder;\n}\n}\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:rangeEquals([CIILjava/lang/String;)Z",
            "method_body": "static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\nif (count == cached.length()) {\nint i = start;\nint j = 0;\nwhile (count-- != 0) {\nif (charBuf[i++] != cached.charAt(j++))\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:cacheString([C[Ljava/lang/String;II)Ljava/lang/String;",
            "method_body": "private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n// limit (no cache):\nif (count > maxStringCacheLen)\nreturn new String(charBuf, start, count);\nif (count < 1)\nreturn \"\";\n\n// calculate hash:\nint hash = 0;\nint offset = start;\nfor (int i = 0; i < count; i++) {\nhash = 31 * hash + charBuf[offset++];\n}\n\n// get from cache\nfinal int index = hash & stringCache.length - 1;\nString cached = stringCache[index];\n\nif (cached == null) { // miss, add\ncached = new String(charBuf, start, count);\nstringCache[index] = cached;\n} else { // hashcode hit, check equality\nif (rangeEquals(charBuf, start, count, cached)) { // hit\nreturn cached;\n} else { // hashcode conflict\ncached = new String(charBuf, start, count);\nstringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n}\n}\nreturn cached;\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matchesLetter()Z",
            "method_body": "boolean matchesLetter() {\nif (isEmpty())\nreturn false;\nchar c = charBuf[bufPos];\nreturn (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matches(C)Z",
            "method_body": "boolean matches(char c) {\nreturn !isEmpty() && charBuf[bufPos] == c;\n\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeLetterSequence()Ljava/lang/String;",
            "method_body": "String consumeLetterSequence() {\nbufferUp();\nint start = bufPos;\nwhile (bufPos < bufLength) {\nchar c = charBuf[bufPos];\nif ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c))\nbufPos++;\nelse\nbreak;\n}\n\nreturn cacheString(charBuf, stringCache, start, bufPos - start);\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeTagName()Ljava/lang/String;",
            "method_body": "String consumeTagName() {\n// '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\nbufferUp();\nfinal int start = bufPos;\nfinal int remaining = bufLength;\nfinal char[] val = charBuf;\n\nwhile (bufPos < remaining) {\nfinal char c = val[bufPos];\nif (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\nbreak;\nbufPos++;\n}\n\nreturn bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeData()Ljava/lang/String;",
            "method_body": "String consumeData() {\n// &, <, null\nbufferUp();\nfinal int start = bufPos;\nfinal int remaining = bufLength;\nfinal char[] val = charBuf;\n\nwhile (bufPos < remaining) {\nfinal char c = val[bufPos];\nif (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\nbreak;\nbufPos++;\n}\n\nreturn bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeToAnySorted([C)Ljava/lang/String;",
            "method_body": "String consumeToAnySorted(final char... chars) {\nbufferUp();\nfinal int start = bufPos;\nfinal int remaining = bufLength;\nfinal char[] val = charBuf;\n\nwhile (bufPos < remaining) {\nif (Arrays.binarySearch(chars, val[bufPos]) >= 0)\nbreak;\nbufPos++;\n}\n\nreturn bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeToAny([C)Ljava/lang/String;",
            "method_body": "public String consumeToAny(final char... chars) {\nbufferUp();\nfinal int start = bufPos;\nfinal int remaining = bufLength;\nfinal char[] val = charBuf;\n\nOUTER: while (bufPos < remaining) {\nfor (char c : chars) {\nif (val[bufPos] == c)\nbreak OUTER;\n}\nbufPos++;\n}\n\nreturn bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeTo(C)Ljava/lang/String;",
            "method_body": "public String consumeTo(char c) {\nint offset = nextIndexOf(c);\nif (offset != -1) {\nString consumed = cacheString(charBuf, stringCache, bufPos, offset);\nbufPos += offset;\nreturn consumed;\n} else {\nreturn consumeToEnd();\n}\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:nextIndexOf(C)I",
            "method_body": "int nextIndexOf(char c) {\n// doesn't handle scanning for surrogates\nbufferUp();\nfor (int i = bufPos; i < bufLength; i++) {\nif (c == charBuf[i])\nreturn i - bufPos;\n}\nreturn -1;\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:advance()V",
            "method_body": "public void advance() {\nbufPos++;\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:unconsume()V",
            "method_body": "void unconsume() {\nbufPos--;\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consume()C",
            "method_body": "char consume() {\nbufferUp();\nchar val = isEmpty() ? EOF : charBuf[bufPos];\nbufPos++;\nreturn val;\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:current()C",
            "method_body": "public char current() {\nbufferUp();\nreturn isEmpty() ? EOF : charBuf[bufPos];\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn bufPos >= bufLength;\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:bufferUp()V",
            "method_body": "private void bufferUp() {\nif (bufPos < bufSplitPoint)\nreturn;\n\ntry {\nreaderPos += bufPos;\nreader.skip(bufPos);\nreader.mark(maxBufferLen);\nbufLength = reader.read(charBuf);\nreader.reset();\nbufPos = 0;\nbufMark = 0;\nbufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n} catch (IOException e) {\nthrow new UncheckedIOException(e);\n}\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/lang/String;)V",
            "method_body": "public CharacterReader(String input) {\nthis(new StringReader(input), input.length());\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/io/Reader;)V",
            "method_body": "public CharacterReader(Reader input) {\nthis(input, maxBufferLen);\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/io/Reader;I)V",
            "method_body": "public CharacterReader(Reader input, int sz) {\nValidate.notNull(input);\nValidate.isTrue(input.markSupported());\nreader = input;\ncharBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\nbufferUp();\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:load(Lorg/jsoup/nodes/Entities$EscapeMode;Ljava/lang/String;I)V",
            "method_body": "private static void load(EscapeMode e, String pointsData, int size) {\ne.nameKeys = new String[size];\ne.codeVals = new int[size];\ne.codeKeys = new int[size];\ne.nameVals = new String[size];\n\nint i = 0;\nCharacterReader reader = new CharacterReader(pointsData);\n\nwhile (!reader.isEmpty()) {\n// NotNestedLessLess=10913,824;1887&\n\nfinal String name = reader.consumeTo('=');\nreader.advance();\nfinal int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\nfinal char codeDelim = reader.current();\nreader.advance();\nfinal int cp2;\nif (codeDelim == ',') {\ncp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\nreader.advance();\n} else {\ncp2 = empty;\n}\nfinal String indexS = reader.consumeTo('&');\nfinal int index = Integer.parseInt(indexS, codepointRadix);\nreader.advance();\n\ne.nameKeys[i] = name;\ne.codeVals[i] = cp1;\ne.codeKeys[index] = cp1;\ne.nameVals[index] = name;\n\nif (cp2 != empty) {\nmultipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n}\ni++;\n}\n\nValidate.isTrue(i == size, \"Unexpected count of entities loaded\");\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:<clinit>()V",
            "method_body": "private static final HashMap<String, String> multipoints = new HashMap<>(); // name -> multiple character references\nprivate static final Document.OutputSettings DefaultOutput = new Document.OutputSettings();\n\npublic enum EscapeMode {\n/**\n* Restricted entities suitable for XHTML output: lt, gt, amp, and quot only.\n*/\nxhtml(EntitiesData.xmlPoints, 4),\n/**\n* Default HTML output entities.\n*/\nbase(EntitiesData.basePoints, 106),\n/**\n* Complete HTML entities.\n*/\nextended(EntitiesData.fullPoints, 2125);\n\n// table of named references to their codepoints. sorted so we can binary search. built by BuildEntities.\nprivate String[] nameKeys;\nprivate int[] codeVals; // limitation is the few references with multiple characters; those go into multipoints.\n\n// table of codepoints to named entities.\nprivate int[] codeKeys; // we don' support multicodepoints to single named value currently\nprivate String[] nameVals;\n\nEscapeMode(String file, int size) {\nload(this, file, size);\n}\n\nint codepointForName(final String name) {\nint index = Arrays.binarySearch(nameKeys, name);\nreturn index >= 0 ? codeVals[index] : empty;\n}\n\nString nameForCodepoint(final int codepoint) {\nfinal int index = Arrays.binarySearch(codeKeys, codepoint);\nif (index >= 0) {\n// the results are ordered so lower case versions of same codepoint come after uppercase, and we prefer to emit lower\n// (and binary search for same item with multi results is undefined\nreturn (index < nameVals.length - 1 && codeKeys[index + 1] == codepoint) ?\nnameVals[index + 1] : nameVals[index];\n}\nreturn emptyName;\n}\n\nprivate int size() {\nreturn nameKeys.length;\n}\n}",
            "method_id": 119
        },
        {
            "method_signature": "org.jsoup.nodes.Entities$EscapeMode:<clinit>()V",
            "method_body": "private static final HashMap<String, String> multipoints = new HashMap<>(); // name -> multiple character references\nprivate static final Document.OutputSettings DefaultOutput = new Document.OutputSettings();\n\npublic enum EscapeMode {\n/**\n* Restricted entities suitable for XHTML output: lt, gt, amp, and quot only.\n*/\nxhtml(EntitiesData.xmlPoints, 4),\n/**\n* Default HTML output entities.\n*/\nbase(EntitiesData.basePoints, 106),\n/**\n* Complete HTML entities.\n*/\nextended(EntitiesData.fullPoints, 2125);\n\n// table of named references to their codepoints. sorted so we can binary search. built by BuildEntities.\nprivate String[] nameKeys;\nprivate int[] codeVals; // limitation is the few references with multiple characters; those go into multipoints.\n\n// table of codepoints to named entities.\nprivate int[] codeKeys; // we don' support multicodepoints to single named value currently\nprivate String[] nameVals;\n\nEscapeMode(String file, int size) {\nload(this, file, size);\n}\n\nint codepointForName(final String name) {\nint index = Arrays.binarySearch(nameKeys, name);\nreturn index >= 0 ? codeVals[index] : empty;\n}\n\nString nameForCodepoint(final int codepoint) {\nfinal int index = Arrays.binarySearch(codeKeys, codepoint);\nif (index >= 0) {\n// the results are ordered so lower case versions of same codepoint come after uppercase, and we prefer to emit lower\n// (and binary search for same item with multi results is undefined\nreturn (index < nameVals.length - 1 && codeKeys[index + 1] == codepoint) ?\nnameVals[index + 1] : nameVals[index];\n}\nreturn emptyName;\n}\n\nprivate int size() {\nreturn nameKeys.length;\n}\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.jsoup.nodes.Entities$EscapeMode:<init>(Ljava/lang/String;ILjava/lang/String;I)V",
            "method_body": "EscapeMode(String file, int size) {\nload(this, file, size);\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:charset(Ljava/nio/charset/Charset;)Lorg/jsoup/nodes/Document$OutputSettings;",
            "method_body": "public OutputSettings charset(Charset charset) {\nthis.charset = charset;\nreturn this;\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.jsoup.internal.Normalizer:lowerCase(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "public static String lowerCase(final String input) {\nreturn input != null ? input.toLowerCase(Locale.ENGLISH) : \"\";\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.jsoup.parser.Tag:register(Lorg/jsoup/parser/Tag;)V",
            "method_body": "private static void register(Tag tag) {\ntags.put(tag.tagName, tag);\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.jsoup.parser.Tag:isFormListed()Z",
            "method_body": "public boolean isFormListed() {\nreturn formList;\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.jsoup.parser.Tag:isKnownTag()Z",
            "method_body": "public boolean isKnownTag() {\nreturn tags.containsKey(tagName);\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.jsoup.parser.Tag:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn empty;\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.jsoup.parser.Tag:valueOf(Ljava/lang/String;Lorg/jsoup/parser/ParseSettings;)Lorg/jsoup/parser/Tag;",
            "method_body": "public static Tag valueOf(String tagName, ParseSettings settings) {\nValidate.notNull(tagName);\nTag tag = tags.get(tagName);\n\nif (tag == null) {\ntagName = settings.normalizeTag(tagName);\nValidate.notEmpty(tagName);\ntag = tags.get(tagName);\n\nif (tag == null) {\n// not defined: create default; go anywhere, do anything! (incl be inside a <p>)\ntag = new Tag(tagName);\ntag.isBlock = false;\n}\n}\nreturn tag;\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.jsoup.parser.Tag:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn tagName;\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.jsoup.parser.Tag:<init>(Ljava/lang/String;)V",
            "method_body": "private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags\n\nprivate String tagName;\nprivate boolean isBlock = true; // block or inline\nprivate boolean formatAsBlock = true; // should be formatted as a block\nprivate boolean canContainInline = true; // only pcdata if not\nprivate boolean empty = false; // can hold nothing; e.g. img\nprivate boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.\nprivate boolean preserveWhitespace = false; // for pre, textarea, script etc\nprivate boolean formList = false; // a control that appears in forms: input, textarea, output etc\nprivate boolean formSubmit = false; // a control that can be submitted in a form: input etc\n\nprivate Tag(String tagName) {\nthis.tagName = tagName;\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.jsoup.nodes.Document:outputSettings()Lorg/jsoup/nodes/Document$OutputSettings;",
            "method_body": "public OutputSettings outputSettings() {\nreturn outputSettings;\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.jsoup.nodes.Document:location()Ljava/lang/String;",
            "method_body": "public String location() {\nreturn location;\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.jsoup.nodes.Element:appendChild(Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Element;",
            "method_body": "public Element appendChild(Node child) {\nValidate.notNull(child);\n\n// was - Node#addChildren(child). short-circuits an array create and a loop.\nreparentChild(child);\nensureChildNodes();\nchildNodes.add(child);\nchild.setSiblingIndex(childNodes.size() - 1);\nreturn this;\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.jsoup.nodes.Element:nodelistChanged()V",
            "method_body": "void nodelistChanged() {\nsuper.nodelistChanged();\nshadowChildrenRef = null;\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.jsoup.nodes.Element:childElementsList()Ljava/util/List;",
            "method_body": "private List<Element> childElementsList() {\nList<Element> children;\nif (shadowChildrenRef == null || (children = shadowChildrenRef.get()) == null) {\nfinal int size = childNodes.size();\nchildren = new ArrayList<>(size);\n//noinspection ForLoopReplaceableByForEach (beacause it allocates an Iterator which is wasteful here)\nfor (int i = 0; i < size; i++) {\nfinal Node node = childNodes.get(i);\nif (node instanceof Element)\nchildren.add((Element) node);\n}\nshadowChildrenRef = new WeakReference<>(children);\n}\nreturn children;\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.jsoup.nodes.Element:child(I)Lorg/jsoup/nodes/Element;",
            "method_body": "public Element child(int index) {\nreturn childElementsList().get(index);\n}",
            "method_id": 136
        },
        {
            "method_signature": "org.jsoup.nodes.Element:tag()Lorg/jsoup/parser/Tag;",
            "method_body": "public Tag tag() {\nreturn tag;\n}",
            "method_id": 137
        },
        {
            "method_signature": "org.jsoup.nodes.Element:tagName()Ljava/lang/String;",
            "method_body": "public String tagName() {\nreturn tag.getName();\n}",
            "method_id": 138
        },
        {
            "method_signature": "org.jsoup.nodes.Element:nodeName()Ljava/lang/String;",
            "method_body": "public String nodeName() {\nreturn tag.getName();\n}",
            "method_id": 139
        },
        {
            "method_signature": "org.jsoup.nodes.Element:childNodeSize()I",
            "method_body": "public int childNodeSize() {\nreturn childNodes.size();\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.jsoup.nodes.Element:attributes()Lorg/jsoup/nodes/Attributes;",
            "method_body": "public Attributes attributes() {\nif (!hasAttributes())\nattributes = new Attributes();\nreturn attributes;\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.jsoup.nodes.Element:hasAttributes()Z",
            "method_body": "protected boolean hasAttributes() {\nreturn attributes != null;\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.jsoup.nodes.Element:ensureChildNodes()Ljava/util/List;",
            "method_body": "protected List<Node> ensureChildNodes() {\nif (childNodes == EMPTY_NODES) {\nchildNodes = new NodeList(this, 4);\n}\nreturn childNodes;\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<clinit>()V",
            "method_body": "private static final List<Node> EMPTY_NODES = Collections.emptyList();\nprivate static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\nprivate Tag tag;\nprivate WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children\nList<Node> childNodes;\nprivate Attributes attributes;\nprivate String baseUri;\n\n/**\n* Create a new, standalone element.\n* @param tag tag name\n*/\npublic Element(String tag) {\nthis(Tag.valueOf(tag), \"\", new Attributes());\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<init>(Lorg/jsoup/parser/Tag;Ljava/lang/String;)V",
            "method_body": "public Element(Tag tag, String baseUri) {\nthis(tag, baseUri, null);\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<init>(Lorg/jsoup/parser/Tag;Ljava/lang/String;Lorg/jsoup/nodes/Attributes;)V",
            "method_body": "public Element(Tag tag, String baseUri, Attributes attributes) {\nValidate.notNull(tag);\nValidate.notNull(baseUri);\nchildNodes = EMPTY_NODES;\nthis.baseUri = baseUri;\nthis.attributes = attributes;\nthis.tag = tag;\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.jsoup.nodes.Node:setSiblingIndex(I)V",
            "method_body": "protected void setSiblingIndex(int siblingIndex) {\nthis.siblingIndex = siblingIndex;\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.jsoup.nodes.Node:reparentChild(Lorg/jsoup/nodes/Node;)V",
            "method_body": "protected void reparentChild(Node child) {\nchild.setParentNode(this);\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.jsoup.nodes.Node:setParentNode(Lorg/jsoup/nodes/Node;)V",
            "method_body": "protected void setParentNode(Node parentNode) {\nValidate.notNull(parentNode);\nif (this.parentNode != null)\nthis.parentNode.removeChild(this);\nthis.parentNode = parentNode;\n}",
            "method_id": 149
        },
        {
            "method_signature": "org.jsoup.nodes.Node:nodelistChanged()V",
            "method_body": "void nodelistChanged() {\n// Element overrides this to clear its shadow children elements\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.jsoup.nodes.Node:parentNode()Lorg/jsoup/nodes/Node;",
            "method_body": "public final Node parentNode() {\nreturn parentNode;\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.jsoup.nodes.Node:<init>()V",
            "method_body": "protected Node() {\n}",
            "method_id": 152
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notEmpty(Ljava/lang/String;)V",
            "method_body": "public static void notEmpty(String string) {\nif (string == null || string.length() == 0)\nthrow new IllegalArgumentException(\"String must not be empty\");\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isFalse(ZLjava/lang/String;)V",
            "method_body": "public static void isFalse(boolean val, String msg) {\nif (val)\nthrow new IllegalArgumentException(msg);\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isFalse(Z)V",
            "method_body": "public static void isFalse(boolean val) {\nif (val)\nthrow new IllegalArgumentException(\"Must be false\");\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isTrue(ZLjava/lang/String;)V",
            "method_body": "public static void isTrue(boolean val, String msg) {\nif (!val)\nthrow new IllegalArgumentException(msg);\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isTrue(Z)V",
            "method_body": "public static void isTrue(boolean val) {\nif (!val)\nthrow new IllegalArgumentException(\"Must be true\");\n}",
            "method_id": 157
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notNull(Ljava/lang/Object;Ljava/lang/String;)V",
            "method_body": "public static void notNull(Object obj, String msg) {\nif (obj == null)\nthrow new IllegalArgumentException(msg);\n}",
            "method_id": 158
        },
        {
            "method_signature": "org.jsoup.parser.ParseSettings:normalizeAttributes(Lorg/jsoup/nodes/Attributes;)Lorg/jsoup/nodes/Attributes;",
            "method_body": "Attributes normalizeAttributes(Attributes attributes) {\nif (!preserveAttributeCase) {\nattributes.normalize();\n}\nreturn attributes;\n}",
            "method_id": 159
        },
        {
            "method_signature": "org.jsoup.parser.ParseSettings:normalizeTag(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "String normalizeTag(String name) {\nname = name.trim();\nif (!preserveTagCase)\nname = lowerCase(name);\nreturn name;\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.jsoup.parser.ParseSettings:<clinit>()V",
            "method_body": "public static final ParseSettings htmlDefault;\n/**\n* Preserve both tag and attribute case.\n*/\npublic static final ParseSettings preserveCase;\n\nstatic {\nhtmlDefault = new ParseSettings(false, false);\npreserveCase = new ParseSettings(true, true);\n}",
            "method_id": 161
        },
        {
            "method_signature": "org.jsoup.parser.ParseSettings:<init>(ZZ)V",
            "method_body": "public ParseSettings(boolean tag, boolean attribute) {\npreserveTagCase = tag;\npreserveAttributeCase = attribute;\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.jsoup.parser.ParseErrorList:<init>(II)V",
            "method_body": "ParseErrorList(int initialCapacity, int maxSize) {\nsuper(initialCapacity);\nthis.maxSize = maxSize;\n}",
            "method_id": 163
        },
        {
            "method_signature": "org.jsoup.parser.Token$EndTag:<init>()V",
            "method_body": "EndTag() {\nsuper();\ntype = TokenType.EndTag;\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:normalize()V",
            "method_body": "public void normalize() {\nfor (int i = 0; i < size; i++) {\nkeys[i] = lowerCase(keys[i]);\n}\n}",
            "method_id": 165
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:iterator()Ljava/util/Iterator;",
            "method_body": "public Iterator<Attribute> iterator() {\nreturn new Iterator<Attribute>() {\nint i = 0;\n\n@Override\npublic boolean hasNext() {\nreturn i < size;\n}\n\n@Override\npublic Attribute next() {\nfinal Attribute attr = new Attribute(keys[i], vals[i], Attributes.this);\ni++;\nreturn attr;\n}\n\n@Override\npublic void remove() {\nAttributes.this.remove(--i); // next() advanced, so rewind\n}\n};\n}",
            "method_id": 166
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:put(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Attributes;",
            "method_body": "public Attributes put(String key, String value) {\nint i = indexOfKey(key);\nif (i != NotFound)\nvals[i] = value;\nelse\nadd(key, value);\nreturn this;\n}",
            "method_id": 167
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:add(Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "private void add(String key, String value) {\ncheckCapacity(size + 1);\nkeys[size] = key;\nvals[size] = value;\nsize++;\n}",
            "method_id": 168
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:indexOfKey(Ljava/lang/String;)I",
            "method_body": "int indexOfKey(String key) {\nValidate.notNull(key);\nfor (int i = 0; i < size; i++) {\nif (key.equals(keys[i]))\nreturn i;\n}\nreturn NotFound;\n}",
            "method_id": 169
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:copyOf([Ljava/lang/String;I)[Ljava/lang/String;",
            "method_body": "private static String[] copyOf(String[] orig, int size) {\nfinal String[] copy = new String[size];\nSystem.arraycopy(orig, 0, copy, 0,\nMath.min(orig.length, size));\nreturn copy;\n}",
            "method_id": 170
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:checkCapacity(I)V",
            "method_body": "private void checkCapacity(int minNewSize) {\nValidate.isTrue(minNewSize >= size);\nint curSize = keys.length;\nif (curSize >= minNewSize)\nreturn;\n\nint newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\nif (minNewSize > newSize)\nnewSize = minNewSize;\n\nkeys = copyOf(keys, newSize);\nvals = copyOf(vals, newSize);\n}",
            "method_id": 171
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:<clinit>()V",
            "method_body": "protected static final String dataPrefix = \"data-\";\nprivate static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n\n// manages the key/val arrays\nprivate static final int GrowthFactor = 2;\nprivate static final String[] Empty = {};",
            "method_id": 172
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:<init>()V",
            "method_body": "static final int NotFound = -1;\nprivate static final String EmptyString = \"\";\n\nprivate int size = 0; // number of slots used (not capacity, which is keys.length\nString[] keys = Empty;\nString[] vals = Empty;\n\n// check there's room for more\nprivate void checkCapacity(int minNewSize) {\nValidate.isTrue(minNewSize >= size);\nint curSize = keys.length;\nif (curSize >= minNewSize)\nreturn;\n\nint newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\nif (minNewSize > newSize)\nnewSize = minNewSize;\n\nkeys = copyOf(keys, newSize);\nvals = copyOf(vals, newSize);\n}",
            "method_id": 173
        },
        {
            "method_signature": "org.jsoup.parser.Token$StartTag:reset()Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Tag reset() {\nsuper.reset();\nattributes = new Attributes();\n// todo - would prefer these to be null, but need to check Element assertions\nreturn this;\n}",
            "method_id": 174
        },
        {
            "method_signature": "org.jsoup.parser.Token$StartTag:<init>()V",
            "method_body": "StartTag() {\nsuper();\nattributes = new Attributes();\ntype = TokenType.StartTag;\n}",
            "method_id": 175
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:ensureAttributeValue()V",
            "method_body": "private void ensureAttributeValue() {\nhasPendingAttributeValue = true;\n// if on second hit, we'll need to move to the builder\nif (pendingAttributeValueS != null) {\npendingAttributeValue.append(pendingAttributeValueS);\npendingAttributeValueS = null;\n}\n}",
            "method_id": 176
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:appendAttributeValue(Ljava/lang/String;)V",
            "method_body": "final void appendAttributeValue(String append) {\nensureAttributeValue();\nif (pendingAttributeValue.length() == 0) {\npendingAttributeValueS = append;\n} else {\npendingAttributeValue.append(append);\n}\n}",
            "method_id": 177
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:appendAttributeName(Ljava/lang/String;)V",
            "method_body": "final void appendAttributeName(String append) {\npendingAttributeName = pendingAttributeName == null ? append : pendingAttributeName.concat(append);\n}",
            "method_id": 178
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:appendTagName(C)V",
            "method_body": "final void appendTagName(char append) {\nappendTagName(String.valueOf(append));\n}",
            "method_id": 179
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:appendTagName(Ljava/lang/String;)V",
            "method_body": "final void appendTagName(String append) {\ntagName = tagName == null ? append : tagName.concat(append);\nnormalName = lowerCase(tagName);\n}",
            "method_id": 180
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:isSelfClosing()Z",
            "method_body": "final boolean isSelfClosing() {\nreturn selfClosing;\n}",
            "method_id": 181
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:normalName()Ljava/lang/String;",
            "method_body": "final String normalName() { // loses case, used in tree building for working out where in tree it should go\nreturn normalName;\n}",
            "method_id": 182
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:name()Ljava/lang/String;",
            "method_body": "final String name() { // preserves case, for input into Tag.valueOf (which may drop case)\nValidate.isFalse(tagName == null || tagName.length() == 0);\nreturn tagName;\n}",
            "method_id": 183
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:finaliseTag()V",
            "method_body": "final void finaliseTag() {\n// finalises for emit\nif (pendingAttributeName != null) {\n// todo: check if attribute name exists; if so, drop and error\nnewAttribute();\n}\n}",
            "method_id": 184
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:newAttribute()V",
            "method_body": "final void newAttribute() {\nif (attributes == null)\nattributes = new Attributes();\n\nif (pendingAttributeName != null) {\n// the tokeniser has skipped whitespace control chars, but trimming could collapse to empty for other control codes, so verify here\npendingAttributeName = pendingAttributeName.trim();\nif (pendingAttributeName.length() > 0) {\nString value;\nif (hasPendingAttributeValue)\nvalue = pendingAttributeValue.length() > 0 ? pendingAttributeValue.toString() : pendingAttributeValueS;\nelse if (hasEmptyAttributeValue)\nvalue = \"\";\nelse\nvalue = null;\nattributes.put(pendingAttributeName, value);\n}\n}\npendingAttributeName = null;\nhasEmptyAttributeValue = false;\nhasPendingAttributeValue = false;\nreset(pendingAttributeValue);\npendingAttributeValueS = null;\n}",
            "method_id": 185
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:reset()Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Tag reset() {\ntagName = null;\nnormalName = null;\npendingAttributeName = null;\nreset(pendingAttributeValue);\npendingAttributeValueS = null;\nhasEmptyAttributeValue = false;\nhasPendingAttributeValue = false;\nselfClosing = false;\nattributes = null;\nreturn this;\n}",
            "method_id": 186
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:<init>()V",
            "method_body": "protected String tagName;\nprotected String normalName; // lc version of tag name, for case insensitive tree build\nprivate String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\nprivate StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\nprivate String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder\nprivate boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value\nprivate boolean hasPendingAttributeValue = false;\nboolean selfClosing = false;\nAttributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n@Override\nTag reset() {\ntagName = null;\nnormalName = null;\npendingAttributeName = null;\nreset(pendingAttributeValue);\npendingAttributeValueS = null;\nhasEmptyAttributeValue = false;\nhasPendingAttributeValue = false;\nselfClosing = false;\nattributes = null;\nreturn this;\n}",
            "method_id": 187
        },
        {
            "method_signature": "org.jsoup.parser.Token:isEOF()Z",
            "method_body": "final boolean isEOF() {\nreturn type == TokenType.EOF;\n}",
            "method_id": 188
        },
        {
            "method_signature": "org.jsoup.parser.Token:asCharacter()Lorg/jsoup/parser/Token$Character;",
            "method_body": "final Character asCharacter() {\nreturn (Character) this;\n}",
            "method_id": 189
        },
        {
            "method_signature": "org.jsoup.parser.Token:isCharacter()Z",
            "method_body": "final boolean isCharacter() {\nreturn type == TokenType.Character;\n}",
            "method_id": 190
        },
        {
            "method_signature": "org.jsoup.parser.Token:asComment()Lorg/jsoup/parser/Token$Comment;",
            "method_body": "final Comment asComment() {\nreturn (Comment) this;\n}",
            "method_id": 191
        },
        {
            "method_signature": "org.jsoup.parser.Token:isComment()Z",
            "method_body": "final boolean isComment() {\nreturn type == TokenType.Comment;\n}",
            "method_id": 192
        },
        {
            "method_signature": "org.jsoup.parser.Token:asEndTag()Lorg/jsoup/parser/Token$EndTag;",
            "method_body": "final EndTag asEndTag() {\nreturn (EndTag) this;\n}",
            "method_id": 193
        },
        {
            "method_signature": "org.jsoup.parser.Token:isEndTag()Z",
            "method_body": "final boolean isEndTag() {\nreturn type == TokenType.EndTag;\n}",
            "method_id": 194
        },
        {
            "method_signature": "org.jsoup.parser.Token:asStartTag()Lorg/jsoup/parser/Token$StartTag;",
            "method_body": "final StartTag asStartTag() {\nreturn (StartTag) this;\n}",
            "method_id": 195
        },
        {
            "method_signature": "org.jsoup.parser.Token:isStartTag()Z",
            "method_body": "final boolean isStartTag() {\nreturn type == TokenType.StartTag;\n}",
            "method_id": 196
        },
        {
            "method_signature": "org.jsoup.parser.Token:isDoctype()Z",
            "method_body": "final boolean isDoctype() {\nreturn type == TokenType.Doctype;\n}",
            "method_id": 197
        },
        {
            "method_signature": "org.jsoup.parser.Token:reset(Ljava/lang/StringBuilder;)V",
            "method_body": "abstract Token reset();\n\nstatic void reset(StringBuilder sb) {\nif (sb != null) {\nsb.delete(0, sb.length());\n}\n}",
            "method_id": 198
        },
        {
            "method_signature": "org.jsoup.parser.Token:<init>()V",
            "method_body": "private Token() {\n}",
            "method_id": 199
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:reconstructFormattingElements()V",
            "method_body": "void reconstructFormattingElements() {\nElement last = lastFormattingElement();\nif (last == null || onStack(last))\nreturn;\n\nElement entry = last;\nint size = formattingElements.size();\nint pos = size - 1;\nboolean skip = false;\nwhile (true) {\nif (pos == 0) { // step 4. if none before, skip to 8\nskip = true;\nbreak;\n}\nentry = formattingElements.get(--pos); // step 5. one earlier than entry\nif (entry == null || onStack(entry)) // step 6 - neither marker nor on stack\nbreak; // jump to 8, else continue back to 4\n}\nwhile(true) {\nif (!skip) // step 7: on later than entry\nentry = formattingElements.get(++pos);\nValidate.notNull(entry); // should not occur, as we break at last element\n\n// 8. create new element from element, 9 insert into current node, onto stack\nskip = false; // can only skip increment from 4.\nElement newEl = insertStartTag(entry.nodeName()); // todo: avoid fostering here?\n// newEl.namespace(entry.namespace()); // todo: namespaces\nnewEl.attributes().addAll(entry.attributes());\n\n// 10. replace entry with new entry\nformattingElements.set(pos, newEl);\n\n// 11\nif (pos == size-1) // if not last entry in list, jump to 7\nbreak;\n}\n}",
            "method_id": 200
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:lastFormattingElement()Lorg/jsoup/nodes/Element;",
            "method_body": "Element lastFormattingElement() {\nreturn formattingElements.size() > 0 ? formattingElements.get(formattingElements.size()-1) : null;\n}",
            "method_id": 201
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:generateImpliedEndTags()V",
            "method_body": "void generateImpliedEndTags() {\ngenerateImpliedEndTags(null);\n}",
            "method_id": 202
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:generateImpliedEndTags(Ljava/lang/String;)V",
            "method_body": "void generateImpliedEndTags(String excludeTag) {\nwhile ((excludeTag != null && !currentElement().nodeName().equals(excludeTag)) &&\ninSorted(currentElement().nodeName(), TagSearchEndTags))\npop();\n}",
            "method_id": 203
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:isFosterInserts()Z",
            "method_body": "boolean isFosterInserts() {\nreturn fosterInserts;\n}",
            "method_id": 204
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:setHeadElement(Lorg/jsoup/nodes/Element;)V",
            "method_body": "void setHeadElement(Element headElement) {\nthis.headElement = headElement;\n}",
            "method_id": 205
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inButtonScope(Ljava/lang/String;)Z",
            "method_body": "boolean inButtonScope(String targetName) {\nreturn inScope(targetName, TagSearchButton);\n}",
            "method_id": 206
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inScope(Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "boolean inScope(String targetName, String[] extras) {\nreturn inSpecificScope(targetName, TagsSearchInScope, extras);\n// todo: in mathml namespace: mi, mo, mn, ms, mtext annotation-xml\n// todo: in svg namespace: forignOjbect, desc, title\n}",
            "method_id": 207
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inScope(Ljava/lang/String;)Z",
            "method_body": "boolean inScope(String targetName) {\nreturn inScope(targetName, null);\n}",
            "method_id": 208
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inSpecificScope([Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// https://html.spec.whatwg.org/multipage/parsing.html#has-an-element-in-the-specific-scope\nfinal int bottom = stack.size() -1;\nfinal int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0;\n// don't walk too far up the tree\n\nfor (int pos = bottom; pos >= top; pos--) {\nfinal String elName = stack.get(pos).nodeName();\nif (inSorted(elName, targetNames))\nreturn true;\nif (inSorted(elName, baseTypes))\nreturn false;\nif (extraTypes != null && inSorted(elName, extraTypes))\nreturn false;\n}\n//Validate.fail(\"Should not be reachable\"); // would end up false because hitting 'html' at root (basetypes)\nreturn false;\n}",
            "method_id": 209
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:inSpecificScope(Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)Z",
            "method_body": "private boolean inSpecificScope(String targetName, String[] baseTypes, String[] extraTypes) {\nspecificScopeTarget[0] = targetName;\nreturn inSpecificScope(specificScopeTarget, baseTypes, extraTypes);\n}",
            "method_id": 210
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:popStackToClose(Ljava/lang/String;)V",
            "method_body": "void popStackToClose(String elName) {\nfor (int pos = stack.size() -1; pos >= 0; pos--) {\nElement next = stack.get(pos);\nstack.remove(pos);\nif (next.nodeName().equals(elName))\nbreak;\n}\n}",
            "method_id": 211
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:getStack()Ljava/util/ArrayList;",
            "method_body": "ArrayList<Element> getStack() {\nreturn stack;\n}",
            "method_id": 212
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:pop()Lorg/jsoup/nodes/Element;",
            "method_body": "Element pop() {\nint size = stack.size();\nreturn stack.remove(size-1);\n}",
            "method_id": 213
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insertNode(Lorg/jsoup/nodes/Node;)V",
            "method_body": "private void insertNode(Node node) {\n// if the stack hasn't been set up yet, elements (doctype, comments) go into the doc\nif (stack.size() == 0)\ndoc.appendChild(node);\nelse if (isFosterInserts())\ninsertInFosterParent(node);\nelse\ncurrentElement().appendChild(node);\n\n// connect form controls to their form element\nif (node instanceof Element && ((Element) node).tag().isFormListed()) {\nif (formElement != null)\nformElement.addElement((Element) node);\n}\n}",
            "method_id": 214
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insert(Lorg/jsoup/parser/Token$Character;)V",
            "method_body": "void insert(Token.Character characterToken) {\nNode node;\n// characters in script and style go in as datanodes, not text nodes\nString tagName = currentElement().tagName();\nif (tagName.equals(\"script\") || tagName.equals(\"style\"))\nnode = new DataNode(characterToken.getData());\nelse\nnode = new TextNode(characterToken.getData());\ncurrentElement().appendChild(node); // doesn't use insertNode, because we don't foster these; and will always have a stack.\n}",
            "method_id": 215
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insert(Lorg/jsoup/parser/Token$Comment;)V",
            "method_body": "void insert(Token.Comment commentToken) {\nComment comment = new Comment(commentToken.getData());\ninsertNode(comment);\n}",
            "method_id": 216
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insertEmpty(Lorg/jsoup/parser/Token$StartTag;)Lorg/jsoup/nodes/Element;",
            "method_body": "Element insertEmpty(Token.StartTag startTag) {\nTag tag = Tag.valueOf(startTag.name(), settings);\nElement el = new Element(tag, baseUri, startTag.attributes);\ninsertNode(el);\nif (startTag.isSelfClosing()) {\nif (tag.isKnownTag()) {\nif (!tag.isEmpty())\ntokeniser.error(\"Tag cannot be self closing; not a void tag\");\n}\nelse // unknown tag, remember this is self closing for output\ntag.setSelfClosing();\n}\nreturn el;\n}",
            "method_id": 217
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insert(Lorg/jsoup/nodes/Element;)V",
            "method_body": "void insert(Element el) {\ninsertNode(el);\nstack.add(el);\n}",
            "method_id": 218
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:insert(Lorg/jsoup/parser/Token$StartTag;)Lorg/jsoup/nodes/Element;",
            "method_body": "Element insert(Token.StartTag startTag) {\n// handle empty unknown tags\n// when the spec expects an empty tag, will directly hit insertEmpty, so won't generate this fake end tag.\nif (startTag.isSelfClosing()) {\nElement el = insertEmpty(startTag);\nstack.add(el);\ntokeniser.transition(TokeniserState.Data); // handles <script />, otherwise needs breakout steps from script data\ntokeniser.emit(emptyEnd.reset().name(el.tagName()));  // ensure we get out of whatever state we are in. emitted for yielded processing\nreturn el;\n}\n\nElement el = new Element(Tag.valueOf(startTag.name(), settings), baseUri, settings.normalizeAttributes(startTag.attributes));\ninsert(el);\nreturn el;\n}",
            "method_id": 219
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:isFragmentParsing()Z",
            "method_body": "boolean isFragmentParsing() {\nreturn fragmentParsing;\n}",
            "method_id": 220
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:framesetOk()Z",
            "method_body": "boolean framesetOk() {\nreturn framesetOk;\n}",
            "method_id": 221
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:framesetOk(Z)V",
            "method_body": "void framesetOk(boolean framesetOk) {\nthis.framesetOk = framesetOk;\n}",
            "method_id": 222
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:originalState()Lorg/jsoup/parser/HtmlTreeBuilderState;",
            "method_body": "HtmlTreeBuilderState originalState() {\nreturn originalState;\n}",
            "method_id": 223
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:markInsertionMode()V",
            "method_body": "void markInsertionMode() {\noriginalState = state;\n}",
            "method_id": 224
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:transition(Lorg/jsoup/parser/HtmlTreeBuilderState;)V",
            "method_body": "void transition(HtmlTreeBuilderState state) {\nthis.state = state;\n}",
            "method_id": 225
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:process(Lorg/jsoup/parser/Token;Lorg/jsoup/parser/HtmlTreeBuilderState;)Z",
            "method_body": "boolean process(Token token, HtmlTreeBuilderState state) {\ncurrentToken = token;\nreturn state.process(token, this);\n}",
            "method_id": 226
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:process(Lorg/jsoup/parser/Token;)Z",
            "method_body": "protected boolean process(Token token) {\ncurrentToken = token;\nreturn this.state.process(token, this);\n}",
            "method_id": 227
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:initialiseParse(Ljava/io/Reader;Ljava/lang/String;Lorg/jsoup/parser/ParseErrorList;Lorg/jsoup/parser/ParseSettings;)V",
            "method_body": "protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\nsuper.initialiseParse(input, baseUri, errors, settings);\n\n// this is a bit mucky. todo - probably just create new parser objects to ensure all reset.\nstate = HtmlTreeBuilderState.Initial;\noriginalState = null;\nbaseUriSetFromDoc = false;\nheadElement = null;\nformElement = null;\ncontextElement = null;\nformattingElements = new ArrayList<>();\npendingTableCharacters = new ArrayList<>();\nemptyEnd = new Token.EndTag();\nframesetOk = true;\nfosterInserts = false;\nfragmentParsing = false;\n}",
            "method_id": 228
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:defaultSettings()Lorg/jsoup/parser/ParseSettings;",
            "method_body": "ParseSettings defaultSettings() {\nreturn ParseSettings.htmlDefault;\n}",
            "method_id": 229
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:currentElement()Lorg/jsoup/nodes/Element;",
            "method_body": "protected Element currentElement() {\nint size = stack.size();\nreturn size > 0 ? stack.get(size-1) : null;\n}",
            "method_id": 230
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:runParser()V",
            "method_body": "protected void runParser() {\nwhile (true) {\nToken token = tokeniser.read();\nprocess(token);\ntoken.reset();\n\nif (token.type == Token.TokenType.EOF)\nbreak;\n}\n}",
            "method_id": 231
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:parse(Ljava/io/Reader;Ljava/lang/String;Lorg/jsoup/parser/ParseErrorList;Lorg/jsoup/parser/ParseSettings;)Lorg/jsoup/nodes/Document;",
            "method_body": "Document parse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\ninitialiseParse(input, baseUri, errors, settings);\nrunParser();\nreturn doc;\n}",
            "method_id": 232
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:initialiseParse(Ljava/io/Reader;Ljava/lang/String;Lorg/jsoup/parser/ParseErrorList;Lorg/jsoup/parser/ParseSettings;)V",
            "method_body": "abstract ParseSettings defaultSettings();\n\nprotected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\nValidate.notNull(input, \"String input must not be null\");\nValidate.notNull(baseUri, \"BaseURI must not be null\");\n\ndoc = new Document(baseUri);\nthis.settings = settings;\nreader = new CharacterReader(input);\nthis.errors = errors;\ncurrentToken = null;\ntokeniser = new Tokeniser(reader, errors);\nstack = new ArrayList<>(32);\nthis.baseUri = baseUri;\n}",
            "method_id": 233
        },
        {
            "method_signature": "org.jsoup.parser.Parser:isTrackErrors()Z",
            "method_body": "public boolean isTrackErrors() {\nreturn maxErrors > 0;\n}",
            "method_id": 234
        },
        {
            "method_signature": "org.jsoup.parser.Parser:parseInput(Ljava/io/Reader;Ljava/lang/String;)Lorg/jsoup/nodes/Document;",
            "method_body": "public Document parseInput(Reader inputHtml, String baseUri) {\nerrors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\nreturn treeBuilder.parse(inputHtml, baseUri, errors, settings);\n}",
            "method_id": 235
        },
        {
            "method_signature": "org.jsoup.parser.Parser:<init>(Lorg/jsoup/parser/TreeBuilder;)V",
            "method_body": "public Parser(TreeBuilder treeBuilder) {\nthis.treeBuilder = treeBuilder;\nsettings = treeBuilder.defaultSettings();\n}",
            "method_id": 236
        },
        {
            "method_signature": "org.jsoup.Jsoup:parse(Ljava/io/File;Ljava/lang/String;)Lorg/jsoup/nodes/Document;",
            "method_body": "public static Document parse(File in, String charsetName) throws IOException {\nreturn DataUtil.load(in, charsetName, in.getAbsolutePath());\n}",
            "method_id": 237
        },
        {
            "method_signature": "org.jsoup.nodes.Node:nextSibling()Lorg/jsoup/nodes/Node;",
            "method_body": "public Node nextSibling() {\nif (parentNode == null)\nreturn null; // root\n\nfinal List<Node> siblings = parentNode.ensureChildNodes();\nfinal int index = siblingIndex+1;\nif (siblings.size() > index)\nreturn siblings.get(index);\nelse\nreturn null;\n}",
            "method_id": 238
        },
        {
            "method_signature": "org.jsoup.nodes.Node:childNode(I)Lorg/jsoup/nodes/Node;",
            "method_body": "public Node childNode(int index) {\nreturn ensureChildNodes().get(index);\n}",
            "method_id": 239
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:isBlank(Ljava/lang/String;)Z",
            "method_body": "public static boolean isBlank(String string) {\nif (string == null || string.length() == 0)\nreturn true;\n\nint l = string.length();\nfor (int i = 0; i < l; i++) {\nif (!StringUtil.isWhitespace(string.codePointAt(i)))\nreturn false;\n}\nreturn true;\n}",
            "method_id": 240
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notNull(Ljava/lang/Object;)V",
            "method_body": "public static void notNull(Object obj) {\nif (obj == null)\nthrow new IllegalArgumentException(\"Object must not be null\");\n}",
            "method_id": 241
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:charset(Ljava/lang/String;)Lorg/jsoup/nodes/Document$OutputSettings;",
            "method_body": "public OutputSettings charset(String charset) {\ncharset(Charset.forName(charset));\nreturn this;\n}",
            "method_id": 242
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notEmpty(Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "public static void notEmpty(String string, String msg) {\nif (string == null || string.length() == 0)\nthrow new IllegalArgumentException(msg);\n}",
            "method_id": 243
        },
        {
            "method_signature": "org.jsoup.nodes.LeafNode:attr(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "public String attr(String key) {\nValidate.notNull(key);\nif (!hasAttributes()) {\nreturn key.equals(nodeName()) ? (String) value : EmptyString;\n}\nreturn super.attr(key);\n}",
            "method_id": 244
        },
        {
            "method_signature": "org.jsoup.parser.ParseErrorList:noTracking()Lorg/jsoup/parser/ParseErrorList;",
            "method_body": "public static ParseErrorList noTracking() {\nreturn new ParseErrorList(0, 0);\n}",
            "method_id": 245
        },
        {
            "method_signature": "org.jsoup.internal.ConstrainableInputStream:readToByteBuffer(I)Ljava/nio/ByteBuffer;",
            "method_body": "public ByteBuffer readToByteBuffer(int max) throws IOException {\nValidate.isTrue(max >= 0, \"maxSize must be 0 (unlimited) or larger\");\nfinal boolean localCapped = max > 0; // still possibly capped in total stream\nfinal int bufferSize = localCapped && max < DefaultSize ? max : DefaultSize;\nfinal byte[] readBuffer = new byte[bufferSize];\nfinal ByteArrayOutputStream outStream = new ByteArrayOutputStream(bufferSize);\n\nint read;\nint remaining = max;\n\nwhile (true) {\nread = read(readBuffer);\nif (read == -1) break;\nif (localCapped) { // this local byteBuffer cap may be smaller than the overall maxSize (like when reading first bytes)\nif (read >= remaining) {\noutStream.write(readBuffer, 0, remaining);\nbreak;\n}\nremaining -= read;\n}\noutStream.write(readBuffer, 0, read);\n}\nreturn ByteBuffer.wrap(outStream.toByteArray());\n}",
            "method_id": 246
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:<init>()V",
            "method_body": "private Entities.EscapeMode escapeMode = Entities.EscapeMode.base;\nprivate Charset charset;\nprivate ThreadLocal<CharsetEncoder> encoderThreadLocal = new ThreadLocal<>(); // initialized by start of OuterHtmlVisitor\nEntities.CoreCharset coreCharset; // fast encoders for ascii and utf8\n\nprivate boolean prettyPrint = true;\nprivate boolean outline = false;\nprivate int indentAmount = 1;\nprivate Syntax syntax = Syntax.html;\n\npublic OutputSettings() {\ncharset(Charset.forName(\"UTF8\"));\n}",
            "method_id": 247
        },
        {
            "method_signature": "org.jsoup.nodes.Document:<init>(Ljava/lang/String;)V",
            "method_body": "public Document(String baseUri) {\nsuper(Tag.valueOf(\"#root\", ParseSettings.htmlDefault), baseUri);\nthis.location = baseUri;\n}",
            "method_id": 248
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:<init>()V",
            "method_body": "CharacterReader reader;\nTokeniser tokeniser;\nprotected Document doc; // current doc we are building into\nprotected ArrayList<Element> stack; // the stack of open elements\nprotected String baseUri; // current base uri, for creating new elements\nprotected Token currentToken; // currentToken is used only for error tracking.\nprotected ParseErrorList errors; // null when not tracking errors\nprotected ParseSettings settings;\n\nprivate Token.StartTag start = new Token.StartTag(); // start tag to process\nprivate Token.EndTag end  = new Token.EndTag();\n\nabstract ParseSettings defaultSettings();\n\nprotected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\nValidate.notNull(input, \"String input must not be null\");\nValidate.notNull(baseUri, \"BaseURI must not be null\");\n\ndoc = new Document(baseUri);\nthis.settings = settings;\nreader = new CharacterReader(input);\nthis.errors = errors;\ncurrentToken = null;\ntokeniser = new Tokeniser(reader, errors);\nstack = new ArrayList<>(32);\nthis.baseUri = baseUri;\n}",
            "method_id": 249
        },
        {
            "method_signature": "org.jsoup.parser.HtmlTreeBuilder:<init>()V",
            "method_body": "private String[] specificScopeTarget = {null};\nprivate String[] specificScopeTarget = {null};",
            "method_id": 250
        },
        {
            "method_signature": "org.jsoup.parser.Parser:htmlParser()Lorg/jsoup/parser/Parser;",
            "method_body": "public static Parser htmlParser() {\nreturn new Parser(new HtmlTreeBuilder());\n}",
            "method_id": 251
        },
        {
            "method_signature": "org.jsoup.helper.W3CDom$W3CBuilder:updateNamespaces(Lorg/jsoup/nodes/Element;)Ljava/lang/String;",
            "method_body": "private String updateNamespaces(org.jsoup.nodes.Element el) {\n// scan the element for namespace declarations\n// like: xmlns=\"blah\" or xmlns:prefix=\"blah\"\nAttributes attributes = el.attributes();\nfor (Attribute attr : attributes) {\nString key = attr.getKey();\nString prefix;\nif (key.equals(xmlnsKey)) {\nprefix = \"\";\n} else if (key.startsWith(xmlnsPrefix)) {\nprefix = key.substring(xmlnsPrefix.length());\n} else {\ncontinue;\n}\nnamespaces.put(prefix, attr.getValue());\n}\n\n// get the element prefix if any\nint pos = el.tagName().indexOf(\":\");\nreturn pos > 0 ? el.tagName().substring(0, pos) : \"\";\n}",
            "method_id": 252
        },
        {
            "method_signature": "org.jsoup.helper.W3CDom$W3CBuilder:tail(Lorg/jsoup/nodes/Node;I)V",
            "method_body": "public void tail(org.jsoup.nodes.Node source, int depth) {\nif (source instanceof org.jsoup.nodes.Element && dest.getParentNode() instanceof Element) {\ndest = (Element) dest.getParentNode(); // undescend. cromulent.\n}\n}",
            "method_id": 253
        },
        {
            "method_signature": "org.jsoup.helper.W3CDom$W3CBuilder:head(Lorg/jsoup/nodes/Node;I)V",
            "method_body": "public void head(org.jsoup.nodes.Node source, int depth) {\nif (source instanceof org.jsoup.nodes.Element) {\norg.jsoup.nodes.Element sourceEl = (org.jsoup.nodes.Element) source;\n\nString prefix = updateNamespaces(sourceEl);\nString namespace = namespaces.get(prefix);\n\nElement el = doc.createElementNS(namespace, sourceEl.tagName());\ncopyAttributes(sourceEl, el);\nif (dest == null) { // sets up the root\ndoc.appendChild(el);\n} else {\ndest.appendChild(el);\n}\ndest = el; // descend\n} else if (source instanceof org.jsoup.nodes.TextNode) {\norg.jsoup.nodes.TextNode sourceText = (org.jsoup.nodes.TextNode) source;\nText text = doc.createTextNode(sourceText.getWholeText());\ndest.appendChild(text);\n} else if (source instanceof org.jsoup.nodes.Comment) {\norg.jsoup.nodes.Comment sourceComment = (org.jsoup.nodes.Comment) source;\nComment comment = doc.createComment(sourceComment.getData());\ndest.appendChild(comment);\n} else if (source instanceof org.jsoup.nodes.DataNode) {\norg.jsoup.nodes.DataNode sourceData = (org.jsoup.nodes.DataNode) source;\nText node = doc.createTextNode(sourceData.getWholeData());\ndest.appendChild(node);\n} else {\n// unhandled\n}\n}",
            "method_id": 254
        },
        {
            "method_signature": "org.jsoup.helper.W3CDom$W3CBuilder:<init>(Lorg/w3c/dom/Document;)V",
            "method_body": "private static final String xmlnsKey = \"xmlns\";\nprivate static final String xmlnsPrefix = \"xmlns:\";\n\nprivate final Document doc;\nprivate final HashMap<String, String> namespaces = new HashMap<>();\nprivate Element dest;\n\npublic W3CBuilder(Document doc) {\nthis.doc = doc;\n}",
            "method_id": 255
        }
    ]
}