{
    "bug_id": 77,
    "test_id": 0,
    "test_name": "org.jsoup.parser.XmlTreeBuilderTest.normalizesDiscordantTags",
    "test_body": "@Test public void normalizesDiscordantTags() {\nParser parser = Parser.xmlParser().settings(ParseSettings.htmlDefault);\nDocument document = Jsoup.parse(\"<div>test</DIV><p></p>\", \"\", parser);\nassertEquals(\"<div>\\n test\\n</div>\\n<p></p>\", document.html());\n// was failing -> toString() = \"<div>\\n test\\n <p></p>\\n</div>\"\n}\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.jsoup.parser.Token:asCharacter()Lorg/jsoup/parser/Token$Character;",
            "method_body": "final Character asCharacter() {\nreturn (Character) this;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.jsoup.nodes.Node:childNode(I)Lorg/jsoup/nodes/Node;",
            "method_body": "public Node childNode(int index) {\nreturn ensureChildNodes().get(index);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.jsoup.nodes.Node:nodelistChanged()V",
            "method_body": "void nodelistChanged() {\n// Element overrides this to clear its shadow children elements\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:<clinit>()V",
            "method_body": "static final String[] padding = {\"\", \" \", \"  \", \"   \", \"    \", \"     \", \"      \", \"       \", \"        \",\n\"         \", \"          \", \"           \", \"            \", \"             \", \"              \", \"               \",\n\"                \", \"                 \", \"                  \", \"                   \", \"                    \"};",
            "method_id": 3
        },
        {
            "method_signature": "org.jsoup.nodes.Node:nextSibling()Lorg/jsoup/nodes/Node;",
            "method_body": "public Node nextSibling() {\nif (parentNode == null)\nreturn null; // root\n\nfinal List<Node> siblings = parentNode.ensureChildNodes();\nfinal int index = siblingIndex+1;\nif (siblings.size() > index)\nreturn siblings.get(index);\nelse\nreturn null;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:parse(Ljava/io/Reader;Ljava/lang/String;Lorg/jsoup/parser/ParseErrorList;Lorg/jsoup/parser/ParseSettings;)Lorg/jsoup/nodes/Document;",
            "method_body": "Document parse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\ninitialiseParse(input, baseUri, errors, settings);\nrunParser();\nreturn doc;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:finaliseTag()V",
            "method_body": "final void finaliseTag() {\n// finalises for emit\nif (pendingAttributeName != null) {\n// todo: check if attribute name exists; if so, drop and error\nnewAttribute();\n}\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.jsoup.nodes.Element:preserveWhitespace(Lorg/jsoup/nodes/Node;)Z",
            "method_body": "static boolean preserveWhitespace(Node node) {\n// looks only at this element and five levels up, to prevent recursion & needless stack searches\nif (node != null && node instanceof Element) {\nElement el = (Element) node;\nint i = 0;\ndo {\nif (el.tag.preserveWhitespace())\nreturn true;\nel = el.parent();\ni++;\n} while (i < 6 && el != null);\n}\nreturn false;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder$1:<clinit>()V",
            "method_body": "protected boolean process(Token token) {\n// start tag, end tag, doctype, comment, character, eof\nswitch (token.type) {\ncase StartTag:\ninsert(token.asStartTag());\nbreak;\ncase EndTag:\npopStackToClose(token.asEndTag());\nbreak;\ncase Comment:\ninsert(token.asComment());\nbreak;\ncase Character:\ninsert(token.asCharacter());\nbreak;\ncase Doctype:\ninsert(token.asDoctype());\nbreak;\ncase EOF: // could put some normalisation here if desired\nbreak;\ndefault:\nValidate.fail(\"Unexpected token type: \" + token.type);\n}\nreturn true;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.jsoup.nodes.Element:nodelistChanged()V",
            "method_body": "void nodelistChanged() {\nsuper.nodelistChanged();\nshadowChildrenRef = null;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.jsoup.parser.ParseSettings:<clinit>()V",
            "method_body": "public static final ParseSettings htmlDefault;\n/**\n* Preserve both tag and attribute case.\n*/\npublic static final ParseSettings preserveCase;\n\nstatic {\nhtmlDefault = new ParseSettings(false, false);\npreserveCase = new ParseSettings(true, true);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/lang/String;)V",
            "method_body": "public CharacterReader(String input) {\nthis(new StringReader(input), input.length());\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:data(Ljava/lang/String;)Lorg/jsoup/parser/Token$Character;",
            "method_body": "Character data(String data) {\nthis.data = data;\nreturn this;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.jsoup.nodes.Element:tagName()Ljava/lang/String;",
            "method_body": "public String tagName() {\nreturn tag.getName();\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.jsoup.nodes.Node:reparentChild(Lorg/jsoup/nodes/Node;)V",
            "method_body": "protected void reparentChild(Node child) {\nchild.setParentNode(this);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:<init>()V",
            "method_body": "protected String tagName;\nprotected String normalName; // lc version of tag name, for case insensitive tree build\nprivate String pendingAttributeName; // attribute names are generally caught in one hop, not accumulated\nprivate StringBuilder pendingAttributeValue = new StringBuilder(); // but values are accumulated, from e.g. & in hrefs\nprivate String pendingAttributeValueS; // try to get attr vals in one shot, vs Builder\nprivate boolean hasEmptyAttributeValue = false; // distinguish boolean attribute from empty string value\nprivate boolean hasPendingAttributeValue = false;\nboolean selfClosing = false;\nAttributes attributes; // start tags get attributes on construction. End tags get attributes on first new attribute (but only for parser convenience, not used).\n\n@Override\nTag reset() {\ntagName = null;\nnormalName = null;\npendingAttributeName = null;\nreset(pendingAttributeValue);\npendingAttributeValueS = null;\nhasEmptyAttributeValue = false;\nhasPendingAttributeValue = false;\nselfClosing = false;\nattributes = null;\nreturn this;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:canEncode(Lorg/jsoup/nodes/Entities$CoreCharset;CLjava/nio/charset/CharsetEncoder;)Z",
            "method_body": "private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n// todo add more charset tests if impacted by Android's bad perf in canEncode\nswitch (charset) {\ncase ascii:\nreturn c < 0x80;\ncase utf:\nreturn true; // real is:!(Character.isLowSurrogate(c) || Character.isHighSurrogate(c)); - but already check above\ndefault:\nreturn fallback.canEncode(c);\n}\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:outerHtmlHead(Ljava/lang/Appendable;ILorg/jsoup/nodes/Document$OutputSettings;)V",
            "method_body": "void outerHtmlHead(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\nif (out.prettyPrint() && ((siblingIndex() == 0 && parentNode instanceof Element && ((Element) parentNode).tag().formatAsBlock() && !isBlank()) || (out.outline() && siblingNodes().size()>0 && !isBlank()) ))\nindent(accum, depth, out);\n\nboolean normaliseWhite = out.prettyPrint() && parent() instanceof Element\n&& !Element.preserveWhitespace(parent());\nEntities.escape(accum, coreValue(), out, false, normaliseWhite, false);\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:read()Lorg/jsoup/parser/Token;",
            "method_body": "Token read() {\nwhile (!isEmitPending)\nstate.read(this, reader);\n\n// if emit is pending, a non-character token was found: return any chars in buffer, and leave token for next read:\nif (charsBuilder.length() > 0) {\nString str = charsBuilder.toString();\ncharsBuilder.delete(0, charsBuilder.length());\ncharsString = null;\nreturn charPending.data(str);\n} else if (charsString != null) {\nToken token = charPending.data(charsString);\ncharsString = null;\nreturn token;\n} else {\nisEmitPending = false;\nreturn emitPending;\n}\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:defaultSettings()Lorg/jsoup/parser/ParseSettings;",
            "method_body": "ParseSettings defaultSettings() {\nreturn ParseSettings.preserveCase;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.jsoup.nodes.Element:tag()Lorg/jsoup/parser/Tag;",
            "method_body": "public Tag tag() {\nreturn tag;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:nextIndexOf(C)I",
            "method_body": "int nextIndexOf(char c) {\n// doesn't handle scanning for surrogates\nbufferUp();\nfor (int i = bufPos; i < bufLength; i++) {\nif (c == charBuf[i])\nreturn i - bufPos;\n}\nreturn -1;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.jsoup.parser.Parser:isTrackErrors()Z",
            "method_body": "public boolean isTrackErrors() {\nreturn maxErrors > 0;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:advanceTransition(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void advanceTransition(TokeniserState state) {\nreader.advance();\nthis.state = state;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:<clinit>()V",
            "method_body": "private static final HashMap<String, String> multipoints = new HashMap<>(); // name -> multiple character references\nprivate static final Document.OutputSettings DefaultOutput = new Document.OutputSettings();\n\npublic enum EscapeMode {\n/**\n* Restricted entities suitable for XHTML output: lt, gt, amp, and quot only.\n*/\nxhtml(EntitiesData.xmlPoints, 4),\n/**\n* Default HTML output entities.\n*/\nbase(EntitiesData.basePoints, 106),\n/**\n* Complete HTML entities.\n*/\nextended(EntitiesData.fullPoints, 2125);\n\n// table of named references to their codepoints. sorted so we can binary search. built by BuildEntities.\nprivate String[] nameKeys;\nprivate int[] codeVals; // limitation is the few references with multiple characters; those go into multipoints.\n\n// table of codepoints to named entities.\nprivate int[] codeKeys; // we don' support multicodepoints to single named value currently\nprivate String[] nameVals;\n\nEscapeMode(String file, int size) {\nload(this, file, size);\n}\n\nint codepointForName(final String name) {\nint index = Arrays.binarySearch(nameKeys, name);\nreturn index >= 0 ? codeVals[index] : empty;\n}\n\nString nameForCodepoint(final int codepoint) {\nfinal int index = Arrays.binarySearch(codeKeys, codepoint);\nif (index >= 0) {\n// the results are ordered so lower case versions of same codepoint come after uppercase, and we prefer to emit lower\n// (and binary search for same item with multi results is undefined\nreturn (index < nameVals.length - 1 && codeKeys[index + 1] == codepoint) ?\nnameVals[index + 1] : nameVals[index];\n}\nreturn emptyName;\n}\n\nprivate int size() {\nreturn nameKeys.length;\n}\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeData()Ljava/lang/String;",
            "method_body": "String consumeData() {\n// &, <, null\nbufferUp();\nfinal int start = bufPos;\nfinal int remaining = bufLength;\nfinal char[] val = charBuf;\n\nwhile (bufPos < remaining) {\nfinal char c = val[bufPos];\nif (c == '&'|| c ==  '<' || c ==  TokeniserState.nullChar)\nbreak;\nbufPos++;\n}\n\nreturn bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:popStackToClose(Lorg/jsoup/parser/Token$EndTag;)V",
            "method_body": "private void popStackToClose(Token.EndTag endTag) {\nString elName = endTag.name();\nElement firstFound = null;\n\nfor (int pos = stack.size() -1; pos >= 0; pos--) {\nElement next = stack.get(pos);\nif (next.nodeName().equals(elName)) {\nfirstFound = next;\nbreak;\n}\n}\nif (firstFound == null)\nreturn; // not found, skip\n\nfor (int pos = stack.size() -1; pos >= 0; pos--) {\nElement next = stack.get(pos);\nstack.remove(pos);\nif (next == firstFound)\nbreak;\n}\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$9:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nif (r.isEmpty()) {\nt.eofError(this);\nt.emit(\"</\");\nt.transition(Data);\n} else if (r.matchesLetter()) {\nt.createTagPending(false);\nt.transition(TagName);\n} else if (r.matches('>')) {\nt.error(this);\nt.advanceTransition(Data);\n} else {\nt.error(this);\nt.advanceTransition(BogusComment);\n}\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.jsoup.nodes.Entities$EscapeMode:<init>(Ljava/lang/String;ILjava/lang/String;I)V",
            "method_body": "EscapeMode(String file, int size) {\nload(this, file, size);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$1:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\ncase '&':\nt.advanceTransition(CharacterReferenceInData);\nbreak;\ncase '<':\nt.advanceTransition(TagOpen);\nbreak;\ncase nullChar:\nt.error(this); // NOT replacement character (oddly?)\nt.emit(r.consume());\nbreak;\ncase eof:\nt.emit(new Token.EOF());\nbreak;\ndefault:\nString data = r.consumeData();\nt.emit(data);\nbreak;\n}\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.jsoup.nodes.LeafNode:childNodeSize()I",
            "method_body": "public int childNodeSize() {\nreturn 0;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.jsoup.parser.Tag:formatAsBlock()Z",
            "method_body": "public boolean formatAsBlock() {\nreturn formatAsBlock;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.jsoup.nodes.Element:html(Ljava/lang/StringBuilder;)V",
            "method_body": "private void html(StringBuilder accum) {\nfor (Node node : childNodes)\nnode.outerHtml(accum);\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:stringBuilder()Ljava/lang/StringBuilder;",
            "method_body": "public static StringBuilder stringBuilder() {\nStringBuilder sb = stringLocal.get();\nif (sb.length() > MaxCachedBuilderSize) {\nsb = new StringBuilder(MaxCachedBuilderSize);\nstringLocal.set(sb);\n} else {\nsb.delete(0, sb.length());\n}\nreturn sb;\n\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/io/Reader;I)V",
            "method_body": "public CharacterReader(Reader input, int sz) {\nValidate.notNull(input);\nValidate.isTrue(input.markSupported());\nreader = input;\ncharBuf = new char[sz > maxBufferLen ? maxBufferLen : sz];\nbufferUp();\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:normalize()V",
            "method_body": "public void normalize() {\nfor (int i = 0; i < size; i++) {\nkeys[i] = lowerCase(keys[i]);\n}\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.jsoup.nodes.Document:nodeName()Ljava/lang/String;",
            "method_body": "public String nodeName() {\nreturn \"#document\";\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.jsoup.nodes.LeafNode:coreValue()Ljava/lang/String;",
            "method_body": "String coreValue() {\nreturn attr(nodeName());\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:charset(Ljava/nio/charset/Charset;)Lorg/jsoup/nodes/Document$OutputSettings;",
            "method_body": "public OutputSettings charset(Charset charset) {\nthis.charset = charset;\nreturn this;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:isSelfClosing()Z",
            "method_body": "final boolean isSelfClosing() {\nreturn selfClosing;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:<init>(Lorg/jsoup/parser/CharacterReader;Lorg/jsoup/parser/ParseErrorList;)V",
            "method_body": "private final CharacterReader reader; // html input\nprivate final ParseErrorList errors; // errors found while tokenising\n\nprivate TokeniserState state = TokeniserState.Data; // current tokenisation state\nprivate Token emitPending; // the token we are about to emit on next read\nprivate boolean isEmitPending = false;\nprivate String charsString = null; // characters pending an emit. Will fall to charsBuilder if more than one\nprivate StringBuilder charsBuilder = new StringBuilder(1024); // buffers characters to output as one token, if more than one emit per read\nStringBuilder dataBuffer = new StringBuilder(1024); // buffers data looking for </script>\n\nToken.Tag tagPending; // tag we are building up\nToken.StartTag startPending = new Token.StartTag();\nToken.EndTag endPending = new Token.EndTag();\nToken.Character charPending = new Token.Character();\nToken.Doctype doctypePending = new Token.Doctype(); // doctype building up\nToken.Comment commentPending = new Token.Comment(); // comment building up\nprivate String lastStartTag; // the last start tag emitted, to test appropriate end tag\n\nTokeniser(CharacterReader reader, ParseErrorList errors) {\nthis.reader = reader;\nthis.errors = errors;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.jsoup.helper.ChangeNotifyingArrayList:<init>(I)V",
            "method_body": "public ChangeNotifyingArrayList(int initialCapacity) {\nsuper(initialCapacity);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.jsoup.parser.Tag:preserveWhitespace()Z",
            "method_body": "public boolean preserveWhitespace() {\nreturn preserveWhitespace;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.jsoup.parser.ParseSettings:<init>(ZZ)V",
            "method_body": "public ParseSettings(boolean tag, boolean attribute) {\npreserveTagCase = tag;\npreserveAttributeCase = attribute;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.jsoup.nodes.Node$OuterHtmlVisitor:<init>(Ljava/lang/Appendable;Lorg/jsoup/nodes/Document$OutputSettings;)V",
            "method_body": "OuterHtmlVisitor(Appendable accum, Document.OutputSettings out) {\nthis.accum = accum;\nthis.out = out;\nout.prepareEncoder();\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.jsoup.nodes.Entities$CoreCharset:byName(Ljava/lang/String;)Lorg/jsoup/nodes/Entities$CoreCharset;",
            "method_body": "static CoreCharset byName(final String name) {\nif (name.equals(\"US-ASCII\"))\nreturn ascii;\nif (name.startsWith(\"UTF-\")) // covers UTF-8, UTF-16, et al\nreturn utf;\nreturn fallback;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:<clinit>()V",
            "method_body": "protected static final String dataPrefix = \"data-\";\nprivate static final int InitialCapacity = 4; // todo - analyze Alexa 1MM sites, determine best setting\n\n// manages the key/val arrays\nprivate static final int GrowthFactor = 2;\nprivate static final String[] Empty = {};",
            "method_id": 46
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:escape(Ljava/lang/Appendable;Ljava/lang/String;Lorg/jsoup/nodes/Document$OutputSettings;ZZZ)V",
            "method_body": "static void escape(Appendable accum, String string, Document.OutputSettings out,\nboolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) throws IOException {\n\nboolean lastWasWhite = false;\nboolean reachedNonWhite = false;\nfinal EscapeMode escapeMode = out.escapeMode();\nfinal CharsetEncoder encoder = out.encoder();\nfinal CoreCharset coreCharset = out.coreCharset; // init in out.prepareEncoder()\nfinal int length = string.length();\n\nint codePoint;\nfor (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\ncodePoint = string.codePointAt(offset);\n\nif (normaliseWhite) {\nif (StringUtil.isWhitespace(codePoint)) {\nif ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\ncontinue;\naccum.append(' ');\nlastWasWhite = true;\ncontinue;\n} else {\nlastWasWhite = false;\nreachedNonWhite = true;\n}\n}\n// surrogate pairs, split implementation for efficiency on single char common case (saves creating strings, char[]):\nif (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\nfinal char c = (char) codePoint;\n// html specific and required escapes:\nswitch (c) {\ncase '&':\naccum.append(\"&amp;\");\nbreak;\ncase 0xA0:\nif (escapeMode != EscapeMode.xhtml)\naccum.append(\"&nbsp;\");\nelse\naccum.append(\"&#xa0;\");\nbreak;\ncase '<':\n// escape when in character data or when in a xml attribue val; not needed in html attr val\nif (!inAttribute || escapeMode == EscapeMode.xhtml)\naccum.append(\"&lt;\");\nelse\naccum.append(c);\nbreak;\ncase '>':\nif (!inAttribute)\naccum.append(\"&gt;\");\nelse\naccum.append(c);\nbreak;\ncase '\"':\nif (inAttribute)\naccum.append(\"&quot;\");\nelse\naccum.append(c);\nbreak;\ndefault:\nif (canEncode(coreCharset, c, encoder))\naccum.append(c);\nelse\nappendEncoded(accum, escapeMode, codePoint);\n}\n} else {\nfinal String c = new String(Character.toChars(codePoint));\nif (encoder.canEncode(c)) // uses fallback encoder for simplicity\naccum.append(c);\nelse\nappendEncoded(accum, escapeMode, codePoint);\n}\n}\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.jsoup.parser.Token:reset(Ljava/lang/StringBuilder;)V",
            "method_body": "abstract Token reset();\n\nstatic void reset(StringBuilder sb) {\nif (sb != null) {\nsb.delete(0, sb.length());\n}\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:padding(I)Ljava/lang/String;",
            "method_body": "public static String padding(int width) {\nif (width < 0)\nthrow new IllegalArgumentException(\"width must be > 0\");\n\nif (width < padding.length)\nreturn padding[width];\nchar[] out = new char[width];\nfor (int i = 0; i < width; i++)\nout[i] = ' ';\nreturn String.valueOf(out);\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:isBlank(Ljava/lang/String;)Z",
            "method_body": "public static boolean isBlank(String string) {\nif (string == null || string.length() == 0)\nreturn true;\n\nint l = string.length();\nfor (int i = 0; i < l; i++) {\nif (!StringUtil.isWhitespace(string.codePointAt(i)))\nreturn false;\n}\nreturn true;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.jsoup.nodes.Entities:load(Lorg/jsoup/nodes/Entities$EscapeMode;Ljava/lang/String;I)V",
            "method_body": "private static void load(EscapeMode e, String pointsData, int size) {\ne.nameKeys = new String[size];\ne.codeVals = new int[size];\ne.codeKeys = new int[size];\ne.nameVals = new String[size];\n\nint i = 0;\nCharacterReader reader = new CharacterReader(pointsData);\n\nwhile (!reader.isEmpty()) {\n// NotNestedLessLess=10913,824;1887&\n\nfinal String name = reader.consumeTo('=');\nreader.advance();\nfinal int cp1 = Integer.parseInt(reader.consumeToAny(codeDelims), codepointRadix);\nfinal char codeDelim = reader.current();\nreader.advance();\nfinal int cp2;\nif (codeDelim == ',') {\ncp2 = Integer.parseInt(reader.consumeTo(';'), codepointRadix);\nreader.advance();\n} else {\ncp2 = empty;\n}\nfinal String indexS = reader.consumeTo('&');\nfinal int index = Integer.parseInt(indexS, codepointRadix);\nreader.advance();\n\ne.nameKeys[i] = name;\ne.codeVals[i] = cp1;\ne.codeKeys[index] = cp1;\ne.nameVals[index] = name;\n\nif (cp2 != empty) {\nmultipoints.put(name, new String(new int[]{cp1, cp2}, 0, 2));\n}\ni++;\n}\n\nValidate.isTrue(i == size, \"Unexpected count of entities loaded\");\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:initialiseParse(Ljava/io/Reader;Ljava/lang/String;Lorg/jsoup/parser/ParseErrorList;Lorg/jsoup/parser/ParseSettings;)V",
            "method_body": "abstract ParseSettings defaultSettings();\n\nprotected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\nValidate.notNull(input, \"String input must not be null\");\nValidate.notNull(baseUri, \"BaseURI must not be null\");\n\ndoc = new Document(baseUri);\nthis.settings = settings;\nreader = new CharacterReader(input);\nthis.errors = errors;\ncurrentToken = null;\ntokeniser = new Tokeniser(reader, errors);\nstack = new ArrayList<>(32);\nthis.baseUri = baseUri;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.jsoup.parser.Tag:isSelfClosing()Z",
            "method_body": "public boolean isSelfClosing() {\nreturn empty || selfClosing;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$10:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\n// previous TagOpen state did NOT consume, will have a letter char in current\n//String tagName = r.consumeToAnySorted(tagCharsSorted).toLowerCase();\nString tagName = r.consumeTagName();\nt.tagPending.appendTagName(tagName);\n\nchar c = r.consume();\nswitch (c) {\ncase '\\t':\ncase '\\n':\ncase '\\r':\ncase '\\f':\ncase ' ':\nt.transition(BeforeAttributeName);\nbreak;\ncase '/':\nt.transition(SelfClosingStartTag);\nbreak;\ncase '>':\nt.emitTagPending();\nt.transition(Data);\nbreak;\ncase nullChar: // replacement\nt.tagPending.appendTagName(replacementStr);\nbreak;\ncase eof: // should emit pending tag?\nt.eofError(this);\nt.transition(Data);\nbreak;\ndefault: // buffer underrun\nt.tagPending.appendTagName(c);\n}\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.jsoup.parser.Token$Comment:<init>()V",
            "method_body": "final StringBuilder data = new StringBuilder();\nboolean bogus = false;\n\n@Override\nToken reset() {\nreset(data);\nbogus = false;\nreturn this;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:<init>()V",
            "method_body": "public OutputSettings() {\ncharset(Charset.forName(\"UTF8\"));\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.jsoup.parser.ParseErrorList:noTracking()Lorg/jsoup/parser/ParseErrorList;",
            "method_body": "public static ParseErrorList noTracking() {\nreturn new ParseErrorList(0, 0);\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.jsoup.nodes.LeafNode:attr(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "public String attr(String key) {\nValidate.notNull(key);\nif (!hasAttributes()) {\nreturn key.equals(nodeName()) ? (String) value : EmptyString;\n}\nreturn super.attr(key);\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:insertNode(Lorg/jsoup/nodes/Node;)V",
            "method_body": "private void insertNode(Node node) {\ncurrentElement().appendChild(node);\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeTagName()Ljava/lang/String;",
            "method_body": "String consumeTagName() {\n// '\\t', '\\n', '\\r', '\\f', ' ', '/', '>', nullChar\nbufferUp();\nfinal int start = bufPos;\nfinal int remaining = bufLength;\nfinal char[] val = charBuf;\n\nwhile (bufPos < remaining) {\nfinal char c = val[bufPos];\nif (c == '\\t'|| c ==  '\\n'|| c ==  '\\r'|| c ==  '\\f'|| c ==  ' '|| c ==  '/'|| c ==  '>'|| c ==  TokeniserState.nullChar)\nbreak;\nbufPos++;\n}\n\nreturn bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.jsoup.parser.Parser:parseInput(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Document;",
            "method_body": "public Document parseInput(String html, String baseUri) {\nerrors = isTrackErrors() ? ParseErrorList.tracking(maxErrors) : ParseErrorList.noTracking();\nreturn treeBuilder.parse(new StringReader(html), baseUri, errors, settings);\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.jsoup.nodes.Document:outputSettings()Lorg/jsoup/nodes/Document$OutputSettings;",
            "method_body": "public OutputSettings outputSettings() {\nreturn outputSettings;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isFalse(ZLjava/lang/String;)V",
            "method_body": "public static void isFalse(boolean val, String msg) {\nif (val)\nthrow new IllegalArgumentException(msg);\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.jsoup.parser.Parser:xmlParser()Lorg/jsoup/parser/Parser;",
            "method_body": "public static Parser xmlParser() {\nreturn new Parser(new XmlTreeBuilder());\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:<init>()V",
            "method_body": "static final int NotFound = -1;\nprivate static final String EmptyString = \"\";\n\nprivate int size = 0; // number of slots used (not capacity, which is keys.length\nString[] keys = Empty;\nString[] vals = Empty;\n\n// check there's room for more\nprivate void checkCapacity(int minNewSize) {\nValidate.isTrue(minNewSize >= size);\nint curSize = keys.length;\nif (curSize >= minNewSize)\nreturn;\n\nint newSize = curSize >= InitialCapacity ? size * GrowthFactor : InitialCapacity;\nif (minNewSize > newSize)\nnewSize = minNewSize;\n\nkeys = copyOf(keys, newSize);\nvals = copyOf(vals, newSize);\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:<init>()V",
            "method_body": "Character() {\nsuper();\ntype = TokenType.Character;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.jsoup.parser.Token$EOF:<init>()V",
            "method_body": "EOF() {\ntype = Token.TokenType.EOF;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isFalse(Z)V",
            "method_body": "public static void isFalse(boolean val) {\nif (val)\nthrow new IllegalArgumentException(\"Must be false\");\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil$1:initialValue()Ljava/lang/StringBuilder;",
            "method_body": "protected StringBuilder initialValue() {\nreturn new StringBuilder(MaxCachedBuilderSize);\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notNull(Ljava/lang/Object;)V",
            "method_body": "public static void notNull(Object obj) {\nif (obj == null)\nthrow new IllegalArgumentException(\"Object must not be null\");\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.jsoup.nodes.Attributes:html(Ljava/lang/Appendable;Lorg/jsoup/nodes/Document$OutputSettings;)V",
            "method_body": "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\nfinal int sz = size;\nfor (int i = 0; i < sz; i++) {\n// inlined from Attribute.html()\nfinal String key = keys[i];\nfinal String val = vals[i];\naccum.append(' ').append(key);\n\n// collapse checked=null, checked=\"\", checked=checked; write out others\nif (!Attribute.shouldCollapseAttribute(key, val, out)) {\naccum.append(\"=\\\"\");\nEntities.escape(accum, val == null ? EmptyString : val, out, true, false, false);\naccum.append('\"');\n}\n}\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.jsoup.parser.Tag:register(Lorg/jsoup/parser/Tag;)V",
            "method_body": "private static void register(Tag tag) {\ntags.put(tag.tagName, tag);\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:syntax(Lorg/jsoup/nodes/Document$OutputSettings$Syntax;)Lorg/jsoup/nodes/Document$OutputSettings;",
            "method_body": "public OutputSettings syntax(Syntax syntax) {\nthis.syntax = syntax;\nreturn this;\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notEmpty(Ljava/lang/String;)V",
            "method_body": "public static void notEmpty(String string) {\nif (string == null || string.length() == 0)\nthrow new IllegalArgumentException(\"String must not be empty\");\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.jsoup.nodes.Node:root()Lorg/jsoup/nodes/Node;",
            "method_body": "public Node root() {\nNode node = this;\nwhile (node.parentNode != null)\nnode = node.parentNode;\nreturn node;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.jsoup.parser.Token:isCData()Z",
            "method_body": "final boolean isCData() {\nreturn this instanceof CData;\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.jsoup.select.NodeTraversor:traverse(Lorg/jsoup/select/NodeVisitor;Lorg/jsoup/nodes/Node;)V",
            "method_body": "public static void traverse(NodeVisitor visitor, Node root) {\nNode node = root;\nint depth = 0;\n\nwhile (node != null) {\nvisitor.head(node, depth);\nif (node.childNodeSize() > 0) {\nnode = node.childNode(0);\ndepth++;\n} else {\nwhile (node.nextSibling() == null && depth > 0) {\nvisitor.tail(node, depth);\nnode = node.parentNode();\ndepth--;\n}\nvisitor.tail(node, depth);\nif (node == root)\nbreak;\nnode = node.nextSibling();\n}\n}\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:prettyPrint()Z",
            "method_body": "public boolean prettyPrint() {\nreturn prettyPrint;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:bufferUp()V",
            "method_body": "private void bufferUp() {\nif (bufPos < bufSplitPoint)\nreturn;\n\ntry {\nreaderPos += bufPos;\nreader.skip(bufPos);\nreader.mark(maxBufferLen);\nbufLength = reader.read(charBuf);\nreader.reset();\nbufPos = 0;\nbufMark = 0;\nbufSplitPoint = bufLength > readAheadLimit ? readAheadLimit : bufLength;\n} catch (IOException e) {\nthrow new UncheckedIOException(e);\n}\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:name()Ljava/lang/String;",
            "method_body": "final String name() { // preserves case, for input into Tag.valueOf (which may drop case)\nValidate.isFalse(tagName == null || tagName.length() == 0);\nreturn tagName;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:prepareEncoder()Ljava/nio/charset/CharsetEncoder;",
            "method_body": "CharsetEncoder prepareEncoder() {\n// created at start of OuterHtmlVisitor so each pass has own encoder, so OutputSettings can be shared among threads\nCharsetEncoder encoder = charset.newEncoder();\nencoderThreadLocal.set(encoder);\ncoreCharset = Entities.CoreCharset.byName(encoder.charset().name());\nreturn encoder;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:insert(Lorg/jsoup/parser/Token$StartTag;)Lorg/jsoup/nodes/Element;",
            "method_body": "Element insert(Token.StartTag startTag) {\nTag tag = Tag.valueOf(startTag.name(), settings);\n// todo: wonder if for xml parsing, should treat all tags as unknown? because it's not html.\nElement el = new Element(tag, baseUri, settings.normalizeAttributes(startTag.attributes));\ninsertNode(el);\nif (startTag.isSelfClosing()) {\nif (!tag.isKnownTag()) // unknown tag, remember this is self closing for output. see above.\ntag.setSelfClosing();\n} else {\nstack.add(el);\n}\nreturn el;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:appendTagName(Ljava/lang/String;)V",
            "method_body": "final void appendTagName(String append) {\ntagName = tagName == null ? append : tagName.concat(append);\nnormalName = lowerCase(tagName);\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.jsoup.internal.Normalizer:lowerCase(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "public static String lowerCase(final String input) {\nreturn input != null ? input.toLowerCase(Locale.ENGLISH) : \"\";\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.jsoup.parser.Token:asStartTag()Lorg/jsoup/parser/Token$StartTag;",
            "method_body": "final StartTag asStartTag() {\nreturn (StartTag) this;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.jsoup.nodes.Element$NodeList:onContentsChanged()V",
            "method_body": "public void onContentsChanged() {\nowner.nodelistChanged();\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.jsoup.parser.Tag:<init>(Ljava/lang/String;)V",
            "method_body": "private static final Map<String, Tag> tags = new HashMap<>(); // map of known tags\n\nprivate String tagName;\nprivate boolean isBlock = true; // block or inline\nprivate boolean formatAsBlock = true; // should be formatted as a block\nprivate boolean canContainInline = true; // only pcdata if not\nprivate boolean empty = false; // can hold nothing; e.g. img\nprivate boolean selfClosing = false; // can self close (<foo />). used for unknown tags that self close, without forcing them as empty.\nprivate boolean preserveWhitespace = false; // for pre, textarea, script etc\nprivate boolean formList = false; // a control that appears in forms: input, textarea, output etc\nprivate boolean formSubmit = false; // a control that can be submitted in a form: input etc\n\nprivate Tag(String tagName) {\nthis.tagName = tagName;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.jsoup.nodes.Node:indent(Ljava/lang/Appendable;ILorg/jsoup/nodes/Document$OutputSettings;)V",
            "method_body": "protected void indent(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\naccum.append('\\n').append(StringUtil.padding(depth * out.indentAmount()));\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.jsoup.parser.TokeniserState$8:read(Lorg/jsoup/parser/Tokeniser;Lorg/jsoup/parser/CharacterReader;)V",
            "method_body": "void read(Tokeniser t, CharacterReader r) {\nswitch (r.current()) {\ncase '!':\nt.advanceTransition(MarkupDeclarationOpen);\nbreak;\ncase '/':\nt.advanceTransition(EndTagOpen);\nbreak;\ncase '?':\nt.advanceTransition(BogusComment);\nbreak;\ndefault:\nif (r.matchesLetter()) {\nt.createTagPending(true);\nt.transition(TagName);\n} else {\nt.error(this);\nt.emit('<'); // char that got us here\nt.transition(Data);\n}\nbreak;\n}\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:process(Lorg/jsoup/parser/Token;)Z",
            "method_body": "protected boolean process(Token token) {\n// start tag, end tag, doctype, comment, character, eof\nswitch (token.type) {\ncase StartTag:\ninsert(token.asStartTag());\nbreak;\ncase EndTag:\npopStackToClose(token.asEndTag());\nbreak;\ncase Comment:\ninsert(token.asComment());\nbreak;\ncase Character:\ninsert(token.asCharacter());\nbreak;\ncase Doctype:\ninsert(token.asDoctype());\nbreak;\ncase EOF: // could put some normalisation here if desired\nbreak;\ndefault:\nValidate.fail(\"Unexpected token type: \" + token.type);\n}\nreturn true;\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.jsoup.nodes.Entities$1:<clinit>()V",
            "method_body": "private static boolean canEncode(final CoreCharset charset, final char c, final CharsetEncoder fallback) {\n// todo add more charset tests if impacted by Android's bad perf in canEncode\nswitch (charset) {\ncase ascii:\nreturn c < 0x80;\ncase utf:\nreturn true; // real is:!(Character.isLowSurrogate(c) || Character.isHighSurrogate(c)); - but already check above\ndefault:\nreturn fallback.canEncode(c);\n}\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.jsoup.parser.ParseSettings:normalizeAttributes(Lorg/jsoup/nodes/Attributes;)Lorg/jsoup/nodes/Attributes;",
            "method_body": "Attributes normalizeAttributes(Attributes attributes) {\nif (!preserveAttributeCase) {\nattributes.normalize();\n}\nreturn attributes;\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.jsoup.parser.Token$StartTag:<init>()V",
            "method_body": "StartTag() {\nsuper();\nattributes = new Attributes();\ntype = TokenType.StartTag;\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:nodeName()Ljava/lang/String;",
            "method_body": "public String nodeName() {\nreturn \"#text\";\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.jsoup.nodes.LeafNode:hasAttributes()Z",
            "method_body": "protected final boolean hasAttributes() {\nreturn value instanceof Attributes;\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.jsoup.nodes.Node:getOutputSettings()Lorg/jsoup/nodes/Document$OutputSettings;",
            "method_body": "Document.OutputSettings getOutputSettings() {\nDocument owner = ownerDocument();\nreturn owner != null ? owner.outputSettings() : (new Document(\"\")).outputSettings();\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.jsoup.Jsoup:parse(Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/parser/Parser;)Lorg/jsoup/nodes/Document;",
            "method_body": "public static Document parse(String html, String baseUri, Parser parser) {\nreturn parser.parseInput(html, baseUri);\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:escapeMode()Lorg/jsoup/nodes/Entities$EscapeMode;",
            "method_body": "public Entities.EscapeMode escapeMode() {\nreturn escapeMode;\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.jsoup.parser.ParseSettings:normalizeTag(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "String normalizeTag(String name) {\nname = name.trim();\nif (!preserveTagCase)\nname = lowerCase(name);\nreturn name;\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.jsoup.parser.Parser:<init>(Lorg/jsoup/parser/TreeBuilder;)V",
            "method_body": "public Parser(TreeBuilder treeBuilder) {\nthis.treeBuilder = treeBuilder;\nsettings = treeBuilder.defaultSettings();\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:getData()Ljava/lang/String;",
            "method_body": "String getData() {\nreturn data;\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:initialiseParse(Ljava/io/Reader;Ljava/lang/String;Lorg/jsoup/parser/ParseErrorList;Lorg/jsoup/parser/ParseSettings;)V",
            "method_body": "protected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\nsuper.initialiseParse(input, baseUri, errors, settings);\nstack.add(doc); // place the document onto the stack. differs from HtmlTreeBuilder (not on stack)\ndoc.outputSettings().syntax(Document.OutputSettings.Syntax.xml);\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeToAny([C)Ljava/lang/String;",
            "method_body": "public String consumeToAny(final char... chars) {\nbufferUp();\nfinal int start = bufPos;\nfinal int remaining = bufLength;\nfinal char[] val = charBuf;\n\nOUTER: while (bufPos < remaining) {\nfor (char c : chars) {\nif (val[bufPos] == c)\nbreak OUTER;\n}\nbufPos++;\n}\n\nreturn bufPos > start ? cacheString(charBuf, stringCache, start, bufPos -start) : \"\";\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.jsoup.nodes.Node:<init>()V",
            "method_body": "protected Node() {\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isTrue(ZLjava/lang/String;)V",
            "method_body": "public static void isTrue(boolean val, String msg) {\nif (!val)\nthrow new IllegalArgumentException(msg);\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.jsoup.nodes.Document:<init>(Ljava/lang/String;)V",
            "method_body": "public Document(String baseUri) {\nsuper(Tag.valueOf(\"#root\", ParseSettings.htmlDefault), baseUri);\nthis.location = baseUri;\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.jsoup.parser.ParseErrorList:<init>(II)V",
            "method_body": "ParseErrorList(int initialCapacity, int maxSize) {\nsuper(initialCapacity);\nthis.maxSize = maxSize;\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:matchesLetter()Z",
            "method_body": "boolean matchesLetter() {\nif (isEmpty())\nreturn false;\nchar c = charBuf[bufPos];\nreturn (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || Character.isLetter(c);\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:<init>(Ljava/io/Reader;)V",
            "method_body": "public CharacterReader(Reader input) {\nthis(input, maxBufferLen);\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.jsoup.nodes.Element:nodeName()Ljava/lang/String;",
            "method_body": "public String nodeName() {\nreturn tag.getName();\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.jsoup.nodes.Entities$EscapeMode:<clinit>()V",
            "method_body": "private static final HashMap<String, String> multipoints = new HashMap<>(); // name -> multiple character references\nprivate static final Document.OutputSettings DefaultOutput = new Document.OutputSettings();\n\npublic enum EscapeMode {\n/**\n* Restricted entities suitable for XHTML output: lt, gt, amp, and quot only.\n*/\nxhtml(EntitiesData.xmlPoints, 4),\n/**\n* Default HTML output entities.\n*/\nbase(EntitiesData.basePoints, 106),\n/**\n* Complete HTML entities.\n*/\nextended(EntitiesData.fullPoints, 2125);\n\n// table of named references to their codepoints. sorted so we can binary search. built by BuildEntities.\nprivate String[] nameKeys;\nprivate int[] codeVals; // limitation is the few references with multiple characters; those go into multipoints.\n\n// table of codepoints to named entities.\nprivate int[] codeKeys; // we don' support multicodepoints to single named value currently\nprivate String[] nameVals;\n\nEscapeMode(String file, int size) {\nload(this, file, size);\n}\n\nint codepointForName(final String name) {\nint index = Arrays.binarySearch(nameKeys, name);\nreturn index >= 0 ? codeVals[index] : empty;\n}\n\nString nameForCodepoint(final int codepoint) {\nfinal int index = Arrays.binarySearch(codeKeys, codepoint);\nif (index >= 0) {\n// the results are ordered so lower case versions of same codepoint come after uppercase, and we prefer to emit lower\n// (and binary search for same item with multi results is undefined\nreturn (index < nameVals.length - 1 && codeKeys[index + 1] == codepoint) ?\nnameVals[index + 1] : nameVals[index];\n}\nreturn emptyName;\n}\n\nprivate int size() {\nreturn nameKeys.length;\n}\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.jsoup.nodes.Node:parent()Lorg/jsoup/nodes/Node;",
            "method_body": "public Node parent() {\nreturn parentNode;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:indentAmount()I",
            "method_body": "public int indentAmount() {\nreturn indentAmount;\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.jsoup.nodes.Element:ensureChildNodes()Ljava/util/List;",
            "method_body": "protected List<Node> ensureChildNodes() {\nif (childNodes == EMPTY_NODES) {\nchildNodes = new NodeList(this, 4);\n}\nreturn childNodes;\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:current()C",
            "method_body": "public char current() {\nbufferUp();\nreturn isEmpty() ? EOF : charBuf[bufPos];\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.jsoup.helper.Validate:notNull(Ljava/lang/Object;Ljava/lang/String;)V",
            "method_body": "public static void notNull(Object obj, String msg) {\nif (obj == null)\nthrow new IllegalArgumentException(msg);\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:cacheString([C[Ljava/lang/String;II)Ljava/lang/String;",
            "method_body": "private static String cacheString(final char[] charBuf, final String[] stringCache, final int start, final int count) {\n// limit (no cache):\nif (count > maxStringCacheLen)\nreturn new String(charBuf, start, count);\nif (count < 1)\nreturn \"\";\n\n// calculate hash:\nint hash = 0;\nint offset = start;\nfor (int i = 0; i < count; i++) {\nhash = 31 * hash + charBuf[offset++];\n}\n\n// get from cache\nfinal int index = hash & stringCache.length - 1;\nString cached = stringCache[index];\n\nif (cached == null) { // miss, add\ncached = new String(charBuf, start, count);\nstringCache[index] = cached;\n} else { // hashcode hit, check equality\nif (rangeEquals(charBuf, start, count, cached)) { // hit\nreturn cached;\n} else { // hashcode conflict\ncached = new String(charBuf, start, count);\nstringCache[index] = cached; // update the cache, as recently used strings are more likely to show up again\n}\n}\nreturn cached;\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.jsoup.nodes.Node:setParentNode(Lorg/jsoup/nodes/Node;)V",
            "method_body": "protected void setParentNode(Node parentNode) {\nValidate.notNull(parentNode);\nif (this.parentNode != null)\nthis.parentNode.removeChild(this);\nthis.parentNode = parentNode;\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.jsoup.nodes.Node:ownerDocument()Lorg/jsoup/nodes/Document;",
            "method_body": "public Document ownerDocument() {\nNode root = root();\nreturn (root instanceof Document) ? (Document) root : null;\n}",
            "method_id": 119
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn bufPos >= bufLength;\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.jsoup.nodes.Element:html()Ljava/lang/String;",
            "method_body": "public String html() {\nStringBuilder accum = StringUtil.stringBuilder();\nhtml(accum);\nreturn getOutputSettings().prettyPrint() ? accum.toString().trim() : accum.toString();\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:currentElement()Lorg/jsoup/nodes/Element;",
            "method_body": "protected Element currentElement() {\nint size = stack.size();\nreturn size > 0 ? stack.get(size-1) : null;\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.jsoup.parser.Token:asEndTag()Lorg/jsoup/parser/Token$EndTag;",
            "method_body": "final EndTag asEndTag() {\nreturn (EndTag) this;\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:rangeEquals([CIILjava/lang/String;)Z",
            "method_body": "static boolean rangeEquals(final char[] charBuf, final int start, int count, final String cached) {\nif (count == cached.length()) {\nint i = start;\nint j = 0;\nwhile (count-- != 0) {\nif (charBuf[i++] != cached.charAt(j++))\nreturn false;\n}\nreturn true;\n}\nreturn false;\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.jsoup.nodes.Element:parent()Lorg/jsoup/nodes/Element;",
            "method_body": "public final Element parent() {\nreturn (Element) parentNode;\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.jsoup.parser.Token$Character:reset()Lorg/jsoup/parser/Token;",
            "method_body": "Token reset() {\ndata = null;\nreturn this;\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.jsoup.nodes.Node:setSiblingIndex(I)V",
            "method_body": "protected void setSiblingIndex(int siblingIndex) {\nthis.siblingIndex = siblingIndex;\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.jsoup.parser.Tag:<clinit>()V",
            "method_body": "private static final String[] blockTags = {\n\"html\", \"head\", \"body\", \"frameset\", \"script\", \"noscript\", \"style\", \"meta\", \"link\", \"title\", \"frame\",\n\"noframes\", \"section\", \"nav\", \"aside\", \"hgroup\", \"header\", \"footer\", \"p\", \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\",\n\"ul\", \"ol\", \"pre\", \"div\", \"blockquote\", \"hr\", \"address\", \"figure\", \"figcaption\", \"form\", \"fieldset\", \"ins\",\n\"del\", \"dl\", \"dt\", \"dd\", \"li\", \"table\", \"caption\", \"thead\", \"tfoot\", \"tbody\", \"colgroup\", \"col\", \"tr\", \"th\",\n\"td\", \"video\", \"audio\", \"canvas\", \"details\", \"menu\", \"plaintext\", \"template\", \"article\", \"main\",\n\"svg\", \"math\"\n};",
            "method_id": 128
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consume()C",
            "method_body": "char consume() {\nbufferUp();\nchar val = isEmpty() ? EOF : charBuf[bufPos];\nbufPos++;\nreturn val;\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<init>(Lorg/jsoup/parser/Tag;Ljava/lang/String;Lorg/jsoup/nodes/Attributes;)V",
            "method_body": "public Element(Tag tag, String baseUri, Attributes attributes) {\nValidate.notNull(tag);\nValidate.notNull(baseUri);\nchildNodes = EMPTY_NODES;\nthis.baseUri = baseUri;\nthis.attributes = attributes;\nthis.tag = tag;\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.jsoup.parser.Token:<init>()V",
            "method_body": "private Token() {\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.jsoup.parser.Token$EndTag:<init>()V",
            "method_body": "EndTag() {\nsuper();\ntype = TokenType.EndTag;\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.jsoup.parser.Tag:valueOf(Ljava/lang/String;Lorg/jsoup/parser/ParseSettings;)Lorg/jsoup/parser/Tag;",
            "method_body": "public static Tag valueOf(String tagName, ParseSettings settings) {\nValidate.notNull(tagName);\nTag tag = tags.get(tagName);\n\nif (tag == null) {\ntagName = settings.normalizeTag(tagName);\nValidate.notEmpty(tagName);\ntag = tags.get(tagName);\n\nif (tag == null) {\n// not defined: create default; go anywhere, do anything! (incl be inside a <p>)\ntag = new Tag(tagName);\ntag.isBlock = false;\n}\n}\nreturn tag;\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.jsoup.nodes.Element:outerHtmlHead(Ljava/lang/Appendable;ILorg/jsoup/nodes/Document$OutputSettings;)V",
            "method_body": "void outerHtmlHead(final Appendable accum, int depth, final Document.OutputSettings out) throws IOException {\nif (out.prettyPrint() && (tag.formatAsBlock() || (parent() != null && parent().tag().formatAsBlock()) || out.outline())) {\nif (accum instanceof StringBuilder) {\nif (((StringBuilder) accum).length() > 0)\nindent(accum, depth, out);\n} else {\nindent(accum, depth, out);\n}\n}\naccum.append('<').append(tagName());\nif (attributes != null) attributes.html(accum, out);\n\n// selfclosing includes unknown tags, isEmpty defines tags that are always empty\nif (childNodes.isEmpty() && tag.isSelfClosing()) {\nif (out.syntax() == Document.OutputSettings.Syntax.html && tag.isEmpty())\naccum.append('>');\nelse\naccum.append(\" />\"); // <img> in html, <img /> in xml\n}\nelse\naccum.append('>');\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:createTagPending(Z)Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Token.Tag createTagPending(boolean start) {\ntagPending = start ? startPending.reset() : endPending.reset();\nreturn tagPending;\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.jsoup.parser.Token$Tag:reset()Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Tag reset() {\ntagName = null;\nnormalName = null;\npendingAttributeName = null;\nreset(pendingAttributeValue);\npendingAttributeValueS = null;\nhasEmptyAttributeValue = false;\nhasPendingAttributeValue = false;\nselfClosing = false;\nattributes = null;\nreturn this;\n}",
            "method_id": 136
        },
        {
            "method_signature": "org.jsoup.parser.Token$StartTag:reset()Lorg/jsoup/parser/Token$Tag;",
            "method_body": "Tag reset() {\nsuper.reset();\nattributes = new Attributes();\n// todo - would prefer these to be null, but need to check Element assertions\nreturn this;\n}",
            "method_id": 137
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:runParser()V",
            "method_body": "protected void runParser() {\nwhile (true) {\nToken token = tokeniser.read();\nprocess(token);\ntoken.reset();\n\nif (token.type == Token.TokenType.EOF)\nbreak;\n}\n}",
            "method_id": 138
        },
        {
            "method_signature": "org.jsoup.helper.StringUtil:isWhitespace(I)Z",
            "method_body": "public static boolean isWhitespace(int c){\nreturn c == ' ' || c == '\\t' || c == '\\n' || c == '\\f' || c == '\\r';\n}",
            "method_id": 139
        },
        {
            "method_signature": "org.jsoup.helper.Validate:isTrue(Z)V",
            "method_body": "public static void isTrue(boolean val) {\nif (!val)\nthrow new IllegalArgumentException(\"Must be true\");\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emitTagPending()V",
            "method_body": "void emitTagPending() {\ntagPending.finaliseTag();\nemit(tagPending);\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.jsoup.nodes.Node:siblingIndex()I",
            "method_body": "public int siblingIndex() {\nreturn siblingIndex;\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<init>(Lorg/jsoup/parser/Tag;Ljava/lang/String;)V",
            "method_body": "public Element(Tag tag, String baseUri) {\nthis(tag, baseUri, null);\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.jsoup.nodes.Document$OutputSettings:encoder()Ljava/nio/charset/CharsetEncoder;",
            "method_body": "CharsetEncoder encoder() {\nCharsetEncoder encoder = encoderThreadLocal.get();\nreturn encoder != null ? encoder : prepareEncoder();\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.jsoup.parser.XmlTreeBuilder:insert(Lorg/jsoup/parser/Token$Character;)V",
            "method_body": "void insert(Token.Character token) {\nfinal String data = token.getData();\ninsertNode(token.isCData() ? new CDataNode(data) : new TextNode(data));\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.jsoup.nodes.Node:parentNode()Lorg/jsoup/nodes/Node;",
            "method_body": "public final Node parentNode() {\nreturn parentNode;\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:transition(Lorg/jsoup/parser/TokeniserState;)V",
            "method_body": "void transition(TokeniserState state) {\nthis.state = state;\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.jsoup.nodes.Node:outerHtml(Ljava/lang/Appendable;)V",
            "method_body": "protected void outerHtml(Appendable accum) {\nNodeTraversor.traverse(new OuterHtmlVisitor(accum, getOutputSettings()), this);\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.jsoup.nodes.Element:<clinit>()V",
            "method_body": "private static final List<Node> EMPTY_NODES = Collections.emptyList();\nprivate static final Pattern classSplit = Pattern.compile(\"\\\\s+\");\nprivate Tag tag;\nprivate WeakReference<List<Element>> shadowChildrenRef; // points to child elements shadowed from node children\nList<Node> childNodes;\nprivate Attributes attributes;\nprivate String baseUri;\n\n/**\n* Create a new, standalone element.\n* @param tag tag name\n*/\npublic Element(String tag) {\nthis(Tag.valueOf(tag), \"\", new Attributes());\n}",
            "method_id": 149
        },
        {
            "method_signature": "org.jsoup.nodes.Node$OuterHtmlVisitor:tail(Lorg/jsoup/nodes/Node;I)V",
            "method_body": "public void tail(Node node, int depth) {\nif (!node.nodeName().equals(\"#text\")) { // saves a void hit.\ntry {\nnode.outerHtmlTail(accum, depth, out);\n} catch (IOException exception) {\nthrow new SerializationException(exception);\n}\n}\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.jsoup.nodes.Element$NodeList:<init>(Lorg/jsoup/nodes/Element;I)V",
            "method_body": "NodeList(Element owner, int initialCapacity) {\nsuper(initialCapacity);\nthis.owner = owner;\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:consumeTo(C)Ljava/lang/String;",
            "method_body": "public String consumeTo(char c) {\nint offset = nextIndexOf(c);\nif (offset != -1) {\nString consumed = cacheString(charBuf, stringCache, bufPos, offset);\nbufPos += offset;\nreturn consumed;\n} else {\nreturn consumeToEnd();\n}\n}",
            "method_id": 152
        },
        {
            "method_signature": "org.jsoup.parser.Token$EOF:reset()Lorg/jsoup/parser/Token;",
            "method_body": "Token reset() {\nreturn this;\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.jsoup.parser.TreeBuilder:<init>()V",
            "method_body": "CharacterReader reader;\nTokeniser tokeniser;\nprotected Document doc; // current doc we are building into\nprotected ArrayList<Element> stack; // the stack of open elements\nprotected String baseUri; // current base uri, for creating new elements\nprotected Token currentToken; // currentToken is used only for error tracking.\nprotected ParseErrorList errors; // null when not tracking errors\nprotected ParseSettings settings;\n\nprivate Token.StartTag start = new Token.StartTag(); // start tag to process\nprivate Token.EndTag end  = new Token.EndTag();\n\nabstract ParseSettings defaultSettings();\n\nprotected void initialiseParse(Reader input, String baseUri, ParseErrorList errors, ParseSettings settings) {\nValidate.notNull(input, \"String input must not be null\");\nValidate.notNull(baseUri, \"BaseURI must not be null\");\n\ndoc = new Document(baseUri);\nthis.settings = settings;\nreader = new CharacterReader(input);\nthis.errors = errors;\ncurrentToken = null;\ntokeniser = new Tokeniser(reader, errors);\nstack = new ArrayList<>(32);\nthis.baseUri = baseUri;\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:isBlank()Z",
            "method_body": "public boolean isBlank() {\nreturn StringUtil.isBlank(coreValue());\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.jsoup.parser.Tag:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn tagName;\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.jsoup.nodes.Element:childNodeSize()I",
            "method_body": "public int childNodeSize() {\nreturn childNodes.size();\n}",
            "method_id": 157
        },
        {
            "method_signature": "org.jsoup.nodes.Element:outerHtmlTail(Ljava/lang/Appendable;ILorg/jsoup/nodes/Document$OutputSettings;)V",
            "method_body": "void outerHtmlTail(Appendable accum, int depth, Document.OutputSettings out) throws IOException {\nif (!(childNodes.isEmpty() && tag.isSelfClosing())) {\nif (out.prettyPrint() && (!childNodes.isEmpty() && (\ntag.formatAsBlock() || (out.outline() && (childNodes.size()>1 || (childNodes.size()==1 && !(childNodes.get(0) instanceof TextNode))))\n)))\nindent(accum, depth, out);\naccum.append(\"</\").append(tagName()).append('>');\n}\n}",
            "method_id": 158
        },
        {
            "method_signature": "org.jsoup.parser.CharacterReader:advance()V",
            "method_body": "public void advance() {\nbufPos++;\n}",
            "method_id": 159
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Lorg/jsoup/parser/Token;)V",
            "method_body": "void emit(Token token) {\nValidate.isFalse(isEmitPending, \"There is an unread token pending!\");\n\nemitPending = token;\nisEmitPending = true;\n\nif (token.type == Token.TokenType.StartTag) {\nToken.StartTag startTag = (Token.StartTag) token;\nlastStartTag = startTag.tagName;\n} else if (token.type == Token.TokenType.EndTag) {\nToken.EndTag endTag = (Token.EndTag) token;\nif (endTag.attributes != null)\nerror(\"Attributes incorrectly present on end tag\");\n}\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.jsoup.parser.Parser:settings(Lorg/jsoup/parser/ParseSettings;)Lorg/jsoup/parser/Parser;",
            "method_body": "public Parser settings(ParseSettings settings) {\nthis.settings = settings;\nreturn this;\n}",
            "method_id": 161
        },
        {
            "method_signature": "org.jsoup.nodes.TextNode:<init>(Ljava/lang/String;)V",
            "method_body": "public TextNode(String text) {\nvalue = text;\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.jsoup.nodes.Node$OuterHtmlVisitor:head(Lorg/jsoup/nodes/Node;I)V",
            "method_body": "public void head(Node node, int depth) {\ntry {\nnode.outerHtmlHead(accum, depth, out);\n} catch (IOException exception) {\nthrow new SerializationException(exception);\n}\n}",
            "method_id": 163
        },
        {
            "method_signature": "org.jsoup.helper.ChangeNotifyingArrayList:add(Ljava/lang/Object;)Z",
            "method_body": "public boolean add(E e) {\nonContentsChanged();\nreturn super.add(e);\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.jsoup.parser.Tokeniser:emit(Ljava/lang/String;)V",
            "method_body": "void emit(final String str) {\n// buffer strings up until last string token found, to emit only one token for a run of character refs etc.\n// does not set isEmitPending; read checks that\nif (charsString == null) {\ncharsString = str;\n}\nelse {\nif (charsBuilder.length() == 0) { // switching to string builder as more than one emit before read\ncharsBuilder.append(charsString);\n}\ncharsBuilder.append(str);\n}\n}",
            "method_id": 165
        },
        {
            "method_signature": "org.jsoup.nodes.Element:appendChild(Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Element;",
            "method_body": "public Element appendChild(Node child) {\nValidate.notNull(child);\n\n// was - Node#addChildren(child). short-circuits an array create and a loop.\nreparentChild(child);\nensureChildNodes();\nchildNodes.add(child);\nchild.setSiblingIndex(childNodes.size() - 1);\nreturn this;\n}",
            "method_id": 166
        },
        {
            "method_signature": "org.jsoup.parser.Token$Doctype:<init>()V",
            "method_body": "final StringBuilder name = new StringBuilder();\nString pubSysKey = null;\nfinal StringBuilder publicIdentifier = new StringBuilder();\nfinal StringBuilder systemIdentifier = new StringBuilder();\nboolean forceQuirks = false;\n\nDoctype() {\ntype = TokenType.Doctype;\n}",
            "method_id": 167
        }
    ]
}