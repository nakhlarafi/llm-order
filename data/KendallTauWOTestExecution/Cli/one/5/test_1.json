{
    "bug_id": 5,
    "test_id": 1,
    "test_name": "org.apache.commons.cli.bug.BugCLI133Test.testOrder",
    "test_body": "public void testOrder() throws ParseException {\nOption optionA = new Option(\"a\", \"first\");\nOptions opts = new Options();\nopts.addOption(optionA);\nPosixParser posixParser = new PosixParser();\nCommandLine line = posixParser.parse(opts, null);\nassertFalse(line.hasOption(null));\n}\n",
    "stack_trace": "java.lang.NullPointerException\nat org.apache.commons.cli.Util.stripLeadingHyphens(Util.java:36)\nat org.apache.commons.cli.CommandLine.resolveOption(CommandLine.java:166)\nat org.apache.commons.cli.CommandLine.hasOption(CommandLine.java:68)\nat org.apache.commons.cli.bug.BugCLI133Test.testOrder(BugCLI133Test.java:32)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.cli.Util:stripLeadingHyphens(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "static String stripLeadingHyphens(String str)\n{\nif (str.startsWith(\"--\"))\n{\nreturn str.substring(2, str.length());\n}\nelse if (str.startsWith(\"-\"))\n{\nreturn str.substring(1, str.length());\n}\n\nreturn str;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;)V",
            "method_body": "public Option(String opt, String description)\nthrows IllegalArgumentException\n{\nthis(opt, null, false, description);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.cli.OptionValidator:validateOption(Ljava/lang/String;)V",
            "method_body": "static void validateOption(String opt)\nthrows IllegalArgumentException\n{\n// check that opt is not NULL\nif (opt == null)\n{\nreturn;\n}\n\n// handle the single character opt\nelse if (opt.length() == 1)\n{\nchar ch = opt.charAt(0);\n\nif (!isValidOpt(ch))\n{\nthrow new IllegalArgumentException(\"illegal option value '\" + ch\n+ \"'\");\n}\n}\n\n// handle the multi character opt\nelse\n{\nchar[] chars = opt.toCharArray();\n\nfor (int i = 0; i < chars.length; i++)\n{\nif (!isValidChar(chars[i]))\n{\nthrow new IllegalArgumentException(\n\"opt contains illegal character value '\" + chars[i]\n+ \"'\");\n}\n}\n}\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.cli.OptionValidator:isValidOpt(C)Z",
            "method_body": "private static boolean isValidOpt(char c)\n{\nreturn (isValidChar(c) || (c == ' ') || (c == '?') || c == '@');\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.cli.OptionValidator:isValidChar(C)Z",
            "method_body": "private static boolean isValidChar(char c)\n{\nreturn Character.isJavaIdentifierPart(c);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.cli.Options:<init>()V",
            "method_body": "public Options()\n{\n// nothing to do\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.cli.PosixParser:<init>()V",
            "method_body": "private ArrayList tokens = new ArrayList();\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.cli.CommandLine:hasOption(Ljava/lang/String;)Z",
            "method_body": "public boolean hasOption(String opt)\n{\nreturn options.contains( resolveOption(opt));\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.cli.CommandLine:resolveOption(Ljava/lang/String;)Lorg/apache/commons/cli/Option;",
            "method_body": "private Option resolveOption( String opt )\n{\nopt = Util.stripLeadingHyphens(opt);\nfor ( Iterator it = options.iterator(); it.hasNext(); )\n{\nOption option = (Option) it.next();\nif (opt.equals(option.getOpt()))\n{\nreturn option;\n}\nif (opt.equals( option.getLongOpt()))\n{\nreturn option;\n}\n\n}\nreturn null;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;)Lorg/apache/commons/cli/CommandLine;",
            "method_body": "public CommandLine parse(Options options, String[] arguments)\nthrows ParseException\n{\nreturn parse(options, arguments, null, false);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.cli.Parser:parse(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Ljava/util/Properties;Z)Lorg/apache/commons/cli/CommandLine;",
            "method_body": "public CommandLine parse(Options options, String[] arguments,\nProperties properties, boolean stopAtNonOption)\nthrows ParseException\n{\n// initialise members\nthis.options = options;\n\n// clear out the data in options in case it's been used before (CLI-71)\nfor (Iterator it = options.helpOptions().iterator(); it.hasNext();) {\nOption opt = (Option) it.next();\nopt.clearValues();\n}\n\nrequiredOptions = options.getRequiredOptions();\ncmd = new CommandLine();\n\nboolean eatTheRest = false;\n\nif (arguments == null)\n{\narguments = new String[0];\n}\n\nList tokenList = Arrays.asList(flatten(this.options,\narguments,\nstopAtNonOption));\n\nListIterator iterator = tokenList.listIterator();\n\n// process each flattened token\nwhile (iterator.hasNext())\n{\nString t = (String) iterator.next();\n\n// the value is the double-dash\nif (\"--\".equals(t))\n{\neatTheRest = true;\n}\n\n// the value is a single dash\nelse if (\"-\".equals(t))\n{\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\nelse\n{\ncmd.addArg(t);\n}\n}\n\n// the value is an option\nelse if (t.startsWith(\"-\"))\n{\nif (stopAtNonOption && !options.hasOption(t))\n{\neatTheRest = true;\ncmd.addArg(t);\n}\nelse\n{\nprocessOption(t, iterator);\n}\n}\n\n// the value is an argument\nelse\n{\ncmd.addArg(t);\n\nif (stopAtNonOption)\n{\neatTheRest = true;\n}\n}\n\n// eat the remaining tokens\nif (eatTheRest)\n{\nwhile (iterator.hasNext())\n{\nString str = (String) iterator.next();\n\n// ensure only one double-dash is added\nif (!\"--\".equals(str))\n{\ncmd.addArg(str);\n}\n}\n}\n}\n\nprocessProperties(properties);\ncheckRequiredOptions();\n\nreturn cmd;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.cli.Parser:processProperties(Ljava/util/Properties;)V",
            "method_body": "private void processProperties(Properties properties)\n{\nif (properties == null)\n{\nreturn;\n}\n\nfor (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n{\nString option = e.nextElement().toString();\n\nif (!cmd.hasOption(option))\n{\nOption opt = options.getOption(option);\n\n// get the value from the properties instance\nString value = properties.getProperty(option);\n\nif (opt.hasArg())\n{\nif ((opt.getValues() == null)\n|| (opt.getValues().length == 0))\n{\ntry\n{\nopt.addValue(value);\n}\ncatch (RuntimeException exp)\n{\n// if we cannot add the value don't worry about it\n}\n}\n}\nelse if (!(\"yes\".equalsIgnoreCase(value)\n|| \"true\".equalsIgnoreCase(value)\n|| \"1\".equalsIgnoreCase(value)))\n{\n// if the value is not yes, true or 1 then don't add the\n// option to the CommandLine\nbreak;\n}\n\ncmd.addOption(opt);\n}\n}\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.cli.Parser:checkRequiredOptions()V",
            "method_body": "private void checkRequiredOptions()\nthrows MissingOptionException\n{\n// if there are required options that have not been\n// processsed\nif (requiredOptions.size() > 0)\n{\nIterator iter = requiredOptions.iterator();\nStringBuffer buff = new StringBuffer(\"Missing required option\");\nbuff.append(requiredOptions.size() == 1 ? \"\" : \"s\");\nbuff.append(\": \");\n\n\n// loop through the required options\nwhile (iter.hasNext())\n{\nbuff.append(iter.next());\n}\n\nthrow new MissingOptionException(buff.toString());\n}\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.cli.PosixParser:init()V",
            "method_body": "private void init()\n{\neatTheRest = false;\ntokens.clear();\ncurrentOption = null;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.cli.PosixParser:flatten(Lorg/apache/commons/cli/Options;[Ljava/lang/String;Z)[Ljava/lang/String;",
            "method_body": "protected String[] flatten(Options options, String[] arguments,\nboolean stopAtNonOption)\n{\ninit();\nthis.options = options;\n\n// an iterator for the command line tokens\nIterator iter = Arrays.asList(arguments).iterator();\nString token;\n\n// process each command line token\nwhile (iter.hasNext())\n{\n// get the next command line token\ntoken = (String) iter.next();\n\n// handle SPECIAL TOKEN\nif (token.startsWith(\"--\"))\n{\nif (token.indexOf('=') != -1)\n{\ntokens.add(token.substring(0, token.indexOf('=')));\ntokens.add(token.substring(token.indexOf('=') + 1,\ntoken.length()));\n}\nelse\n{\ntokens.add(token);\n}\n}\n\n// single hyphen\nelse if (\"-\".equals(token))\n{\nprocessSingleHyphen(token);\n}\nelse if (token.startsWith(\"-\"))\n{\nint tokenLength = token.length();\n\nif (tokenLength == 2)\n{\nprocessOptionToken(token, stopAtNonOption);\n}\nelse if (options.hasOption(token)) {\ntokens.add(token);\n}\n// requires bursting\nelse\n{\nburstToken(token, stopAtNonOption);\n}\n}\nelse\n{\nif (stopAtNonOption)\n{\nprocess(token);\n}\nelse\n{\ntokens.add(token);\n}\n}\n\ngobble(iter);\n}\n\nreturn (String[]) tokens.toArray(new String[tokens.size()]);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.cli.Options:addOption(Lorg/apache/commons/cli/Option;)Lorg/apache/commons/cli/Options;",
            "method_body": "public Options addOption(Option opt)\n{\nString key = opt.getKey();\n\n// add it to the long option list\nif (opt.hasLongOpt())\n{\nlongOpts.put(opt.getLongOpt(), opt);\n}\n\n// if the option is required add it to the required list\nif (opt.isRequired() )\n{\nif( requiredOpts.contains(key) ) {\nrequiredOpts.remove( requiredOpts.indexOf(key) );\n}\nrequiredOpts.add(key);\n}\n\nshortOpts.put(key, opt);\n\nreturn this;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.cli.Options:helpOptions()Ljava/util/List;",
            "method_body": "List helpOptions()\n{\nList opts = new ArrayList(shortOpts.values());\n\n// now look through the long opts to see if there are any Long-opt\n// only options\nIterator iter = longOpts.values().iterator();\n\nwhile (iter.hasNext())\n{\nObject item = iter.next();\n\nif (!opts.contains(item))\n{\nopts.add(item);\n}\n}\n\nreturn new ArrayList(opts);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.cli.Options:getRequiredOptions()Ljava/util/List;",
            "method_body": "public List getRequiredOptions()\n{\nreturn requiredOpts;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.cli.Option:<init>(Ljava/lang/String;Ljava/lang/String;ZLjava/lang/String;)V",
            "method_body": "public Option(String opt, String longOpt, boolean hasArg,\nString description)\nthrows IllegalArgumentException\n{\n// ensure that the option is valid\nOptionValidator.validateOption(opt);\n\nthis.opt = opt;\nthis.longOpt = longOpt;\n\n// if hasArg is set then the number of arguments is 1\nif (hasArg)\n{\nthis.numberOfArgs = 1;\n}\n\nthis.hasArg = hasArg;\nthis.description = description;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.cli.Option:getKey()Ljava/lang/String;",
            "method_body": "String getKey()\n{\n// if 'opt' is null, then it is a 'long' option\nif (opt == null)\n{\nreturn this.longOpt;\n}\n\nreturn this.opt;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.cli.Option:hasLongOpt()Z",
            "method_body": "public boolean hasLongOpt()\n{\nreturn (this.longOpt != null);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.cli.Option:isRequired()Z",
            "method_body": "public boolean isRequired()\n{\nreturn this.required;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.cli.Option:clearValues()V",
            "method_body": "void clearValues() {\nthis.values.clear();\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.cli.CommandLine:<init>()V",
            "method_body": "CommandLine()\n{\n// nothing to do\n}",
            "method_id": 23
        }
    ]
}