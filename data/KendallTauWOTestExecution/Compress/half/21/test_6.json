{
    "bug_id": 21,
    "test_id": 6,
    "test_name": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFileTest.testNineEmptyFiles",
    "test_body": "public void testNineEmptyFiles() throws Exception {\ntestCompress252(9, 0);\n}\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
            "method_body": "public void putArchiveEntry(final ArchiveEntry archiveEntry) throws IOException {\nfinal SevenZArchiveEntry entry = (SevenZArchiveEntry) archiveEntry;\nfiles.add(entry);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn name;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readBits(Ljava/io/DataInput;I)Ljava/util/BitSet;",
            "method_body": "private BitSet readBits(final DataInput header, final int size) throws IOException {\nfinal BitSet bits = new BitSet(size);\nint mask = 0;\nint cache = 0;\nfor (int i = 0; i < size; i++) {\nif (mask == 0) {\nmask = 0x80;\ncache = header.readUnsignedByte();\n}\nbits.set(i, (cache & mask) != 0);\nmask >>>= 1;\n}\nreturn bits;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStartHeader(J)Lorg/apache/commons/compress/archivers/sevenz/StartHeader;",
            "method_body": "private StartHeader readStartHeader(final long startHeaderCrc) throws IOException {\nfinal StartHeader startHeader = new StartHeader();\nDataInputStream dataInputStream = null;\ntry {\ndataInputStream = new DataInputStream(new CRC32VerifyingInputStream(\nnew BoundedRandomAccessFileInputStream(file, 20), 20, startHeaderCrc));\nstartHeader.nextHeaderOffset = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderSize = Long.reverseBytes(dataInputStream.readLong());\nstartHeader.nextHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(dataInputStream.readInt());\nreturn startHeader;\n} finally {\nif (dataInputStream != null) {\ndataInputStream.close();\n}\n}\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(Ljava/util/Date;)V",
            "method_body": "public void setLastModifiedDate(Date lastModifiedDate) {\nhasLastModifiedDate = lastModifiedDate != null;\nif (hasLastModifiedDate) {\nthis.lastModifiedDate = javaTimeToNtfsTime(lastModifiedDate);\n}\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:close()V",
            "method_body": "public void close() throws IOException {\nin.close();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:ntfsTimeToJavaTime(J)Ljava/util/Date;",
            "method_body": "public static Date ntfsTimeToJavaTime(final long ntfsTime) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nfinal long realTime = ntfsEpoch.getTimeInMillis() + (ntfsTime / (10*1000));\nreturn new Date(realTime);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isAntiItem()Z",
            "method_body": "public boolean isAntiItem() {\nreturn isAntiItem;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
            "method_body": "private void readStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nint nid = header.readUnsignedByte();\n\nif (nid == NID.kPackInfo) {\nreadPackInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid == NID.kUnpackInfo) {\nreadUnpackInfo(header, archive);\nnid = header.readUnsignedByte();\n} else {\n// archive without unpack/coders info\narchive.folders = new Folder[0];\n}\n\nif (nid == NID.kSubStreamsInfo) {\nreadSubStreamsInfo(header, archive);\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated StreamsInfo\");\n}\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyStreams(Ljava/io/DataOutput;)V",
            "method_body": "private void writeFileEmptyStreams(final DataOutput header) throws IOException {\nboolean hasEmptyStreams = false;\nfor (final SevenZArchiveEntry entry : files) {\nif (!entry.hasStream()) {\nhasEmptyStreams = true;\nbreak;\n}\n}\nif (hasEmptyStreams) {\nheader.write(NID.kEmptyStream);\nfinal BitSet emptyStreams = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nemptyStreams.set(i, !files.get(i).hasStream());\n}\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyStreams, files.size());\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:javaTimeToNtfsTime(Ljava/util/Date;)J",
            "method_body": "public static long javaTimeToNtfsTime(final Date date) {\nfinal Calendar ntfsEpoch = Calendar.getInstance();\nntfsEpoch.setTimeZone(TimeZone.getTimeZone(\"GMT+0\"));\nntfsEpoch.set(1601, 0, 1, 0, 0, 0);\nntfsEpoch.set(Calendar.MILLISECOND, 0);\nreturn ((date.getTime() - ntfsEpoch.getTimeInMillis())* 1000 * 10);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setAntiItem(Z)V",
            "method_body": "public void setAntiItem(boolean isAntiItem) {\nthis.isAntiItem = isAntiItem;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileEmptyFiles(Ljava/io/DataOutput;)V",
            "method_body": "private void writeFileEmptyFiles(final DataOutput header) throws IOException {\nboolean hasEmptyFiles = false;\nint emptyStreamCounter = 0;\nfinal BitSet emptyFiles = new BitSet(0);\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isDir = files.get(i).isDirectory();\nemptyFiles.set(emptyStreamCounter++, !isDir);\nhasEmptyFiles |= !isDir;\n}\n}\nif (hasEmptyFiles) {\nheader.write(NID.kEmptyFile);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, emptyFiles, emptyStreamCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:<init>()V",
            "method_body": "public SevenZArchiveEntry() {\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasLastModifiedDate(Z)V",
            "method_body": "public void setHasLastModifiedDate(boolean hasLastModifiedDate) {\nthis.hasLastModifiedDate = hasLastModifiedDate;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasAccessDate()Z",
            "method_body": "public boolean getHasAccessDate() {\nreturn hasAccessDate;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([BII)V",
            "method_body": "public void write(final byte[] b, final int off, final int len) throws IOException {\nif (len > 0) {\ngetCurrentOutputStream().write(b, off, len);\n}\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<clinit>()V",
            "method_body": "static final int SIGNATURE_HEADER_SIZE = 32;\n\nprivate static final int DRAIN_BUF_SIZE = 64 * 1024;\n\nprivate RandomAccessFile file;\nprivate final Archive archive;\nprivate int currentEntryIndex = -1;\nprivate int currentFolderIndex = -1;\nprivate InputStream currentFolderInputStream = null;\nprivate InputStream currentEntryInputStream = null;\nprivate byte[] password;\n\nstatic final byte[] sevenZSignature = {\n(byte)'7', (byte)'z', (byte)0xBC, (byte)0xAF, (byte)0x27, (byte)0x1C\n};",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeUint64(Ljava/io/DataOutput;J)V",
            "method_body": "private void writeUint64(final DataOutput header, long value) throws IOException {\nint firstByte = 0;\nint mask = 0x80;\nint i;\nfor (i = 0; i < 8; i++) {\nif (value < ((1L << ( 7  * (i + 1))))) {\nfirstByte |= (value >>> (8 * i));\nbreak;\n}\nfirstByte |= mask;\nmask >>>= 1;\n}\nheader.write(firstByte);\nfor (; i > 0; i--) {\nheader.write((int) (0xff & value));\nvalue >>>= 8;\n}\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:write([B)V",
            "method_body": "public void write(final byte[] b) throws IOException {\nwrite(b, 0, b.length);\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.compress.utils.CRC32VerifyingInputStream:<init>(Ljava/io/InputStream;JJ)V",
            "method_body": "public CRC32VerifyingInputStream(final InputStream in, final long size, final long expectedCrc32) {\nsuper(new CRC32(), in, size, expectedCrc32);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read()I",
            "method_body": "public int read() throws IOException {\nif (bytesRemaining <= 0) {\nreturn -1;\n}\nint ret = in.read();\nif (ret >= 0) {\nchecksum.update(ret);\n--bytesRemaining;\n}\nif (bytesRemaining == 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readHeaders([B)Lorg/apache/commons/compress/archivers/sevenz/Archive;",
            "method_body": "private Archive readHeaders(byte[] password) throws IOException {\nfinal byte[] signature = new byte[6];\nfile.readFully(signature);\nif (!Arrays.equals(signature, sevenZSignature)) {\nthrow new IOException(\"Bad 7z signature\");\n}\n// 7zFormat.txt has it wrong - it's first major then minor\nfinal byte archiveVersionMajor = file.readByte();\nfinal byte archiveVersionMinor = file.readByte();\nif (archiveVersionMajor != 0) {\nthrow new IOException(String.format(\"Unsupported 7z version (%d,%d)\",\narchiveVersionMajor, archiveVersionMinor));\n}\n\nfinal long startHeaderCrc = 0xffffFFFFL & Integer.reverseBytes(file.readInt());\nfinal StartHeader startHeader = readStartHeader(startHeaderCrc);\n\nfinal int nextHeaderSizeInt = (int) startHeader.nextHeaderSize;\nif (nextHeaderSizeInt != startHeader.nextHeaderSize) {\nthrow new IOException(\"cannot handle nextHeaderSize \" + startHeader.nextHeaderSize);\n}\nfile.seek(SIGNATURE_HEADER_SIZE + startHeader.nextHeaderOffset);\nfinal byte[] nextHeader = new byte[nextHeaderSizeInt];\nfile.readFully(nextHeader);\nfinal CRC32 crc = new CRC32();\ncrc.update(nextHeader);\nif (startHeader.nextHeaderCrc != crc.getValue()) {\nthrow new IOException(\"NextHeader CRC mismatch\");\n}\n\nfinal ByteArrayInputStream byteStream = new ByteArrayInputStream(nextHeader);\nDataInputStream nextHeaderInputStream = new DataInputStream(\nbyteStream);\nArchive archive = new Archive();\nint nid = nextHeaderInputStream.readUnsignedByte();\nif (nid == NID.kEncodedHeader) {\nnextHeaderInputStream =\nreadEncodedHeader(nextHeaderInputStream, archive, password);\n// Archive gets rebuilt with the new header\narchive = new Archive();\nnid = nextHeaderInputStream.readUnsignedByte();\n}\nif (nid == NID.kHeader) {\nreadHeader(nextHeaderInputStream, archive);\nnextHeaderInputStream.close();\n} else {\nthrow new IOException(\"Broken or unsupported archive: no Header\");\n}\nreturn archive;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:close()V",
            "method_body": "public void close() {\n// the nested RandomAccessFile is controlled externally\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeStreamsInfo(Ljava/io/DataOutput;)V",
            "method_body": "private void writeStreamsInfo(final DataOutput header) throws IOException {\nif (numNonEmptyStreams > 0) {\nwritePackInfo(header);\nwriteUnpackInfo(header);\n}\n\nwriteSubStreamsInfo(header);\n\nheader.write(NID.kEnd);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:read([BII)I",
            "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nint ret = in.read(b, off, len);\nif (ret >= 0) {\nchecksum.update(b, off, ret);\nbytesRemaining -= ret;\n}\nif (bytesRemaining <= 0 && expectedChecksum != checksum.getValue()) {\nthrow new IOException(\"Checksum verification failed\");\n}\nreturn ret;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileATimes(Ljava/io/DataOutput;)V",
            "method_body": "private void writeFileATimes(final DataOutput header) throws IOException {\nint numAccessDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\n++numAccessDates;\n}\n}\nif (numAccessDates > 0) {\nheader.write(NID.kATime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numAccessDates != files.size()) {\nout.write(0);\nfinal BitSet aTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\naTimes.set(i, files.get(i).getHasAccessDate());\n}\nwriteBits(out, aTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasAccessDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getAccessDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setDirectory(Z)V",
            "method_body": "public void setDirectory(boolean isDirectory) {\nthis.isDirectory = isDirectory;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.utils.ChecksumVerifyingInputStream:<init>(Ljava/util/zip/Checksum;Ljava/io/InputStream;JJ)V",
            "method_body": "public ChecksumVerifyingInputStream(final Checksum checksum, final InputStream in,\nfinal long size, final long expectedChecksum) {\nthis.checksum = checksum;\nthis.in = in;\nthis.expectedChecksum = expectedChecksum;\nthis.bytesRemaining = size;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZMethod:<init>(Ljava/lang/String;I[B)V",
            "method_body": "private SevenZMethod(byte[] id) {\nthis.id = id;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeSubStreamsInfo(Ljava/io/DataOutput;)V",
            "method_body": "private void writeSubStreamsInfo(final DataOutput header) throws IOException {\nheader.write(NID.kSubStreamsInfo);\n//\n//        header.write(NID.kCRC);\n//        header.write(1);\n//        for (final SevenZArchiveEntry entry : files) {\n//            if (entry.getHasCrc()) {\n//                header.writeInt(Integer.reverseBytes(entry.getCrc()));\n//            }\n//        }\n//\nheader.write(NID.kEnd);\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:close()V",
            "method_body": "public void close() throws IOException {\nif (!finished) {\nfinish();\n}\nfile.close();\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasLastModifiedDate()Z",
            "method_body": "public boolean getHasLastModifiedDate() {\nreturn hasLastModifiedDate;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readUint64(Ljava/io/DataInput;)J",
            "method_body": "private static long readUint64(final DataInput in) throws IOException {\n// long rather than int as it might get shifted beyond the range of an int\nlong firstByte = in.readUnsignedByte();\nint mask = 0x80;\nlong value = 0;\nfor (int i = 0; i < 8; i++) {\nif ((firstByte & mask) == 0) {\nreturn value | ((firstByte & (mask - 1)) << (8 * i));\n}\nlong nextByte = in.readUnsignedByte();\nvalue |= (nextByte << (8 * i));\nmask >>>= 1;\n}\nreturn value;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasStream(Z)V",
            "method_body": "public void setHasStream(boolean hasStream) {\nthis.hasStream = hasStream;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read()I",
            "method_body": "public int read() throws IOException {\nif (bytesRemaining > 0) {\n--bytesRemaining;\nreturn file.read();\n} else {\nreturn -1;\n}\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileCTimes(Ljava/io/DataOutput;)V",
            "method_body": "private void writeFileCTimes(final DataOutput header) throws IOException {\nint numCreationDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\n++numCreationDates;\n}\n}\nif (numCreationDates > 0) {\nheader.write(NID.kCTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numCreationDates != files.size()) {\nout.write(0);\nfinal BitSet cTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\ncTimes.set(i, files.get(i).getHasCreationDate());\n}\nwriteBits(out, cTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasCreationDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getCreationDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileNames(Ljava/io/DataOutput;)V",
            "method_body": "private void writeFileNames(final DataOutput header) throws IOException {\nheader.write(NID.kName);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nout.write(entry.getName().getBytes(\"UTF-16LE\"));\nout.writeShort(0);\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:hasStream()Z",
            "method_body": "public boolean hasStream() {\nreturn hasStream;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:<init>(Ljava/io/File;)V",
            "method_body": "public SevenZOutputFile(final File filename) throws IOException {\nfile = new RandomAccessFile(filename, \"rw\");\nfile.seek(SevenZFile.SIGNATURE_HEADER_SIZE);\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readSubStreamsInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
            "method_body": "private void readSubStreamsInfo(final DataInput header, final Archive archive) throws IOException {\nfor (final Folder folder : archive.folders) {\nfolder.numUnpackSubStreams = 1;\n}\nint totalUnpackStreams = archive.folders.length;\n\nint nid = header.readUnsignedByte();\nif (nid == NID.kNumUnpackStream) {\ntotalUnpackStreams = 0;\nfor (final Folder folder : archive.folders) {\nfinal long numStreams = readUint64(header);\nfolder.numUnpackSubStreams = (int)numStreams;\ntotalUnpackStreams += numStreams;\n}\nnid = header.readUnsignedByte();\n}\n\nfinal SubStreamsInfo subStreamsInfo = new SubStreamsInfo();\nsubStreamsInfo.unpackSizes = new long[totalUnpackStreams];\nsubStreamsInfo.hasCrc = new BitSet(totalUnpackStreams);\nsubStreamsInfo.crcs = new long[totalUnpackStreams];\n\nint nextUnpackStream = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams == 0) {\ncontinue;\n}\nlong sum = 0;\nif (nid == NID.kSize) {\nfor (int i = 0; i < (folder.numUnpackSubStreams - 1); i++) {\nfinal long size = readUint64(header);\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = size;\nsum += size;\n}\n}\nsubStreamsInfo.unpackSizes[nextUnpackStream++] = folder.getUnpackSize() - sum;\n}\nif (nid == NID.kSize) {\nnid = header.readUnsignedByte();\n}\n\nint numDigests = 0;\nfor (final Folder folder : archive.folders) {\nif (folder.numUnpackSubStreams != 1 || !folder.hasCrc) {\nnumDigests += folder.numUnpackSubStreams;\n}\n}\n\nif (nid == NID.kCRC) {\nfinal BitSet hasMissingCrc = readAllOrBits(header, numDigests);\nfinal long[] missingCrcs = new long[numDigests];\nfor (int i = 0; i < numDigests; i++) {\nif (hasMissingCrc.get(i)) {\nmissingCrcs[i] = 0xffffFFFFL & Integer.reverseBytes(header.readInt());\n}\n}\nint nextCrc = 0;\nint nextMissingCrc = 0;\nfor (final Folder folder: archive.folders) {\nif (folder.numUnpackSubStreams == 1 && folder.hasCrc) {\nsubStreamsInfo.hasCrc.set(nextCrc, true);\nsubStreamsInfo.crcs[nextCrc] = folder.crc;\n++nextCrc;\n} else {\nfor (int i = 0; i < folder.numUnpackSubStreams; i++) {\nsubStreamsInfo.hasCrc.set(nextCrc, hasMissingCrc.get(nextMissingCrc));\nsubStreamsInfo.crcs[nextCrc] = missingCrcs[nextMissingCrc];\n++nextCrc;\n++nextMissingCrc;\n}\n}\n}\n\nnid = header.readUnsignedByte();\n}\n\nif (nid != NID.kEnd) {\nthrow new IOException(\"Badly terminated SubStreamsInfo\");\n}\n\narchive.subStreamsInfo = subStreamsInfo;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileAntiItems(Ljava/io/DataOutput;)V",
            "method_body": "private void writeFileAntiItems(final DataOutput header) throws IOException {\nboolean hasAntiItems = false;\nfinal BitSet antiItems = new BitSet(0);\nint antiItemCounter = 0;\nfor (int i = 0; i < files.size(); i++) {\nif (!files.get(i).hasStream()) {\nboolean isAnti = files.get(i).isAntiItem();\nantiItems.set(antiItemCounter++, isAnti);\nhasAntiItems |= isAnti;\n}\n}\nif (hasAntiItems) {\nheader.write(NID.kAnti);\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nwriteBits(out, antiItems, antiItemCounter);\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasWindowsAttributes()Z",
            "method_body": "public boolean getHasWindowsAttributes() {\nreturn hasWindowsAttributes;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeBits(Ljava/io/DataOutput;Ljava/util/BitSet;I)V",
            "method_body": "private void writeBits(final DataOutput header, final BitSet bits, final int length) throws IOException {\nint cache = 0;\nint shift = 7;\nfor (int i = 0; i < length; i++) {\ncache |= ((bits.get(i) ? 1 : 0) << shift);\n--shift;\nif (shift == 0) {\nheader.write(cache);\nshift = 7;\ncache = 0;\n}\n}\nif (length > 0 && shift > 0) {\nheader.write(cache);\n}\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getLastModifiedDate()Ljava/util/Date;",
            "method_body": "public Date getLastModifiedDate() {\nif (hasLastModifiedDate) {\nreturn ntfsTimeToJavaTime(lastModifiedDate);\n} else {\nthrow new UnsupportedOperationException(\n\"The entry doesn't have this timestamp\");\n}\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:isDirectory()Z",
            "method_body": "public boolean isDirectory() {\nreturn isDirectory;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setCompressedSize(J)V",
            "method_body": "void setCompressedSize(long size) {\nthis.compressedSize = size;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFilesInfo(Ljava/io/DataOutput;)V",
            "method_body": "private void writeFilesInfo(final DataOutput header) throws IOException {\nheader.write(NID.kFilesInfo);\n\nwriteUint64(header, files.size());\n\nwriteFileEmptyStreams(header);\nwriteFileEmptyFiles(header);\nwriteFileAntiItems(header);\nwriteFileNames(header);\nwriteFileCTimes(header);\nwriteFileATimes(header);\nwriteFileMTimes(header);\nwriteFileWindowsAttributes(header);\nheader.write(0);\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setHasCrc(Z)V",
            "method_body": "public void setHasCrc(boolean hasCrc) {\nthis.hasCrc = hasCrc;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setSize(J)V",
            "method_body": "public void setSize(long size) {\nthis.size = size;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:readFilesInfo(Ljava/io/DataInput;Lorg/apache/commons/compress/archivers/sevenz/Archive;)V",
            "method_body": "private void readFilesInfo(final DataInput header, final Archive archive) throws IOException {\nfinal long numFiles = readUint64(header);\nfinal SevenZArchiveEntry[] files = new SevenZArchiveEntry[(int)numFiles];\nfor (int i = 0; i < files.length; i++) {\nfiles[i] = new SevenZArchiveEntry();\n}\nBitSet isEmptyStream = null;\nBitSet isEmptyFile = null;\nBitSet isAnti = null;\nwhile (true) {\nfinal int propertyType = header.readUnsignedByte();\nif (propertyType == 0) {\nbreak;\n}\nlong size = readUint64(header);\nswitch (propertyType) {\ncase NID.kEmptyStream: {\nisEmptyStream = readBits(header, files.length);\nbreak;\n}\ncase NID.kEmptyFile: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kEmptyFile\");\n}\nisEmptyFile = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kAnti: {\nif (isEmptyStream == null) { // protect against NPE\nthrow new IOException(\"Header format error: kEmptyStream must appear before kAnti\");\n}\nisAnti = readBits(header, isEmptyStream.cardinality());\nbreak;\n}\ncase NID.kName: {\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Not implemented\");\n} else {\nif (((size - 1) & 1) != 0) {\nthrow new IOException(\"File names length invalid\");\n}\nfinal byte[] names = new byte[(int)(size - 1)];\nheader.readFully(names);\nint nextFile = 0;\nint nextName = 0;\nfor (int i = 0; i < names.length; i += 2) {\nif (names[i] == 0 && names[i+1] == 0) {\nfiles[nextFile++].setName(new String(names, nextName, i-nextName, CharsetNames.UTF_16LE));\nnextName = i + 2;\n}\n}\nif (nextName != names.length || nextFile != files.length) {\nthrow new IOException(\"Error parsing file names\");\n}\n}\nbreak;\n}\ncase NID.kCTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasCreationDate(timesDefined.get(i));\nif (files[i].getHasCreationDate()) {\nfiles[i].setCreationDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kATime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasAccessDate(timesDefined.get(i));\nif (files[i].getHasAccessDate()) {\nfiles[i].setAccessDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kMTime: {\nfinal BitSet timesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasLastModifiedDate(timesDefined.get(i));\nif (files[i].getHasLastModifiedDate()) {\nfiles[i].setLastModifiedDate(Long.reverseBytes(header.readLong()));\n}\n}\n}\nbreak;\n}\ncase NID.kWinAttributes: {\nfinal BitSet attributesDefined = readAllOrBits(header, files.length);\nfinal int external = header.readUnsignedByte();\nif (external != 0) {\nthrow new IOException(\"Unimplemented\");\n} else {\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasWindowsAttributes(attributesDefined.get(i));\nif (files[i].getHasWindowsAttributes()) {\nfiles[i].setWindowsAttributes(Integer.reverseBytes(header.readInt()));\n}\n}\n}\nbreak;\n}\ncase NID.kStartPos: {\nthrow new IOException(\"kStartPos is unsupported, please report\");\n}\ncase NID.kDummy: {\nthrow new IOException(\"kDummy is unsupported, please report\");\n}\n\ndefault: {\nthrow new IOException(\"Unknown property \" + propertyType);\n// FIXME: Should actually:\n//header.skipBytes((int)size);\n}\n}\n}\nint nonEmptyFileCounter = 0;\nint emptyFileCounter = 0;\nfor (int i = 0; i < files.length; i++) {\nfiles[i].setHasStream((isEmptyStream == null) ? true : !isEmptyStream.get(i));\nif (files[i].hasStream()) {\nfiles[i].setDirectory(false);\nfiles[i].setAntiItem(false);\nfiles[i].setHasCrc(archive.subStreamsInfo.hasCrc.get(nonEmptyFileCounter));\nfiles[i].setCrcValue(archive.subStreamsInfo.crcs[nonEmptyFileCounter]);\nfiles[i].setSize(archive.subStreamsInfo.unpackSizes[nonEmptyFileCounter]);\n++nonEmptyFileCounter;\n} else {\nfiles[i].setDirectory((isEmptyFile == null) ? true : !isEmptyFile.get(emptyFileCounter));\nfiles[i].setAntiItem((isAnti == null) ? false : isAnti.get(emptyFileCounter));\nfiles[i].setHasCrc(false);\nfiles[i].setSize(0);\n++emptyFileCounter;\n}\n}\narchive.files = files;\ncalculateStreamMap(archive);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:getHasCreationDate()Z",
            "method_body": "public boolean getHasCreationDate() {\nreturn hasCreationDate;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:finish()V",
            "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\nfinished = true;\n\nfinal long headerPosition = file.getFilePointer();\n\nfinal ByteArrayOutputStream headerBaos = new ByteArrayOutputStream();\nfinal DataOutputStream header = new DataOutputStream(headerBaos);\n\nwriteHeader(header);\nheader.flush();\nfinal byte[] headerBytes = headerBaos.toByteArray();\nfile.write(headerBytes);\n\nfinal CRC32 crc32 = new CRC32();\n\n// signature header\nfile.seek(0);\nfile.write(SevenZFile.sevenZSignature);\n// version\nfile.write(0);\nfile.write(2);\n\n// start header\nfinal ByteArrayOutputStream startHeaderBaos = new ByteArrayOutputStream();\nfinal DataOutputStream startHeaderStream = new DataOutputStream(startHeaderBaos);\nstartHeaderStream.writeLong(Long.reverseBytes(headerPosition - SevenZFile.SIGNATURE_HEADER_SIZE));\nstartHeaderStream.writeLong(Long.reverseBytes(0xffffFFFFL & headerBytes.length));\ncrc32.reset();\ncrc32.update(headerBytes);\nstartHeaderStream.writeInt(Integer.reverseBytes((int)crc32.getValue()));\nstartHeaderStream.flush();\nfinal byte[] startHeaderBytes = startHeaderBaos.toByteArray();\ncrc32.reset();\ncrc32.update(startHeaderBytes);\nfile.writeInt(Integer.reverseBytes((int) crc32.getValue()));\nfile.write(startHeaderBytes);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileMTimes(Ljava/io/DataOutput;)V",
            "method_body": "private void writeFileMTimes(final DataOutput header) throws IOException {\nint numLastModifiedDates = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\n++numLastModifiedDates;\n}\n}\nif (numLastModifiedDates > 0) {\nheader.write(NID.kMTime);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numLastModifiedDates != files.size()) {\nout.write(0);\nfinal BitSet mTimes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nmTimes.set(i, files.get(i).getHasLastModifiedDate());\n}\nwriteBits(out, mTimes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasLastModifiedDate()) {\nout.writeLong(Long.reverseBytes(\nSevenZArchiveEntry.javaTimeToNtfsTime(entry.getLastModifiedDate())));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;)V",
            "method_body": "public SevenZFile(final File filename) throws IOException {\nthis(filename, null);\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZFile:<init>(Ljava/io/File;[B)V",
            "method_body": "public SevenZFile(final File filename, final byte[] password) throws IOException {\nboolean succeeded = false;\nthis.file = new RandomAccessFile(filename, \"r\");\ntry {\narchive = readHeaders(password);\nif (password != null) {\nthis.password = new byte[password.length];\nSystem.arraycopy(password, 0, this.password, 0, password.length);\n} else {\nthis.password = null;\n}\nsucceeded = true;\n} finally {\nif (!succeeded) {\nthis.file.close();\n}\n}\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setName(Ljava/lang/String;)V",
            "method_body": "public void setName(String name) {\nthis.name = name;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeFileWindowsAttributes(Ljava/io/DataOutput;)V",
            "method_body": "private void writeFileWindowsAttributes(final DataOutput header) throws IOException {\nint numWindowsAttributes = 0;\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\n++numWindowsAttributes;\n}\n}\nif (numWindowsAttributes > 0) {\nheader.write(NID.kWinAttributes);\n\nfinal ByteArrayOutputStream baos = new ByteArrayOutputStream();\nfinal DataOutputStream out = new DataOutputStream(baos);\nif (numWindowsAttributes != files.size()) {\nout.write(0);\nfinal BitSet attributes = new BitSet(files.size());\nfor (int i = 0; i < files.size(); i++) {\nattributes.set(i, files.get(i).getHasWindowsAttributes());\n}\nwriteBits(out, attributes, files.size());\n} else {\nout.write(1);\n}\nout.write(0);\nfor (final SevenZArchiveEntry entry : files) {\nif (entry.getHasWindowsAttributes()) {\nout.writeInt(Integer.reverseBytes(entry.getWindowsAttributes()));\n}\n}\nout.flush();\nfinal byte[] contents = baos.toByteArray();\nwriteUint64(header, contents.length);\nheader.write(contents);\n}\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:writeHeader(Ljava/io/DataOutput;)V",
            "method_body": "private void writeHeader(final DataOutput header) throws IOException {\nheader.write(NID.kHeader);\n\nheader.write(NID.kMainStreamsInfo);\nwriteStreamsInfo(header);\nwriteFilesInfo(header);\nheader.write(NID.kEnd);\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:createArchiveEntry(Ljava/io/File;Ljava/lang/String;)Lorg/apache/commons/compress/archivers/sevenz/SevenZArchiveEntry;",
            "method_body": "public SevenZArchiveEntry createArchiveEntry(final File inputFile,\nfinal String entryName) throws IOException {\nfinal SevenZArchiveEntry entry = new SevenZArchiveEntry();\nentry.setDirectory(inputFile.isDirectory());\nentry.setName(entryName);\nentry.setLastModifiedDate(new Date(inputFile.lastModified()));\nreturn entry;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZArchiveEntry:setLastModifiedDate(J)V",
            "method_body": "public void setLastModifiedDate(long ntfsLastModifiedDate) {\nthis.lastModifiedDate = ntfsLastModifiedDate;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:<init>(Ljava/io/RandomAccessFile;J)V",
            "method_body": "public BoundedRandomAccessFileInputStream(final RandomAccessFile file,\nfinal long size) {\nthis.file = file;\nthis.bytesRemaining = size;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.BoundedRandomAccessFileInputStream:read([BII)I",
            "method_body": "public int read(byte[] b, int off, int len) throws IOException {\nif (bytesRemaining == 0) {\nreturn -1;\n}\nint bytesToRead = len;\nif (bytesToRead > bytesRemaining) {\nbytesToRead = (int) bytesRemaining;\n}\nfinal int bytesRead = file.read(b, off, bytesToRead);\nif (bytesRead >= 0) {\nbytesRemaining -= bytesRead;\n}\nreturn bytesRead;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.sevenz.SevenZOutputFile:closeArchiveEntry()V",
            "method_body": "public void closeArchiveEntry() throws IOException {\nif (currentOutputStream != null) {\ncurrentOutputStream.flush();\ncurrentOutputStream.close();\n}\n\nfinal SevenZArchiveEntry entry = files.get(files.size() - 1);\nif (fileBytesWritten > 0) {\nentry.setHasStream(true);\n++numNonEmptyStreams;\nentry.setSize(currentOutputStream.getBytesWritten());\nentry.setCompressedSize(fileBytesWritten);\nentry.setCrcValue(crc32.getValue());\nentry.setCompressedCrcValue(compressedCrc32.getValue());\nentry.setHasCrc(true);\n} else {\nentry.setHasStream(false);\nentry.setSize(0);\nentry.setCompressedSize(0);\nentry.setHasCrc(false);\n}\ncurrentOutputStream = null;\ncrc32.reset();\ncompressedCrc32.reset();\nfileBytesWritten = 0;\n}",
            "method_id": 63
        }
    ]
}