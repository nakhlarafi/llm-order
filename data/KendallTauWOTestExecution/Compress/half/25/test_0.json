{
    "bug_id": 25,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStreamTest.testReadingOfFirstStoredEntry",
    "test_body": "public void testReadingOfFirstStoredEntry() throws Exception {\nZipArchiveInputStream in = new ZipArchiveInputStream(new FileInputStream(getFile(\"COMPRESS-264.zip\")));\ntry {\nZipArchiveEntry ze = in.getNextZipEntry();\nassertEquals(5, ze.getSize());\nassertArrayEquals(new byte[] {'d', 'a', 't', 'a', '\\n'},\nIOUtils.toByteArray(in));\n} finally {\nin.close();\n}\n}\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<init>(Ljava/lang/String;II)V",
            "method_body": "ZipMethod(int code) {\nthis.code = code;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/lang/String;)V",
            "method_body": "public ZipArchiveEntry(String name) {\nsuper(name);\nsetName(name);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue()J",
            "method_body": "public long getValue() {\nreturn value;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesUTF8ForNames()Z",
            "method_body": "public boolean usesUTF8ForNames() {\nreturn languageEncodingFlag;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipLong)) {\nreturn false;\n}\nreturn value == ((ZipLong) o).getValue();\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useStrongEncryption(Z)V",
            "method_body": "public void useStrongEncryption(boolean b) {\nstrongEncryptionFlag = b;\nif (b) {\nuseEncryption(true);\n}\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>([BI)V",
            "method_body": "public ZipShort (byte[] bytes, int offset) {\nvalue = ZipShort.getValue(bytes, offset);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFirstLocalFileHeader([B)V",
            "method_body": "private void readFirstLocalFileHeader(byte[] lfh) throws IOException {\nreadFully(lfh);\nZipLong sig = new ZipLong(lfh);\nif (sig.equals(ZipLong.DD_SIG)) {\nthrow new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.SPLITTING);\n}\n\nif (sig.equals(ZipLong.SINGLE_SEGMENT_SPLIT_MARKER)) {\n// The archive is not really split as only one segment was\n// needed in the end.  Just skip over the marker.\nbyte[] missedLfhBytes = new byte[4];\nreadFully(missedLfhBytes);\nSystem.arraycopy(lfh, 4, lfh, 0, LFH_LEN - 4);\nSystem.arraycopy(missedLfhBytes, 0, lfh, LFH_LEN - 4, 4);\n}\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:decode([B)Ljava/lang/String;",
            "method_body": "public String decode(byte[] data) throws IOException {\nif (this.charsetName == null) { // i.e. use default charset, see no-args constructor\nreturn new String(data);\n} else {\nreturn new String(data,this.charsetName);\n}\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesEncryption()Z",
            "method_body": "public boolean usesEncryption() {\nreturn encryptionFlag;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:parse([BZLorg/apache/commons/compress/archivers/zip/ExtraFieldUtils$UnparseableExtraField;)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public static ZipExtraField[] parse(byte[] data, boolean local,\nUnparseableExtraField onUnparseableData)\nthrows ZipException {\nList<ZipExtraField> v = new ArrayList<ZipExtraField>();\nint start = 0;\nLOOP:\nwhile (start <= data.length - WORD) {\nZipShort headerId = new ZipShort(data, start);\nint length = new ZipShort(data, start + 2).getValue();\nif (start + WORD + length > data.length) {\nswitch(onUnparseableData.getKey()) {\ncase UnparseableExtraField.THROW_KEY:\nthrow new ZipException(\"bad extra field starting at \"\n+ start + \".  Block length of \"\n+ length + \" bytes exceeds remaining\"\n+ \" data of \"\n+ (data.length - start - WORD)\n+ \" bytes.\");\ncase UnparseableExtraField.READ_KEY:\nUnparseableExtraFieldData field =\nnew UnparseableExtraFieldData();\nif (local) {\nfield.parseFromLocalFileData(data, start,\ndata.length - start);\n} else {\nfield.parseFromCentralDirectoryData(data, start,\ndata.length - start);\n}\nv.add(field);\n//$FALL-THROUGH$\ncase UnparseableExtraField.SKIP_KEY:\n// since we cannot parse the data we must assume\n// the extra field consumes the whole rest of the\n// available data\nbreak LOOP;\ndefault:\nthrow new ZipException(\"unknown UnparseableExtraField key: \"\n+ onUnparseableData.getKey());\n}\n}\ntry {\nZipExtraField ze = createExtraField(headerId);\nif (local) {\nze.parseFromLocalFileData(data, start + WORD, length);\n} else {\nze.parseFromCentralDirectoryData(data, start + WORD,\nlength);\n}\nv.add(ze);\n} catch (InstantiationException ie) {\nthrow (ZipException) new ZipException(ie.getMessage()).initCause(ie);\n} catch (IllegalAccessException iae) {\nthrow (ZipException) new ZipException(iae.getMessage()).initCause(iae);\n}\nstart += length + WORD;\n}\n\nZipExtraField[] result = new ZipExtraField[v.size()];\nreturn v.toArray(result);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<init>()V",
            "method_body": "public JarMarker() {\n// empty\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<init>()V",
            "method_body": "public X5455_ExtendedTimestamp() {}\npublic X5455_ExtendedTimestamp() {}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([BI)V",
            "method_body": "public ZipLong (byte[] bytes, int offset) {\nvalue = ZipLong.getValue(bytes, offset);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readFully([B)V",
            "method_body": "private void readFully(byte[] b) throws IOException {\nint count = IOUtils.readFully(in, b);\ncount(count);\nif (count < b.length) {\nthrow new EOFException();\n}\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:setFlags(B)V",
            "method_body": "public void setFlags(byte flags) {\nthis.flags = flags;\nthis.bit0_modifyTimePresent = (flags & MODIFY_TIME_BIT) == MODIFY_TIME_BIT;\nthis.bit1_accessTimePresent = (flags & ACCESS_TIME_BIT) == ACCESS_TIME_BIT;\nthis.bit2_createTimePresent = (flags & CREATE_TIME_BIT) == CREATE_TIME_BIT;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataData()[B",
            "method_body": "public byte[] getLocalFileDataData() {\nbyte[] uidBytes = uid.toByteArray();\nbyte[] gidBytes = gid.toByteArray();\n\n// BigInteger might prepend a leading-zero to force a positive representation\n// (e.g., so that the sign-bit is set to zero).  We need to remove that\n// before sending the number over the wire.\nuidBytes = trimLeadingZeroesForceMinLength(uidBytes);\ngidBytes = trimLeadingZeroesForceMinLength(gidBytes);\n\n// Couldn't bring myself to just call getLocalFileDataLength() when we've\n// already got the arrays right here.  Yeah, yeah, I know, premature\n// optimization is the root of all...\n//\n// The 3 comes from:  version=1 + uidsize=1 + gidsize=1\nbyte[] data = new byte[3 + uidBytes.length + gidBytes.length];\n\n// reverse() switches byte array from big-endian to little-endian.\nreverse(uidBytes);\nreverse(gidBytes);\n\nint pos = 0;\ndata[pos++] = unsignedIntToSignedByte(version);\ndata[pos++] = unsignedIntToSignedByte(uidBytes.length);\nSystem.arraycopy(uidBytes, 0, data, pos, uidBytes.length);\npos += uidBytes.length;\ndata[pos++] = unsignedIntToSignedByte(gidBytes.length);\nSystem.arraycopy(gidBytes, 0, data, pos, gidBytes.length);\nreturn data;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:supportsDataDescriptorFor(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
            "method_body": "private boolean supportsDataDescriptorFor(ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesDataDescriptor()\n\n|| (allowStoredEntriesWithDataDescriptor && entry.getMethod() == ZipEntry.STORED)\n|| entry.getMethod() == ZipEntry.DEFLATED;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:toByteArray(Ljava/io/InputStream;)[B",
            "method_body": "public static byte[] toByteArray(final InputStream input) throws IOException {\nfinal ByteArrayOutputStream output = new ByteArrayOutputStream();\ncopy(input, output);\nreturn output.toByteArray();\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<clinit>()V",
            "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x756E);\nprivate static final int      WORD = 4;\n/**\n* Standard Unix stat(2) file mode.\n*/\nprivate int mode = 0;\n/**\n* User ID.\n*/\nprivate int uid = 0;\n/**\n* Group ID.\n*/\nprivate int gid = 0;\n/**\n* File this entry points to, if it is a symbolic link.\n*\n* <p>empty string - if entry is not a symbolic link.</p>\n*/\nprivate String link = \"\";\n/**\n* Is this an entry for a directory?\n*/\nprivate boolean dirFlag = false;\n\n/**\n* Instance used to calculate checksums.\n*/\nprivate CRC32 crc = new CRC32();\n\n/** Constructor for AsiExtraField. */\npublic AsiExtraField() {\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding) {\nthis(inputStream, encoding, true);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue()I",
            "method_body": "public int getValue() {\nreturn value;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<init>()V",
            "method_body": "public UnicodePathExtraField () {\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getValue([BI)I",
            "method_body": "public static int getValue(byte[] bytes, int offset) {\nint value = (bytes[offset + 1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:<clinit>()V",
            "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x5455);\nprivate static final long serialVersionUID = 1L;\n\n/**\n* The bit set inside the flags by when the last modification time\n* is present in this extra field.\n*/\npublic static final byte MODIFY_TIME_BIT = 1;\n/**\n* The bit set inside the flags by when the lasr access time is\n* present in this extra field.\n*/\npublic static final byte ACCESS_TIME_BIT = 2;\n/**\n* The bit set inside the flags by when the original creation time\n* is present in this extra field.\n*/\npublic static final byte CREATE_TIME_BIT = 4;\n\n// The 3 boolean fields (below) come from this flags byte.  The remaining 5 bits\n// are ignored according to the current version of the spec (December 2012).\nprivate byte flags;\n\n// Note: even if bit1 and bit2 are set, the Central data will still not contain\n// access/create fields:  only local data ever holds those!  This causes\n// some of our implementation to look a little odd, with seemingly spurious\n// != null and length checks.\nprivate boolean bit0_modifyTimePresent;\nprivate boolean bit1_accessTimePresent;\nprivate boolean bit2_createTimePresent;\n\nprivate ZipLong modifyTime;\nprivate ZipLong accessTime;\nprivate ZipLong createTime;\n\n/**\n* Constructor for X5455_ExtendedTimestamp.\n*/\npublic X5455_ExtendedTimestamp() {}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:parseFromLocalFileData([BII)V",
            "method_body": "public void parseFromLocalFileData(\nbyte[] data, int offset, int length\n) throws ZipException {\nreset();\nthis.version = signedByteToUnsignedInt(data[offset++]);\nint uidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] uidBytes = new byte[uidSize];\nSystem.arraycopy(data, offset, uidBytes, 0, uidSize);\noffset += uidSize;\nthis.uid = new BigInteger(1, reverse(uidBytes)); // sign-bit forced positive\n\nint gidSize = signedByteToUnsignedInt(data[offset++]);\nbyte[] gidBytes = new byte[gidSize];\nSystem.arraycopy(data, offset, gidBytes, 0, gidSize);\nthis.gid = new BigInteger(1, reverse(gidBytes)); // sign-bit forced positive\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)V",
            "method_body": "public void setExtraFields(ZipExtraField[] fields) {\nextraFields = new LinkedHashMap<ZipShort, ZipExtraField>();\nfor (ZipExtraField field : fields) {\nif (field instanceof UnparseableExtraFieldData) {\nunparseableExtra = (UnparseableExtraFieldData) field;\n} else {\nextraFields.put(field.getHeaderId(), field);\n}\n}\nsetExtra();\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:readStored([BII)I",
            "method_body": "private int readStored(byte[] buffer, int offset, int length) throws IOException {\n\nif (current.hasDataDescriptor) {\nif (lastStoredEntry == null) {\nreadStoredEntry();\n}\nreturn lastStoredEntry.read(buffer, offset, length);\n}\n\nlong csize = current.entry.getSize();\nif (current.bytesRead >= csize) {\nreturn -1;\n}\n\nif (buf.position() >= buf.limit()) {\nbuf.position(0);\nint l = in.read(buf.array());\nif (l == -1) {\nreturn -1;\n}\nbuf.limit(l);\n\ncount(buf.limit());\ncurrent.bytesReadFromStream += buf.limit();\n}\n\nint toRead = Math.min(buf.remaining(), length);\nif ((csize - current.bytesRead) < toRead) {\n// if it is smaller than toRead then it fits into an int\ntoRead = (int) (csize - current.bytesRead);\n}\nbuf.get(buffer, offset, toRead);\ncurrent.bytesRead += toRead;\nreturn toRead;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:reverse([B)[B",
            "method_body": "public static byte[] reverse(final byte[] array) {\nfinal int z = array.length - 1; // position of last element\nfor (int i = 0; i < array.length / 2; i++) {\nbyte x = array[i];\narray[i] = array[z - i];\narray[z - i] = x;\n}\nreturn array;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setSize(J)V",
            "method_body": "public void setSize(long size) {\nif (size < 0) {\nthrow new IllegalArgumentException(\"invalid entry size\");\n}\nthis.size = size;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.utils.Charsets:<clinit>()V",
            "method_body": "public static final Charset ISO_8859_1 = Charset.forName(CharsetNames.ISO_8859_1);\n\n/**\n* <p>\n* Seven-bit ASCII, also known as ISO646-US, also known as the Basic Latin block of the Unicode character set.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset US_ASCII = Charset.forName(CharsetNames.US_ASCII);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, The byte order specified by a mandatory initial byte-order mark\n* (either order accepted on input, big-endian used on output)\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16 = Charset.forName(CharsetNames.UTF_16);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, big-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16BE = Charset.forName(CharsetNames.UTF_16BE);\n\n/**\n* <p>\n* Sixteen-bit Unicode Transformation Format, little-endian byte order.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_16LE = Charset.forName(CharsetNames.UTF_16LE);\n\n/**\n* <p>\n* Eight-bit Unicode Transformation Format.\n* </p>\n* <p>\n* Every implementation of the Java platform is required to support this character encoding.\n* </p>\n*\n* @see <a href=\"http://docs.oracle.com/javase/6/docs/api/java/nio/charset/Charset.html\">Standard charsets</a>\n*/\npublic static final Charset UTF_8 = Charset.forName(CharsetNames.UTF_8);\n}\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:getBytes()[B",
            "method_body": "public byte[] getBytes() {\nbyte[] result = new byte[2];\nresult[0] = (byte) (value & BYTE_MASK);\nresult[1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nreturn result;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:read([BII)I",
            "method_body": "public int read(byte[] buffer, int offset, int length) throws IOException {\nif (closed) {\nthrow new IOException(\"The stream is closed\");\n}\n\nif (current == null) {\nreturn -1;\n}\n\n// avoid int overflow, check null buffer\nif (offset > buffer.length || length < 0 || offset < 0 || buffer.length - offset < length) {\nthrow new ArrayIndexOutOfBoundsException();\n}\n\nZipUtil.checkRequestedFeatures(current.entry);\nif (!supportsDataDescriptorFor(current.entry)) {\nthrow new UnsupportedZipFeatureException(UnsupportedZipFeatureException.Feature.DATA_DESCRIPTOR,\ncurrent.entry);\n}\n\nint read;\nif (current.entry.getMethod() == ZipArchiveOutputStream.STORED) {\nread = readStored(buffer, offset, length);\n} else if (current.entry.getMethod() == ZipArchiveOutputStream.DEFLATED) {\nread = readDeflated(buffer, offset, length);\n} else if (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n|| current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\nread = current.in.read(buffer, offset, length);\n} else {\nthrow new UnsupportedZipFeatureException(ZipMethod.getMethodByCode(current.entry.getMethod()),\ncurrent.entry);\n}\n\nif (read >= 0) {\ncurrent.crc.update(buffer, offset, read);\n}\n\nreturn read;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[BII)I",
            "method_body": "public static int readFully(InputStream input, byte[] b, int offset, int len)\nthrows IOException {\nif (len < 0 || offset < 0 || len + offset > b.length) {\nthrow new IndexOutOfBoundsException();\n}\nint count = 0, x = 0;\nwhile (count != len) {\nx = input.read(b, offset + count, len - count);\nif (x == -1) {\nbreak;\n}\ncount += x;\n}\nreturn count;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper$SimpleEncodingHolder:<init>([C)V",
            "method_body": "SimpleEncodingHolder(char [] highChars) {\nthis.highChars = highChars;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraFields(Z)[Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public ZipExtraField[] getExtraFields(boolean includeUnparseable) {\nif (extraFields == null) {\nreturn !includeUnparseable || unparseableExtra == null\n? new ZipExtraField[0]\n: new ZipExtraField[] { unparseableExtra };\n}\nList<ZipExtraField> result =\nnew ArrayList<ZipExtraField>(extraFields.values());\nif (includeUnparseable && unparseableExtra != null) {\nresult.add(unparseableExtra);\n}\nreturn result.toArray(new ZipExtraField[0]);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:<clinit>()V",
            "method_body": "private static final int WORD = 4;\n\n/**\n* Static registry of known extra fields.\n*/\nprivate static final Map<ZipShort, Class<?>> implementations;\n\nstatic {\nimplementations = new ConcurrentHashMap<ZipShort, Class<?>>();\nregister(AsiExtraField.class);\nregister(X5455_ExtendedTimestamp.class);\nregister(X7875_NewUnix.class);\nregister(JarMarker.class);\nregister(UnicodePathExtraField.class);\nregister(UnicodeCommentExtraField.class);\nregister(Zip64ExtendedInformationExtraField.class);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getLocalFileDataLength() {\nint uidSize = trimLeadingZeroesForceMinLength(uid.toByteArray()).length;\nint gidSize = trimLeadingZeroesForceMinLength(gid.toByteArray()).length;\n\n// The 3 comes from:  version=1 + uidsize=1 + gidsize=1\nreturn new ZipShort(3 + uidSize + gidSize);\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:<init>(I)V",
            "method_body": "public ZipShort (int value) {\nthis.value = value;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<clinit>()V",
            "method_body": "public static final int PLATFORM_UNIX = 3;\npublic static final int PLATFORM_FAT  = 0;\nprivate static final int SHORT_MASK = 0xFFFF;\nprivate static final int SHORT_SHIFT = 16;\nprivate static final byte[] EMPTY = new byte[0];\n\n/**\n* The {@link java.util.zip.ZipEntry} base class only supports",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:readFully(Ljava/io/InputStream;[B)I",
            "method_body": "public static int readFully(InputStream input, byte[] b) throws IOException {\nreturn readFully(input, b, 0, b.length);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<clinit>()V",
            "method_body": "public static final int THROW_KEY = 0;\n/**\n* Key for \"skip\" action.\n*/\npublic static final int SKIP_KEY = 1;\n/**\n* Key for \"read\" action.\n*/\npublic static final int READ_KEY = 2;\n\n/**\n* Throw an exception if field cannot be parsed.\n*/\npublic static final UnparseableExtraField THROW\n= new UnparseableExtraField(THROW_KEY);\n\n/**\n* Skip the extra field entirely and don't make its data\n* available - effectively removing the extra field data.\n*/\npublic static final UnparseableExtraField SKIP\n= new UnparseableExtraField(SKIP_KEY);\n\n/**\n* Read the extra field data into an instance of {@link\n* UnparseableExtraFieldData UnparseableExtraFieldData}.",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<init>()V",
            "method_body": "public Zip64ExtendedInformationExtraField() { }\npublic Zip64ExtendedInformationExtraField() { }",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getSize()J",
            "method_body": "public long getSize() {\nreturn size;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:reset()V",
            "method_body": "private void reset() {\n// Typical UID/GID of the first non-root user created on a unix system.\nuid = ONE_THOUSAND;\ngid = ONE_THOUSAND;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:<clinit>()V",
            "method_body": "private final int code;\nMap<Integer, ZipMethod> cte = new HashMap<Integer, ZipMethod>();\nfor (ZipMethod method : values()) {\ncte.put(Integer.valueOf(method.getCode()), method);\ncodeToEnum = Collections.unmodifiableMap(cte);\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<init>()V",
            "method_body": "public UnicodeCommentExtraField () {\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn name == null ? super.getName() : name;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useUTF8ForNames(Z)V",
            "method_body": "public void useUTF8ForNames(boolean b) {\nlanguageEncodingFlag = b;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>([B)V",
            "method_body": "public ZipLong (byte[] bytes) {\nthis(bytes, 0);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:getUnicodeStringIfOriginalMatches(Lorg/apache/commons/compress/archivers/zip/AbstractUnicodeExtraField;[B)Ljava/lang/String;",
            "method_body": "String getUnicodeStringIfOriginalMatches(AbstractUnicodeExtraField f,\nbyte[] orig) {\nif (f != null) {\nCRC32 crc32 = new CRC32();\ncrc32.update(orig);\nlong origCRC32 = crc32.getValue();\n\nif (origCRC32 == f.getNameCRC32()) {\ntry {\nreturn ZipEncodingHelper\n.UTF8_ZIP_ENCODING.decode(f.getUnicodeName());\n} catch (IOException ex) {\n// UTF-8 unsupported?  should be impossible the\n// Unicode*ExtraField must contain some bad bytes\n\n// TODO log this anywhere?\nreturn null;\n}\n}\n}\nreturn null;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:mergeExtraFields([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;Z)V",
            "method_body": "private void mergeExtraFields(ZipExtraField[] f, boolean local)\nthrows ZipException {\nif (extraFields == null) {\nsetExtraFields(f);\n} else {\nfor (ZipExtraField element : f) {\nZipExtraField existing;\nif (element instanceof UnparseableExtraFieldData) {\nexisting = unparseableExtra;\n} else {\nexisting = getExtraField(element.getHeaderId());\n}\nif (existing == null) {\naddExtraField(element);\n} else {\nif (local) {\nbyte[] b = element.getLocalFileDataData();\nexisting.parseFromLocalFileData(b, 0, b.length);\n} else {\nbyte[] b = element.getCentralDirectoryData();\nexisting.parseFromCentralDirectoryData(b, 0, b.length);\n}\n}\n}\nsetExtra();\n}\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;I)J",
            "method_body": "public static long copy(final InputStream input, final OutputStream output, int buffersize) throws IOException {\nfinal byte[] buffer = new byte[buffersize];\nint n = 0;\nlong count=0;\nwhile (-1 != (n = input.read(buffer))) {\noutput.write(buffer, 0, n);\ncount += n;\n}\nreturn count;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getValue([BI)J",
            "method_body": "public static long getValue(byte[] bytes, int offset) {\nlong value = (bytes[offset + BYTE_3] << BYTE_3_SHIFT) & BYTE_3_MASK;\nvalue += (bytes[offset + BYTE_2] << BYTE_2_SHIFT) & BYTE_2_MASK;\nvalue += (bytes[offset + BYTE_1] << BYTE_1_SHIFT) & BYTE_1_MASK;\nvalue += (bytes[offset] & BYTE_MASK);\nreturn value;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:<init>()V",
            "method_body": "public GeneralPurposeBit() {\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:processZip64Extra(Lorg/apache/commons/compress/archivers/zip/ZipLong;Lorg/apache/commons/compress/archivers/zip/ZipLong;)V",
            "method_body": "private void processZip64Extra(ZipLong size, ZipLong cSize) {\nZip64ExtendedInformationExtraField z64 =\n(Zip64ExtendedInformationExtraField)\ncurrent.entry.getExtraField(Zip64ExtendedInformationExtraField.HEADER_ID);\ncurrent.usesZip64 = z64 != null;\nif (!current.hasDataDescriptor) {\nif (z64 != null // same as current.usesZip64 but avoids NPE warning\n&& (cSize.equals(ZipLong.ZIP64_MAGIC) || size.equals(ZipLong.ZIP64_MAGIC)) ) {\ncurrent.entry.setCompressedSize(z64.getCompressedSize().getLongValue());\ncurrent.entry.setSize(z64.getSize().getLongValue());\n} else {\ncurrent.entry.setCompressedSize(cSize.getValue());\ncurrent.entry.setSize(size.getValue());\n}\n}\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setPlatform(I)V",
            "method_body": "protected void setPlatform(int platform) {\nthis.platform = platform;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:reset()V",
            "method_body": "private void reset() {\nsetFlags((byte) 0);\nthis.modifyTime = null;\nthis.accessTime = null;\nthis.createTime = null;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useEncryption(Z)V",
            "method_body": "public void useEncryption(boolean b) {\nencryptionFlag = b;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;ZZ)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream,\nString encoding,\nboolean useUnicodeExtraFields,\nboolean allowStoredEntriesWithDataDescriptor) {\nzipEncoding = ZipEncodingHelper.getZipEncoding(encoding);\nthis.useUnicodeExtraFields = useUnicodeExtraFields;\nin = new PushbackInputStream(inputStream, buf.capacity());\nthis.allowStoredEntriesWithDataDescriptor =\nallowStoredEntriesWithDataDescriptor;\n// haven't read anything so far\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:mergeLocalFileDataData([Lorg/apache/commons/compress/archivers/zip/ZipExtraField;)[B",
            "method_body": "public static byte[] mergeLocalFileDataData(ZipExtraField[] data) {\nfinal boolean lastIsUnparseableHolder = data.length > 0\n&& data[data.length - 1] instanceof UnparseableExtraFieldData;\nint regularExtraFieldCount =\nlastIsUnparseableHolder ? data.length - 1 : data.length;\n\nint sum = WORD * regularExtraFieldCount;\nfor (ZipExtraField element : data) {\nsum += element.getLocalFileDataLength().getValue();\n}\n\nbyte[] result = new byte[sum];\nint start = 0;\nfor (int i = 0; i < regularExtraFieldCount; i++) {\nSystem.arraycopy(data[i].getHeaderId().getBytes(),\n0, result, start, 2);\nSystem.arraycopy(data[i].getLocalFileDataLength().getBytes(),\n0, result, start + 2, 2);\nbyte[] local = data[i].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start + WORD, local.length);\nstart += local.length + WORD;\n}\nif (lastIsUnparseableHolder) {\nbyte[] local = data[data.length - 1].getLocalFileDataData();\nSystem.arraycopy(local, 0, result, start, local.length);\n}\nreturn result;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;)V",
            "method_body": "protected void setName(String name) {\nif (name != null && getPlatform() == PLATFORM_FAT\n&& name.indexOf(\"/\") == -1) {\nname = name.replace('\\\\', '/');\n}\nthis.name = name;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.FallbackZipEncoding:<init>(Ljava/lang/String;)V",
            "method_body": "public FallbackZipEncoding(String charsetName) {\nthis.charsetName = charsetName;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipMethod:getCode()I",
            "method_body": "public int getCode() {\nreturn code;\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.compress.utils.IOUtils:copy(Ljava/io/InputStream;Ljava/io/OutputStream;)J",
            "method_body": "public static long copy(final InputStream input, final OutputStream output) throws IOException {\nreturn copy(input, output, 8024);\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra()V",
            "method_body": "protected void setExtra() {\nsuper.setExtra(ExtraFieldUtils.mergeLocalFileDataData(getExtraFields(true)));\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream$CurrentEntry:<init>()V",
            "method_body": "private final ZipArchiveEntry entry = new ZipArchiveEntry();\nprivate final CRC32 crc = new CRC32();\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn UPATH_ID;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:<clinit>()V",
            "method_body": "static final ZipShort HEADER_ID = new ZipShort(0x0001);\n\nprivate static final String LFH_MUST_HAVE_BOTH_SIZES_MSG =\n\"Zip64 extended information must contain\"\n+ \" both size values in the local file header.\";\nprivate static final byte[] EMPTY = new byte[0];\n\nprivate ZipEightByteInteger size, compressedSize, relativeHeaderOffset;\nprivate ZipLong diskStart;\n\n/**\n* Stored in {@link #parseFromCentralDirectoryData\n* parseFromCentralDirectoryData} so it can be reused when ZipFile",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>()V",
            "method_body": "protected ZipArchiveEntry() {\nthis(\"\");\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:parse([BI)Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
            "method_body": "public static GeneralPurposeBit parse(final byte[] data, final int offset) {\nfinal int generalPurposeFlag = ZipShort.getValue(data, offset);\nGeneralPurposeBit b = new GeneralPurposeBit();\nb.useDataDescriptor((generalPurposeFlag & DATA_DESCRIPTOR_FLAG) != 0);\nb.useUTF8ForNames((generalPurposeFlag & UFT8_NAMES_FLAG) != 0);\nb.useStrongEncryption((generalPurposeFlag & STRONG_ENCRYPTION_FLAG) != 0);\nb.useEncryption((generalPurposeFlag & ENCRYPTION_FLAG) != 0);\nb.slidingDictionarySize = (generalPurposeFlag & SLIDING_DICTIONARY_SIZE_FLAG) != 0 ? 8192 : 4096;\nb.numberOfShannonFanoTrees = (generalPurposeFlag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) != 0 ? 3 : 2;\nreturn b;\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:<clinit>()V",
            "method_body": "private static final Map<String, SimpleEncodingHolder> simpleEncodings;\n\nstatic {\nMap<String, SimpleEncodingHolder> se =\nnew HashMap<String, SimpleEncodingHolder>();\n\nchar[] cp437_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00a2, 0x00a3, 0x00a5,\n0x20a7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x2310,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x2561,\n0x2562, 0x2556, 0x2555, 0x2563, 0x2551, 0x2557,\n0x255d, 0x255c, 0x255b, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x255e, 0x255f,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x2567, 0x2568, 0x2564, 0x2565, 0x2559,\n0x2558, 0x2552, 0x2553, 0x256b, 0x256a, 0x2518,\n0x250c, 0x2588, 0x2584, 0x258c, 0x2590, 0x2580,\n0x03b1, 0x00df, 0x0393, 0x03c0, 0x03a3, 0x03c3,\n0x00b5, 0x03c4, 0x03a6, 0x0398, 0x03a9, 0x03b4,\n0x221e, 0x03c6, 0x03b5, 0x2229, 0x2261, 0x00b1,\n0x2265, 0x2264, 0x2320, 0x2321, 0x00f7, 0x2248,\n0x00b0, 0x2219, 0x00b7, 0x221a, 0x207f, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp437 = new SimpleEncodingHolder(cp437_high_chars);\n\nse.put(\"CP437\", cp437);\nse.put(\"Cp437\", cp437);\nse.put(\"cp437\", cp437);\nse.put(\"IBM437\", cp437);\nse.put(\"ibm437\", cp437);\n\nchar[] cp850_high_chars =\nnew char[] { 0x00c7, 0x00fc, 0x00e9, 0x00e2, 0x00e4, 0x00e0,\n0x00e5, 0x00e7, 0x00ea, 0x00eb, 0x00e8, 0x00ef,\n0x00ee, 0x00ec, 0x00c4, 0x00c5, 0x00c9, 0x00e6,\n0x00c6, 0x00f4, 0x00f6, 0x00f2, 0x00fb, 0x00f9,\n0x00ff, 0x00d6, 0x00dc, 0x00f8, 0x00a3, 0x00d8,\n0x00d7, 0x0192, 0x00e1, 0x00ed, 0x00f3, 0x00fa,\n0x00f1, 0x00d1, 0x00aa, 0x00ba, 0x00bf, 0x00ae,\n0x00ac, 0x00bd, 0x00bc, 0x00a1, 0x00ab, 0x00bb,\n0x2591, 0x2592, 0x2593, 0x2502, 0x2524, 0x00c1,\n0x00c2, 0x00c0, 0x00a9, 0x2563, 0x2551, 0x2557,\n0x255d, 0x00a2, 0x00a5, 0x2510, 0x2514, 0x2534,\n0x252c, 0x251c, 0x2500, 0x253c, 0x00e3, 0x00c3,\n0x255a, 0x2554, 0x2569, 0x2566, 0x2560, 0x2550,\n0x256c, 0x00a4, 0x00f0, 0x00d0, 0x00ca, 0x00cb,\n0x00c8, 0x0131, 0x00cd, 0x00ce, 0x00cf, 0x2518,\n0x250c, 0x2588, 0x2584, 0x00a6, 0x00cc, 0x2580,\n0x00d3, 0x00df, 0x00d4, 0x00d2, 0x00f5, 0x00d5,\n0x00b5, 0x00fe, 0x00de, 0x00da, 0x00db, 0x00d9,\n0x00fd, 0x00dd, 0x00af, 0x00b4, 0x00ad, 0x00b1,\n0x2017, 0x00be, 0x00b6, 0x00a7, 0x00f7, 0x00b8,\n0x00b0, 0x00a8, 0x00b7, 0x00b9, 0x00b3, 0x00b2,\n0x25a0, 0x00a0 };\n\nSimpleEncodingHolder cp850 = new SimpleEncodingHolder(cp850_high_chars);\n\nse.put(\"CP850\", cp850);\nse.put(\"Cp850\", cp850);\nse.put(\"cp850\", cp850);\nse.put(\"IBM850\", cp850);\nse.put(\"ibm850\", cp850);\nsimpleEncodings = Collections.unmodifiableMap(se);\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream) {\nthis(inputStream, ZipEncodingHelper.UTF8);\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:<clinit>()V",
            "method_body": "private static final ZipShort ID = new ZipShort(0xCAFE);\nprivate static final ZipShort NULL = new ZipShort(0);\nprivate static final byte[] NO_BYTES = new byte[0];\nprivate static final JarMarker DEFAULT = new JarMarker();\n\n/** No-arg constructor */\npublic JarMarker() {\n// empty\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getLocalFileDataData()[B",
            "method_body": "public byte[] getLocalFileDataData() {\nbyte[] data = new byte[getLocalFileDataLength().getValue()];\nint pos = 0;\ndata[pos++] = 0;\nif (bit0_modifyTimePresent) {\ndata[0] |= MODIFY_TIME_BIT;\nSystem.arraycopy(modifyTime.getBytes(), 0, data, pos, 4);\npos += 4;\n}\nif (bit1_accessTimePresent && accessTime != null) {\ndata[0] |= ACCESS_TIME_BIT;\nSystem.arraycopy(accessTime.getBytes(), 0, data, pos, 4);\npos += 4;\n}\nif (bit2_createTimePresent && createTime != null) {\ndata[0] |= CREATE_TIME_BIT;\nSystem.arraycopy(createTime.getBytes(), 0, data, pos, 4);\npos += 4;\n}\nreturn data;\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setExtra([B)V",
            "method_body": "public void setExtra(byte[] extra) throws RuntimeException {\ntry {\nZipExtraField[] local =\nExtraFieldUtils.parse(extra, true,\nExtraFieldUtils.UnparseableExtraField.READ);\nmergeExtraFields(local, true);\n} catch (ZipException e) {\n// actually this is not possible as of Commons Compress 1.1\nthrow new RuntimeException(\"Error parsing extra fields for entry: \"\n+ getName() + \" - \" + e.getMessage(), e);\n}\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:useDataDescriptor(Z)V",
            "method_body": "public void useDataDescriptor(boolean b) {\ndataDescriptorFlag = b;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:<clinit>()V",
            "method_body": "private static final byte[] DOS_TIME_MIN = ZipLong.getBytes(0x00002100L);\n\n/**\n* Convert a Date object to a DOS date/time field.\n* @param time the <code>Date</code> to convert\n* @return the date as a <code>ZipLong</code>\n*/\npublic static ZipLong toDosTime(Date time) {\nreturn new ZipLong(toDosTime(time.getTime()));\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:createExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public static ZipExtraField createExtraField(ZipShort headerId)\nthrows InstantiationException, IllegalAccessException {\nClass<?> c = implementations.get(headerId);\nif (c != null) {\nreturn (ZipExtraField) c.newInstance();\n}\nUnrecognizedExtraField u = new UnrecognizedExtraField();\nu.setHeaderId(headerId);\nreturn u;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AbstractUnicodeExtraField:<init>()V",
            "method_body": "protected AbstractUnicodeExtraField() {\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:trimLeadingZeroesForceMinLength([B)[B",
            "method_body": "static byte[] trimLeadingZeroesForceMinLength(byte[] array) {\nif (array == null) {\nreturn array;\n}\n\nint pos = 0;\nfor (byte b : array) {\nif (b == 0) {\npos++;\n} else {\nbreak;\n}\n}\n\n/*\n\nI agonized over my choice of MIN_LENGTH=1.  Here's the situation:\nInfoZip (the tool I am using to test interop) always sets these\nto length=4.  And so a UID of 0 (typically root) for example is\nencoded as {4,0,0,0,0} (len=4, 32 bits of zero), when it could just\nas easily be encoded as {1,0} (len=1, 8 bits of zero) according to\nthe spec.\n\nIn the end I decided on MIN_LENGTH=1 for four reasons:\n\n1.)  We are adhering to the spec as far as I can tell, and so\na consumer that cannot parse this is broken.\n\n2.)  Fundamentally, zip files are about shrinking things, so\nlet's save a few bytes per entry while we can.\n\n3.)  Of all the people creating zip files using commons-\ncompress, how many care about UNIX UID/GID attributes\nof the files they store?   (e.g., I am probably thinking\nway too hard about this and no one cares!)\n\n4.)  InfoZip's tool, even though it carefully stores every UID/GID\nfor every file zipped on a unix machine (by default) currently\nappears unable to ever restore UID/GID.\nunzip -X has no effect on my machine, even when run as root!!!!\n\nAnd thus it is decided:  MIN_LENGTH=1.\n\nIf anyone runs into interop problems from this, feel free to set\nit to MIN_LENGTH=4 at some future time, and then we will behave\nexactly like InfoZip (requires changes to unit tests, though).\n\nAnd I am sorry that the time you spent reading this comment is now\ngone and you can never have it back.\n\n*/\nfinal int MIN_LENGTH = 1;\n\nbyte[] trimmedArray = new byte[Math.max(MIN_LENGTH, array.length - pos)];\nint startPos = trimmedArray.length - (array.length - pos);\nSystem.arraycopy(array, pos, trimmedArray, startPos, trimmedArray.length - startPos);\nreturn trimmedArray;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn UCOM_ID;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:<init>(Ljava/util/zip/ZipEntry;)V",
            "method_body": "private long size = SIZE_UNKNOWN;\nprivate int internalAttributes = 0;\nprivate int platform = PLATFORM_FAT;\nprivate long externalAttributes = 0;\nprivate LinkedHashMap<ZipShort, ZipExtraField> extraFields = null;\nprivate UnparseableExtraFieldData unparseableExtra = null;\nprivate String name = null;\nprivate byte[] rawName = null;\nprivate GeneralPurposeBit gpb = new GeneralPurposeBit();\nsuper(name);\nsetName(name);\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setName(Ljava/lang/String;[B)V",
            "method_body": "protected void setName(String name, byte[] rawName) {\nsetName(name);\nthis.rawName = rawName;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
            "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.GeneralPurposeBit:usesDataDescriptor()Z",
            "method_body": "public boolean usesDataDescriptor() {\nreturn dataDescriptorFlag;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getMethod()I",
            "method_body": "public int getMethod() {\nreturn method;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:getZipEncoding(Ljava/lang/String;)Lorg/apache/commons/compress/archivers/zip/ZipEncoding;",
            "method_body": "public static ZipEncoding getZipEncoding(String name) {\n\n// fallback encoding is good enough for UTF-8.\nif (isUTF8(name)) {\nreturn UTF8_ZIP_ENCODING;\n}\n\nif (name == null) {\nreturn new FallbackZipEncoding();\n}\n\nSimpleEncodingHolder h = simpleEncodings.get(name);\n\nif (h!=null) {\nreturn h.getEncoding();\n}\n\ntry {\n\nCharset cs = Charset.forName(name);\nreturn new NioZipEncoding(cs);\n\n} catch (UnsupportedCharsetException e) {\nreturn new FallbackZipEncoding(name);\n}\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:dosToJavaTime(J)J",
            "method_body": "public static long dosToJavaTime(long dosTime) {\nCalendar cal = Calendar.getInstance();\n// CheckStyle:MagicNumberCheck OFF - no point\ncal.set(Calendar.YEAR, (int) ((dosTime >> 25) & 0x7f) + 1980);\ncal.set(Calendar.MONTH, (int) ((dosTime >> 21) & 0x0f) - 1);\ncal.set(Calendar.DATE, (int) (dosTime >> 16) & 0x1f);\ncal.set(Calendar.HOUR_OF_DAY, (int) (dosTime >> 11) & 0x1f);\ncal.set(Calendar.MINUTE, (int) (dosTime >> 5) & 0x3f);\ncal.set(Calendar.SECOND, (int) (dosTime << 1) & 0x3e);\ncal.set(Calendar.MILLISECOND, 0);\n// CheckStyle:MagicNumberCheck ON\nreturn cal.getTime().getTime();\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getGeneralPurposeBit()Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;",
            "method_body": "public GeneralPurposeBit getGeneralPurposeBit() {\nreturn gpb;\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setMethod(I)V",
            "method_body": "public void setMethod(int method) {\nif (method < 0) {\nthrow new IllegalArgumentException(\n\"ZIP compression method can not be negative: \" + method);\n}\nthis.method = method;\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils$UnparseableExtraField:<init>(I)V",
            "method_body": "private UnparseableExtraField(int k) {\nkey = k;\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(I)V",
            "method_body": "protected void count(int read) {\ncount((long) read);\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
            "method_body": "private static final long serialVersionUID = 1L;\n\n//private static final int BYTE_BIT_SIZE = 8;\n\nprivate static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature.\n*\n* <p>Actually, PKWARE uses this as marker for split/spanned\n* archives and other archivers have started to use it as Data\n* Descriptor signature (as well).</p>\n* @since 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Marks ZIP archives that were supposed to be split or spanned\n* but only needed a single segment in then end (so are actually\n* neither split nor spanned).\n*\n* <p>This is the \"PK00\" prefix found in some archives.</p>\n* @since 1.5\n*/\npublic static final ZipLong SINGLE_SEGMENT_SPLIT_MARKER =\nnew ZipLong(0X30304B50L);\n\n/**\n* Archive extra data record signature.\n* @since 1.5\n*/\npublic static final ZipLong AED_SIG = new ZipLong(0X08064B50L);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodeCommentExtraField:<clinit>()V",
            "method_body": "public static final ZipShort UCOM_ID = new ZipShort(0x6375);\n\npublic UnicodeCommentExtraField () {\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:checkRequestedFeatures(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)V",
            "method_body": "static void checkRequestedFeatures(ZipArchiveEntry ze)\nthrows UnsupportedZipFeatureException {\nif (!supportsEncryptionOf(ze)) {\nthrow\nnew UnsupportedZipFeatureException(UnsupportedZipFeatureException\n.Feature.ENCRYPTION, ze);\n}\nif (!supportsMethodOf(ze)) {\nZipMethod m = ZipMethod.getMethodByCode(ze.getMethod());\nif (m == null) {\nthrow\nnew UnsupportedZipFeatureException(UnsupportedZipFeatureException\n.Feature.METHOD, ze);\n} else {\nthrow new UnsupportedZipFeatureException(m, ze);\n}\n}\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.UnicodePathExtraField:<clinit>()V",
            "method_body": "public static final ZipShort UPATH_ID = new ZipShort(0x7075);\n\npublic UnicodePathExtraField () {\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:parseFromLocalFileData([BII)V",
            "method_body": "public void parseFromLocalFileData(\nbyte[] data, int offset, int length\n) throws ZipException {\nreset();\nfinal int len = offset + length;\nsetFlags(data[offset++]);\nif (bit0_modifyTimePresent) {\nmodifyTime = new ZipLong(data, offset);\noffset += 4;\n}\n\n// Notice the extra length check in case we are parsing the shorter\n// central data field (for both access and create timestamps).\nif (bit1_accessTimePresent && offset + 4 <= len) {\naccessTime = new ZipLong(data, offset);\noffset += 4;\n}\nif (bit2_createTimePresent && offset + 4 <= len) {\ncreateTime = new ZipLong(data, offset);\noffset += 4;\n}\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipEncodingHelper:isUTF8(Ljava/lang/String;)Z",
            "method_body": "static boolean isUTF8(String charsetName) {\nif (charsetName == null) {\n// check platform's default encoding\ncharsetName = System.getProperty(\"file.encoding\");\n}\nif (Charsets.UTF_8.name().equalsIgnoreCase(charsetName)) {\nreturn true;\n}\nfor (String alias : Charsets.UTF_8.aliases()) {\nif (alias.equalsIgnoreCase(charsetName)) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:unsignedIntToSignedByte(I)B",
            "method_body": "public static byte unsignedIntToSignedByte(int i) {\nif (i > 255 || i < 0) {\nthrow new IllegalArgumentException(\"Can only convert non-negative integers between [0,255] to byte: [\" + i + \"]\");\n}\nif (i < 128) {\nreturn (byte) i;\n} else {\nreturn (byte) (i - 256);\n}\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getPlatform()I",
            "method_body": "public int getPlatform() {\nreturn platform;\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.JarMarker:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn ID;\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveInputStream:count(J)V",
            "method_body": "protected void count(long read) {\nif (read != -1) {\nbytesRead = bytesRead + read;\n}\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsMethodOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
            "method_body": "private static boolean supportsMethodOf(ZipArchiveEntry entry) {\nreturn entry.getMethod() == ZipEntry.STORED\n|| entry.getMethod() == ZipMethod.UNSHRINKING.getCode()\n|| entry.getMethod() == ZipMethod.IMPLODING.getCode()\n|| entry.getMethod() == ZipEntry.DEFLATED;\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:getNextZipEntry()Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;",
            "method_body": "public ZipArchiveEntry getNextZipEntry() throws IOException {\nboolean firstEntry = true;\nif (closed || hitCentralDirectory) {\nreturn null;\n}\nif (current != null) {\ncloseEntry();\nfirstEntry = false;\n}\n\ntry {\nif (firstEntry) {\n// split archives have a special signature before the\n// first local file header - look for it and fail with\n// the appropriate error message if this is a split\n// archive.\nreadFirstLocalFileHeader(LFH_BUF);\n} else {\nreadFully(LFH_BUF);\n}\n} catch (EOFException e) {\nreturn null;\n}\n\nZipLong sig = new ZipLong(LFH_BUF);\nif (sig.equals(ZipLong.CFH_SIG) || sig.equals(ZipLong.AED_SIG)) {\nhitCentralDirectory = true;\nskipRemainderOfArchive();\n}\nif (!sig.equals(ZipLong.LFH_SIG)) {\nreturn null;\n}\n\nint off = WORD;\ncurrent = new CurrentEntry();\n\nint versionMadeBy = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\ncurrent.entry.setPlatform((versionMadeBy >> ZipFile.BYTE_SHIFT) & ZipFile.NIBLET_MASK);\n\nfinal GeneralPurposeBit gpFlag = GeneralPurposeBit.parse(LFH_BUF, off);\nfinal boolean hasUTF8Flag = gpFlag.usesUTF8ForNames();\nfinal ZipEncoding entryEncoding = hasUTF8Flag ? ZipEncodingHelper.UTF8_ZIP_ENCODING : zipEncoding;\ncurrent.hasDataDescriptor = gpFlag.usesDataDescriptor();\ncurrent.entry.setGeneralPurposeBit(gpFlag);\n\noff += SHORT;\n\ncurrent.entry.setMethod(ZipShort.getValue(LFH_BUF, off));\noff += SHORT;\n\nlong time = ZipUtil.dosToJavaTime(ZipLong.getValue(LFH_BUF, off));\ncurrent.entry.setTime(time);\noff += WORD;\n\nZipLong size = null, cSize = null;\nif (!current.hasDataDescriptor) {\ncurrent.entry.setCrc(ZipLong.getValue(LFH_BUF, off));\noff += WORD;\n\ncSize = new ZipLong(LFH_BUF, off);\noff += WORD;\n\nsize = new ZipLong(LFH_BUF, off);\noff += WORD;\n} else {\noff += 3 * WORD;\n}\n\nint fileNameLen = ZipShort.getValue(LFH_BUF, off);\n\noff += SHORT;\n\nint extraLen = ZipShort.getValue(LFH_BUF, off);\noff += SHORT;\n\nbyte[] fileName = new byte[fileNameLen];\nreadFully(fileName);\ncurrent.entry.setName(entryEncoding.decode(fileName), fileName);\n\nbyte[] extraData = new byte[extraLen];\nreadFully(extraData);\ncurrent.entry.setExtra(extraData);\n\nif (!hasUTF8Flag && useUnicodeExtraFields) {\nZipUtil.setNameAndCommentFromExtraFields(current.entry, fileName, null);\n}\n\nprocessZip64Extra(size, cSize);\n\nif (current.entry.getCompressedSize() != -1) {\nif (current.entry.getMethod() == ZipMethod.UNSHRINKING.getCode()) {\ncurrent.in = new UnshrinkingInputStream(new BoundedInputStream(in, current.entry.getCompressedSize()));\n} else if (current.entry.getMethod() == ZipMethod.IMPLODING.getCode()) {\ncurrent.in = new ExplodingInputStream(\ncurrent.entry.getGeneralPurposeBit().getSlidingDictionarySize(),\ncurrent.entry.getGeneralPurposeBit().getNumberOfShannonFanoTrees(),\nnew BoundedInputStream(in, current.entry.getCompressedSize()));\n}\n}\n\nentriesRead++;\nreturn current.entry;\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ExtraFieldUtils:register(Ljava/lang/Class;)V",
            "method_body": "public static void register(Class<?> c) {\ntry {\nZipExtraField ze = (ZipExtraField) c.newInstance();\nimplementations.put(ze.getHeaderId(), c);\n} catch (ClassCastException cc) {\nthrow new RuntimeException(c + \" doesn\\'t implement ZipExtraField\");\n} catch (InstantiationException ie) {\nthrow new RuntimeException(c + \" is not a concrete class\");\n} catch (IllegalAccessException ie) {\nthrow new RuntimeException(c + \"\\'s no-arg constructor is not public\");\n}\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:getExtraField(Lorg/apache/commons/compress/archivers/zip/ZipShort;)Lorg/apache/commons/compress/archivers/zip/ZipExtraField;",
            "method_body": "public ZipExtraField getExtraField(ZipShort type) {\nif (extraFields != null) {\nreturn extraFields.get(type);\n}\nreturn null;\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
            "method_body": "public ZipLong(long value) {\nthis.value = value;\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:hashCode()I",
            "method_body": "public int hashCode() {\nreturn value;\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
            "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
            "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data decsriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(ByteArrayOutputStream bos, int offset, int lastRead, int expectedDDLen)\nthrows IOException {\n\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\nif ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n|| (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\nbos.write(buf.array(), 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.AsiExtraField:<init>()V",
            "method_body": "public AsiExtraField() {\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<clinit>()V",
            "method_body": "private static final ZipShort HEADER_ID = new ZipShort(0x7875);\nprivate static final BigInteger ONE_THOUSAND = BigInteger.valueOf(1000);\nprivate static final long serialVersionUID = 1L;\n\nprivate int version = 1; // always '1' according to current info-zip spec.\n\n// BigInteger helps us with little-endian / big-endian conversions.\n// (thanks to BigInteger.toByteArray() and a reverse() method we created).\n// Also, the spec theoretically allows UID/GID up to 255 bytes long!\n//\n// NOTE:  equals() and hashCode() currently assume these can never be null.\nprivate BigInteger uid;\nprivate BigInteger gid;\n\n/**\n* Constructor for X7875_NewUnix.\n*/\npublic X7875_NewUnix() {\nreset();\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<init>(Ljava/io/InputStream;Ljava/lang/String;Z)V",
            "method_body": "public ZipArchiveInputStream(InputStream inputStream, String encoding, boolean useUnicodeExtraFields) {\nthis(inputStream, encoding, useUnicodeExtraFields, false);\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:close()V",
            "method_body": "public void close() throws IOException {\nif (!closed) {\nclosed = true;\nin.close();\ninf.end();\n}\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:signedByteToUnsignedInt(B)I",
            "method_body": "public static int signedByteToUnsignedInt(byte b) {\nif (b >= 0) {\nreturn b;\n} else {\nreturn 256 + b;\n}\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:setNameAndCommentFromExtraFields(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;[B[B)V",
            "method_body": "static void setNameAndCommentFromExtraFields(ZipArchiveEntry ze,\nbyte[] originalNameBytes,\nbyte[] commentBytes) {\nUnicodePathExtraField name = (UnicodePathExtraField)\nze.getExtraField(UnicodePathExtraField.UPATH_ID);\nString originalName = ze.getName();\nString newName = getUnicodeStringIfOriginalMatches(name,\noriginalNameBytes);\nif (newName != null && !originalName.equals(newName)) {\nze.setName(newName);\n}\n\nif (commentBytes != null && commentBytes.length > 0) {\nUnicodeCommentExtraField cmt = (UnicodeCommentExtraField)\nze.getExtraField(UnicodeCommentExtraField.UCOM_ID);\nString newComment =\ngetUnicodeStringIfOriginalMatches(cmt, commentBytes);\nif (newComment != null) {\nze.setComment(newComment);\n}\n}\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:<init>()V",
            "method_body": "public X7875_NewUnix() {\nreset();\n}",
            "method_id": 119
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X5455_ExtendedTimestamp:getLocalFileDataLength()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getLocalFileDataLength() {\nreturn new ZipShort(1 +\n(bit0_modifyTimePresent ? 4 : 0) +\n(bit1_accessTimePresent && accessTime != null ? 4 : 0) +\n(bit2_createTimePresent && createTime != null ? 4 : 0)\n);\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.Zip64ExtendedInformationExtraField:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveEntry:setGeneralPurposeBit(Lorg/apache/commons/compress/archivers/zip/GeneralPurposeBit;)V",
            "method_body": "public void setGeneralPurposeBit(GeneralPurposeBit b) {\ngpb = b;\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.X7875_NewUnix:getHeaderId()Lorg/apache/commons/compress/archivers/zip/ZipShort;",
            "method_body": "public ZipShort getHeaderId() {\nreturn HEADER_ID;\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipUtil:supportsEncryptionOf(Lorg/apache/commons/compress/archivers/zip/ZipArchiveEntry;)Z",
            "method_body": "private static boolean supportsEncryptionOf(ZipArchiveEntry entry) {\nreturn !entry.getGeneralPurposeBit().usesEncryption();\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipShort:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(Object o) {\nif (o == null || !(o instanceof ZipShort)) {\nreturn false;\n}\nreturn value == ((ZipShort) o).getValue();\n}",
            "method_id": 125
        }
    ]
}