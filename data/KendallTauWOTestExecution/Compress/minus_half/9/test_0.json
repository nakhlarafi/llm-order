{
    "bug_id": 9,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStreamTest.testCount",
    "test_body": "public void testCount() throws Exception {\nFile f = File.createTempFile(\"commons-compress-tarcount\", \".tar\");\nf.deleteOnExit();\nFileOutputStream fos = new FileOutputStream(f);\nArchiveOutputStream tarOut = new ArchiveStreamFactory()\n.createArchiveOutputStream(ArchiveStreamFactory.TAR, fos);\nFile file1 = getFile(\"test1.xml\");\nTarArchiveEntry sEntry = new TarArchiveEntry(file1);\ntarOut.putArchiveEntry(sEntry);\nFileInputStream in = new FileInputStream(file1);\nbyte[] buf = new byte[8192];\nint read = 0;\nwhile ((read = in.read(buf)) > 0) {\ntarOut.write(buf, 0, read);\n}\nin.close();\ntarOut.closeArchiveEntry();\ntarOut.close();\nassertEquals(f.length(), tarOut.getBytesWritten());\n}\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;Ljava/lang/String;)V",
            "method_body": "public TarArchiveEntry(File file, String fileName) {\nthis();\n\nthis.file = file;\n\nthis.linkName = \"\";\n\nif (file.isDirectory()) {\nthis.mode = DEFAULT_DIR_MODE;\nthis.linkFlag = LF_DIR;\n\nint nameLength = fileName.length();\nif (nameLength == 0 || fileName.charAt(nameLength - 1) != '/') {\nthis.name = fileName + \"/\";\n} else {\nthis.name = fileName;\n}\nthis.size = 0;\n} else {\nthis.mode = DEFAULT_FILE_MODE;\nthis.linkFlag = LF_NORMAL;\nthis.size = file.length();\nthis.name = fileName;\n}\n\nthis.modTime = file.lastModified() / MILLIS_PER_SECOND;\nthis.devMajor = 0;\nthis.devMinor = 0;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(I)V",
            "method_body": "protected void count(int written) {\ncount((long) written);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatOctalBytes(J[BII)I",
            "method_body": "public static int formatOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-2; // For space and trailing null\nformatUnsignedOctalString(value, buf, offset, idx);\n\nbuf[offset + idx++] = (byte) ' '; // Trailing space\nbuf[offset + idx]   = 0; // Trailing null\n\nreturn offset + length;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:count(J)V",
            "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten = bytesWritten + written;\n}\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;II)V",
            "method_body": "public TarArchiveOutputStream(OutputStream os, int blockSize, int recordSize) {\nout = new CountingOutputStream(os);\n\nthis.buffer = new TarBuffer(out, blockSize, recordSize);\nthis.assemLen = 0;\nthis.assemBuf = new byte[recordSize];\nthis.recordBuf = new byte[recordSize];\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
            "method_body": "public long getSize() {\nreturn size;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
            "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:computeCheckSum([B)J",
            "method_body": "public static long computeCheckSum(final byte[] buf) {\nlong sum = 0;\n\nfor (int i = 0; i < buf.length; ++i) {\nsum += BYTE_MASK & buf[i];\n}\n\nreturn sum;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:write([BII)V",
            "method_body": "public void write(byte[] b, int off, int len) throws IOException {\nout.write(b, off, len);\ncount(len);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatUnsignedOctalString(J[BII)V",
            "method_body": "public static void formatUnsignedOctalString(final long value, byte[] buffer,\nfinal int offset, final int length) {\nint remaining = length;\nremaining--;\nif (value == 0) {\nbuffer[offset + remaining--] = (byte) '0';\n} else {\nlong val = value;\nfor (; remaining >= 0 && val != 0; --remaining) {\n// CheckStyle:MagicNumber OFF\nbuffer[offset + remaining] = (byte) ((byte) '0' + (byte) (val & 7));\nval = val >>> 3;\n// CheckStyle:MagicNumber ON\n}\nif (val != 0){\nthrow new IllegalArgumentException\n(value+\"=\"+Long.toOctalString(value)+ \" will not fit in octal number buffer of length \"+length);\n}\n}\n\nfor (; remaining >= 0; --remaining) { // leading zeros\nbuffer[offset + remaining] = (byte) '0';\n}\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:getBytesWritten()J",
            "method_body": "public long getBytesWritten() {\nreturn bytesWritten;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:<init>(Ljava/io/OutputStream;)V",
            "method_body": "public CountingOutputStream(final OutputStream out) {\nsuper(out);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveOutputStream:<init>()V",
            "method_body": "private final byte[] oneByte = new byte[1];\nprivate long bytesWritten = 0;\n* {@link #closeArchiveEntry()} to complete the process.",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatCheckSumOctalBytes(J[BII)I",
            "method_body": "public static int formatCheckSumOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-2; // for NUL and space\nformatUnsignedOctalString(value, buf, offset, idx);\n\nbuf[offset + idx++]   = 0; // Trailing null\nbuf[offset + idx]     = (byte) ' '; // Trailing space\n\nreturn offset + length;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:writeEOFRecord()V",
            "method_body": "private void writeEOFRecord() throws IOException {\nfor (int i = 0; i < recordBuf.length; ++i) {\nrecordBuf[i] = 0;\n}\n\nbuffer.writeRecord(recordBuf);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:initialize(II)V",
            "method_body": "private void initialize(int blockSize, int recordSize) {\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\n\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n} else {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:write([BII)V",
            "method_body": "public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {\nif ((currBytes + numToWrite) > currSize) {\nthrow new IOException(\"request to write '\" + numToWrite\n+ \"' bytes exceeds size in header of '\"\n+ currSize + \"' bytes for entry '\"\n+ currName + \"'\");\n\n//\n// We have to deal with assembly!!!\n// The programmer can be writing little 32 byte chunks for all\n// we know, and we must assemble complete records for writing.\n// REVIEW Maybe this should be in TarBuffer? Could that help to\n// eliminate some of the buffer copying.\n//\n}\n\nif (assemLen > 0) {\nif ((assemLen + numToWrite) >= recordBuf.length) {\nint aLen = recordBuf.length - assemLen;\n\nSystem.arraycopy(assemBuf, 0, recordBuf, 0,\nassemLen);\nSystem.arraycopy(wBuf, wOffset, recordBuf,\nassemLen, aLen);\nbuffer.writeRecord(recordBuf);\n\ncurrBytes += recordBuf.length;\nwOffset += aLen;\nnumToWrite -= aLen;\nassemLen = 0;\n} else {\nSystem.arraycopy(wBuf, wOffset, assemBuf, assemLen,\nnumToWrite);\n\nwOffset += numToWrite;\nassemLen += numToWrite;\nnumToWrite = 0;\n}\n}\n\n//\n// When we get here we have EITHER:\n// o An empty \"assemble\" buffer.\n// o No bytes to write (numToWrite == 0)\n//\nwhile (numToWrite > 0) {\nif (numToWrite < recordBuf.length) {\nSystem.arraycopy(wBuf, wOffset, assemBuf, assemLen,\nnumToWrite);\n\nassemLen += numToWrite;\n\nbreak;\n}\n\nbuffer.writeRecord(wBuf, wOffset);\n\nint num = recordBuf.length;\n\ncurrBytes += num;\nnumToWrite -= num;\nwOffset += num;\n}\ncount(numToWrite);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn name.toString();\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatNameBytes(Ljava/lang/String;[BII)I",
            "method_body": "public static int formatNameBytes(String name, byte[] buf, final int offset, final int length) {\nint i;\n\n// copy until end of input or output is reached.\nfor (i = 0; i < length && i < name.length(); ++i) {\nbuf[offset + i] = (byte) name.charAt(i);\n}\n\n// Pad any remaining output bytes with NUL\nfor (; i < length; ++i) {\nbuf[offset + i] = 0;\n}\n\nreturn offset + length;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:writeBlock()V",
            "method_body": "private void writeBlock() throws IOException {\nif (outStream == null) {\nthrow new IOException(\"writing to an input buffer\");\n}\n\noutStream.write(blockBuffer, 0, blockSize);\noutStream.flush();\n\ncurrRecIdx = 0;\ncurrBlkIdx++;\nArrays.fill(blockBuffer, (byte) 0);\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveOutputStream(Ljava/lang/String;Ljava/io/OutputStream;)Lorg/apache/commons/compress/archivers/ArchiveOutputStream;",
            "method_body": "public ArchiveOutputStream createArchiveOutputStream(\nfinal String archiverName, final OutputStream out)\nthrows ArchiveException {\nif (archiverName == null) {\nthrow new IllegalArgumentException(\"Archivername must not be null.\");\n}\nif (out == null) {\nthrow new IllegalArgumentException(\"OutputStream must not be null.\");\n}\n\nif (AR.equalsIgnoreCase(archiverName)) {\nreturn new ArArchiveOutputStream(out);\n}\nif (ZIP.equalsIgnoreCase(archiverName)) {\nreturn new ZipArchiveOutputStream(out);\n}\nif (TAR.equalsIgnoreCase(archiverName)) {\nreturn new TarArchiveOutputStream(out);\n}\nif (JAR.equalsIgnoreCase(archiverName)) {\nreturn new JarArchiveOutputStream(out);\n}\nif (CPIO.equalsIgnoreCase(archiverName)) {\nreturn new CpioArchiveOutputStream(out);\n}\nthrow new ArchiveException(\"Archiver: \" + archiverName + \" not found.\");\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:<init>(Ljava/io/OutputStream;)V",
            "method_body": "public TarArchiveOutputStream(OutputStream os) {\nthis(os, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:normalizeFileName(Ljava/lang/String;Z)Ljava/lang/String;",
            "method_body": "private static String normalizeFileName(String fileName,\nboolean preserveLeadingSlashes) {\nString osname = System.getProperty(\"os.name\").toLowerCase(Locale.ENGLISH);\n\nif (osname != null) {\n\n// Strip off drive letters!\n// REVIEW Would a better check be \"(File.separator == '\\')\"?\n\nif (osname.startsWith(\"windows\")) {\nif (fileName.length() > 2) {\nchar ch1 = fileName.charAt(0);\nchar ch2 = fileName.charAt(1);\n\nif (ch2 == ':'\n&& ((ch1 >= 'a' && ch1 <= 'z')\n|| (ch1 >= 'A' && ch1 <= 'Z'))) {\nfileName = fileName.substring(2);\n}\n}\n} else if (osname.indexOf(\"netware\") > -1) {\nint colon = fileName.indexOf(':');\nif (colon != -1) {\nfileName = fileName.substring(colon + 1);\n}\n}\n}\n\nfileName = fileName.replace(File.separatorChar, '/');\n\n// No absolute pathnames\n// Windows (and Posix?) paths can start with \"\\\\NetworkDrive\\\",\n// so we loop on starting /'s.\nwhile (!preserveLeadingSlashes && fileName.startsWith(\"/\")) {\nfileName = fileName.substring(1);\n}\nreturn fileName;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:formatLongOctalBytes(J[BII)I",
            "method_body": "public static int formatLongOctalBytes(final long value, byte[] buf, final int offset, final int length) {\n\nint idx=length-1; // For space\n\nformatUnsignedOctalString(value, buf, offset, idx);\nbuf[offset + idx] = (byte) ' '; // Trailing space\n\nreturn offset + length;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>(Ljava/io/File;)V",
            "method_body": "public TarArchiveEntry(File file) {\nthis(file, normalizeFileName(file.getPath(), false));\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:close()V",
            "method_body": "public void close() throws IOException {\nif(!finished) {\nfinish();\n}\n\nif (!closed) {\nbuffer.close();\nout.close();\nclosed = true;\n}\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:writeRecord([B)V",
            "method_body": "public void writeRecord(byte[] record) throws IOException {\nif (outStream == null) {\nif (inStream == null){\nthrow new IOException(\"Output buffer is closed\");\n}\nthrow new IOException(\"writing to an input buffer\");\n}\n\nif (record.length != recordSize) {\nthrow new IOException(\"record to write has length '\"\n+ record.length\n+ \"' which is not the record size of '\"\n+ recordSize + \"'\");\n}\n\nif (currRecIdx >= recsPerBlock) {\nwriteBlock();\n}\n\nSystem.arraycopy(record, 0, blockBuffer,\n(currRecIdx * recordSize),\nrecordSize);\n\ncurrRecIdx++;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:closeArchiveEntry()V",
            "method_body": "public void closeArchiveEntry() throws IOException {\nif(finished) {\nthrow new IOException(\"Stream has already been finished\");\n}\nif (!haveUnclosedEntry){\nthrow new IOException(\"No current entry to close\");\n}\nif (assemLen > 0) {\nfor (int i = assemLen; i < assemBuf.length; ++i) {\nassemBuf[i] = 0;\n}\n\nbuffer.writeRecord(assemBuf);\n\ncurrBytes += assemLen;\nassemLen = 0;\n}\n\nif (currBytes < currSize) {\nthrow new IOException(\"entry '\" + currName + \"' closed at '\"\n+ currBytes\n+ \"' before the '\" + currSize\n+ \"' bytes specified in the header were written\");\n}\nhaveUnclosedEntry = false;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.utils.CountingOutputStream:count(J)V",
            "method_body": "protected void count(long written) {\nif (written != -1) {\nbytesWritten.addAndGet(written);\n}\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:flushBlock()V",
            "method_body": "void flushBlock() throws IOException {\nif (outStream == null) {\nthrow new IOException(\"writing to an input buffer\");\n}\n\nif (currRecIdx > 0) {\nwriteBlock();\n}\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/OutputStream;II)V",
            "method_body": "public TarBuffer(OutputStream outStream, int blockSize, int recordSize) {\nthis.inStream = null;\nthis.outStream = outStream;\n\nthis.initialize(blockSize, recordSize);\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:writeEntryHeader([B)V",
            "method_body": "public void writeEntryHeader(byte[] outbuf) {\nint offset = 0;\n\noffset = TarUtils.formatNameBytes(name, outbuf, offset, NAMELEN);\noffset = TarUtils.formatOctalBytes(mode, outbuf, offset, MODELEN);\noffset = TarUtils.formatOctalBytes(userId, outbuf, offset, UIDLEN);\noffset = TarUtils.formatOctalBytes(groupId, outbuf, offset, GIDLEN);\noffset = TarUtils.formatLongOctalBytes(size, outbuf, offset, SIZELEN);\noffset = TarUtils.formatLongOctalBytes(modTime, outbuf, offset, MODTIMELEN);\n\nint csOffset = offset;\n\nfor (int c = 0; c < CHKSUMLEN; ++c) {\noutbuf[offset++] = (byte) ' ';\n}\n\noutbuf[offset++] = linkFlag;\noffset = TarUtils.formatNameBytes(linkName, outbuf, offset, NAMELEN);\noffset = TarUtils.formatNameBytes(magic, outbuf, offset, MAGICLEN);\noffset = TarUtils.formatNameBytes(version, outbuf, offset, VERSIONLEN);\noffset = TarUtils.formatNameBytes(userName, outbuf, offset, UNAMELEN);\noffset = TarUtils.formatNameBytes(groupName, outbuf, offset, GNAMELEN);\noffset = TarUtils.formatOctalBytes(devMajor, outbuf, offset, DEVLEN);\noffset = TarUtils.formatOctalBytes(devMinor, outbuf, offset, DEVLEN);\n\nwhile (offset < outbuf.length) {\noutbuf[offset++] = 0;\n}\n\nlong chk = TarUtils.computeCheckSum(outbuf);\n\nTarUtils.formatCheckSumOctalBytes(chk, outbuf, csOffset, CHKSUMLEN);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:putArchiveEntry(Lorg/apache/commons/compress/archivers/ArchiveEntry;)V",
            "method_body": "public void putArchiveEntry(ArchiveEntry archiveEntry) throws IOException {\nif(finished) {\nthrow new IOException(\"Stream has already been finished\");\n}\nTarArchiveEntry entry = (TarArchiveEntry) archiveEntry;\nif (entry.getName().length() >= TarConstants.NAMELEN) {\n\nif (longFileMode == LONGFILE_GNU) {\n// create a TarEntry for the LongLink, the contents\n// of which are the entry's name\nTarArchiveEntry longLinkEntry = new TarArchiveEntry(TarConstants.GNU_LONGLINK,\nTarConstants.LF_GNUTYPE_LONGNAME);\n\nfinal byte[] nameBytes = ArchiveUtils.toAsciiBytes(entry.getName());\nlongLinkEntry.setSize(nameBytes.length + 1); // +1 for NUL\nputArchiveEntry(longLinkEntry);\nwrite(nameBytes);\nwrite(0); // NUL terminator\ncloseArchiveEntry();\n} else if (longFileMode != LONGFILE_TRUNCATE) {\nthrow new RuntimeException(\"file name '\" + entry.getName()\n+ \"' is too long ( > \"\n+ TarConstants.NAMELEN + \" bytes)\");\n}\n}\n\nentry.writeEntryHeader(recordBuf);\nbuffer.writeRecord(recordBuf);\n\ncurrBytes = 0;\n\nif (entry.isDirectory()) {\ncurrSize = 0;\n} else {\ncurrSize = entry.getSize();\n}\ncurrName = entry.getName();\nhaveUnclosedEntry = true;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
            "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\n\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveOutputStream:finish()V",
            "method_body": "public void finish() throws IOException {\nif (finished) {\nthrow new IOException(\"This archive has already been finished\");\n}\n\nif(haveUnclosedEntry) {\nthrow new IOException(\"This archives contains unclosed entries.\");\n}\nwriteEOFRecord();\nwriteEOFRecord();\nbuffer.flushBlock();\nfinished = true;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:close()V",
            "method_body": "public void close() throws IOException {\nif (outStream != null) {\nflushBlock();\n\nif (outStream != System.out\n&& outStream != System.err) {\noutStream.close();\n\noutStream = null;\n}\n} else if (inStream != null) {\nif (inStream != System.in) {\ninStream.close();\n}\ninStream = null;\n}\n}",
            "method_id": 35
        }
    ]
}