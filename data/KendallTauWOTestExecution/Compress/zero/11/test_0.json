{
    "bug_id": 11,
    "test_id": 0,
    "test_name": "org.apache.commons.compress.archivers.ArchiveStreamFactoryTest.shortTextFilesAreNoTARs",
    "test_body": "public void shortTextFilesAreNoTARs() throws Exception {\ntry {\nnew ArchiveStreamFactory()\n.createArchiveInputStream(new ByteArrayInputStream(\"This certainly is not a tar archive, really, no kidding\".getBytes()));\nfail(\"created an input stream for a non-archive\");\n} catch (ArchiveException ae) {\nassertTrue(ae.getMessage().startsWith(\"No Archiver found\"));\n}\n}\n",
    "stack_trace": "",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextEntry()Lorg/apache/commons/compress/archivers/ArchiveEntry;",
            "method_body": "public ArchiveEntry getNextEntry() throws IOException {\nreturn getNextTarEntry();\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:evaluateType([B)I",
            "method_body": "private int evaluateType(byte[] header) {\nfinal ByteBuffer magic = ByteBuffer.wrap(header, MAGIC_OFFSET, MAGICLEN);\nif (magic.compareTo(ByteBuffer.wrap(MAGIC_GNU.getBytes())) == 0)\nreturn FORMAT_OLDGNU;\nif (magic.compareTo(ByteBuffer.wrap(MAGIC_POSIX.getBytes())) == 0)\nreturn FORMAT_POSIX;\nreturn 0;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveOutputStream:<clinit>()V",
            "method_body": "public static final int EFS_FLAG = GeneralPurposeBit.UFT8_NAMES_FLAG;\n\n/**\n* Current entry.\n*/\nprivate CurrentEntry entry;\n\n/**\n* The file comment.\n*/\nprivate String comment = \"\";\n\n/**\n* Compression level for next entry.\n*/\nprivate int level = DEFAULT_COMPRESSION;\n\n/**\n* Has the compression level changed when compared to the last\n* entry?\n*/\nprivate boolean hasCompressionLevelChanged = false;\n\n/**\n* Default compression method for next entry.\n*/\nprivate int method = java.util.zip.ZipEntry.DEFLATED;\n\n/**\n* List of ZipArchiveEntries written so far.\n*/\nprivate final List<ZipArchiveEntry> entries =\nnew LinkedList<ZipArchiveEntry>();\n\n/**\n* CRC instance to avoid parsing DEFLATED data twice.\n*/\nprivate final CRC32 crc = new CRC32();\n\n/**\n* Count the bytes written to out.\n*/\nprivate long written = 0;\n\n/**\n* Start of central directory.\n*/\nprivate long cdOffset = 0;\n\n/**\n* Length of central directory.\n*/\nprivate long cdLength = 0;\n\n/**\n* Helper, a 0 as ZipShort.\n*/\nprivate static final byte[] ZERO = {0, 0};",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readBlock()Z",
            "method_body": "private boolean readBlock() throws IOException {\nif (inStream == null) {\nthrow new IOException(\"reading from an output buffer\");\n}\n\ncurrRecIdx = 0;\n\nint offset = 0;\nint bytesNeeded = blockSize;\n\nwhile (bytesNeeded > 0) {\nlong numBytes = inStream.read(blockBuffer, offset,\nbytesNeeded);\n\n//\n// NOTE\n// We have fit EOF, and the block is not full!\n//\n// This is a broken archive. It does not follow the standard\n// blocking algorithm. However, because we are generous, and\n// it requires little effort, we will simply ignore the error\n// and continue as if the entire block were read. This does\n// not appear to break anything upstream. We used to return\n// false in this case.\n//\n// Thanks to 'Yohann.Roussel@alcatel.fr' for this fix.\n//\nif (numBytes == -1) {\nif (offset == 0) {\n// Ensure that we do not read gigabytes of zeros\n// for a corrupt tar file.\n// See http://issues.apache.org/bugzilla/show_bug.cgi?id=39924\nreturn false;\n}\n// However, just leaving the unread portion of the buffer dirty does\n// cause problems in some cases.  This problem is described in\n// http://issues.apache.org/bugzilla/show_bug.cgi?id=29877\n//\n// The solution is to fill the unused portion of the buffer with zeros.\n\nArrays.fill(blockBuffer, offset, offset + bytesNeeded, (byte) 0);\n\nbreak;\n}\n\noffset += numBytes;\nbytesNeeded -= numBytes;\n\nif (numBytes != blockSize) {\n// TODO: Incomplete Read occured - throw exception?\n}\n}\n\ncurrBlkIdx++;\n\nreturn true;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctal([BII)J",
            "method_body": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\nlong    result = 0;\nint     end = offset + length;\nint     start = offset;\n\nif (length < 2){\nthrow new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n}\n\nboolean allNUL = true;\nfor (int i = start; i < end; i++){\nif (buffer[i] != 0){\nallNUL = false;\nbreak;\n}\n}\nif (allNUL) {\nreturn 0L;\n}\n\n// Skip leading spaces\nwhile (start < end){\nif (buffer[start] == ' '){\nstart++;\n} else {\nbreak;\n}\n}\n\n// Must have trailing NUL or space\nbyte trailer;\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\n} else {\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, end-1, trailer));\n}\n// May have additional NUL or space\ntrailer = buffer[end-1];\nif (trailer == 0 || trailer == ' '){\nend--;\n}\n\nfor ( ;start < end; start++) {\nfinal byte currentByte = buffer[start];\n// CheckStyle:MagicNumber OFF\nif (currentByte < '0' || currentByte > '7'){\nthrow new IllegalArgumentException(\nexceptionMessage(buffer, offset, length, start, currentByte));\n}\nresult = (result << 3) + (currentByte - '0'); // convert from ASCII\n// CheckStyle:MagicNumber ON\n}\n\nreturn result;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseName([BII)Ljava/lang/String;",
            "method_body": "public static String parseName(byte[] buffer, final int offset, final int length) {\nStringBuffer result = new StringBuffer(length);\nint          end = offset + length;\n\nfor (int i = offset; i < end; ++i) {\nbyte b = buffer[i];\nif (b == 0) { // Trailing null\nbreak;\n}\nresult.append((char) (b & 0xFF)); // Allow for sign-extension\n}\n\nreturn result.toString();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>()V",
            "method_body": "private TarArchiveEntry () {\nthis.magic = MAGIC_POSIX;\nthis.version = VERSION_POSIX;\nthis.name = \"\";\nthis.linkName = \"\";\n\nString user = System.getProperty(\"user.name\", \"\");\n\nif (user.length() > MAX_NAMELEN) {\nuser = user.substring(0, MAX_NAMELEN);\n}\n\nthis.userId = 0;\nthis.groupId = 0;\nthis.userName = user;\nthis.groupName = \"\";\nthis.file = null;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes(J)[B",
            "method_body": "public static byte[] getBytes(long value) {\nbyte[] result = new byte[WORD];\nresult[0] = (byte) ((value & BYTE_MASK));\nresult[BYTE_1] = (byte) ((value & BYTE_1_MASK) >> BYTE_1_SHIFT);\nresult[BYTE_2] = (byte) ((value & BYTE_2_MASK) >> BYTE_2_SHIFT);\nresult[BYTE_3] = (byte) ((value & BYTE_3_MASK) >> BYTE_3_SHIFT);\nreturn result;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.cpio.CpioArchiveInputStream:matches([BI)Z",
            "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < 6) {\nreturn false;\n}\n\n// Check binary values\nif (signature[0] == 0x71 && (signature[1] & 0xFF) == 0xc7) {\nreturn true;\n}\nif (signature[1] == 0x71 && (signature[0] & 0xFF) == 0xc7) {\nreturn true;\n}\n\n// Check Ascii (String) values\n// 3037 3037 30nn\nif (signature[0] != 0x30) {\nreturn false;\n}\nif (signature[1] != 0x37) {\nreturn false;\n}\nif (signature[2] != 0x30) {\nreturn false;\n}\nif (signature[3] != 0x37) {\nreturn false;\n}\nif (signature[4] != 0x30) {\nreturn false;\n}\n// Check last byte\nif (signature[5] == 0x31) {\nreturn true;\n}\nif (signature[5] == 0x32) {\nreturn true;\n}\nif (signature[5] == 0x37) {\nreturn true;\n}\n\nreturn false;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:<init>([B)V",
            "method_body": "public TarArchiveEntry(byte[] headerBuf) {\nthis();\nparseTarHeader(headerBuf);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:<init>(Ljava/io/InputStream;II)V",
            "method_body": "public TarBuffer(InputStream inStream, int blockSize, int recordSize) {\nthis.inStream = inStream;\nthis.outStream = null;\n\nthis.initialize(blockSize, recordSize);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getName()Ljava/lang/String;",
            "method_body": "public String getName() {\nreturn name.toString();\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:checksig([B[B)Z",
            "method_body": "private static boolean checksig(byte[] signature, byte[] expected){\nfor (int i = 0; i < expected.length; i++) {\nif (signature[i] != expected[i]) {\nreturn false;\n}\n}\nreturn true;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:getRecordSize()I",
            "method_body": "public int getRecordSize() {\nreturn this.recordSize;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isDirectory()Z",
            "method_body": "public boolean isDirectory() {\nif (file != null) {\nreturn file.isDirectory();\n}\n\nif (linkFlag == LF_DIR) {\nreturn true;\n}\n\nif (getName().endsWith(\"/\")) {\nreturn true;\n}\n\nreturn false;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ArchiveStreamFactory:createArchiveInputStream(Ljava/io/InputStream;)Lorg/apache/commons/compress/archivers/ArchiveInputStream;",
            "method_body": "public ArchiveInputStream createArchiveInputStream(final InputStream in)\nthrows ArchiveException {\nif (in == null) {\nthrow new IllegalArgumentException(\"Stream must not be null.\");\n}\n\nif (!in.markSupported()) {\nthrow new IllegalArgumentException(\"Mark is not supported.\");\n}\n\nfinal byte[] signature = new byte[12];\nin.mark(signature.length);\ntry {\nint signatureLength = in.read(signature);\nin.reset();\nif (ZipArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ZipArchiveInputStream(in);\n} else if (JarArchiveInputStream.matches(signature, signatureLength)) {\nreturn new JarArchiveInputStream(in);\n} else if (ArArchiveInputStream.matches(signature, signatureLength)) {\nreturn new ArArchiveInputStream(in);\n} else if (CpioArchiveInputStream.matches(signature, signatureLength)) {\nreturn new CpioArchiveInputStream(in);\n}\n\n// Dump needs a bigger buffer to check the signature;\nfinal byte[] dumpsig = new byte[32];\nin.mark(dumpsig.length);\nsignatureLength = in.read(dumpsig);\nin.reset();\nif (DumpArchiveInputStream.matches(dumpsig, signatureLength)) {\nreturn new DumpArchiveInputStream(in);\n}\n\n// Tar needs an even bigger buffer to check the signature; read the first block\nfinal byte[] tarheader = new byte[512];\nin.mark(tarheader.length);\nsignatureLength = in.read(tarheader);\nin.reset();\nif (TarArchiveInputStream.matches(tarheader, signatureLength)) {\nreturn new TarArchiveInputStream(in);\n}\n// COMPRESS-117 - improve auto-recognition\ntry {\nTarArchiveInputStream tais = new TarArchiveInputStream(new ByteArrayInputStream(tarheader));\ntais.getNextEntry();\nreturn new TarArchiveInputStream(in);\n} catch (Exception e) { // NOPMD\n// can generate IllegalArgumentException as well as IOException\n// autodetection, simply not a TAR\n// ignored\n}\n} catch (IOException e) {\nthrow new ArchiveException(\"Could not use reset and mark operations.\", e);\n}\n\nthrow new ArchiveException(\"No Archiver found for the stream signature\");\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:isEOFRecord([B)Z",
            "method_body": "public boolean isEOFRecord(byte[] record) {\nfor (int i = 0, sz = getRecordSize(); i < sz; ++i) {\nif (record[i] != 0) {\nreturn false;\n}\n}\n\nreturn true;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:matches([BI)Z",
            "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < ZipArchiveOutputStream.LFH_SIG.length) {\nreturn false;\n}\n\nreturn checksig(signature, ZipArchiveOutputStream.LFH_SIG) // normal file\n|| checksig(signature, ZipArchiveOutputStream.EOCD_SIG); // empty zip\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNUSparse()Z",
            "method_body": "public boolean isGNUSparse() {\nreturn linkFlag == LF_GNUTYPE_SPARSE;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:getBytes()[B",
            "method_body": "public byte[] getBytes() {\nreturn ZipLong.getBytes(value);\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:<clinit>()V",
            "method_body": "static final String BSD_LONGNAME_PREFIX = \"#1/\";\nprivate static final int BSD_LONGNAME_PREFIX_LEN =\nBSD_LONGNAME_PREFIX.length();\nprivate static final String BSD_LONGNAME_PATTERN =\n\"^\" + BSD_LONGNAME_PREFIX + \"\\\\d+\";\n\n/**\n* Does the name look like it is a long name (or a name containing\n* spaces) as encoded by BSD ar?\n*\n* <p>From the FreeBSD ar(5) man page:</p>\n* <pre>\n* BSD   In the BSD variant, names that are shorter than 16\n*\t     characters and without embedded spaces are stored\n*\t     directly in this field.  If a name has an embedded\n*\t     space, or if it is longer than 16 characters, then\n*\t     the string \"#1/\" followed by the decimal represen-\n*\t     tation of the length of the file name is placed in\n*\t     this field.\tThe actual file name is stored immedi-\n*\t     ately after the archive header.  The content of the\n*\t     archive member follows the file name.  The ar_size\n*\t     field of the header (see below) will then hold the\n*\t     sum of the size of the file name and the size of\n*\t     the member.\n* </pre>\n*\n* @since Apache Commons Compress 1.3\n*/\nprivate static boolean isBSDLongName(String name) {\nreturn name != null && name.matches(BSD_LONGNAME_PATTERN);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.jar.JarArchiveInputStream:matches([BI)Z",
            "method_body": "public static boolean matches(byte[] signature, int length ) {\nreturn ZipArchiveInputStream.matches(signature, length);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipArchiveInputStream:<clinit>()V",
            "method_body": "private static final byte[] LFH = ZipLong.LFH_SIG.getBytes();\nprivate static final byte[] CFH = ZipLong.CFH_SIG.getBytes();\nprivate static final byte[] DD = ZipLong.DD_SIG.getBytes();\n\n/**\n* Checks whether the current buffer contains the signature of a\n* &quot;data decsriptor&quot;, &quot;local file header&quot; or\n* &quot;central directory entry&quot;.\n*\n* <p>If it contains such a signature, reads the data descriptor\n* and positions the stream right after the data descriptor.</p>\n*/\nprivate boolean bufferContainsSignature(ByteArrayOutputStream bos,\nint offset, int lastRead,\nint expectedDDLen)\nthrows IOException {\nboolean done = false;\nint readTooMuch = 0;\nfor (int i = 0; !done && i < lastRead - 4; i++) {\nif (buf.buf[i] == LFH[0] && buf.buf[i + 1] == LFH[1]) {\nif ((buf.buf[i + 2] == LFH[2] && buf.buf[i + 3] == LFH[3])\n|| (buf.buf[i] == CFH[2] && buf.buf[i + 3] == CFH[3])) {\n// found a LFH or CFH:\nreadTooMuch = offset + lastRead - i - expectedDDLen;\ndone = true;\n}\nelse if (buf.buf[i + 2] == DD[2] && buf.buf[i + 3] == DD[3]) {\n// found DD:\nreadTooMuch = offset + lastRead - i;\ndone = true;\n}\nif (done) {\n// * push back bytes read in excess as well as the data\n//   descriptor\n// * copy the remaining bytes to cache\n// * read data descriptor\npushback(buf.buf, offset + lastRead - readTooMuch,\nreadTooMuch);\nbos.write(buf.buf, 0, i);\nreadDataDescriptor();\n}\n}\n}\nreturn done;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getRecord()[B",
            "method_body": "private byte[] getRecord() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nbyte[] headerBuf = buffer.readRecord();\n\nif (headerBuf == null) {\nhasHitEOF = true;\n} else if (buffer.isEOFRecord(headerBuf)) {\nhasHitEOF = true;\n}\n\nreturn hasHitEOF ? null : headerBuf;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<clinit>()V",
            "method_body": "private static final int BYTE_1 = 1;\nprivate static final int BYTE_1_MASK = 0xFF00;\nprivate static final int BYTE_1_SHIFT = 8;\n\nprivate static final int BYTE_2 = 2;\nprivate static final int BYTE_2_MASK = 0xFF0000;\nprivate static final int BYTE_2_SHIFT = 16;\n\nprivate static final int BYTE_3 = 3;\nprivate static final long BYTE_3_MASK = 0xFF000000L;\nprivate static final int BYTE_3_SHIFT = 24;\n\nprivate final long value;\n\n/** Central File Header Signature */\npublic static final ZipLong CFH_SIG = new ZipLong(0X02014B50L);\n\n/** Local File Header Signature */\npublic static final ZipLong LFH_SIG = new ZipLong(0X04034B50L);\n\n/**\n* Data Descriptor signature\n* @since Apache Commons Compress 1.1\n*/\npublic static final ZipLong DD_SIG = new ZipLong(0X08074B50L);\n\n/**\n* Value stored in size and similar fields if ZIP64 extensions are\n* used.\n* @since Apache Commons Compress 1.3\n*/\nstatic final ZipLong ZIP64_MAGIC = new ZipLong(ZipConstants.ZIP64_MAGIC);\n\n/**\n* Create instance from a number.\n* @param value the long to store as a ZipLong\n*/\npublic ZipLong(long value) {\nthis.value = value;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;)V",
            "method_body": "public TarArchiveInputStream(InputStream is) {\nthis(is, TarBuffer.DEFAULT_BLKSIZE, TarBuffer.DEFAULT_RCDSIZE);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:parseTarHeader([B)V",
            "method_body": "public void parseTarHeader(byte[] header) {\nint offset = 0;\n\nname = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmode = (int) TarUtils.parseOctal(header, offset, MODELEN);\noffset += MODELEN;\nuserId = (int) TarUtils.parseOctal(header, offset, UIDLEN);\noffset += UIDLEN;\ngroupId = (int) TarUtils.parseOctal(header, offset, GIDLEN);\noffset += GIDLEN;\nsize = TarUtils.parseOctalOrBinary(header, offset, SIZELEN);\noffset += SIZELEN;\nmodTime = TarUtils.parseOctal(header, offset, MODTIMELEN);\noffset += MODTIMELEN;\noffset += CHKSUMLEN;\nlinkFlag = header[offset++];\nlinkName = TarUtils.parseName(header, offset, NAMELEN);\noffset += NAMELEN;\nmagic = TarUtils.parseName(header, offset, MAGICLEN);\noffset += MAGICLEN;\nversion = TarUtils.parseName(header, offset, VERSIONLEN);\noffset += VERSIONLEN;\nuserName = TarUtils.parseName(header, offset, UNAMELEN);\noffset += UNAMELEN;\ngroupName = TarUtils.parseName(header, offset, GNAMELEN);\noffset += GNAMELEN;\ndevMajor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\ndevMinor = (int) TarUtils.parseOctal(header, offset, DEVLEN);\noffset += DEVLEN;\n\nint type = evaluateType(header);\nswitch (type) {\ncase FORMAT_OLDGNU: {\noffset += ATIMELEN_GNU;\noffset += CTIMELEN_GNU;\noffset += OFFSETLEN_GNU;\noffset += LONGNAMESLEN_GNU;\noffset += PAD2LEN_GNU;\noffset += SPARSELEN_GNU;\nisExtended = TarUtils.parseBoolean(header, offset);\noffset += ISEXTENDEDLEN_GNU;\nrealSize = TarUtils.parseOctal(header, offset, REALSIZELEN_GNU);\noffset += REALSIZELEN_GNU;\nbreak;\n}\ncase FORMAT_POSIX:\ndefault: {\nString prefix = TarUtils.parseName(header, offset, PREFIXLEN);\n// SunOS tar -E does not add / to directory names, so fix\n// up to be consistent\nif (isDirectory() && !name.endsWith(\"/\")){\nname = name + \"/\";\n}\nif (prefix.length() > 0){\nname = prefix + \"/\" + name;\n}\n}\n}\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:readRecord()[B",
            "method_body": "public byte[] readRecord() throws IOException {\nif (inStream == null) {\nif (outStream == null) {\nthrow new IOException(\"input buffer is closed\");\n}\nthrow new IOException(\"reading from an output buffer\");\n}\n\nif (currRecIdx >= recsPerBlock && !readBlock()) {\nreturn null;\n}\n\nbyte[] result = new byte[recordSize];\n\nSystem.arraycopy(blockBuffer,\n(currRecIdx * recordSize), result, 0,\nrecordSize);\n\ncurrRecIdx++;\n\nreturn result;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isPaxHeader()Z",
            "method_body": "public boolean isPaxHeader(){\nreturn linkFlag == LF_PAX_EXTENDED_HEADER_LC\n|| linkFlag == LF_PAX_EXTENDED_HEADER_UC;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.zip.ZipLong:<init>(J)V",
            "method_body": "public ZipLong(long value) {\nthis.value = value;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:getSize()J",
            "method_body": "public long getSize() {\nreturn size;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:<init>(Ljava/io/InputStream;II)V",
            "method_body": "public TarArchiveInputStream(InputStream is, int blockSize, int recordSize) {\nthis.buffer = new TarBuffer(is, blockSize, recordSize);\nthis.readBuf = null;\nthis.hasHitEOF = false;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:matches([BI)Z",
            "method_body": "public static boolean matches(byte[] signature, int length) {\nif (length < TarConstants.VERSION_OFFSET+TarConstants.VERSIONLEN) {\nreturn false;\n}\n\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_POSIX,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_POSIX,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n){\nreturn true;\n}\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_GNU,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\n(\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_SPACE,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n||\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_GNU_ZERO,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n)\n){\nreturn true;\n}\n// COMPRESS-107 - recognise Ant tar files\nif (ArchiveUtils.matchAsciiBuffer(TarConstants.MAGIC_ANT,\nsignature, TarConstants.MAGIC_OFFSET, TarConstants.MAGICLEN)\n&&\nArchiveUtils.matchAsciiBuffer(TarConstants.VERSION_ANT,\nsignature, TarConstants.VERSION_OFFSET, TarConstants.VERSIONLEN)\n){\nreturn true;\n}\nreturn false;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveUtil:convert32([BI)I",
            "method_body": "public static final int convert32(byte[] buffer, int offset) {\nint i = 0;\ni = buffer[offset + 3] << 24;\ni += (buffer[offset + 2] << 16) & 0x00FF0000;\ni += (buffer[offset + 1] << 8) & 0x0000FF00;\ni += buffer[offset] & 0x000000FF;\n\nreturn i;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveInputStream:getNextTarEntry()Lorg/apache/commons/compress/archivers/tar/TarArchiveEntry;",
            "method_body": "public TarArchiveEntry getNextTarEntry() throws IOException {\nif (hasHitEOF) {\nreturn null;\n}\n\nif (currEntry != null) {\nlong numToSkip = entrySize - entryOffset;\n\nwhile (numToSkip > 0) {\nlong skipped = skip(numToSkip);\nif (skipped <= 0) {\nthrow new RuntimeException(\"failed to skip current tar entry\");\n}\nnumToSkip -= skipped;\n}\n\nreadBuf = null;\n}\n\nbyte[] headerBuf = getRecord();\n\nif (hasHitEOF) {\ncurrEntry = null;\nreturn null;\n}\n\ncurrEntry = new TarArchiveEntry(headerBuf);\nentryOffset = 0;\nentrySize = currEntry.getSize();\n\nif (currEntry.isGNULongNameEntry()) {\n// read in the name\nStringBuffer longName = new StringBuffer();\nbyte[] buf = new byte[SMALL_BUFFER_SIZE];\nint length = 0;\nwhile ((length = read(buf)) >= 0) {\nlongName.append(new String(buf, 0, length));\n}\ngetNextEntry();\nif (currEntry == null) {\n// Bugzilla: 40334\n// Malformed tar file - long entry name not followed by entry\nreturn null;\n}\n// remove trailing null terminator\nif (longName.length() > 0\n&& longName.charAt(longName.length() - 1) == 0) {\nlongName.deleteCharAt(longName.length() - 1);\n}\ncurrEntry.setName(longName.toString());\n}\n\nif (currEntry.isPaxHeader()){ // Process Pax headers\npaxHeaders();\n}\n\nif (currEntry.isGNUSparse()){ // Process sparse files\nreadGNUSparse();\n}\n\n// If the size of the next element in the archive has changed\n// due to a new size being reported in the posix header\n// information, we update entrySize here so that it contains\n// the correct value.\nentrySize = currEntry.getSize();\nreturn currEntry;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarUtils:parseOctalOrBinary([BII)J",
            "method_body": "public static long parseOctalOrBinary(final byte[] buffer, final int offset,\nfinal int length) {\n\nif ((buffer[offset] & 0x80) == 0) {\nreturn parseOctal(buffer, offset, length);\n}\n\nlong val = buffer[offset] & 0x7f;\nfor (int i = 1; i < length; i++) {\nif (val >= (1L << (63 - 8))) {\nthrow new IllegalArgumentException(\n\"At offset \" + offset + \", \" + length + \" byte \" +\n\"binary number exceeds maximum signed long value\");\n}\nval = (val << 8) + (buffer[offset + i] & 0xff);\n}\nreturn val;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.dump.DumpArchiveInputStream:matches([BI)Z",
            "method_body": "public static boolean matches(byte[] buffer, int length) {\n// do we have enough of the header?\nif (length < 32) {\nreturn false;\n}\n\n// this is the best test\nif (length >= DumpArchiveConstants.TP_SIZE) {\nreturn DumpArchiveUtil.verify(buffer);\n}\n\n// this will work in a pinch.\nreturn DumpArchiveConstants.NFS_MAGIC == DumpArchiveUtil.convert32(buffer,\n24);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarArchiveEntry:isGNULongNameEntry()Z",
            "method_body": "public boolean isGNULongNameEntry() {\nreturn linkFlag == LF_GNUTYPE_LONGNAME\n&& name.toString().equals(GNU_LONGLINK);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.tar.TarBuffer:initialize(II)V",
            "method_body": "private void initialize(int blockSize, int recordSize) {\nthis.blockSize = blockSize;\nthis.recordSize = recordSize;\nthis.recsPerBlock = (this.blockSize / this.recordSize);\nthis.blockBuffer = new byte[this.blockSize];\n\nif (this.inStream != null) {\nthis.currBlkIdx = -1;\nthis.currRecIdx = this.recsPerBlock;\n} else {\nthis.currBlkIdx = 0;\nthis.currRecIdx = 0;\n}\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.compress.archivers.ar.ArArchiveInputStream:matches([BI)Z",
            "method_body": "public static boolean matches(byte[] signature, int length) {\n// 3c21 7261 6863 0a3e\n\nif (length < 8) {\nreturn false;\n}\nif (signature[0] != 0x21) {\nreturn false;\n}\nif (signature[1] != 0x3c) {\nreturn false;\n}\nif (signature[2] != 0x61) {\nreturn false;\n}\nif (signature[3] != 0x72) {\nreturn false;\n}\nif (signature[4] != 0x63) {\nreturn false;\n}\nif (signature[5] != 0x68) {\nreturn false;\n}\nif (signature[6] != 0x3e) {\nreturn false;\n}\nif (signature[7] != 0x0a) {\nreturn false;\n}\n\nreturn true;\n}",
            "method_id": 39
        }
    ]
}