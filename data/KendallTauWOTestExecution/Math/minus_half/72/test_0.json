{
    "bug_id": 72,
    "test_id": 0,
    "test_name": "org.apache.commons.math.analysis.solvers.BrentSolverTest.testRootEndpoints",
    "test_body": "public void testRootEndpoints() throws Exception {\nUnivariateRealFunction f = new SinFunction();\nUnivariateRealSolver solver = new BrentSolver();\n// endpoint is root\ndouble result = solver.solve(f, Math.PI, 4);\nassertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\nresult = solver.solve(f, 3, Math.PI);\nassertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\nresult = solver.solve(f, Math.PI, 4, 3.5);\nassertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\nresult = solver.solve(f, 3, Math.PI, 3.07);\nassertEquals(Math.PI, result, solver.getAbsoluteAccuracy());\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<3.141592653589793> but was:<1.2246467991473532E-16>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:120)\nat junit.framework.Assert.assertEquals(Assert.java:129)\nat junit.framework.TestCase.assertEquals(TestCase.java:288)\nat org.apache.commons.math.analysis.solvers.BrentSolverTest.testRootEndpoints(BrentSolverTest.java:317)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:solve(Lorg/apache/commons/math/analysis/UnivariateRealFunction;DDD)D",
            "method_body": "public double solve(final UnivariateRealFunction f,\nfinal double min, final double max, final double initial)\nthrows MaxIterationsExceededException, FunctionEvaluationException {\n\nclearResult();\nverifySequence(min, initial, max);\n\n// return the initial guess if it is good enough\ndouble yInitial = f.value(initial);\nif (Math.abs(yInitial) <= functionValueAccuracy) {\nsetResult(initial, 0);\nreturn result;\n}\n\n// return the first endpoint if it is good enough\ndouble yMin = f.value(min);\nif (Math.abs(yMin) <= functionValueAccuracy) {\nsetResult(yMin, 0);\nreturn result;\n}\n\n// reduce interval if min and initial bracket the root\nif (yInitial * yMin < 0) {\nreturn solve(f, min, yMin, initial, yInitial, min, yMin);\n}\n\n// return the second endpoint if it is good enough\ndouble yMax = f.value(max);\nif (Math.abs(yMax) <= functionValueAccuracy) {\nsetResult(yMax, 0);\nreturn result;\n}\n\n// reduce interval if initial and max bracket the root\nif (yInitial * yMax < 0) {\nreturn solve(f, initial, yInitial, max, yMax, initial, yInitial);\n}\n\nif (yMin * yMax > 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\nNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n}\n\n// full Brent algorithm starting with provided initial guess\nreturn solve(f, min, yMin, max, yMax, initial, yInitial);\n\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:verifyInterval(DD)V",
            "method_body": "protected void verifyInterval(final double lower, final double upper) {\nif (lower >= upper) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"endpoints do not specify an interval: [{0}, {1}]\",\nlower, upper);\n}\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:solve(Lorg/apache/commons/math/analysis/UnivariateRealFunction;DDDDDD)D",
            "method_body": "private double solve(final UnivariateRealFunction f,\ndouble x0, double y0,\ndouble x1, double y1,\ndouble x2, double y2)\nthrows MaxIterationsExceededException, FunctionEvaluationException {\n\ndouble delta = x1 - x0;\ndouble oldDelta = delta;\n\nint i = 0;\nwhile (i < maximalIterationCount) {\nif (Math.abs(y2) < Math.abs(y1)) {\n// use the bracket point if is better than last approximation\nx0 = x1;\nx1 = x2;\nx2 = x0;\ny0 = y1;\ny1 = y2;\ny2 = y0;\n}\nif (Math.abs(y1) <= functionValueAccuracy) {\n// Avoid division by very small values. Assume\n// the iteration has converged (the problem may\n// still be ill conditioned)\nsetResult(x1, i);\nreturn result;\n}\ndouble dx = x2 - x1;\ndouble tolerance =\nMath.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\nif (Math.abs(dx) <= tolerance) {\nsetResult(x1, i);\nreturn result;\n}\nif ((Math.abs(oldDelta) < tolerance) ||\n(Math.abs(y0) <= Math.abs(y1))) {\n// Force bisection.\ndelta = 0.5 * dx;\noldDelta = delta;\n} else {\ndouble r3 = y1 / y0;\ndouble p;\ndouble p1;\n// the equality test (x0 == x2) is intentional,\n// it is part of the original Brent's method,\n// it should NOT be replaced by proximity test\nif (x0 == x2) {\n// Linear interpolation.\np = dx * r3;\np1 = 1.0 - r3;\n} else {\n// Inverse quadratic interpolation.\ndouble r1 = y0 / y2;\ndouble r2 = y1 / y2;\np = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\np1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n}\nif (p > 0.0) {\np1 = -p1;\n} else {\np = -p;\n}\nif (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\np >= Math.abs(0.5 * oldDelta * p1)) {\n// Inverse quadratic interpolation gives a value\n// in the wrong direction, or progress is slow.\n// Fall back to bisection.\ndelta = 0.5 * dx;\noldDelta = delta;\n} else {\noldDelta = delta;\ndelta = p / p1;\n}\n}\n// Save old X1, Y1\nx0 = x1;\ny0 = y1;\n// Compute new X1, Y1\nif (Math.abs(delta) > tolerance) {\nx1 = x1 + delta;\n} else if (dx > 0.0) {\nx1 = x1 + 0.5 * tolerance;\n} else if (dx <= 0.0) {\nx1 = x1 - 0.5 * tolerance;\n}\ny1 = f.value(x1);\nif ((y1 > 0) == (y2 > 0)) {\nx2 = x0;\ny2 = y0;\ndelta = x1 - x0;\noldDelta = delta;\n}\ni++;\n}\nthrow new MaxIterationsExceededException(maximalIterationCount);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.ConvergingAlgorithmImpl:<init>(ID)V",
            "method_body": "protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\nfinal double defaultAbsoluteAccuracy) {\nthis.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\nthis.defaultRelativeAccuracy = 1.0e-14;\nthis.absoluteAccuracy = defaultAbsoluteAccuracy;\nthis.relativeAccuracy = defaultRelativeAccuracy;\nthis.defaultMaximalIterationCount = defaultMaximalIterationCount;\nthis.maximalIterationCount = defaultMaximalIterationCount;\nthis.iterationCount = 0;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.ConvergingAlgorithmImpl:getAbsoluteAccuracy()D",
            "method_body": "public double getAbsoluteAccuracy() {\nreturn absoluteAccuracy;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:isSequence(DDD)Z",
            "method_body": "protected boolean isSequence(final double start, final double mid, final double end) {\nreturn (start < mid) && (mid < end);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:clearResult()V",
            "method_body": "protected final void clearResult() {\nthis.iterationCount = 0;\nthis.resultComputed = false;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:setResult(DI)V",
            "method_body": "protected final void setResult(final double newResult, final int iterationCount) {\nthis.result         = newResult;\nthis.iterationCount = iterationCount;\nthis.resultComputed = true;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:solve(Lorg/apache/commons/math/analysis/UnivariateRealFunction;DD)D",
            "method_body": "public double solve(final UnivariateRealFunction f,\nfinal double min, final double max)\nthrows MaxIterationsExceededException,\nFunctionEvaluationException {\n\nclearResult();\nverifyInterval(min, max);\n\ndouble ret = Double.NaN;\n\ndouble yMin = f.value(min);\ndouble yMax = f.value(max);\n\n// Verify bracketing\ndouble sign = yMin * yMax;\nif (sign > 0) {\n// check if either value is close to a zero\nif (Math.abs(yMin) <= functionValueAccuracy) {\nsetResult(min, 0);\nret = min;\n} else if (Math.abs(yMax) <= functionValueAccuracy) {\nsetResult(max, 0);\nret = max;\n} else {\n// neither value is close to zero and min and max do not bracket root.\nthrow MathRuntimeException.createIllegalArgumentException(\nNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n}\n} else if (sign < 0){\n// solve using only the first endpoint as initial guess\nret = solve(f, min, yMin, max, yMax, min, yMin);\n} else {\n// either min or max is a root\nif (yMin == 0.0) {\nret = min;\n} else {\nret = max;\n}\n}\n\nreturn ret;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:<init>(ID)V",
            "method_body": "protected UnivariateRealSolverImpl(final int defaultMaximalIterationCount,\nfinal double defaultAbsoluteAccuracy) {\nsuper(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\nthis.defaultFunctionValueAccuracy = 1.0e-15;\nthis.functionValueAccuracy = defaultFunctionValueAccuracy;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:<init>()V",
            "method_body": "public BrentSolver() {\nsuper(100, 1E-6);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:verifySequence(DDD)V",
            "method_body": "protected void verifySequence(final double lower, final double initial, final double upper) {\nif (!isSequence(lower, initial, upper)) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"invalid interval, initial value parameters:  lower={0}, initial={1}, upper={2}\",\nlower, initial, upper);\n}\n}",
            "method_id": 11
        }
    ]
}