{
    "bug_id": 44,
    "test_id": 0,
    "test_name": "org.apache.commons.math.ode.events.EventStateTest.testIssue695",
    "test_body": "public void testIssue695() {\nFirstOrderDifferentialEquations equation = new FirstOrderDifferentialEquations() {\npublic int getDimension() {\nreturn 1;\n}\npublic void computeDerivatives(double t, double[] y, double[] yDot) {\nyDot[0] = 1.0;\n}\n};\nDormandPrince853Integrator integrator = new DormandPrince853Integrator(0.001, 1000, 1.0e-14, 1.0e-14);\nintegrator.addEventHandler(new ResettingEvent(10.99), 0.1, 1.0e-9, 1000);\nintegrator.addEventHandler(new ResettingEvent(11.01), 0.1, 1.0e-9, 1000);\nintegrator.setInitialStepSize(3.0);\ndouble target = 30.0;\ndouble[] y = new double[1];\ndouble tEnd = integrator.integrate(equation, 0.0, y, target, y);\nAssert.assertEquals(target, tEnd, 1.0e-10);\nAssert.assertEquals(32.0, y[0], 1.0e-10);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: going backard in time! (7.796578226186635 < 10.99)\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.apache.commons.math.ode.events.EventStateTest$ResettingEvent.g(EventStateTest.java:120)\nat org.apache.commons.math.ode.events.EventState.evaluateStep(EventState.java:214)\nat org.apache.commons.math.ode.AbstractIntegrator.acceptStep(AbstractIntegrator.java:302)\nat org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator.integrate(EmbeddedRungeKuttaIntegrator.java:296)\nat org.apache.commons.math.ode.AbstractIntegrator.integrate(AbstractIntegrator.java:213)\nat org.apache.commons.math.ode.events.EventStateTest.testIssue695(EventStateTest.java:100)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:addEventHandler(Lorg/apache/commons/math/ode/events/EventHandler;DDI)V",
            "method_body": "public void addEventHandler(final EventHandler handler,\nfinal double maxCheckInterval,\nfinal double convergence,\nfinal int maxIterationCount) {\naddEventHandler(handler, maxCheckInterval, convergence,\nmaxIterationCount,\nnew BracketingNthOrderBrentSolver(convergence, 5));\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:doCopy()Lorg/apache/commons/math/ode/sampling/StepInterpolator;",
            "method_body": "protected StepInterpolator doCopy() {\nreturn new DormandPrince853StepInterpolator(this);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:<init>()V",
            "method_body": "public Incrementor() {\nthis(0);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:addEventHandler(Lorg/apache/commons/math/ode/events/EventHandler;DDILorg/apache/commons/math/analysis/solvers/UnivariateRealSolver;)V",
            "method_body": "public void addEventHandler(final EventHandler handler,\nfinal double maxCheckInterval,\nfinal double convergence,\nfinal int maxIterationCount,\nfinal UnivariateRealSolver solver) {\neventsStates.add(new EventState(handler, maxCheckInterval, convergence,\nmaxIterationCount, solver));\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:max(II)I",
            "method_body": "public static int max(final int a, final int b) {\nreturn (a <= b) ? b : a;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator:<init>(Lorg/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator;)V",
            "method_body": "public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {\n\nsuper(interpolator);\n\nif (interpolator.currentState != null) {\nfinal int dimension = currentState.length;\n\nyDotK = new double[interpolator.yDotK.length][];\nfor (int k = 0; k < interpolator.yDotK.length; ++k) {\nyDotK[k] = new double[dimension];\nSystem.arraycopy(interpolator.yDotK[k], 0,\nyDotK[k], 0, dimension);\n}\n\n} else {\nyDotK = null;\n}\n\n// we cannot keep any reference to the equations in the copy\n// the interpolator should have been finalized before\nintegrator = null;\n\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:getMin()D",
            "method_body": "public double getMin() {\nreturn searchMin;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.ode.ExpandableStatefulODE:getPrimaryMapper()Lorg/apache/commons/math/ode/EquationsMapper;",
            "method_body": "public EquationsMapper getPrimaryMapper() {\nreturn primaryMapper;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:reinitializeBegin(Lorg/apache/commons/math/ode/sampling/StepInterpolator;)V",
            "method_body": "public void reinitializeBegin(final StepInterpolator interpolator) {\n\nt0 = interpolator.getPreviousTime();\ninterpolator.setInterpolatedTime(t0);\ng0 = handler.g(t0, interpolator.getInterpolatedState());\nif (g0 == 0) {\n// excerpt from MATH-421 issue:\n// If an ODE solver is setup with an EventHandler that return STOP\n// when the even is triggered, the integrator stops (which is exactly\n// the expected behavior). If however the user wants to restart the\n// solver from the final state reached at the event with the same\n// configuration (expecting the event to be triggered again at a\n// later time), then the integrator may fail to start. It can get stuck\n// at the previous event. The use case for the bug MATH-421 is fairly\n// general, so events occurring exactly at start in the first step should\n// be ignored.\n\n// extremely rare case: there is a zero EXACTLY at interval start\n// we will use the sign slightly after step beginning to force ignoring this zero\nfinal double epsilon = FastMath.max(solver.getAbsoluteAccuracy(),\nFastMath.abs(solver.getRelativeAccuracy() * t0));\nfinal double tStart = t0 + 0.5 * epsilon;\ninterpolator.setInterpolatedTime(tStart);\ng0 = handler.g(tStart, interpolator.getInterpolatedState());\n}\ng0Positive = g0 >= 0;\n\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:solve(ILorg/apache/commons/math/analysis/UnivariateRealFunction;DD)D",
            "method_body": "public double solve(int maxEval, FUNC f, double min, double max) {\nreturn solve(maxEval, f, min, max, min + 0.5 * (max - min));\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:<init>()V",
            "method_body": "public DormandPrince853StepInterpolator() {\nsuper();\nyDotKLast = null;\nv         = null;\nvectorsInitialized = false;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:getEventTime()D",
            "method_body": "public double getEventTime() {\nreturn pendingEvent ?\npendingEventTime :\n(forward ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:<init>(DDD)V",
            "method_body": "protected BaseAbstractUnivariateRealSolver(final double relativeAccuracy,\nfinal double absoluteAccuracy,\nfinal double functionValueAccuracy) {\nthis.absoluteAccuracy = absoluteAccuracy;\nthis.relativeAccuracy = relativeAccuracy;\nthis.functionValueAccuracy = functionValueAccuracy;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:min(DD)D",
            "method_body": "public static double min(final double a, final double b) {\nif (a > b) {\nreturn b;\n}\nif (a < b) {\nreturn a;\n}\n/* if either arg is NaN, return NaN */\nif (a != b) {\nreturn Double.NaN;\n}\n/* min(+0.0,-0.0) == -0.0 */\n/* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn a;\n}\nreturn b;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.ode.EquationsMapper:<init>(II)V",
            "method_body": "public EquationsMapper(final int firstIndex, final int dimension) {\nthis.firstIndex = firstIndex;\nthis.dimension  = dimension;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:ulp(D)D",
            "method_body": "public static double ulp(double x) {\nif (Double.isInfinite(x)) {\nreturn Double.POSITIVE_INFINITY;\n}\nreturn abs(x - Double.longBitsToDouble(Double.doubleToLongBits(x) ^ 1));\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.ode.ExpandableStatefulODE:getTotalDimension()I",
            "method_body": "public int getTotalDimension() {\nif (components.isEmpty()) {\n// there are no secondary equations, the complete set is limited to the primary set\nreturn primaryMapper.getDimension();\n} else {\n// there are secondary equations, the complete set ends after the last set\nfinal EquationsMapper lastMapper = components.get(components.size() - 1).mapper;\nreturn lastMapper.getFirstIndex() + lastMapper.getDimension();\n}\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getGlobalCurrentTime()D",
            "method_body": "public double getGlobalCurrentTime() {\nreturn globalCurrentTime;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setEquations(Lorg/apache/commons/math/ode/ExpandableStatefulODE;)V",
            "method_body": "protected void setEquations(final ExpandableStatefulODE equations) {\nthis.expandable = equations;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:sanityChecks(Lorg/apache/commons/math/ode/ExpandableStatefulODE;D)V",
            "method_body": "protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\nthrows NumberIsTooSmallException {\n\nfinal double threshold = 1000 * FastMath.ulp(FastMath.max(FastMath.abs(equations.getTime()),\nFastMath.abs(t)));\nfinal double dt = FastMath.abs(equations.getTime() - t);\nif (dt <= threshold) {\nthrow new NumberIsTooSmallException(LocalizedFormats.TOO_SMALL_INTEGRATION_INTERVAL,\ndt, threshold, false);\n}\n\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.ode.EquationsMapper:getDimension()I",
            "method_body": "public int getDimension() {\nreturn dimension;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:<init>(D)V",
            "method_body": "protected BaseAbstractUnivariateRealSolver(final double absoluteAccuracy) {\nthis(DEFAULT_RELATIVE_ACCURACY,\nabsoluteAccuracy,\nDEFAULT_FUNCTION_VALUE_ACCURACY);\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:finalizeStep()V",
            "method_body": "public final void finalizeStep() {\nif (! finalized) {\ndoFinalize();\nfinalized = true;\n}\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:setup(ILorg/apache/commons/math/analysis/UnivariateRealFunction;DDD)V",
            "method_body": "protected void setup(int maxEval,\nFUNC f,\ndouble min, double max,\ndouble startValue) {\n// Checks.\nMathUtils.checkNotNull(f);\n\n// Reset.\nsearchMin = min;\nsearchMax = max;\nsearchStart = startValue;\nfunction = f;\nevaluations.setMaximalCount(maxEval);\nevaluations.resetCount();\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:setStepSizeControl(DDDD)V",
            "method_body": "public void setStepSizeControl(final double minimalStep, final double maximalStep,\nfinal double absoluteTolerance,\nfinal double relativeTolerance) {\n\nminStep     = FastMath.abs(minimalStep);\nmaxStep     = FastMath.abs(maximalStep);\ninitialStep = -1;\n\nscalAbsoluteTolerance = absoluteTolerance;\nscalRelativeTolerance = relativeTolerance;\nvecAbsoluteTolerance  = null;\nvecRelativeTolerance  = null;\n\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:evaluateStep(Lorg/apache/commons/math/ode/sampling/StepInterpolator;)Z",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nthrows ConvergenceException {\n\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal double dt = t1 - t0;\nif (FastMath.abs(dt) < convergence) {\n// we cannot do anything on such a small step, don't trigger any events\nreturn false;\n}\nfinal int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\nfinal double h = dt / n;\n\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\npublic double value(final double t) {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\n}\n};\n\ndouble ta = t0;\ndouble ga = g0;\nfor (int i = 0; i < n; ++i) {\n\n// evaluate handler value at the end of the substep\nfinal double tb = t0 + (i + 1) * h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n// check events occurrence\nif (g0Positive ^ (gb >= 0)) {\n// there is a sign change: an event is expected during this step\n\n// variation direction, with respect to the integration direction\nincreasing = gb >= ga;\n\n// find the event time making sure we select a solution just at or past the exact root\nfinal double root;\nif (solver instanceof BracketedUnivariateRealSolver<?>) {\n@SuppressWarnings(\"unchecked\")\nBracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n(BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\nroot = forward ?\nbracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) :\nbracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n} else {\nfinal double baseRoot = forward ?\nsolver.solve(maxIterationCount, f, ta, tb) :\nsolver.solve(maxIterationCount, f, tb, ta);\nfinal int remainingEval = maxIterationCount - solver.getEvaluations();\nBracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\nnew PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\nroot = forward ?\nUnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\nbaseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) :\nUnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\nbaseRoot, tb, ta, AllowedSolution.LEFT_SIDE);\n}\n\nif ((!Double.isNaN(previousEventTime)) &&\n(FastMath.abs(root - ta) <= convergence) &&\n(FastMath.abs(root - previousEventTime) <= convergence)) {\n// we have either found nothing or found (again ?) a past event,\n// retry the substep excluding this value\nta = forward ? ta + convergence : ta - convergence;\nga = f.value(ta);\n--i;\n} else if (Double.isNaN(previousEventTime) ||\n(FastMath.abs(previousEventTime - root) > convergence)) {\npendingEventTime = root;\npendingEvent = true;\nreturn true;\n} else {\n// no sign change: there is no event for now\nta = tb;\nga = gb;\n}\n\n} else {\n// no sign change: there is no event for now\nta = tb;\nga = gb;\n}\n\n}\n\n// no event during the whole step\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getGlobalPreviousTime()D",
            "method_body": "public double getGlobalPreviousTime() {\nreturn globalPreviousTime;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:solve(ILorg/apache/commons/math/analysis/UnivariateRealFunction;DDD)D",
            "method_body": "public double solve(int maxEval, FUNC f, double min, double max, double startValue) {\n// Initialization.\nsetup(maxEval, f, min, max, startValue);\n\n// Perform computation.\nreturn doSolve();\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:getRelativeAccuracy()D",
            "method_body": "public double getRelativeAccuracy() {\nreturn relativeAccuracy;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() {\nif (++count > maximalCount) {\nmaxCountCallback.trigger(maximalCount);\n}\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:pow(DD)D",
            "method_body": "public static double pow(double x, double y) {\nfinal double lns[] = new double[2];\n\nif (y == 0.0) {\nreturn 1.0;\n}\n\nif (x != x) { // X is NaN\nreturn x;\n}\n\n\nif (x == 0) {\nlong bits = Double.doubleToLongBits(x);\nif ((bits & 0x8000000000000000L) != 0) {\n// -zero\nlong yi = (long) y;\n\nif (y < 0 && y == yi && (yi & 1) == 1) {\nreturn Double.NEGATIVE_INFINITY;\n}\n\nif (y > 0 && y == yi && (yi & 1) == 1) {\nreturn -0.0;\n}\n}\n\nif (y < 0) {\nreturn Double.POSITIVE_INFINITY;\n}\nif (y > 0) {\nreturn 0.0;\n}\n\nreturn Double.NaN;\n}\n\nif (x == Double.POSITIVE_INFINITY) {\nif (y != y) { // y is NaN\nreturn y;\n}\nif (y < 0.0) {\nreturn 0.0;\n} else {\nreturn Double.POSITIVE_INFINITY;\n}\n}\n\nif (y == Double.POSITIVE_INFINITY) {\nif (x * x == 1.0) {\nreturn Double.NaN;\n}\n\nif (x * x > 1.0) {\nreturn Double.POSITIVE_INFINITY;\n} else {\nreturn 0.0;\n}\n}\n\nif (x == Double.NEGATIVE_INFINITY) {\nif (y != y) { // y is NaN\nreturn y;\n}\n\nif (y < 0) {\nlong yi = (long) y;\nif (y == yi && (yi & 1) == 1) {\nreturn -0.0;\n}\n\nreturn 0.0;\n}\n\nif (y > 0)  {\nlong yi = (long) y;\nif (y == yi && (yi & 1) == 1) {\nreturn Double.NEGATIVE_INFINITY;\n}\n\nreturn Double.POSITIVE_INFINITY;\n}\n}\n\nif (y == Double.NEGATIVE_INFINITY) {\n\nif (x * x == 1.0) {\nreturn Double.NaN;\n}\n\nif (x * x < 1.0) {\nreturn Double.POSITIVE_INFINITY;\n} else {\nreturn 0.0;\n}\n}\n\n/* Handle special case x<0 */\nif (x < 0) {\n// y is an even integer in this case\nif (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\nreturn pow(-x, y);\n}\n\nif (y == (long) y) {\n// If y is an integer\nreturn ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n} else {\nreturn Double.NaN;\n}\n}\n\n/* Split y into ya and yb such that y = ya+yb */\ndouble ya;\ndouble yb;\nif (y < 8e298 && y > -8e298) {\ndouble tmp1 = y * HEX_40000000;\nya = y + tmp1 - tmp1;\nyb = y - ya;\n} else {\ndouble tmp1 = y * 9.31322574615478515625E-10;\ndouble tmp2 = tmp1 * 9.31322574615478515625E-10;\nya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\nyb = y - ya;\n}\n\n/* Compute ln(x) */\nfinal double lores = log(x, lns);\nif (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\nreturn lores;\n}\n\ndouble lna = lns[0];\ndouble lnb = lns[1];\n\n/* resplit lns */\ndouble tmp1 = lna * HEX_40000000;\ndouble tmp2 = lna + tmp1 - tmp1;\nlnb += lna - tmp2;\nlna = tmp2;\n\n// y*ln(x) = (aa+ab)\nfinal double aa = lna * ya;\nfinal double ab = lna * yb + lnb * ya + lnb * yb;\n\nlna = aa+ab;\nlnb = -(lna - aa - ab);\n\ndouble z = 1.0 / 120.0;\nz = z * lnb + (1.0 / 24.0);\nz = z * lnb + (1.0 / 6.0);\nz = z * lnb + 0.5;\nz = z * lnb + 1.0;\nz = z * lnb;\n\nfinal double result = exp(lna, z, null);\n//result = result + result * z;\nreturn result;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.util.MathUtils:checkNotNull(Ljava/lang/Object;)V",
            "method_body": "public static void checkNotNull(Object o)\nthrows NullArgumentException {\nif (o == null) {\nthrow new NullArgumentException();\n}\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.AbstractUnivariateRealSolver:<init>(D)V",
            "method_body": "protected AbstractUnivariateRealSolver(final double absoluteAccuracy) {\nsuper(absoluteAccuracy);\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.ode.ExpandableStatefulODE:getSecondaryMappers()[Lorg/apache/commons/math/ode/EquationsMapper;",
            "method_body": "public EquationsMapper[] getSecondaryMappers() {\nfinal EquationsMapper[] mappers = new EquationsMapper[components.size()];\nfor (int i = 0; i < mappers.length; ++i) {\nmappers[i] = components.get(i).mapper;\n}\nreturn mappers;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:getAbsoluteAccuracy()D",
            "method_body": "public double getAbsoluteAccuracy() {\nreturn absoluteAccuracy;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getInterpolatedState()[D",
            "method_body": "public double[] getInterpolatedState() {\nevaluateCompleteInterpolatedState();\nprimaryMapper.extractEquationData(interpolatedState,\ninterpolatedPrimaryState);\nreturn interpolatedPrimaryState;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:<init>(Lorg/apache/commons/math/ode/events/EventHandler;DDILorg/apache/commons/math/analysis/solvers/UnivariateRealSolver;)V",
            "method_body": "public EventState(final EventHandler handler, final double maxCheckInterval,\nfinal double convergence, final int maxIterationCount,\nfinal UnivariateRealSolver solver) {\nthis.handler           = handler;\nthis.maxCheckInterval  = maxCheckInterval;\nthis.convergence       = FastMath.abs(convergence);\nthis.maxIterationCount = maxIterationCount;\nthis.solver            = solver;\n\n// some dummy values ...\nt0                = Double.NaN;\ng0                = Double.NaN;\ng0Positive        = true;\npendingEvent      = false;\npendingEventTime  = Double.NaN;\npreviousEventTime = Double.NaN;\nincreasing        = true;\nnextAction        = EventHandler.Action.CONTINUE;\n\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:integrate(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nfinal double t0, final double[] y0, final double t, final double[] y)\nthrows MathIllegalStateException, MathIllegalArgumentException {\n\nif (y0.length != equations.getDimension()) {\nthrow new DimensionMismatchException(y0.length, equations.getDimension());\n}\nif (y.length != equations.getDimension()) {\nthrow new DimensionMismatchException(y.length, equations.getDimension());\n}\n\n// prepare expandable stateful equations\nfinal ExpandableStatefulODE expandableODE = new ExpandableStatefulODE(equations);\nexpandableODE.setTime(t0);\nexpandableODE.setPrimaryState(y0);\n\n// perform integration\nintegrate(expandableODE, t);\n\n// extract results back from the stateful equations\nSystem.arraycopy(expandableODE.getPrimaryState(), 0, y, 0, y.length);\nreturn expandableODE.getTime();\n\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:initializeStep(ZI[DD[D[D[D[D)D",
            "method_body": "public double initializeStep(final boolean forward, final int order, final double[] scale,\nfinal double t0, final double[] y0, final double[] yDot0,\nfinal double[] y1, final double[] yDot1) {\n\nif (initialStep > 0) {\n// use the user provided value\nreturn forward ? initialStep : -initialStep;\n}\n\n// very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n// this guess will be used to perform an Euler step\ndouble ratio;\ndouble yOnScale2 = 0;\ndouble yDotOnScale2 = 0;\nfor (int j = 0; j < scale.length; ++j) {\nratio         = y0[j] / scale[j];\nyOnScale2    += ratio * ratio;\nratio         = yDot0[j] / scale[j];\nyDotOnScale2 += ratio * ratio;\n}\n\ndouble h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n1.0e-6 : (0.01 * FastMath.sqrt(yOnScale2 / yDotOnScale2));\nif (! forward) {\nh = -h;\n}\n\n// perform an Euler step using the preceding rough guess\nfor (int j = 0; j < y0.length; ++j) {\ny1[j] = y0[j] + h * yDot0[j];\n}\ncomputeDerivatives(t0 + h, y1, yDot1);\n\n// estimate the second derivative of the solution\ndouble yDDotOnScale = 0;\nfor (int j = 0; j < scale.length; ++j) {\nratio         = (yDot1[j] - yDot0[j]) / scale[j];\nyDDotOnScale += ratio * ratio;\n}\nyDDotOnScale = FastMath.sqrt(yDDotOnScale) / h;\n\n// step size is computed such that\n// h^order * max (||y'/tol||, ||y''/tol||) = 0.01\nfinal double maxInv2 = FastMath.max(FastMath.sqrt(yDotOnScale2), yDDotOnScale);\nfinal double h1 = (maxInv2 < 1.0e-15) ?\nFastMath.max(1.0e-6, 0.001 * FastMath.abs(h)) :\nFastMath.pow(0.01 / maxInv2, 1.0 / order);\nh = FastMath.min(100.0 * FastMath.abs(h), h1);\nh = FastMath.max(h, 1.0e-12 * FastMath.abs(t0));  // avoids cancellation when computing t1 - t0\nif (h < getMinStep()) {\nh = getMinStep();\n}\nif (h > getMaxStep()) {\nh = getMaxStep();\n}\nif (! forward) {\nh = -h;\n}\n\nreturn h;\n\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:storeTime(D)V",
            "method_body": "public void storeTime(final double t) {\n\nglobalCurrentTime = t;\nsoftCurrentTime   = globalCurrentTime;\nh                 = globalCurrentTime - globalPreviousTime;\nsetInterpolatedTime(t);\n\n// the step is not finalized anymore\nfinalized  = false;\n\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMinReduction(D)V",
            "method_body": "public void setMinReduction(final double minReduction) {\nthis.minReduction = minReduction;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:<init>()V",
            "method_body": "protected AbstractStepInterpolator() {\nglobalPreviousTime = Double.NaN;\nglobalCurrentTime  = Double.NaN;\nsoftPreviousTime   = Double.NaN;\nsoftCurrentTime    = Double.NaN;\nh                  = Double.NaN;\ninterpolatedTime   = Double.NaN;\ncurrentState       = null;\nfinalized          = false;\nthis.forward       = true;\nthis.dirtyState    = true;\nprimaryMapper      = null;\nsecondaryMappers   = null;\nallocateInterpolatedArrays(-1);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setMaxEvaluations(I)V",
            "method_body": "public void setMaxEvaluations(int maxEvaluations) {\nevaluations.setMaximalCount((maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations);\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:storeTime(D)V",
            "method_body": "public void storeTime(final double t) {\nsuper.storeTime(t);\nvectorsInitialized = false;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator:reinitialize(Lorg/apache/commons/math/ode/AbstractIntegrator;[D[[DZLorg/apache/commons/math/ode/EquationsMapper;[Lorg/apache/commons/math/ode/EquationsMapper;)V",
            "method_body": "public void reinitialize(final AbstractIntegrator rkIntegrator,\nfinal double[] y, final double[][] yDotArray, final boolean forward,\nfinal EquationsMapper primaryMapper,\nfinal EquationsMapper[] secondaryMappers) {\nreinitialize(y, forward, primaryMapper, secondaryMappers);\nthis.yDotK = yDotArray;\nthis.integrator = rkIntegrator;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:allocateInterpolatedArrays(I)V",
            "method_body": "private void allocateInterpolatedArrays(final int dimension) {\nif (dimension < 0) {\ninterpolatedState                = null;\ninterpolatedDerivatives          = null;\ninterpolatedPrimaryState         = null;\ninterpolatedPrimaryDerivatives   = null;\ninterpolatedSecondaryState       = null;\ninterpolatedSecondaryDerivatives = null;\n} else {\ninterpolatedState                = new double[dimension];\ninterpolatedDerivatives          = new double[dimension];\ninterpolatedPrimaryState         = new double[primaryMapper.getDimension()];\ninterpolatedPrimaryDerivatives   = new double[primaryMapper.getDimension()];\nif (secondaryMappers == null) {\ninterpolatedSecondaryState       = null;\ninterpolatedSecondaryDerivatives = null;\n} else {\ninterpolatedSecondaryState       = new double[secondaryMappers.length][];\ninterpolatedSecondaryDerivatives = new double[secondaryMappers.length][];\nfor (int i = 0; i < secondaryMappers.length; ++i) {\ninterpolatedSecondaryState[i]       = new double[secondaryMappers[i].getDimension()];\ninterpolatedSecondaryDerivatives[i] = new double[secondaryMappers[i].getDimension()];\n}\n}\n}\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:isForward()Z",
            "method_body": "public boolean isForward() {\nreturn forward;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:abs(J)J",
            "method_body": "public static long abs(final long x) {\nreturn (x < 0l) ? -x : x;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:<init>(Ljava/lang/String;)V",
            "method_body": "public AbstractIntegrator(final String name) {\nthis.name = name;\nstepHandlers = new ArrayList<StepHandler>();\nstepStart = Double.NaN;\nstepSize  = Double.NaN;\neventsStates = new ArrayList<EventState>();\nstatesInitialized = false;\nevaluations = new Incrementor();\nsetMaxEvaluations(-1);\nresetEvaluations();\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:resetInternalState()V",
            "method_body": "protected void resetInternalState() {\nstepStart = Double.NaN;\nstepSize  = FastMath.sqrt(minStep * maxStep);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math.ode.EquationsMapper:extractEquationData([D[D)V",
            "method_body": "public void extractEquationData(double[] complete, double[] equationData)\nthrows DimensionMismatchException {\nif (equationData.length != dimension) {\nthrow new DimensionMismatchException(equationData.length, dimension);\n}\nSystem.arraycopy(complete, firstIndex, equationData, 0, dimension);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator:<init>()V",
            "method_body": "protected RungeKuttaStepInterpolator() {\nsuper();\nyDotK      = null;\nintegrator = null;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math.ode.ExpandableStatefulODE:setTime(D)V",
            "method_body": "public void setTime(final double time) {\nthis.time = time;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math.ode.ExpandableStatefulODE:getCompleteState()[D",
            "method_body": "public double[] getCompleteState() {\n\n// allocate complete array\ndouble[] completeState = new double[getTotalDimension()];\n\n// set the data\nprimaryMapper.insertEquationData(primaryState, completeState);\nfor (final SecondaryComponent component : components) {\ncomponent.mapper.insertEquationData(component.state, completeState);\n}\n\nreturn completeState;\n\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getCurrentTime()D",
            "method_body": "public double getCurrentTime() {\nreturn softCurrentTime;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:log(D[D)D",
            "method_body": "private static double log(final double x, final double[] hiPrec) {\nif (x==0) { // Handle special case of +0/-0\nreturn Double.NEGATIVE_INFINITY;\n}\nlong bits = Double.doubleToLongBits(x);\n\n/* Handle special cases of negative input, and NaN */\nif ((bits & 0x8000000000000000L) != 0 || x != x) {\nif (x != 0.0) {\nif (hiPrec != null) {\nhiPrec[0] = Double.NaN;\n}\n\nreturn Double.NaN;\n}\n}\n\n/* Handle special cases of Positive infinity. */\nif (x == Double.POSITIVE_INFINITY) {\nif (hiPrec != null) {\nhiPrec[0] = Double.POSITIVE_INFINITY;\n}\n\nreturn Double.POSITIVE_INFINITY;\n}\n\n/* Extract the exponent */\nint exp = (int)(bits >> 52)-1023;\n\nif ((bits & 0x7ff0000000000000L) == 0) {\n// Subnormal!\nif (x == 0) {\n// Zero\nif (hiPrec != null) {\nhiPrec[0] = Double.NEGATIVE_INFINITY;\n}\n\nreturn Double.NEGATIVE_INFINITY;\n}\n\n/* Normalize the subnormal number. */\nbits <<= 1;\nwhile ( (bits & 0x0010000000000000L) == 0) {\nexp--;\nbits <<= 1;\n}\n}\n\n\nif (exp == -1 || exp == 0) {\nif (x < 1.01 && x > 0.99 && hiPrec == null) {\n/* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\npolynomial expansion in higer precision. */\n\n/* Compute x - 1.0 and split it */\ndouble xa = x - 1.0;\ndouble xb = xa - x + 1.0;\ndouble tmp = xa * HEX_40000000;\ndouble aa = xa + tmp - tmp;\ndouble ab = xa - aa;\nxa = aa;\nxb = ab;\n\ndouble ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\ndouble yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n\nfor (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\n/* Add  a = y + lnQuickCoef */\naa = ya + LN_QUICK_COEF[i][0];\nab = yb + LN_QUICK_COEF[i][1];\n/* Split y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n}\n\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\nreturn ya + yb;\n}\n}\n\n// lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\ndouble lnm[] = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n/*\ndouble epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\nepsilon -= 1.0;\n*/\n\n// y is the most significant 10 bits of the mantissa\n//double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n//double epsilon = (x - y) / y;\ndouble epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\ndouble lnza = 0.0;\ndouble lnzb = 0.0;\n\nif (hiPrec != null) {\n/* split epsilon -> x */\ndouble tmp = epsilon * HEX_40000000;\ndouble aa = epsilon + tmp - tmp;\ndouble ab = epsilon - aa;\ndouble xa = aa;\ndouble xb = ab;\n\n/* Need a more accurate epsilon, so adjust the division. */\ndouble numer = bits & 0x3ffffffffffL;\ndouble denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\naa = numer - xa*denom - xb * denom;\nxb += aa / denom;\n\n/* Remez polynomial evaluation */\ndouble ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\ndouble yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n\nfor (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\n/* Add  a = y + lnHiPrecCoef */\naa = ya + LN_HI_PREC_COEF[i][0];\nab = yb + LN_HI_PREC_COEF[i][1];\n/* Split y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n}\n\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n\n/* split, so now lnz = a */\n/*\ntmp = aa * 1073741824.0;\nlnza = aa + tmp - tmp;\nlnzb = aa - lnza + ab;\n*/\nlnza = aa + ab;\nlnzb = -(lnza - aa - ab);\n} else {\n/* High precision not required.  Eval Remez polynomial\nusing standard double precision */\nlnza = -0.16624882440418567;\nlnza = lnza * epsilon + 0.19999954120254515;\nlnza = lnza * epsilon + -0.2499999997677497;\nlnza = lnza * epsilon + 0.3333333333332802;\nlnza = lnza * epsilon + -0.5;\nlnza = lnza * epsilon + 1.0;\nlnza = lnza * epsilon;\n}\n\n/* Relative sizes:\n* lnzb     [0, 2.33E-10]\n* lnm[1]   [0, 1.17E-7]\n* ln2B*exp [0, 1.12E-4]\n* lnza      [0, 9.7E-4]\n* lnm[0]   [0, 0.692]\n* ln2A*exp [0, 709]\n*/\n\n/* Compute the following sum:\n* lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n*/\n\n//return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\ndouble a = LN_2_A*exp;\ndouble b = 0.0;\ndouble c = a+lnm[0];\ndouble d = -(c-a-lnm[0]);\na = c;\nb = b + d;\n\nc = a + lnza;\nd = -(c - a - lnza);\na = c;\nb = b + d;\n\nc = a + LN_2_B*exp;\nd = -(c - a - LN_2_B*exp);\na = c;\nb = b + d;\n\nc = a + lnm[1];\nd = -(c - a - lnm[1]);\na = c;\nb = b + d;\n\nc = a + lnzb;\nd = -(c - a - lnzb);\na = c;\nb = b + d;\n\nif (hiPrec != null) {\nhiPrec[0] = a;\nhiPrec[1] = b;\n}\n\nreturn a + b;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:reinitialize([DZLorg/apache/commons/math/ode/EquationsMapper;[Lorg/apache/commons/math/ode/EquationsMapper;)V",
            "method_body": "protected void reinitialize(final double[] y, final boolean isForward,\nfinal EquationsMapper primary,\nfinal EquationsMapper[] secondary) {\n\nglobalPreviousTime    = Double.NaN;\nglobalCurrentTime     = Double.NaN;\nsoftPreviousTime      = Double.NaN;\nsoftCurrentTime       = Double.NaN;\nh                     = Double.NaN;\ninterpolatedTime      = Double.NaN;\ncurrentState          = y;\nfinalized             = false;\nthis.forward          = isForward;\nthis.dirtyState       = true;\nthis.primaryMapper    = primary;\nthis.secondaryMappers = secondary.clone();\nallocateInterpolatedArrays(y.length);\n\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:integrate(Lorg/apache/commons/math/ode/ExpandableStatefulODE;D)V",
            "method_body": "public void integrate(final ExpandableStatefulODE equations, final double t)\nthrows MathIllegalStateException, MathIllegalArgumentException {\n\nsanityChecks(equations, t);\nsetEquations(equations);\nresetEvaluations();\nfinal boolean forward = t > equations.getTime();\n\n// create some internal working arrays\nfinal double[] y0  = equations.getCompleteState();\nfinal double[] y = y0.clone();\nfinal int stages = c.length + 1;\nfinal double[][] yDotK = new double[stages][y.length];\nfinal double[] yTmp    = new double[y.length];\nfinal double[] yDotTmp = new double[y.length];\n\n// set up an interpolator sharing the integrator arrays\nfinal RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\ninterpolator.reinitialize(this, yTmp, yDotK, forward,\nequations.getPrimaryMapper(), equations.getSecondaryMappers());\ninterpolator.storeTime(equations.getTime());\n\n// set up integration control objects\nstepStart         = equations.getTime();\ndouble  hNew      = 0;\nboolean firstTime = true;\nfor (StepHandler handler : stepHandlers) {\nhandler.reset();\n}\nsetStateInitialized(false);\n\n// main integration loop\nisLastStep = false;\ndo {\n\ninterpolator.shift();\n\n// iterate over step size, ensuring local normalized error is smaller than 1\ndouble error = 10;\nwhile (error >= 1.0) {\n\nif (firstTime || !fsal) {\n// first stage\ncomputeDerivatives(stepStart, y, yDotK[0]);\n}\n\nif (firstTime) {\nfinal double[] scale = new double[mainSetDimension];\nif (vecAbsoluteTolerance == null) {\nfor (int i = 0; i < scale.length; ++i) {\nscale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n}\n} else {\nfor (int i = 0; i < scale.length; ++i) {\nscale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n}\n}\nhNew = initializeStep(forward, getOrder(), scale,\nstepStart, y, yDotK[0], yTmp, yDotK[1]);\nfirstTime = false;\n}\n\nstepSize = hNew;\n\n// next stages\nfor (int k = 1; k < stages; ++k) {\n\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum = a[k-1][0] * yDotK[0][j];\nfor (int l = 1; l < k; ++l) {\nsum += a[k-1][l] * yDotK[l][j];\n}\nyTmp[j] = y[j] + stepSize * sum;\n}\n\ncomputeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n}\n\n// estimate the state at the end of the step\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum    = b[0] * yDotK[0][j];\nfor (int l = 1; l < stages; ++l) {\nsum    += b[l] * yDotK[l][j];\n}\nyTmp[j] = y[j] + stepSize * sum;\n}\n\n// estimate the error at the end of the step\nerror = estimateError(yDotK, y, yTmp, stepSize);\nif (error >= 1.0) {\n// reject the step and attempt to reduce error by stepsize control\nfinal double factor =\nFastMath.min(maxGrowth,\nFastMath.max(minReduction, safety * FastMath.pow(error, exp)));\nhNew = filterStep(stepSize * factor, forward, false);\n}\n\n}\n\n// local error is small enough: accept the step, trigger events and step handlers\ninterpolator.storeTime(stepStart + stepSize);\nSystem.arraycopy(yTmp, 0, y, 0, y0.length);\nSystem.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\nstepStart = acceptStep(interpolator, y, yDotTmp, t);\n\nif (!isLastStep) {\n\n// prepare next step\ninterpolator.storeTime(stepStart);\n\nif (fsal) {\n// save the last evaluation for the next step\nSystem.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n}\n\n// stepsize control for next step\nfinal double factor =\nFastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\nfinal double  scaledH    = stepSize * factor;\nfinal double  nextT      = stepStart + scaledH;\nfinal boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\nhNew = filterStep(scaledH, forward, nextIsLast);\n\nfinal double  filteredNextT      = stepStart + hNew;\nfinal boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\nif (filteredNextIsLast) {\nhNew = t - stepStart;\n}\n\n}\n\n} while (!isLastStep);\n\n// dispatch results\nequations.setTime(stepStart);\nequations.setCompleteState(y);\n\nresetInternalState();\n\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math.ode.ExpandableStatefulODE:getTime()D",
            "method_body": "public double getTime() {\nreturn time;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:estimateError([[D[D[DD)D",
            "method_body": "protected double estimateError(final double[][] yDotK,\nfinal double[] y0, final double[] y1,\nfinal double h) {\ndouble error1 = 0;\ndouble error2 = 0;\n\nfor (int j = 0; j < mainSetDimension; ++j) {\nfinal double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +\nE1_07 * yDotK[6][j]  + E1_08 * yDotK[7][j] +\nE1_09 * yDotK[8][j]  + E1_10 * yDotK[9][j] +\nE1_11 * yDotK[10][j] + E1_12 * yDotK[11][j];\nfinal double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +\nE2_07 * yDotK[6][j]  + E2_08 * yDotK[7][j] +\nE2_09 * yDotK[8][j]  + E2_10 * yDotK[9][j] +\nE2_11 * yDotK[10][j] + E2_12 * yDotK[11][j];\n\nfinal double yScale = FastMath.max(FastMath.abs(y0[j]), FastMath.abs(y1[j]));\nfinal double tol = (vecAbsoluteTolerance == null) ?\n(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\nfinal double ratio1  = errSum1 / tol;\nerror1        += ratio1 * ratio1;\nfinal double ratio2  = errSum2 / tol;\nerror2        += ratio2 * ratio2;\n}\n\ndouble den = error1 + 0.01 * error2;\nif (den <= 0.0) {\nden = 1.0;\n}\n\nreturn FastMath.abs(h) * error1 / FastMath.sqrt(mainSetDimension * den);\n\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver:<init>(DI)V",
            "method_body": "public BracketingNthOrderBrentSolver(final double absoluteAccuracy,\nfinal int maximalOrder)\nthrows NumberIsTooSmallException {\nsuper(absoluteAccuracy);\nif (maximalOrder < 2) {\nthrow new NumberIsTooSmallException(maximalOrder, 2, true);\n}\nthis.maximalOrder = maximalOrder;\nthis.allowed = AllowedSolution.ANY_SIDE;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:<init>(DDDD)V",
            "method_body": "public DormandPrince853Integrator(final double minStep, final double maxStep,\nfinal double scalAbsoluteTolerance,\nfinal double scalRelativeTolerance) {\nsuper(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\nnew DormandPrince853StepInterpolator(),\nminStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver:doSolve()D",
            "method_body": "protected double doSolve() {\n\n// prepare arrays with the first points\nfinal double[] x = new double[maximalOrder + 1];\nfinal double[] y = new double[maximalOrder + 1];\nx[0] = getMin();\nx[1] = getStartValue();\nx[2] = getMax();\nverifySequence(x[0], x[1], x[2]);\n\n// evaluate initial guess\ny[1] = computeObjectiveValue(x[1]);\nif (Precision.equals(y[1], 0.0, 1)) {\n// return the initial guess if it is a perfect root.\nreturn x[1];\n}\n\n// evaluate first  endpoint\ny[0] = computeObjectiveValue(x[0]);\nif (Precision.equals(y[0], 0.0, 1)) {\n// return the first endpoint if it is a perfect root.\nreturn x[0];\n}\n\nint nbPoints;\nint signChangeIndex;\nif (y[0] * y[1] < 0) {\n\n// reduce interval if it brackets the root\nnbPoints        = 2;\nsignChangeIndex = 1;\n\n} else {\n\n// evaluate second endpoint\ny[2] = computeObjectiveValue(x[2]);\nif (Precision.equals(y[2], 0.0, 1)) {\n// return the second endpoint if it is a perfect root.\nreturn x[2];\n}\n\nif (y[1] * y[2] < 0) {\n// use all computed point as a start sampling array for solving\nnbPoints        = 3;\nsignChangeIndex = 2;\n} else {\nthrow new NoBracketingException(x[0], x[2], y[0], y[2]);\n}\n\n}\n\n// prepare a work array for inverse polynomial interpolation\nfinal double[] tmpX = new double[x.length];\n\n// current tightest bracketing of the root\ndouble xA    = x[signChangeIndex - 1];\ndouble yA    = y[signChangeIndex - 1];\ndouble absYA = FastMath.abs(yA);\nint agingA   = 0;\ndouble xB    = x[signChangeIndex];\ndouble yB    = y[signChangeIndex];\ndouble absYB = FastMath.abs(yB);\nint agingB   = 0;\n\n// search loop\nwhile (true) {\n\n// check convergence of bracketing interval\nfinal double xTol = getAbsoluteAccuracy() +\ngetRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\nif (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\nswitch (allowed) {\ncase ANY_SIDE :\nreturn absYA < absYB ? xA : xB;\ncase LEFT_SIDE :\nreturn xA;\ncase RIGHT_SIDE :\nreturn xB;\ncase BELOW_SIDE :\nreturn (yA <= 0) ? xA : xB;\ncase ABOVE_SIDE :\nreturn (yA <  0) ? xB : xA;\ndefault :\n// this should never happen\nthrow new MathInternalError(null);\n}\n}\n\n// target for the next evaluation point\ndouble targetY;\nif (agingA >= MAXIMAL_AGING) {\n// we keep updating the high bracket, try to compensate this\ntargetY = -REDUCTION_FACTOR * yB;\n} else if (agingB >= MAXIMAL_AGING) {\n// we keep updating the low bracket, try to compensate this\ntargetY = -REDUCTION_FACTOR * yA;\n} else {\n// bracketing is balanced, try to find the root itself\ntargetY = 0;\n}\n\n// make a few attempts to guess a root,\ndouble nextX;\nint start = 0;\nint end   = nbPoints;\ndo {\n\n// guess a value for current target, using inverse polynomial interpolation\nSystem.arraycopy(x, start, tmpX, start, end - start);\nnextX = guessX(targetY, tmpX, y, start, end);\n\nif (!((nextX > xA) && (nextX < xB))) {\n// the guessed root is not strictly inside of the tightest bracketing interval\n\n// the guessed root is either not strictly inside the interval or it\n// is a NaN (which occurs when some sampling points share the same y)\n// we try again with a lower interpolation order\nif (signChangeIndex - start >= end - signChangeIndex) {\n// we have more points before the sign change, drop the lowest point\n++start;\n} else {\n// we have more points after sign change, drop the highest point\n--end;\n}\n\n// we need to do one more attempt\nnextX = Double.NaN;\n\n}\n\n} while (Double.isNaN(nextX) && (end - start > 1));\n\nif (Double.isNaN(nextX)) {\n// fall back to bisection\nnextX = xA + 0.5 * (xB - xA);\nstart = signChangeIndex - 1;\nend   = signChangeIndex;\n}\n\n// evaluate the function at the guessed root\nfinal double nextY = computeObjectiveValue(nextX);\nif (Precision.equals(nextY, 0.0, 1)) {\n// we have found an exact root, since it is not an approximation\n// we don't need to bother about the allowed solutions setting\nreturn nextX;\n}\n\nif ((nbPoints > 2) && (end - start != nbPoints)) {\n\n// we have been forced to ignore some points to keep bracketing,\n// they are probably too far from the root, drop them from now on\nnbPoints = end - start;\nSystem.arraycopy(x, start, x, 0, nbPoints);\nSystem.arraycopy(y, start, y, 0, nbPoints);\nsignChangeIndex -= start;\n\n} else  if (nbPoints == x.length) {\n\n// we have to drop one point in order to insert the new one\nnbPoints--;\n\n// keep the tightest bracketing interval as centered as possible\nif (signChangeIndex >= (x.length + 1) / 2) {\n// we drop the lowest point, we have to shift the arrays and the index\nSystem.arraycopy(x, 1, x, 0, nbPoints);\nSystem.arraycopy(y, 1, y, 0, nbPoints);\n--signChangeIndex;\n}\n\n}\n\n// insert the last computed point\n//(by construction, we know it lies inside the tightest bracketing interval)\nSystem.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\nx[signChangeIndex] = nextX;\nSystem.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\ny[signChangeIndex] = nextY;\n++nbPoints;\n\n// update the bracketing interval\nif (nextY * yA <= 0) {\n// the sign change occurs before the inserted point\nxB = nextX;\nyB = nextY;\nabsYB = FastMath.abs(yB);\n++agingA;\nagingB = 0;\n} else {\n// the sign change occurs after the inserted point\nxA = nextX;\nyA = nextY;\nabsYA = FastMath.abs(yA);\nagingA = 0;\n++agingB;\n\n// update the sign change index\nsignChangeIndex++;\n\n}\n\n}\n\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:reinitialize(Lorg/apache/commons/math/ode/AbstractIntegrator;[D[[DZLorg/apache/commons/math/ode/EquationsMapper;[Lorg/apache/commons/math/ode/EquationsMapper;)V",
            "method_body": "public void reinitialize(final AbstractIntegrator integrator,\nfinal double[] y, final double[][] yDotK, final boolean forward,\nfinal EquationsMapper primaryMapper,\nfinal EquationsMapper[] secondaryMappers) {\n\nsuper.reinitialize(integrator, y, yDotK, forward, primaryMapper, secondaryMappers);\n\nfinal int dimension = currentState.length;\n\nyDotKLast = new double[3][];\nfor (int k = 0; k < yDotKLast.length; ++k) {\nyDotKLast[k] = new double[dimension];\n}\n\nv = new double[7][];\nfor (int k = 0; k < v.length; ++k) {\nv[k]  = new double[dimension];\n}\n\nvectorsInitialized = false;\n\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils:verifySequence(DDD)V",
            "method_body": "public static void verifySequence(final double lower,\nfinal double initial,\nfinal double upper) {\nverifyInterval(lower, initial);\nverifyInterval(initial, upper);\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:sanityChecks(Lorg/apache/commons/math/ode/ExpandableStatefulODE;D)V",
            "method_body": "protected void sanityChecks(final ExpandableStatefulODE equations, final double t)\nthrows DimensionMismatchException, NumberIsTooSmallException {\n\nsuper.sanityChecks(equations, t);\n\nmainSetDimension = equations.getPrimaryMapper().getDimension();\n\nif ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != mainSetDimension)) {\nthrow new DimensionMismatchException(mainSetDimension, vecAbsoluteTolerance.length);\n}\n\nif ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != mainSetDimension)) {\nthrow new DimensionMismatchException(mainSetDimension, vecRelativeTolerance.length);\n}\n\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:shift()V",
            "method_body": "public void shift() {\nglobalPreviousTime = globalCurrentTime;\nsoftPreviousTime   = globalPreviousTime;\nsoftCurrentTime    = globalCurrentTime;\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:stepAccepted(D[D)V",
            "method_body": "public void stepAccepted(final double t, final double[] y) {\n\nt0 = t;\ng0 = handler.g(t, y);\n\nif (pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence)) {\n// force the sign to its value \"just after the event\"\npreviousEventTime = t;\ng0Positive        = increasing;\nnextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n} else {\ng0Positive = g0 >= 0;\nnextAction = EventHandler.Action.CONTINUE;\n}\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState$1:<init>(Lorg/apache/commons/math/ode/events/EventState;Lorg/apache/commons/math/ode/sampling/StepInterpolator;)V",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal double dt = t1 - t0;\nif (FastMath.abs(dt) < convergence) {\nfinal int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\nfinal double h = dt / n;\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\ndouble ta = t0;\ndouble ga = g0;\nfor (int i = 0; i < n; ++i) {\nfinal double tb = t0 + (i + 1) * h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\nif (g0Positive ^ (gb >= 0)) {\nincreasing = gb >= ga;\nif (solver instanceof BracketedUnivariateRealSolver<?>) {\nBracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\nroot = forward ?\n} else {\nif ((!Double.isNaN(previousEventTime)) &&\n} else if (Double.isNaN(previousEventTime) ||\npendingEventTime = root;\npendingEvent = true;\nreturn true;\nta = tb;\nga = gb;\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:evaluateCompleteInterpolatedState()V",
            "method_body": "protected abstract void computeInterpolatedStateAndDerivatives(double theta,\ndouble oneMinusThetaH);\n\n/** Lazy evaluation of complete interpolated state.\n*/\nprivate void evaluateCompleteInterpolatedState() {\n// lazy evaluation of the state\nif (dirtyState) {\nfinal double oneMinusThetaH = globalCurrentTime - interpolatedTime;\nfinal double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\ncomputeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\ndirtyState = false;\n}\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:<init>(I)V",
            "method_body": "public Incrementor(int max) {\nthis(max,\nnew MaxCountExceededCallback() {\n/** {@inheritDoc} */\npublic void trigger(int max) {\nthrow new MaxCountExceededException(max);\n}\n});\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:<init>(Ljava/lang/String;Z[D[[D[DLorg/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator;DDDD)V",
            "method_body": "protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\nfinal double[] c, final double[][] a, final double[] b,\nfinal RungeKuttaStepInterpolator prototype,\nfinal double minStep, final double maxStep,\nfinal double scalAbsoluteTolerance,\nfinal double scalRelativeTolerance) {\n\nsuper(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\nthis.fsal      = fsal;\nthis.c         = c;\nthis.a         = a;\nthis.b         = b;\nthis.prototype = prototype;\n\nexp = -1.0 / getOrder();\n\n// set the default values of the algorithm control parameters\nsetSafety(0.9);\nsetMinReduction(0.2);\nsetMaxGrowth(10.0);\n\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver:solve(ILorg/apache/commons/math/analysis/UnivariateRealFunction;DDLorg/apache/commons/math/analysis/solvers/AllowedSolution;)D",
            "method_body": "public double solve(int maxEval, UnivariateRealFunction f, double min,\ndouble max, AllowedSolution allowedSolution) {\nthis.allowed = allowedSolution;\nreturn super.solve(maxEval, f, min, max);\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:filterStep(DZZ)D",
            "method_body": "protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)\nthrows NumberIsTooSmallException {\n\ndouble filteredH = h;\nif (FastMath.abs(h) < minStep) {\nif (acceptSmall) {\nfilteredH = forward ? minStep : -minStep;\n} else {\nthrow new NumberIsTooSmallException(LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION,\nminStep, FastMath.abs(h), true);\n}\n}\n\nif (filteredH > maxStep) {\nfilteredH = maxStep;\n} else if (filteredH < -maxStep) {\nfilteredH = -maxStep;\n}\n\nreturn filteredH;\n\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:ceil(D)D",
            "method_body": "public static double ceil(double x) {\ndouble y;\n\nif (x != x) { // NaN\nreturn x;\n}\n\ny = floor(x);\nif (y == x) {\nreturn y;\n}\n\ny += 1.0;\n\nif (y == 0) {\nreturn x*y;\n}\n\nreturn y;\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\n}\nif (a < b) {\nreturn b;\n}\n/* if either arg is NaN, return NaN */\nif (a != b) {\nreturn Double.NaN;\n}\n/* min(+0.0,-0.0) == -0.0 */\n/* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn b;\n}\nreturn a;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BracketingNthOrderBrentSolver:guessX(D[D[DII)D",
            "method_body": "private double guessX(final double targetY, final double[] x, final double[] y,\nfinal int start, final int end) {\n\n// compute Q Newton coefficients by divided differences\nfor (int i = start; i < end - 1; ++i) {\nfinal int delta = i + 1 - start;\nfor (int j = end - 1; j > i; --j) {\nx[j] = (x[j] - x[j-1]) / (y[j] - y[j - delta]);\n}\n}\n\n// evaluate Q(targetY)\ndouble x0 = 0;\nfor (int j = end - 1; j >= start; --j) {\nx0 = x[j] + x0 * (targetY - y[j]);\n}\n\nreturn x0;\n\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverUtils:verifyInterval(DD)V",
            "method_body": "public static void verifyInterval(final double lower,\nfinal double upper) {\nif (lower >= upper) {\nthrow new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\nlower, upper, false);\n}\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:computeDerivatives(D[D[D)V",
            "method_body": "public abstract void integrate(ExpandableStatefulODE equations, double t)\nthrows MathIllegalStateException, MathIllegalArgumentException;\n\n/** Compute the derivatives and check the number of evaluations.\n* @param t current value of the independent <I>time</I> variable\n* @param y array containing the current value of the state vector\n* @param yDot placeholder array where to put the time derivative of the state vector\n* @exception MaxCountExceededException if the number of functions evaluations is exceeded\n*/\npublic void computeDerivatives(final double t, final double[] y, final double[] yDot)\nthrows MaxCountExceededException {\nevaluations.incrementCount();\nexpandable.computeDerivatives(t, y, yDot);\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.math.util.Precision:equals(DDI)Z",
            "method_body": "public static boolean equals(double x, double y, int maxUlps) {\nlong xInt = Double.doubleToLongBits(x);\nlong yInt = Double.doubleToLongBits(y);\n\n// Make lexicographically ordered as a two's-complement integer.\nif (xInt < 0) {\nxInt = SGN_MASK - xInt;\n}\nif (yInt < 0) {\nyInt = SGN_MASK - yInt;\n}\n\nfinal boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\nreturn isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:getStartValue()D",
            "method_body": "public double getStartValue() {\nreturn searchStart;\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:setSoftCurrentTime(D)V",
            "method_body": "public void setSoftCurrentTime(final double softCurrentTime) {\nthis.softCurrentTime  = softCurrentTime;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:incrementEvaluationCount()V",
            "method_body": "protected void incrementEvaluationCount() {\ntry {\nevaluations.incrementCount();\n} catch (MaxCountExceededException e) {\nthrow new TooManyEvaluationsException(e.getMax());\n}\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:verifySequence(DDD)V",
            "method_body": "protected void verifySequence(final double lower,\nfinal double initial,\nfinal double upper) {\nUnivariateRealSolverUtils.verifySequence(lower, initial, upper);\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:getMax()D",
            "method_body": "public double getMax() {\nreturn searchMax;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:floor(D)D",
            "method_body": "public static double floor(double x) {\nlong y;\n\nif (x != x) { // NaN\nreturn x;\n}\n\nif (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\nreturn x;\n}\n\ny = (long) x;\nif (x < 0 && y != x) {\ny--;\n}\n\nif (y == 0) {\nreturn x*y;\n}\n\nreturn y;\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:getFunctionValueAccuracy()D",
            "method_body": "public double getFunctionValueAccuracy() {\nreturn functionValueAccuracy;\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:acceptStep(Lorg/apache/commons/math/ode/sampling/AbstractStepInterpolator;[D[DD)D",
            "method_body": "protected double acceptStep(final AbstractStepInterpolator interpolator,\nfinal double[] y, final double[] yDot, final double tEnd)\nthrows MathIllegalStateException {\n\ndouble previousT = interpolator.getGlobalPreviousTime();\nfinal double currentT = interpolator.getGlobalCurrentTime();\nresetOccurred = false;\n\n// initialize the events states if needed\nif (! statesInitialized) {\nfor (EventState state : eventsStates) {\nstate.reinitializeBegin(interpolator);\n}\nstatesInitialized = true;\n}\n\n// search for next events that may occur during the step\nfinal int orderingSign = interpolator.isForward() ? +1 : -1;\nSortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n/** {@inheritDoc} */\npublic int compare(EventState es0, EventState es1) {\nreturn orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n}\n\n});\n\nfor (final EventState state : eventsStates) {\nif (state.evaluateStep(interpolator)) {\n// the event occurs during the current step\noccuringEvents.add(state);\n}\n}\n\nwhile (!occuringEvents.isEmpty()) {\n\n// handle the chronologically first event\nfinal Iterator<EventState> iterator = occuringEvents.iterator();\nfinal EventState currentEvent = iterator.next();\niterator.remove();\n\n// restrict the interpolator to the first part of the step, up to the event\nfinal double eventT = currentEvent.getEventTime();\ninterpolator.setSoftPreviousTime(previousT);\ninterpolator.setSoftCurrentTime(eventT);\n\n// trigger the event\ninterpolator.setInterpolatedTime(eventT);\nfinal double[] eventY = interpolator.getInterpolatedState();\ncurrentEvent.stepAccepted(eventT, eventY);\nisLastStep = currentEvent.stop();\n\n// handle the first part of the step, up to the event\nfor (final StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, isLastStep);\n}\n\nif (isLastStep) {\n// the event asked to stop integration\nSystem.arraycopy(eventY, 0, y, 0, y.length);\nreturn eventT;\n}\n\nif (currentEvent.reset(eventT, eventY)) {\n// some event handler has triggered changes that\n// invalidate the derivatives, we need to recompute them\nSystem.arraycopy(eventY, 0, y, 0, y.length);\ncomputeDerivatives(eventT, y, yDot);\nresetOccurred = true;\nreturn eventT;\n}\n\n// prepare handling of the remaining part of the step\npreviousT = eventT;\ninterpolator.setSoftPreviousTime(eventT);\ninterpolator.setSoftCurrentTime(currentT);\n\n// check if the same event occurs again in the remaining part of the step\nif (currentEvent.evaluateStep(interpolator)) {\n// the event occurs during the current step\noccuringEvents.add(currentEvent);\n}\n\n}\n\ninterpolator.setInterpolatedTime(currentT);\nfinal double[] currentY = interpolator.getInterpolatedState();\nfor (final EventState state : eventsStates) {\nstate.stepAccepted(currentT, currentY);\nisLastStep = isLastStep || state.stop();\n}\nisLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n// handle the remaining part of the step, after all events if any\nfor (StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, isLastStep);\n}\n\nreturn currentT;\n\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setStateInitialized(Z)V",
            "method_body": "protected void setStateInitialized(final boolean stateInitialized) {\nthis.statesInitialized = stateInitialized;\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.math.ode.ExpandableStatefulODE:computeDerivatives(D[D[D)V",
            "method_body": "public void computeDerivatives(final double t, final double[] y, final double[] yDot) {\n\n// compute derivatives of the primary equations\nprimaryMapper.extractEquationData(y, primaryState);\nprimary.computeDerivatives(t, primaryState, primaryStateDot);\nprimaryMapper.insertEquationData(primaryStateDot, yDot);\n\n// Add contribution for secondary equations\nfor (final SecondaryComponent component : components) {\ncomponent.mapper.extractEquationData(y, component.state);\ncomponent.equation.computeDerivatives(t, primaryState, primaryStateDot,\ncomponent.state, component.stateDot);\ncomponent.mapper.insertEquationData(component.stateDot, yDot);\n}\n\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.math.ode.ExpandableStatefulODE:setPrimaryState([D)V",
            "method_body": "public void setPrimaryState(final double[] primaryState) throws DimensionMismatchException {\n\n// safety checks\nif (primaryState.length != this.primaryState.length) {\nthrow new DimensionMismatchException(primaryState.length, this.primaryState.length);\n}\n\n// set the data\nSystem.arraycopy(primaryState, 0, this.primaryState, 0, primaryState.length);\n\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:setInterpolatedTime(D)V",
            "method_body": "public void setInterpolatedTime(final double time) {\ninterpolatedTime = time;\ndirtyState       = true;\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:doFinalize()V",
            "method_body": "protected void doFinalize() {\n\nif (currentState == null) {\n// we are finalizing an uninitialized instance\nreturn;\n}\n\ndouble s;\nfinal double[] yTmp = new double[currentState.length];\nfinal double pT = getGlobalPreviousTime();\n\n// k14\nfor (int j = 0; j < currentState.length; ++j) {\ns = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\nK14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +\nK14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\nyTmp[j] = currentState[j] + h * s;\n}\nintegrator.computeDerivatives(pT + C14 * h, yTmp, yDotKLast[0]);\n\n// k15\nfor (int j = 0; j < currentState.length; ++j) {\ns = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\nK15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +\nK15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +\nK15_14 * yDotKLast[0][j];\nyTmp[j] = currentState[j] + h * s;\n}\nintegrator.computeDerivatives(pT + C15 * h, yTmp, yDotKLast[1]);\n\n// k16\nfor (int j = 0; j < currentState.length; ++j) {\ns = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\nK16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +\nK16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +\nK16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\nyTmp[j] = currentState[j] + h * s;\n}\nintegrator.computeDerivatives(pT + C16 * h, yTmp, yDotKLast[2]);\n\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:copy()Lorg/apache/commons/math/ode/sampling/StepInterpolator;",
            "method_body": "public StepInterpolator copy() {\n\n// finalize the step before performing copy\nfinalizeStep();\n\n// create the new independent instance\nreturn doCopy();\n\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getPreviousTime()D",
            "method_body": "public double getPreviousTime() {\nreturn softPreviousTime;\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:setInitialStepSize(D)V",
            "method_body": "public void setInitialStepSize(final double initialStepSize) {\nif ((initialStepSize < minStep) || (initialStepSize > maxStep)) {\ninitialStep = -1.0;\n} else {\ninitialStep = initialStepSize;\n}\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:stop()Z",
            "method_body": "public boolean stop() {\nreturn nextAction == EventHandler.Action.STOP;\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:<init>(Lorg/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator;)V",
            "method_body": "public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {\n\nsuper(interpolator);\n\nif (interpolator.currentState == null) {\n\nyDotKLast = null;\nv         = null;\nvectorsInitialized = false;\n\n} else {\n\nfinal int dimension = interpolator.currentState.length;\n\nyDotKLast    = new double[3][];\nfor (int k = 0; k < yDotKLast.length; ++k) {\nyDotKLast[k] = new double[dimension];\nSystem.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,\ndimension);\n}\n\nv = new double[7][];\nfor (int k = 0; k < v.length; ++k) {\nv[k] = new double[dimension];\nSystem.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);\n}\n\nvectorsInitialized = interpolator.vectorsInitialized;\n\n}\n\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMaxGrowth(D)V",
            "method_body": "public void setMaxGrowth(final double maxGrowth) {\nthis.maxGrowth = maxGrowth;\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setSafety(D)V",
            "method_body": "public void setSafety(final double safety) {\nthis.safety = safety;\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.apache.commons.math.ode.EquationsMapper:insertEquationData([D[D)V",
            "method_body": "public void insertEquationData(double[] equationData, double[] complete)\nthrows DimensionMismatchException {\nif (equationData.length != dimension) {\nthrow new DimensionMismatchException(equationData.length, dimension);\n}\nSystem.arraycopy(equationData, 0, complete, firstIndex, dimension);\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.apache.commons.math.ode.ExpandableStatefulODE:<init>(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;)V",
            "method_body": "public ExpandableStatefulODE(final FirstOrderDifferentialEquations primary) {\nfinal int n          = primary.getDimension();\nthis.primary         = primary;\nthis.primaryMapper   = new EquationsMapper(0, n);\nthis.time            = Double.NaN;\nthis.primaryState    = new double[n];\nthis.primaryStateDot = new double[n];\nthis.components      = new ArrayList<ExpandableStatefulODE.SecondaryComponent>();\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:computeInterpolatedStateAndDerivatives(DD)V",
            "method_body": "protected void computeInterpolatedStateAndDerivatives(final double theta,\nfinal double oneMinusThetaH) {\n\nif (! vectorsInitialized) {\n\nif (v == null) {\nv = new double[7][];\nfor (int k = 0; k < 7; ++k) {\nv[k] = new double[interpolatedState.length];\n}\n}\n\n// perform the last evaluations if they have not been done yet\nfinalizeStep();\n\n// compute the interpolation vectors for this time step\nfor (int i = 0; i < interpolatedState.length; ++i) {\nfinal double yDot1  = yDotK[0][i];\nfinal double yDot6  = yDotK[5][i];\nfinal double yDot7  = yDotK[6][i];\nfinal double yDot8  = yDotK[7][i];\nfinal double yDot9  = yDotK[8][i];\nfinal double yDot10 = yDotK[9][i];\nfinal double yDot11 = yDotK[10][i];\nfinal double yDot12 = yDotK[11][i];\nfinal double yDot13 = yDotK[12][i];\nfinal double yDot14 = yDotKLast[0][i];\nfinal double yDot15 = yDotKLast[1][i];\nfinal double yDot16 = yDotKLast[2][i];\nv[0][i] = B_01 * yDot1  + B_06 * yDot6 + B_07 * yDot7 +\nB_08 * yDot8  + B_09 * yDot9 + B_10 * yDot10 +\nB_11 * yDot11 + B_12 * yDot12;\nv[1][i] = yDot1 - v[0][i];\nv[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\nfor (int k = 0; k < D.length; ++k) {\nv[k+3][i] = D[k][0] * yDot1  + D[k][1]  * yDot6  + D[k][2]  * yDot7  +\nD[k][3] * yDot8  + D[k][4]  * yDot9  + D[k][5]  * yDot10 +\nD[k][6] * yDot11 + D[k][7]  * yDot12 + D[k][8]  * yDot13 +\nD[k][9] * yDot14 + D[k][10] * yDot15 + D[k][11] * yDot16;\n}\n}\n\nvectorsInitialized = true;\n\n}\n\nfinal double eta      = 1 - theta;\nfinal double twoTheta = 2 * theta;\nfinal double theta2   = theta * theta;\nfinal double dot1 = 1 - twoTheta;\nfinal double dot2 = theta * (2 - 3 * theta);\nfinal double dot3 = twoTheta * (1 + theta * (twoTheta -3));\nfinal double dot4 = theta2 * (3 + theta * (5 * theta - 8));\nfinal double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\nfinal double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\n\nfor (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = currentState[i] -\noneMinusThetaH * (v[0][i] -\ntheta * (v[1][i] +\ntheta * (v[2][i] +\neta * (v[3][i] +\ntheta * (v[4][i] +\neta * (v[5][i] +\ntheta * (v[6][i])))))));\ninterpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\ndot3 * v[3][i] + dot4 * v[4][i] +\ndot5 * v[5][i] + dot6 * v[6][i];\n}\n\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:<init>(ILorg/apache/commons/math/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max,\nMaxCountExceededCallback cb) {\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$1:compare(Lorg/apache/commons/math/ode/events/EventState;Lorg/apache/commons/math/ode/events/EventState;)I",
            "method_body": "protected double acceptStep(final AbstractStepInterpolator interpolator,\nfinal double[] y, final double[] yDot, final double tEnd)\nthrows MathIllegalStateException {\n\ndouble previousT = interpolator.getGlobalPreviousTime();\nfinal double currentT = interpolator.getGlobalCurrentTime();\nresetOccurred = false;\n\n// initialize the events states if needed\nif (! statesInitialized) {\nfor (EventState state : eventsStates) {\nstate.reinitializeBegin(interpolator);\n}\nstatesInitialized = true;\n}\n\n// search for next events that may occur during the step\nfinal int orderingSign = interpolator.isForward() ? +1 : -1;\nSortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n\n/** {@inheritDoc} */\npublic int compare(EventState es0, EventState es1) {\nreturn orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n}\n\n});\n\nfor (final EventState state : eventsStates) {\nif (state.evaluateStep(interpolator)) {\n// the event occurs during the current step\noccuringEvents.add(state);\n}\n}\n\nwhile (!occuringEvents.isEmpty()) {\n\n// handle the chronologically first event\nfinal Iterator<EventState> iterator = occuringEvents.iterator();\nfinal EventState currentEvent = iterator.next();\niterator.remove();\n\n// restrict the interpolator to the first part of the step, up to the event\nfinal double eventT = currentEvent.getEventTime();\ninterpolator.setSoftPreviousTime(previousT);\ninterpolator.setSoftCurrentTime(eventT);\n\n// trigger the event\ninterpolator.setInterpolatedTime(eventT);\nfinal double[] eventY = interpolator.getInterpolatedState();\ncurrentEvent.stepAccepted(eventT, eventY);\nisLastStep = currentEvent.stop();\n\n// handle the first part of the step, up to the event\nfor (final StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, isLastStep);\n}\n\nif (isLastStep) {\n// the event asked to stop integration\nSystem.arraycopy(eventY, 0, y, 0, y.length);\nreturn eventT;\n}\n\nif (currentEvent.reset(eventT, eventY)) {\n// some event handler has triggered changes that\n// invalidate the derivatives, we need to recompute them\nSystem.arraycopy(eventY, 0, y, 0, y.length);\ncomputeDerivatives(eventT, y, yDot);\nresetOccurred = true;\nreturn eventT;\n}\n\n// prepare handling of the remaining part of the step\npreviousT = eventT;\ninterpolator.setSoftPreviousTime(eventT);\ninterpolator.setSoftCurrentTime(currentT);\n\n// check if the same event occurs again in the remaining part of the step\nif (currentEvent.evaluateStep(interpolator)) {\n// the event occurs during the current step\noccuringEvents.add(currentEvent);\n}\n\n}\n\ninterpolator.setInterpolatedTime(currentT);\nfinal double[] currentY = interpolator.getInterpolatedState();\nfor (final EventState state : eventsStates) {\nstate.stepAccepted(currentT, currentY);\nisLastStep = isLastStep || state.stop();\n}\nisLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\n\n// handle the remaining part of the step, after all events if any\nfor (StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, isLastStep);\n}\n\nreturn currentT;\n\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:<init>(Ljava/lang/String;DDDD)V",
            "method_body": "public AdaptiveStepsizeIntegrator(final String name,\nfinal double minStep, final double maxStep,\nfinal double scalAbsoluteTolerance,\nfinal double scalRelativeTolerance) {\n\nsuper(name);\nsetStepSizeControl(minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\nresetInternalState();\n\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:<init>(Lorg/apache/commons/math/ode/sampling/AbstractStepInterpolator;)V",
            "method_body": "protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {\n\nglobalPreviousTime = interpolator.globalPreviousTime;\nglobalCurrentTime  = interpolator.globalCurrentTime;\nsoftPreviousTime   = interpolator.softPreviousTime;\nsoftCurrentTime    = interpolator.softCurrentTime;\nh                  = interpolator.h;\ninterpolatedTime   = interpolator.interpolatedTime;\n\nif (interpolator.currentState == null) {\ncurrentState     = null;\nprimaryMapper    = null;\nsecondaryMappers = null;\nallocateInterpolatedArrays(-1);\n} else {\ncurrentState                     = interpolator.currentState.clone();\ninterpolatedState                = interpolator.interpolatedState.clone();\ninterpolatedDerivatives          = interpolator.interpolatedDerivatives.clone();\ninterpolatedPrimaryState         = interpolator.interpolatedPrimaryState.clone();\ninterpolatedPrimaryDerivatives   = interpolator.interpolatedPrimaryDerivatives.clone();\ninterpolatedSecondaryState       = new double[interpolator.interpolatedSecondaryState.length][];\ninterpolatedSecondaryDerivatives = new double[interpolator.interpolatedSecondaryDerivatives.length][];\nfor (int i = 0; i < interpolatedSecondaryState.length; ++i) {\ninterpolatedSecondaryState[i]       = interpolator.interpolatedSecondaryState[i].clone();\ninterpolatedSecondaryDerivatives[i] = interpolator.interpolatedSecondaryDerivatives[i].clone();\n}\n}\n\nfinalized        = interpolator.finalized;\nforward          = interpolator.forward;\ndirtyState       = interpolator.dirtyState;\nprimaryMapper    = interpolator.primaryMapper;\nsecondaryMappers = (interpolator.secondaryMappers == null) ?\nnull : interpolator.secondaryMappers.clone();\n\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BaseAbstractUnivariateRealSolver:computeObjectiveValue(D)D",
            "method_body": "protected double computeObjectiveValue(double point)\nthrows TooManyEvaluationsException {\nincrementEvaluationCount();\nreturn function.value(point);\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState$1:value(D)D",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nthrows ConvergenceException {\n\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal double dt = t1 - t0;\nif (FastMath.abs(dt) < convergence) {\n// we cannot do anything on such a small step, don't trigger any events\nreturn false;\n}\nfinal int    n = FastMath.max(1, (int) FastMath.ceil(FastMath.abs(dt) / maxCheckInterval));\nfinal double h = dt / n;\n\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\npublic double value(final double t) {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\n}\n};\n\ndouble ta = t0;\ndouble ga = g0;\nfor (int i = 0; i < n; ++i) {\n\n// evaluate handler value at the end of the substep\nfinal double tb = t0 + (i + 1) * h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n// check events occurrence\nif (g0Positive ^ (gb >= 0)) {\n// there is a sign change: an event is expected during this step\n\n// variation direction, with respect to the integration direction\nincreasing = gb >= ga;\n\n// find the event time making sure we select a solution just at or past the exact root\nfinal double root;\nif (solver instanceof BracketedUnivariateRealSolver<?>) {\n@SuppressWarnings(\"unchecked\")\nBracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\n(BracketedUnivariateRealSolver<UnivariateRealFunction>) solver;\nroot = forward ?\nbracketing.solve(maxIterationCount, f, ta, tb, AllowedSolution.RIGHT_SIDE) :\nbracketing.solve(maxIterationCount, f, tb, ta, AllowedSolution.LEFT_SIDE);\n} else {\nfinal double baseRoot = forward ?\nsolver.solve(maxIterationCount, f, ta, tb) :\nsolver.solve(maxIterationCount, f, tb, ta);\nfinal int remainingEval = maxIterationCount - solver.getEvaluations();\nBracketedUnivariateRealSolver<UnivariateRealFunction> bracketing =\nnew PegasusSolver(solver.getRelativeAccuracy(), solver.getAbsoluteAccuracy());\nroot = forward ?\nUnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\nbaseRoot, ta, tb, AllowedSolution.RIGHT_SIDE) :\nUnivariateRealSolverUtils.forceSide(remainingEval, f, bracketing,\nbaseRoot, tb, ta, AllowedSolution.LEFT_SIDE);\n}\n\nif ((!Double.isNaN(previousEventTime)) &&\n(FastMath.abs(root - ta) <= convergence) &&\n(FastMath.abs(root - previousEventTime) <= convergence)) {\n// we have either found nothing or found (again ?) a past event,\n// retry the substep excluding this value\nta = forward ? ta + convergence : ta - convergence;\nga = f.value(ta);\n--i;\n} else if (Double.isNaN(previousEventTime) ||\n(FastMath.abs(previousEventTime - root) > convergence)) {\npendingEventTime = root;\npendingEvent = true;\nreturn true;\n} else {\n// no sign change: there is no event for now\nta = tb;\nga = gb;\n}\n\n} else {\n// no sign change: there is no event for now\nta = tb;\nga = gb;\n}\n\n}\n\n// no event during the whole step\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:setSoftPreviousTime(D)V",
            "method_body": "public void setSoftPreviousTime(final double softPreviousTime) {\nthis.softPreviousTime = softPreviousTime;\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:resetEvaluations()V",
            "method_body": "protected void resetEvaluations() {\nevaluations.resetCount();\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:exp(DD[D)D",
            "method_body": "private static double exp(double x, double extra, double[] hiPrec) {\ndouble intPartA;\ndouble intPartB;\nint intVal;\n\n/* Lookup exp(floor(x)).\n* intPartA will have the upper 22 bits, intPartB will have the lower\n* 52 bits.\n*/\nif (x < 0.0) {\nintVal = (int) -x;\n\nif (intVal > 746) {\nif (hiPrec != null) {\nhiPrec[0] = 0.0;\nhiPrec[1] = 0.0;\n}\nreturn 0.0;\n}\n\nif (intVal > 709) {\n/* This will produce a subnormal output */\nfinal double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\nif (hiPrec != null) {\nhiPrec[0] /= 285040095144011776.0;\nhiPrec[1] /= 285040095144011776.0;\n}\nreturn result;\n}\n\nif (intVal == 709) {\n/* exp(1.494140625) is nearly a machine number... */\nfinal double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\nif (hiPrec != null) {\nhiPrec[0] /= 4.455505956692756620;\nhiPrec[1] /= 4.455505956692756620;\n}\nreturn result;\n}\n\nintVal++;\n\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\nintVal = -intVal;\n} else {\nintVal = (int) x;\n\nif (intVal > 709) {\nif (hiPrec != null) {\nhiPrec[0] = Double.POSITIVE_INFINITY;\nhiPrec[1] = 0.0;\n}\nreturn Double.POSITIVE_INFINITY;\n}\n\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n}\n\n/* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n* x and look up the exp function of it.\n* fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n*/\nfinal int intFrac = (int) ((x - intVal) * 1024.0);\nfinal double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\nfinal double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n/* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n* has a value in the range 0 <= epsilon < 2^-10.\n* Do the subtraction from x as the last step to avoid possible loss of percison.\n*/\nfinal double epsilon = x - (intVal + intFrac / 1024.0);\n\n/* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\nfull double precision (52 bits).  Since z < 2^-10, we will have\n62 bits of precision when combined with the contant 1.  This will be\nused in the last addition below to get proper rounding. */\n\n/* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\nis less than 0.5 ULP */\ndouble z = 0.04168701738764507;\nz = z * epsilon + 0.1666666505023083;\nz = z * epsilon + 0.5000000000042687;\nz = z * epsilon + 1.0;\nz = z * epsilon + -3.940510424527919E-20;\n\n/* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\nexpansion.\ntempA is exact since intPartA and intPartB only have 22 bits each.\ntempB will have 52 bits of precision.\n*/\ndouble tempA = intPartA * fracPartA;\ndouble tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n/* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\nimportant.  For accuracy add by increasing size.  tempA is exact and\nmuch larger than the others.  If there are extra bits specified from the\npow() function, use them. */\nfinal double tempC = tempB + tempA;\nfinal double result;\nif (extra != 0.0) {\nresult = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n} else {\nresult = tempC*z + tempB + tempA;\n}\n\nif (hiPrec != null) {\n// If requesting high precision\nhiPrec[0] = tempA;\nhiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n}\n\nreturn result;\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$1:compare(Ljava/lang/Object;Ljava/lang/Object;)I",
            "method_body": "protected double acceptStep(final AbstractStepInterpolator interpolator,\ndouble previousT = interpolator.getGlobalPreviousTime();\nfinal double currentT = interpolator.getGlobalCurrentTime();\nresetOccurred = false;\nif (! statesInitialized) {\nfor (EventState state : eventsStates) {\nstate.reinitializeBegin(interpolator);\nstatesInitialized = true;\nfinal int orderingSign = interpolator.isForward() ? +1 : -1;\nSortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\nreturn orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\nfor (final EventState state : eventsStates) {\nif (state.evaluateStep(interpolator)) {\noccuringEvents.add(state);\nwhile (!occuringEvents.isEmpty()) {\nfinal Iterator<EventState> iterator = occuringEvents.iterator();\nfinal EventState currentEvent = iterator.next();\niterator.remove();\nfinal double eventT = currentEvent.getEventTime();\ninterpolator.setSoftPreviousTime(previousT);\ninterpolator.setSoftCurrentTime(eventT);\ninterpolator.setInterpolatedTime(eventT);\nfinal double[] eventY = interpolator.getInterpolatedState();\ncurrentEvent.stepAccepted(eventT, eventY);\nisLastStep = currentEvent.stop();\nfor (final StepHandler handler : stepHandlers) {\nif (isLastStep) {\nif (currentEvent.reset(eventT, eventY)) {\nSystem.arraycopy(eventY, 0, y, 0, y.length);\ncomputeDerivatives(eventT, y, yDot);\nresetOccurred = true;\nreturn eventT;\ninterpolator.setInterpolatedTime(currentT);\nfinal double[] currentY = interpolator.getInterpolatedState();\nfor (final EventState state : eventsStates) {\nstate.stepAccepted(currentT, currentY);\nisLastStep = isLastStep || state.stop();\nisLastStep = isLastStep || Precision.equals(currentT, tEnd, 1);\nfor (StepHandler handler : stepHandlers) {\nreturn currentT;\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:getOrder()I",
            "method_body": "public int getOrder() {\nreturn 8;\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:reset(D[D)Z",
            "method_body": "public boolean reset(final double t, final double[] y) {\n\nif (!(pendingEvent && (FastMath.abs(pendingEventTime - t) <= convergence))) {\nreturn false;\n}\n\nif (nextAction == EventHandler.Action.RESET_STATE) {\nhandler.resetState(t, y);\n}\npendingEvent      = false;\npendingEventTime  = Double.NaN;\n\nreturn (nextAction == EventHandler.Action.RESET_STATE) ||\n(nextAction == EventHandler.Action.RESET_DERIVATIVES);\n\n}",
            "method_id": 118
        }
    ]
}