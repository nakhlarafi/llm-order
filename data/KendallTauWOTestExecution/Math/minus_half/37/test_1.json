{
    "bug_id": 37,
    "test_id": 1,
    "test_name": "org.apache.commons.math.complex.ComplexTest.testTanInf",
    "test_body": "public void testTanInf() {\nTestUtils.assertSame(Complex.valueOf(0.0, 1.0), oneInf.tan());\nTestUtils.assertSame(Complex.valueOf(0.0, -1.0), oneNegInf.tan());\nTestUtils.assertSame(Complex.NaN, infOne.tan());\nTestUtils.assertSame(Complex.NaN, negInfOne.tan());\nTestUtils.assertSame(Complex.NaN, infInf.tan());\nTestUtils.assertSame(Complex.NaN, infNegInf.tan());\nTestUtils.assertSame(Complex.NaN, negInfInf.tan());\nTestUtils.assertSame(Complex.NaN, negInfNegInf.tan());\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<1.0> but was:<NaN>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math.TestUtils.assertSame(TestUtils.java:77)\nat org.apache.commons.math.TestUtils.assertSame(TestUtils.java:86)\nat org.apache.commons.math.complex.ComplexTest.testTanInf(ComplexTest.java:1015)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.util.FastMath:polySine(D)D",
            "method_body": "private static double polySine(final double x)\n{\ndouble x2 = x*x;\n\ndouble p = 2.7553817452272217E-6;\np = p * x2 + -1.9841269659586505E-4;\np = p * x2 + 0.008333333333329196;\np = p * x2 + -0.16666666666666666;\n//p *= x2;\n//p *= x;\np = p * x2 * x;\n\nreturn p;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\n\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\n\nreturn p;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:valueOf(DD)Lorg/apache/commons/math/complex/Complex;",
            "method_body": "public static Complex valueOf(double realPart,\ndouble imaginaryPart) {\nif (Double.isNaN(realPart) ||\nDouble.isNaN(imaginaryPart)) {\nreturn NaN;\n}\nreturn new Complex(realPart, imaginaryPart);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xa;\ndouble xb = 0.0;\n\n/* Take absolute value of the input */\nxa = x;\nif (x < 0) {\nnegative = true;\nxa = -xa;\n}\n\n/* Check for zero and negative zero */\nif (xa == 0.0) {\nlong bits = Double.doubleToLongBits(x);\nif (bits < 0) {\nreturn -0.0;\n}\nreturn 0.0;\n}\n\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nreturn Double.NaN;\n}\n\n/* Perform any argument reduction */\nif (xa > 3294198.0) {\n// PI * (2**20)\n// Argument too big for CodyWaite reduction.  Must use\n// PayneHanek.\ndouble reduceResults[] = new double[3];\nreducePayneHanek(xa, reduceResults);\nquadrant = ((int) reduceResults[0]) & 3;\nxa = reduceResults[1];\nxb = reduceResults[2];\n} else if (xa > 1.5707963267948966) {\n/* Inline the Cody/Waite reduction for performance */\n\n// Estimate k\n//k = (int)(xa / 1.5707963267948966);\nint k = (int)(xa * 0.6366197723675814);\n\n// Compute remainder\ndouble remA;\ndouble remB;\nwhile (true) {\ndouble a = -k * 1.570796251296997;\nremA = xa + a;\nremB = -(remA - xa - a);\n\na = -k * 7.549789948768648E-8;\ndouble b = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\na = -k * 6.123233995736766E-17;\nb = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\nif (remA > 0.0) {\nbreak;\n}\n\n// Remainder is negative, so decrement k and try again.\n// This should only happen if the input is very close\n// to an even multiple of pi/2\nk--;\n}\nquadrant = k & 3;\nxa = remA;\nxb = remB;\n}\n\nif (negative) {\nquadrant ^= 2;  // Flip bit 1\n}\n\nswitch (quadrant) {\ncase 0:\nreturn sinQ(xa, xb);\ncase 1:\nreturn cosQ(xa, xb);\ncase 2:\nreturn -sinQ(xa, xb);\ncase 3:\nreturn -cosQ(xa, xb);\ndefault:\nreturn Double.NaN;\n}\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:getImaginary()D",
            "method_body": "public double getImaginary() {\nreturn imaginary;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:tan()Lorg/apache/commons/math/complex/Complex;",
            "method_body": "public Complex tan() {\nif (isNaN) {\nreturn NaN;\n}\n\ndouble real2 = 2.0 * real;\ndouble imaginary2 = 2.0 * imaginary;\ndouble d = FastMath.cos(real2) + FastMath.cosh(imaginary2);\n\nreturn createComplex(FastMath.sin(real2) / d,\nFastMath.sinh(imaginary2) / d);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:getReal()D",
            "method_body": "public double getReal() {\nreturn real;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:sinQ(DD)D",
            "method_body": "private static double sinQ(double xa, double xb) {\nint idx = (int) ((xa * 8.0) + 0.5);\nfinal double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n// Table lookups\nfinal double sintA = SINE_TABLE_A[idx];\nfinal double sintB = SINE_TABLE_B[idx];\nfinal double costA = COSINE_TABLE_A[idx];\nfinal double costB = COSINE_TABLE_B[idx];\n\n// Polynomial eval of sin(epsilon), cos(epsilon)\ndouble sinEpsA = epsilon;\ndouble sinEpsB = polySine(epsilon);\nfinal double cosEpsA = 1.0;\nfinal double cosEpsB = polyCosine(epsilon);\n\n// Split epsilon   xa + xb = x\nfinal double temp = sinEpsA * HEX_40000000;\ndouble temp2 = (sinEpsA + temp) - temp;\nsinEpsB +=  sinEpsA - temp2;\nsinEpsA = temp2;\n\n/* Compute sin(x) by angle addition formula */\ndouble result;\n\n/* Compute the following sum:\n*\n* result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n*          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n*\n* Ranges of elements\n*\n* xxxtA   0            PI/2\n* xxxtB   -1.5e-9      1.5e-9\n* sinEpsA -0.0625      0.0625\n* sinEpsB -6e-11       6e-11\n* cosEpsA  1.0\n* cosEpsB  0           -0.0625\n*\n*/\n\n//result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n//          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n//result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n//result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\ndouble a = 0;\ndouble b = 0;\n\ndouble t = sintA;\ndouble c = a + t;\ndouble d = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA * sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nb = b + sintA * cosEpsB + costA * sinEpsB;\n/*\nt = sintA*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nb = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n/*\nt = sintB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = sintB*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nif (xb != 0.0) {\nt = ((costA + costB) * (cosEpsA + cosEpsB) -\n(sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n}\n\nresult = a + b;\n\nreturn result;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:<init>(DD)V",
            "method_body": "public Complex(double real, double imaginary) {\nthis.real = real;\nthis.imaginary = imaginary;\n\nisNaN = Double.isNaN(real) || Double.isNaN(imaginary);\nisInfinite = !isNaN &&\n(Double.isInfinite(real) || Double.isInfinite(imaginary));\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:cosQ(DD)D",
            "method_body": "private static double cosQ(double xa, double xb) {\nfinal double pi2a = 1.5707963267948966;\nfinal double pi2b = 6.123233995736766E-17;\n\nfinal double a = pi2a - xa;\ndouble b = -(a - pi2a + xa);\nb += pi2b - xb;\n\nreturn sinQ(a, b);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:exp(D)D",
            "method_body": "public static double exp(double x) {\nreturn exp(x, 0.0, null);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.complex.Complex:createComplex(DD)Lorg/apache/commons/math/complex/Complex;",
            "method_body": "protected Complex createComplex(double realPart,\ndouble imaginaryPart) {\nreturn new Complex(realPart, imaginaryPart);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:cos(D)D",
            "method_body": "public static double cos(double x) {\nint quadrant = 0;\n\n/* Take absolute value of the input */\ndouble xa = x;\nif (x < 0) {\nxa = -xa;\n}\n\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nreturn Double.NaN;\n}\n\n/* Perform any argument reduction */\ndouble xb = 0;\nif (xa > 3294198.0) {\n// PI * (2**20)\n// Argument too big for CodyWaite reduction.  Must use\n// PayneHanek.\ndouble reduceResults[] = new double[3];\nreducePayneHanek(xa, reduceResults);\nquadrant = ((int) reduceResults[0]) & 3;\nxa = reduceResults[1];\nxb = reduceResults[2];\n} else if (xa > 1.5707963267948966) {\n/* Inline the Cody/Waite reduction for performance */\n\n// Estimate k\n//k = (int)(xa / 1.5707963267948966);\nint k = (int)(xa * 0.6366197723675814);\n\n// Compute remainder\ndouble remA;\ndouble remB;\nwhile (true) {\ndouble a = -k * 1.570796251296997;\nremA = xa + a;\nremB = -(remA - xa - a);\n\na = -k * 7.549789948768648E-8;\ndouble b = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\na = -k * 6.123233995736766E-17;\nb = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\nif (remA > 0.0) {\nbreak;\n}\n\n// Remainder is negative, so decrement k and try again.\n// This should only happen if the input is very close\n// to an even multiple of pi/2\nk--;\n}\nquadrant = k & 3;\nxa = remA;\nxb = remB;\n}\n\n//if (negative)\n//  quadrant = (quadrant + 2) % 4;\n\nswitch (quadrant) {\ncase 0:\nreturn cosQ(xa, xb);\ncase 1:\nreturn -sinQ(xa, xb);\ncase 2:\nreturn -cosQ(xa, xb);\ncase 3:\nreturn sinQ(xa, xb);\ndefault:\nreturn Double.NaN;\n}\n}",
            "method_id": 12
        }
    ]
}