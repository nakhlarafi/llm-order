{
    "bug_id": 99,
    "test_id": 0,
    "test_name": "org.apache.commons.math.util.MathUtilsTest.testLcm",
    "test_body": "public void testLcm() {\nint a = 30;\nint b = 50;\nint c = 77;\nassertEquals(0, MathUtils.lcm(0, b));\nassertEquals(0, MathUtils.lcm(a, 0));\nassertEquals(b, MathUtils.lcm(1, b));\nassertEquals(a, MathUtils.lcm(a, 1));\nassertEquals(150, MathUtils.lcm(a, b));\nassertEquals(150, MathUtils.lcm(-a, b));\nassertEquals(150, MathUtils.lcm(a, -b));\nassertEquals(150, MathUtils.lcm(-a, -b));\nassertEquals(2310, MathUtils.lcm(a, c));\n// Assert that no intermediate value overflows:\n// The naive implementation of lcm(a,b) would be (a*b)/gcd(a,b)\nassertEquals((1<<20)*15, MathUtils.lcm((1<<20)*3, (1<<20)*5));\n// Special case\nassertEquals(0, MathUtils.lcm(0, 0));\ntry {\n// lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\nMathUtils.lcm(Integer.MIN_VALUE, 1);\nfail(\"Expecting ArithmeticException\");\n} catch (ArithmeticException ex) {\n// expected\n}\ntry {\n// lcm == abs(MIN_VALUE) cannot be represented as a nonnegative int\nMathUtils.lcm(Integer.MIN_VALUE, 1<<20);\nfail(\"Expecting ArithmeticException\");\n} catch (ArithmeticException ex) {\n// expected\n}\ntry {\nMathUtils.lcm(Integer.MAX_VALUE, Integer.MAX_VALUE - 1);\nfail(\"Expecting ArithmeticException\");\n} catch (ArithmeticException ex) {\n// expected\n}\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: Expecting ArithmeticException\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.TestCase.fail(TestCase.java:227)\nat org.apache.commons.math.util.MathUtilsTest.testLcm(MathUtilsTest.java:590)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.util.MathUtils:lcm(II)I",
            "method_body": "public static int lcm(int a, int b) {\nif (a==0 || b==0){\nreturn 0;\n}\nint lcm = Math.abs(mulAndCheck(a / gcd(a, b), b));\nreturn lcm;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.util.MathUtils:mulAndCheck(II)I",
            "method_body": "public static int mulAndCheck(int x, int y) {\nlong m = ((long)x) * ((long)y);\nif (m < Integer.MIN_VALUE || m > Integer.MAX_VALUE) {\nthrow new ArithmeticException(\"overflow: mul\");\n}\nreturn (int)m;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.util.MathUtils:gcd(II)I",
            "method_body": "public static int gcd(final int p, final int q) {\nint u = p;\nint v = q;\nif ((u == 0) || (v == 0)) {\nreturn (Math.abs(u) + Math.abs(v));\n}\n// keep u and v negative, as negative integers range down to\n// -2^31, while positive numbers can only be as large as 2^31-1\n// (i.e. we can't necessarily negate a negative number without\n// overflow)\n/* assert u!=0 && v!=0; */\nif (u > 0) {\nu = -u;\n} // make u negative\nif (v > 0) {\nv = -v;\n} // make v negative\n// B1. [Find power of 2]\nint k = 0;\nwhile ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n// both even...\nu /= 2;\nv /= 2;\nk++; // cast out twos.\n}\nif (k == 31) {\nthrow MathRuntimeException.createArithmeticException(\n\"overflow: gcd({0}, {1}) is 2^31\",\nnew Object[] { p, q });\n}\n// B2. Initialize: u and v have been divided by 2^k and at least\n// one is odd.\nint t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n// t negative: u was odd, v may be even (t replaces v)\n// t positive: u was even, v is odd (t replaces u)\ndo {\n/* assert u<0 && v<0; */\n// B4/B3: cast out twos from t.\nwhile ((t & 1) == 0) { // while t is even..\nt /= 2; // cast out twos\n}\n// B5 [reset max(u,v)]\nif (t > 0) {\nu = -t;\n} else {\nv = t;\n}\n// B6/B3. at this point both u and v should be odd.\nt = (v - u) / 2;\n// |u| larger: t positive (replace u)\n// |v| larger: t negative (replace v)\n} while (t != 0);\nreturn -u * (1 << k); // gcd is u*2^k\n}",
            "method_id": 2
        }
    ]
}