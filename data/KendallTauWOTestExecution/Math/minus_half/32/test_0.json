{
    "bug_id": 32,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest.testIssue780",
    "test_body": "public void testIssue780() {\nfloat[] coords = {\n1.000000f, -1.000000f, -1.000000f, \n1.000000f, -1.000000f, 1.000000f, \n-1.000000f, -1.000000f, 1.000000f, \n-1.000000f, -1.000000f, -1.000000f, \n1.000000f, 1.000000f, -1f, \n0.999999f, 1.000000f, 1.000000f,   // 1.000000f, 1.000000f, 1.000000f, \n-1.000000f, 1.000000f, 1.000000f, \n-1.000000f, 1.000000f, -1.000000f};\nint[] indices = {\n0, 1, 2, 0, 2, 3, \n4, 7, 6, 4, 6, 5, \n0, 4, 5, 0, 5, 1, \n1, 5, 6, 1, 6, 2, \n2, 6, 7, 2, 7, 3, \n4, 0, 3, 4, 3, 7};\nArrayList<SubHyperplane<Euclidean3D>> subHyperplaneList = new ArrayList<SubHyperplane<Euclidean3D>>();\nfor (int idx = 0; idx < indices.length; idx += 3) {\nint idxA = indices[idx] * 3;\nint idxB = indices[idx + 1] * 3;\nint idxC = indices[idx + 2] * 3;\nVector3D v_1 = new Vector3D(coords[idxA], coords[idxA + 1], coords[idxA + 2]);\nVector3D v_2 = new Vector3D(coords[idxB], coords[idxB + 1], coords[idxB + 2]);\nVector3D v_3 = new Vector3D(coords[idxC], coords[idxC + 1], coords[idxC + 2]);\nVector3D[] vertices = {v_1, v_2, v_3};\nPlane polyPlane = new Plane(v_1, v_2, v_3);\nArrayList<SubHyperplane<Euclidean2D>> lines = new ArrayList<SubHyperplane<Euclidean2D>>();\nVector2D[] projPts = new Vector2D[vertices.length];\nfor (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\nprojPts[ptIdx] = polyPlane.toSubSpace(vertices[ptIdx]);\n}\nSubLine lineInPlane = null;\nfor (int ptIdx = 0; ptIdx < projPts.length; ptIdx++) {\nlineInPlane = new SubLine(projPts[ptIdx], projPts[(ptIdx + 1) % projPts.length]);\nlines.add(lineInPlane);\n}\nRegion<Euclidean2D> polyRegion = new PolygonsSet(lines);\nSubPlane polygon = new SubPlane(polyPlane, polyRegion);\nsubHyperplaneList.add(polygon);\n}\nPolyhedronsSet polyhedronsSet = new PolyhedronsSet(subHyperplaneList);\nAssert.assertEquals( 8.0, polyhedronsSet.getSize(), 3.0e-6);\nAssert.assertEquals(24.0, polyhedronsSet.getBoundarySize(), 5.0e-6);\n}\n",
    "stack_trace": "java.lang.ClassCastException: org.apache.commons.math3.geometry.partitioning.BoundaryAttribute cannot be cast to java.lang.Boolean\nat org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet.computeGeometricalProperties(PolygonsSet.java:136)\nat org.apache.commons.math3.geometry.partitioning.AbstractRegion.getSize(AbstractRegion.java:381)\nat org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor.addContribution(PolyhedronsSet.java:171)\nat org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor.visitInternalNode(PolyhedronsSet.java:153)\nat org.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:263)\nat org.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:262)\nat org.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:262)\nat org.apache.commons.math3.geometry.partitioning.BSPTree.visit(BSPTree.java:264)\nat org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet.computeGeometricalProperties(PolyhedronsSet.java:118)\nat org.apache.commons.math3.geometry.partitioning.AbstractRegion.getSize(AbstractRegion.java:381)\nat org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSetTest.testIssue780(PolyhedronsSetTest.java:281)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:subtract(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D subtract(final Vector<Euclidean3D> v) {\nfinal Vector3D v3 = (Vector3D) v;\nreturn new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$ComparableSegment:<init>(Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Line;)V",
            "method_body": "public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {\nsuper(start, end, line);\nsortingKey = (start == null) ?\nnew OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\nnew OrderedTuple(start.getX(), start.getY());\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree:getNotSmaller(Ljava/lang/Comparable;)Lorg/apache/commons/math3/geometry/partitioning/utilities/AVLTree$Node;",
            "method_body": "public Node getNotSmaller(final T reference) {\nNode candidate = null;\nfor (Node node = top; node != null;) {\nif (node.element.compareTo(reference) < 0) {\nif (node.right == null) {\nreturn candidate;\n}\nnode = node.right;\n} else {\ncandidate = node;\nif (node.left == null) {\nreturn candidate;\n}\nnode = node.left;\n}\n}\nreturn null;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet:computeGeometricalProperties()V",
            "method_body": "protected void computeGeometricalProperties() {\n\n// compute the contribution of all boundary facets\ngetTree(true).visit(new FacetsContributionVisitor());\n\nif (getSize() < 0) {\n// the polyhedrons set as a finite outside\n// surrounded by an infinite inside\nsetSize(Double.POSITIVE_INFINITY);\nsetBarycenter(Vector3D.NaN);\n} else {\n// the polyhedrons set is finite, apply the remaining scaling factors\nsetSize(getSize() / 3.0);\nsetBarycenter(new Vector3D(1.0 / (4 * getSize()), (Vector3D) getBarycenter()));\n}\n\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.SubHyperplane$SplitSubHyperplane:getPlus()Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "public SubHyperplane<U> getPlus() {\nreturn plus;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:linearCombination(DDDDDD)D",
            "method_body": "public static double linearCombination(final double a1, final double b1,\nfinal double a2, final double b2,\nfinal double a3, final double b3) {\n\n// the code below is split in many additions/subtractions that may\n// appear redundant. However, they should NOT be simplified, as they\n// do use IEEE754 floating point arithmetic rounding properties.\n// as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n// The variables naming conventions are that xyzHigh contains the most significant\n// bits of xyz and xyzLow contains its least significant bits. So theoretically\n// xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n// be represented in only one double precision number so we preserve two numbers\n// to hold it as long as we can, combining the high and low order bits together\n// only at the end, after cancellation may have occurred on high order bits\n\n// split a1 and b1 as two 26 bits numbers\nfinal double ca1        = SPLIT_FACTOR * a1;\nfinal double a1High     = ca1 - (ca1 - a1);\nfinal double a1Low      = a1 - a1High;\nfinal double cb1        = SPLIT_FACTOR * b1;\nfinal double b1High     = cb1 - (cb1 - b1);\nfinal double b1Low      = b1 - b1High;\n\n// accurate multiplication a1 * b1\nfinal double prod1High  = a1 * b1;\nfinal double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n// split a2 and b2 as two 26 bits numbers\nfinal double ca2        = SPLIT_FACTOR * a2;\nfinal double a2High     = ca2 - (ca2 - a2);\nfinal double a2Low      = a2 - a2High;\nfinal double cb2        = SPLIT_FACTOR * b2;\nfinal double b2High     = cb2 - (cb2 - b2);\nfinal double b2Low      = b2 - b2High;\n\n// accurate multiplication a2 * b2\nfinal double prod2High  = a2 * b2;\nfinal double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n// split a3 and b3 as two 26 bits numbers\nfinal double ca3        = SPLIT_FACTOR * a3;\nfinal double a3High     = ca3 - (ca3 - a3);\nfinal double a3Low      = a3 - a3High;\nfinal double cb3        = SPLIT_FACTOR * b3;\nfinal double b3High     = cb3 - (cb3 - b3);\nfinal double b3Low      = b3 - b3High;\n\n// accurate multiplication a3 * b3\nfinal double prod3High  = a3 * b3;\nfinal double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n// accurate addition a1 * b1 + a2 * b2\nfinal double s12High    = prod1High + prod2High;\nfinal double s12Prime   = s12High - prod2High;\nfinal double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n// accurate addition a1 * b1 + a2 * b2 + a3 * b3\nfinal double s123High   = s12High + prod3High;\nfinal double s123Prime  = s123High - prod3High;\nfinal double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n// final rounding, s123 may have suffered many cancellations, we try\n// to recover some bits from the extra words we have saved up to now\ndouble result = s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\nif (Double.isNaN(result)) {\n// either we have split infinite numbers or some coefficients were NaNs,\n// just rely on the naive implementation and let IEEE754 handle this\nresult = a1 * b1 + a2 * b2 + a3 * b3;\n}\n\nreturn result;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:getNorm()D",
            "method_body": "public double getNorm() {\n// there are no cancellation problems here, so we use the straightforward formula\nreturn FastMath.sqrt (x * x + y * y + z * z);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:getHyperplane()Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;",
            "method_body": "public Hyperplane<S> getHyperplane() {\nreturn hyperplane;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cos(D)D",
            "method_body": "public static double cos(double x) {\nint quadrant = 0;\n\n/* Take absolute value of the input */\ndouble xa = x;\nif (x < 0) {\nxa = -xa;\n}\n\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nreturn Double.NaN;\n}\n\n/* Perform any argument reduction */\ndouble xb = 0;\nif (xa > 3294198.0) {\n// PI * (2**20)\n// Argument too big for CodyWaite reduction.  Must use\n// PayneHanek.\ndouble reduceResults[] = new double[3];\nreducePayneHanek(xa, reduceResults);\nquadrant = ((int) reduceResults[0]) & 3;\nxa = reduceResults[1];\nxb = reduceResults[2];\n} else if (xa > 1.5707963267948966) {\n/* Inline the Cody/Waite reduction for performance */\n\n// Estimate k\n//k = (int)(xa / 1.5707963267948966);\nint k = (int)(xa * 0.6366197723675814);\n\n// Compute remainder\ndouble remA;\ndouble remB;\nwhile (true) {\ndouble a = -k * 1.570796251296997;\nremA = xa + a;\nremB = -(remA - xa - a);\n\na = -k * 7.549789948768648E-8;\ndouble b = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\na = -k * 6.123233995736766E-17;\nb = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\nif (remA > 0.0) {\nbreak;\n}\n\n// Remainder is negative, so decrement k and try again.\n// This should only happen if the input is very close\n// to an even multiple of pi/2\nk--;\n}\nquadrant = k & 3;\nxa = remA;\nxb = remB;\n}\n\n//if (negative)\n//  quadrant = (quadrant + 2) % 4;\n\nswitch (quadrant) {\ncase 0:\nreturn cosQ(xa, xb);\ncase 1:\nreturn -sinQ(xa, xb);\ncase 2:\nreturn -cosQ(xa, xb);\ncase 3:\nreturn sinQ(xa, xb);\ndefault:\nreturn Double.NaN;\n}\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:insertInTree(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Z)V",
            "method_body": "public void insertInTree(final BSPTree<S> parentTree, final boolean isPlusChild) {\n\n// set up parent/child links\nparent = parentTree;\nif (parentTree != null) {\nif (isPlusChild) {\nparentTree.plus = this;\n} else {\nparentTree.minus = this;\n}\n}\n\n// make sure the inserted tree lies in the cell defined by its parent nodes\nif (cut != null) {\n\n// explore the parent nodes from here towards tree root\nfor (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\n\n// this is an hyperplane of some parent node\nfinal Hyperplane<S> hyperplane = tree.parent.cut.getHyperplane();\n\n// chop off the parts of the inserted tree that extend\n// on the wrong side of this parent hyperplane\nif (tree == tree.parent.plus) {\ncut = cut.split(hyperplane).getPlus();\nplus.chopOffMinus(hyperplane);\nminus.chopOffMinus(hyperplane);\n} else {\ncut = cut.split(hyperplane).getMinus();\nplus.chopOffPlus(hyperplane);\nminus.chopOffPlus(hyperplane);\n}\n\n}\n\n// since we may have drop some parts of the inserted tree,\n// perform a condensation pass to keep the tree structure simple\ncondense();\n\n}\n\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:setSize(D)V",
            "method_body": "protected void setSize(final double size) {\nthis.size = size;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:asList()Ljava/util/List;",
            "method_body": "public List<Interval> asList() {\nfinal List<Interval> list = new ArrayList<Interval>();\nrecurseList(getTree(false), list,\nDouble.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\nreturn list;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:doubleHighPart(D)D",
            "method_body": "private static double doubleHighPart(double d) {\nif (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){\nreturn d; // These are un-normalised - don't try to convert\n}\nlong xl = Double.doubleToLongBits(d);\nxl = xl & MASK_30BITS; // Drop low order bits\nreturn Double.longBitsToDouble(xl);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute:<init>(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;)V",
            "method_body": "public BoundaryAttribute(final SubHyperplane<S> plusOutside,\nfinal SubHyperplane<S> plusInside) {\nthis.plusOutside = plusOutside;\nthis.plusInside  = plusInside;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory$UnionMerger:merge(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Lorg/apache/commons/math3/geometry/partitioning/BSPTree;ZZ)Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "public BSPTree<S> merge(final BSPTree<S> leaf, final BSPTree<S> tree,\nfinal BSPTree<S> parentTree,\nfinal boolean isPlusChild, final boolean leafFromInstance) {\nif ((Boolean) leaf.getAttribute()) {\n// the leaf node represents an inside cell\nleaf.insertInTree(parentTree, isPlusChild);\nreturn leaf;\n}\n// the leaf node represents an outside cell\ntree.insertInTree(parentTree, isPlusChild);\nreturn tree;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint:sameOrientationAs(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Z",
            "method_body": "public boolean sameOrientationAs(final Hyperplane<Euclidean1D> other) {\nreturn !(direct ^ ((OrientedPoint) other).direct);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:setBarycenter(Lorg/apache/commons/math3/geometry/Vector;)V",
            "method_body": "protected void setBarycenter(final Vector<S> barycenter) {\nthis.barycenter = barycenter;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:getOffset(Lorg/apache/commons/math3/geometry/euclidean/twod/Line;)D",
            "method_body": "public double getOffset(final Line line) {\nreturn originOffset +\n((cos * line.cos + sin * line.sin > 0) ? -line.originOffset : line.originOffset);\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint:split(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane$SplitSubHyperplane;",
            "method_body": "public SplitSubHyperplane<Euclidean1D> split(final Hyperplane<Euclidean1D> hyperplane) {\nfinal double global = hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\nreturn (global < -1.0e-10) ?\nnew SplitSubHyperplane<Euclidean1D>(null, this) :\nnew SplitSubHyperplane<Euclidean1D>(this, null);\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:<init>(Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;)V",
            "method_body": "public Line(final Vector2D p1, final Vector2D p2) {\nreset(p1, p2);\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:getRemainingRegion()Lorg/apache/commons/math3/geometry/partitioning/Region;",
            "method_body": "public Region<T> getRemainingRegion() {\nreturn remainingRegion;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval:getMidPoint()D",
            "method_body": "public double getMidPoint() {\nreturn 0.5 * (lower + upper);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:<init>(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;Lorg/apache/commons/math3/geometry/partitioning/Region;)V",
            "method_body": "protected AbstractSubHyperplane(final Hyperplane<S> hyperplane,\nfinal Region<T> remainingRegion) {\nthis.hyperplane      = hyperplane;\nthis.remainingRegion = remainingRegion;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathUtils:normalizeAngle(DD)D",
            "method_body": "public static double normalizeAngle(double a, double center) {\nreturn a - TWO_PI * FastMath.floor((a + FastMath.PI - center) / TWO_PI);\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Segment:getEnd()Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;",
            "method_body": "public Vector2D getEnd() {\nreturn end;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:characterize(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Lorg/apache/commons/math3/geometry/partitioning/Characterization;)V",
            "method_body": "private void characterize(final BSPTree<S> node, final SubHyperplane<S> sub,\nfinal Characterization<S> characterization) {\nif (node.getCut() == null) {\n// we have reached a leaf node\nfinal boolean inside = (Boolean) node.getAttribute();\ncharacterization.add(sub, inside);\n} else {\nfinal Hyperplane<S> hyperplane = node.getCut().getHyperplane();\nswitch (sub.side(hyperplane)) {\ncase PLUS:\ncharacterize(node.getPlus(), sub, characterization);\nbreak;\ncase MINUS:\ncharacterize(node.getMinus(), sub, characterization);\nbreak;\ncase BOTH:\nfinal SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);\ncharacterize(node.getPlus(),  split.getPlus(),  characterization);\ncharacterize(node.getMinus(), split.getMinus(), characterization);\nbreak;\ndefault:\n// this should not happen\nthrow new MathInternalError();\n}\n}\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D:getY()D",
            "method_body": "public double getY() {\nreturn y;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:getTree(Z)Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "public BSPTree<S> getTree(final boolean includeBoundaryAttributes) {\nif (includeBoundaryAttributes && (tree.getCut() != null) && (tree.getAttribute() == null)) {\n// we need to compute the boundary attributes\nrecurseBuildBoundary(tree);\n}\nreturn tree;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine:side(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Lorg/apache/commons/math3/geometry/partitioning/Side;",
            "method_body": "public Side side(final Hyperplane<Euclidean2D> hyperplane) {\n\nfinal Line    thisLine  = (Line) getHyperplane();\nfinal Line    otherLine = (Line) hyperplane;\nfinal Vector2D crossing  = thisLine.intersection(otherLine);\n\nif (crossing == null) {\n// the lines are parallel,\nfinal double global = otherLine.getOffset(thisLine);\nreturn (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n}\n\n// the lines do intersect\nfinal boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\nfinal Vector1D x = thisLine.toSubSpace(crossing);\nreturn getRemainingRegion().side(new OrientedPoint(x, direct));\n\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet:<init>()V",
            "method_body": "public PolygonsSet() {\nsuper();\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:merge(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Lorg/apache/commons/math3/geometry/partitioning/BSPTree$LeafMerger;Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Z)Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "private BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger,\nfinal BSPTree<S> parentTree, final boolean isPlusChild) {\nif (cut == null) {\n// cell/tree operation\nreturn leafMerger.merge(this, tree, parentTree, isPlusChild, true);\n} else if (tree.cut == null) {\n// tree/cell operation\nreturn leafMerger.merge(tree, this, parentTree, isPlusChild, false);\n} else {\n// tree/tree operation\nfinal BSPTree<S> merged = tree.split(cut);\nif (parentTree != null) {\nmerged.parent = parentTree;\nif (isPlusChild) {\nparentTree.plus = merged;\n} else {\nparentTree.minus = merged;\n}\n}\n\n// merging phase\nplus.merge(merged.plus, leafMerger, merged, true);\nminus.merge(merged.minus, leafMerger, merged, false);\nmerged.condense();\nif (merged.cut != null) {\nmerged.cut =\nmerged.fitToCell(merged.cut.getHyperplane().wholeHyperplane());\n}\n\nreturn merged;\n\n}\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:reunite(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;)Lorg/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane;",
            "method_body": "public AbstractSubHyperplane<S, T> reunite(final SubHyperplane<S> other) {\n@SuppressWarnings(\"unchecked\")\nAbstractSubHyperplane<S, T> o = (AbstractSubHyperplane<S, T>) other;\nreturn buildNew(hyperplane,\nnew RegionFactory<T>().union(remainingRegion, o.remainingRegion));\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:atan2(DD)D",
            "method_body": "public static double atan2(double y, double x) {\nif (x != x || y != y) {\nreturn Double.NaN;\n}\n\nif (y == 0) {\nfinal double result = x * y;\nfinal double invx = 1d / x;\nfinal double invy = 1d / y;\n\nif (invx == 0) { // X is infinite\nif (x > 0) {\nreturn y; // return +/- 0.0\n} else {\nreturn copySign(Math.PI, y);\n}\n}\n\nif (x < 0 || invx < 0) {\nif (y < 0 || invy < 0) {\nreturn -Math.PI;\n} else {\nreturn Math.PI;\n}\n} else {\nreturn result;\n}\n}\n\n// y cannot now be zero\n\nif (y == Double.POSITIVE_INFINITY) {\nif (x == Double.POSITIVE_INFINITY) {\nreturn Math.PI * F_1_4;\n}\n\nif (x == Double.NEGATIVE_INFINITY) {\nreturn Math.PI * F_3_4;\n}\n\nreturn Math.PI * F_1_2;\n}\n\nif (y == Double.NEGATIVE_INFINITY) {\nif (x == Double.POSITIVE_INFINITY) {\nreturn -Math.PI * F_1_4;\n}\n\nif (x == Double.NEGATIVE_INFINITY) {\nreturn -Math.PI * F_3_4;\n}\n\nreturn -Math.PI * F_1_2;\n}\n\nif (x == Double.POSITIVE_INFINITY) {\nif (y > 0 || 1 / y > 0) {\nreturn 0d;\n}\n\nif (y < 0 || 1 / y < 0) {\nreturn -0d;\n}\n}\n\nif (x == Double.NEGATIVE_INFINITY)\n{\nif (y > 0.0 || 1 / y > 0.0) {\nreturn Math.PI;\n}\n\nif (y < 0 || 1 / y < 0) {\nreturn -Math.PI;\n}\n}\n\n// Neither y nor x can be infinite or NAN here\n\nif (x == 0) {\nif (y > 0 || 1 / y > 0) {\nreturn Math.PI * F_1_2;\n}\n\nif (y < 0 || 1 / y < 0) {\nreturn -Math.PI * F_1_2;\n}\n}\n\n// Compute ratio r = y/x\nfinal double r = y / x;\nif (Double.isInfinite(r)) { // bypass calculations that can create NaN\nreturn atan(r, 0, x < 0);\n}\n\ndouble ra = doubleHighPart(r);\ndouble rb = r - ra;\n\n// Split x\nfinal double xa = doubleHighPart(x);\nfinal double xb = x - xa;\n\nrb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\nfinal double temp = ra + rb;\nrb = -(temp - ra - rb);\nra = temp;\n\nif (ra == 0) { // Fix up the sign so atan works correctly\nra = copySign(0d, y);\n}\n\n// Call atan\nfinal double result = atan(ra, rb, x < 0);\n\nreturn result;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:checkPoint(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/partitioning/Region$Location;",
            "method_body": "protected Location checkPoint(final BSPTree<S> node, final Vector<S> point) {\nfinal BSPTree<S> cell = node.getCell(point);\nif (cell.getCut() == null) {\n// the point is in the interior of a cell, just check the attribute\nreturn ((Boolean) cell.getAttribute()) ? Location.INSIDE : Location.OUTSIDE;\n}\n\n// the point is on a cut-sub-hyperplane, is it on a boundary ?\nfinal Location minusCode = checkPoint(cell.getMinus(), point);\nfinal Location plusCode  = checkPoint(cell.getPlus(),  point);\nreturn (minusCode == plusCode) ? minusCode : Location.BOUNDARY;\n\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:getBarycenter()Lorg/apache/commons/math3/geometry/Vector;",
            "method_body": "public Vector<S> getBarycenter() {\nif (barycenter == null) {\ncomputeGeometricalProperties();\n}\nreturn barycenter;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple:exponent(J)I",
            "method_body": "private static int exponent(final long bits) {\nreturn ((int) ((bits & EXPONENT_MASK) >> 52)) - 1075;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:atan(DDZ)D",
            "method_body": "private static double atan(double xa, double xb, boolean leftPlane) {\nboolean negate = false;\nint idx;\n\nif (xa == 0.0) { // Matches +/- 0.0; return correct sign\nreturn leftPlane ? copySign(Math.PI, xa) : xa;\n}\n\nif (xa < 0) {\n// negative\nxa = -xa;\nxb = -xb;\nnegate = true;\n}\n\nif (xa > 1.633123935319537E16) { // Very large input\nreturn (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);\n}\n\n/* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */\nif (xa < 1) {\nidx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n} else {\nfinal double oneOverXa = 1 / xa;\nidx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\n}\ndouble epsA = xa - TANGENT_TABLE_A[idx];\ndouble epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\nepsB += xb - TANGENT_TABLE_B[idx];\n\ndouble temp = epsA + epsB;\nepsB = -(temp - epsA - epsB);\nepsA = temp;\n\n/* Compute eps = eps / (1.0 + xa*tangent) */\ntemp = xa * HEX_40000000;\ndouble ya = xa + temp - temp;\ndouble yb = xb + xa - ya;\nxa = ya;\nxb += yb;\n\n//if (idx > 8 || idx == 0)\nif (idx == 0) {\n/* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */\n//double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);\nfinal double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n//double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);\nya = epsA * denom;\nyb = epsB * denom;\n} else {\ndouble temp2 = xa * TANGENT_TABLE_A[idx];\ndouble za = 1d + temp2;\ndouble zb = -(za - 1d - temp2);\ntemp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\ntemp = za + temp2;\nzb += -(temp - za - temp2);\nza = temp;\n\nzb += xb * TANGENT_TABLE_B[idx];\nya = epsA / za;\n\ntemp = ya * HEX_40000000;\nfinal double yaa = (ya + temp) - temp;\nfinal double yab = ya - yaa;\n\ntemp = za * HEX_40000000;\nfinal double zaa = (za + temp) - temp;\nfinal double zab = za - zaa;\n\n/* Correct for rounding in division */\nyb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n\nyb += -epsA * zb / za / za;\nyb += epsB / za;\n}\n\n\nepsA = ya;\nepsB = yb;\n\n/* Evaluate polynomial */\nfinal double epsA2 = epsA * epsA;\n\n/*\nyb = -0.09001346640161823;\nyb = yb * epsA2 + 0.11110718400605211;\nyb = yb * epsA2 + -0.1428571349122913;\nyb = yb * epsA2 + 0.19999999999273194;\nyb = yb * epsA2 + -0.33333333333333093;\nyb = yb * epsA2 * epsA;\n*/\n\nyb = 0.07490822288864472;\nyb = yb * epsA2 + -0.09088450866185192;\nyb = yb * epsA2 + 0.11111095942313305;\nyb = yb * epsA2 + -0.1428571423679182;\nyb = yb * epsA2 + 0.19999999999923582;\nyb = yb * epsA2 + -0.33333333333333287;\nyb = yb * epsA2 * epsA;\n\n\nya = epsA;\n\ntemp = ya + yb;\nyb = -(temp - ya - yb);\nya = temp;\n\n/* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */\nyb += epsB / (1d + epsA * epsA);\n\n//result = yb + eighths[idx] + ya;\ndouble za = EIGHTHS[idx] + ya;\ndouble zb = -(za - EIGHTHS[idx] - ya);\ntemp = za + yb;\nzb += -(temp - za - yb);\nza = temp;\n\ndouble result = za + zb;\ndouble resultb = -(result - za - zb);\n\nif (leftPlane) {\n// Result is in the left plane\nfinal double pia = 1.5707963267948966 * 2;\nfinal double pib = 6.123233995736766E-17 * 2;\n\nza = pia - result;\nzb = -(za - pia + result);\nzb += pib - resultb;\n\nresult = za + zb;\nresultb = -(result - za - zb);\n}\n\n\nif (negate ^ leftPlane) {\nresult = -result;\n}\n\nreturn result;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:recurseList(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Ljava/util/List;DD)V",
            "method_body": "private void recurseList(final BSPTree<Euclidean1D> node,\nfinal List<Interval> list,\nfinal double lower, final double upper) {\n\nif (node.getCut() == null) {\nif ((Boolean) node.getAttribute()) {\n// this leaf cell is an inside cell: an interval\nlist.add(new Interval(lower, upper));\n}\n} else {\nfinal OrientedPoint op  = (OrientedPoint) node.getCut().getHyperplane();\nfinal Vector1D       loc = op.getLocation();\ndouble              x   = loc.getX();\n\n// make sure we explore the tree in increasing order\nfinal BSPTree<Euclidean1D> low  =\nop.isDirect() ? node.getMinus() : node.getPlus();\nfinal BSPTree<Euclidean1D> high =\nop.isDirect() ? node.getPlus()  : node.getMinus();\n\nrecurseList(low, list, lower, x);\nif ((checkPoint(low,  loc) == Location.INSIDE) &&\n(checkPoint(high, loc) == Location.INSIDE)) {\n// merge the last interval added and the first one of the high sub-tree\nx = list.remove(list.size() - 1).getLower();\n}\nrecurseList(high, list, x, upper);\n\n}\n\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:recurseSides(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Lorg/apache/commons/math3/geometry/partitioning/AbstractRegion$Sides;)V",
            "method_body": "private void recurseSides(final BSPTree<S> node, final SubHyperplane<S> sub, final Sides sides) {\n\nif (node.getCut() == null) {\nif ((Boolean) node.getAttribute()) {\n// this is an inside cell expanding across the hyperplane\nsides.rememberPlusFound();\nsides.rememberMinusFound();\n}\nreturn;\n}\n\nfinal Hyperplane<S> hyperplane = node.getCut().getHyperplane();\nswitch (sub.side(hyperplane)) {\ncase PLUS :\n// the sub-hyperplane is entirely in the plus sub-tree\nif (node.getCut().side(sub.getHyperplane()) == Side.PLUS) {\nif (!isEmpty(node.getMinus())) {\nsides.rememberPlusFound();\n}\n} else {\nif (!isEmpty(node.getMinus())) {\nsides.rememberMinusFound();\n}\n}\nif (!(sides.plusFound() && sides.minusFound())) {\nrecurseSides(node.getPlus(), sub, sides);\n}\nbreak;\ncase MINUS :\n// the sub-hyperplane is entirely in the minus sub-tree\nif (node.getCut().side(sub.getHyperplane()) == Side.PLUS) {\nif (!isEmpty(node.getPlus())) {\nsides.rememberPlusFound();\n}\n} else {\nif (!isEmpty(node.getPlus())) {\nsides.rememberMinusFound();\n}\n}\nif (!(sides.plusFound() && sides.minusFound())) {\nrecurseSides(node.getMinus(), sub, sides);\n}\nbreak;\ncase BOTH :\n// the sub-hyperplane extends in both sub-trees\nfinal SubHyperplane.SplitSubHyperplane<S> split = sub.split(hyperplane);\n\n// explore first the plus sub-tree\nrecurseSides(node.getPlus(), split.getPlus(), sides);\n\n// if needed, explore the minus sub-tree\nif (!(sides.plusFound() && sides.minusFound())) {\nrecurseSides(node.getMinus(), split.getMinus(), sides);\n}\nbreak;\ndefault :\n// the sub-hyperplane and the cut sub-hyperplane share the same hyperplane\nif (node.getCut().getHyperplane().sameOrientationAs(sub.getHyperplane())) {\nif ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) {\nsides.rememberPlusFound();\n}\nif ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) {\nsides.rememberMinusFound();\n}\n} else {\nif ((node.getPlus().getCut() != null) || ((Boolean) node.getPlus().getAttribute())) {\nsides.rememberMinusFound();\n}\nif ((node.getMinus().getCut() != null) || ((Boolean) node.getMinus().getAttribute())) {\nsides.rememberPlusFound();\n}\n}\n}\n\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple:sign(J)J",
            "method_body": "private static long sign(final long bits) {\nreturn bits & SIGN_MASK;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:<init>(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Ljava/lang/Object;)V",
            "method_body": "public BSPTree(final SubHyperplane<S> cut, final BSPTree<S> plus, final BSPTree<S> minus,\nfinal Object attribute) {\nthis.cut       = cut;\nthis.plus      = plus;\nthis.minus     = minus;\nthis.parent    = null;\nthis.attribute = attribute;\nplus.parent    = this;\nminus.parent   = this;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn isEmpty(tree);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:getDirection()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D getDirection() {\nreturn direction;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D:distance(Lorg/apache/commons/math3/geometry/Vector;)D",
            "method_body": "public double distance(Vector<Euclidean2D> p) {\nVector2D p3 = (Vector2D) p;\nfinal double dx = p3.x - x;\nfinal double dy = p3.y - y;\nreturn FastMath.sqrt(dx * dx + dy * dy);\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xa;\ndouble xb = 0.0;\n\n/* Take absolute value of the input */\nxa = x;\nif (x < 0) {\nnegative = true;\nxa = -xa;\n}\n\n/* Check for zero and negative zero */\nif (xa == 0.0) {\nlong bits = Double.doubleToLongBits(x);\nif (bits < 0) {\nreturn -0.0;\n}\nreturn 0.0;\n}\n\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nreturn Double.NaN;\n}\n\n/* Perform any argument reduction */\nif (xa > 3294198.0) {\n// PI * (2**20)\n// Argument too big for CodyWaite reduction.  Must use\n// PayneHanek.\ndouble reduceResults[] = new double[3];\nreducePayneHanek(xa, reduceResults);\nquadrant = ((int) reduceResults[0]) & 3;\nxa = reduceResults[1];\nxb = reduceResults[2];\n} else if (xa > 1.5707963267948966) {\n/* Inline the Cody/Waite reduction for performance */\n\n// Estimate k\n//k = (int)(xa / 1.5707963267948966);\nint k = (int)(xa * 0.6366197723675814);\n\n// Compute remainder\ndouble remA;\ndouble remB;\nwhile (true) {\ndouble a = -k * 1.570796251296997;\nremA = xa + a;\nremB = -(remA - xa - a);\n\na = -k * 7.549789948768648E-8;\ndouble b = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\na = -k * 6.123233995736766E-17;\nb = remA;\nremA = a + b;\nremB += -(remA - b - a);\n\nif (remA > 0.0) {\nbreak;\n}\n\n// Remainder is negative, so decrement k and try again.\n// This should only happen if the input is very close\n// to an even multiple of pi/2\nk--;\n}\nquadrant = k & 3;\nxa = remA;\nxb = remB;\n}\n\nif (negative) {\nquadrant ^= 2;  // Flip bit 1\n}\n\nswitch (quadrant) {\ncase 0:\nreturn sinQ(xa, xb);\ncase 1:\nreturn cosQ(xa, xb);\ncase 2:\nreturn -sinQ(xa, xb);\ncase 3:\nreturn -cosQ(xa, xb);\ndefault:\nreturn Double.NaN;\n}\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$2:visitOrder(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)Lorg/apache/commons/math3/geometry/partitioning/BSPTreeVisitor$Order;",
            "method_body": "public Order visitOrder(final BSPTree<S> node) {\nreturn Order.PLUS_SUB_MINUS;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:getOffset(Lorg/apache/commons/math3/geometry/euclidean/threed/Plane;)D",
            "method_body": "public double getOffset(final Plane plane) {\nreturn originOffset + (sameOrientationAs(plane) ? -plane.originOffset : plane.originOffset);\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval:getUpper()D",
            "method_body": "public double getUpper() {\nreturn upper;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:getMinus()Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "public BSPTree<S> getMinus() {\nreturn minus;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:hasIn()Z",
            "method_body": "public boolean hasIn() {\nreturn (in != null) && (!in.isEmpty());\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory$NodesCleaner:visitOrder(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)Lorg/apache/commons/math3/geometry/partitioning/BSPTreeVisitor$Order;",
            "method_body": "public Order visitOrder(final BSPTree<S> node) {\nreturn Order.PLUS_SUB_MINUS;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:getAttribute()Ljava/lang/Object;",
            "method_body": "public Object getAttribute() {\nreturn attribute;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:getNext()Lorg/apache/commons/math3/geometry/partitioning/utilities/AVLTree$Node;",
            "method_body": "public Node getNext() {\n\nif (right != null) {\nfinal Node node = right.getSmallest();\nif (node != null) {\nreturn node;\n}\n}\n\nfor (Node node = this; node.parent != null; node = node.parent) {\nif (node != node.parent.right) {\nreturn node.parent;\n}\n}\n\nreturn null;\n\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint:getLocation()Lorg/apache/commons/math3/geometry/euclidean/oned/Vector1D;",
            "method_body": "public Vector1D getLocation() {\nreturn location;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:getLargest()Lorg/apache/commons/math3/geometry/partitioning/utilities/AVLTree$Node;",
            "method_body": "Node getLargest() {\nNode node = this;\nwhile (node.right != null) {\nnode = node.right;\n}\nreturn node;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:<init>(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)V",
            "method_body": "public IntervalsSet(final BSPTree<Euclidean1D> tree) {\nsuper(tree);\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:<init>(DD)V",
            "method_body": "public IntervalsSet(final double lower, final double upper) {\nsuper(buildTree(lower, upper));\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.SubHyperplane$SplitSubHyperplane:<init>(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;)V",
            "method_body": "public SplitSubHyperplane(final SubHyperplane<U> plus,\nfinal SubHyperplane<U> minus) {\nthis.plus  = plus;\nthis.minus = minus;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides:plusFound()Z",
            "method_body": "public boolean plusFound() {\nreturn plusFound;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree:<init>()V",
            "method_body": "public AVLTree() {\ntop = null;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine:buildIntervalSet(Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;)Lorg/apache/commons/math3/geometry/euclidean/oned/IntervalsSet;",
            "method_body": "private static IntervalsSet buildIntervalSet(final Vector2D start, final Vector2D end) {\nfinal Line line = new Line(start, end);\nreturn new IntervalsSet(line.toSubSpace(start).getX(),\nline.toSubSpace(end).getX());\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor:visitOrder(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)Lorg/apache/commons/math3/geometry/partitioning/BSPTreeVisitor$Order;",
            "method_body": "public Order visitOrder(final BSPTree<Euclidean3D> node) {\nreturn Order.MINUS_SUB_PLUS;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:computeGeometricalProperties()V",
            "method_body": "protected void computeGeometricalProperties() {\nif (getTree(false).getCut() == null) {\nsetBarycenter(Vector1D.NaN);\nsetSize(((Boolean) getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n} else {\ndouble size = 0.0;\ndouble sum = 0.0;\nfor (final Interval interval : asList()) {\nsize += interval.getLength();\nsum  += interval.getLength() * interval.getMidPoint();\n}\nsetSize(size);\nif (Double.isInfinite(size)) {\nsetBarycenter(Vector1D.NaN);\n} else if (size >= Precision.SAFE_MIN) {\nsetBarycenter(new Vector1D(sum / size));\n} else {\nsetBarycenter(((OrientedPoint) getTree(false).getCut().getHyperplane()).getLocation());\n}\n}\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:getAngle()D",
            "method_body": "public double getAngle() {\nreturn MathUtils.normalizeAngle(angle, FastMath.PI);\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder:visitInternalNode(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)V",
            "method_body": "public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n@SuppressWarnings(\"unchecked\")\nfinal BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\nif (attribute.getPlusOutside() != null) {\naddContribution(attribute.getPlusOutside(), false);\n}\nif (attribute.getPlusInside() != null) {\naddContribution(attribute.getPlusInside(), true);\n}\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:getY()D",
            "method_body": "public double getY() {\nreturn y;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$ComparableSegment:<init>(Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;DD)V",
            "method_body": "public ComparableSegment(final Vector2D start, final double dx, final double dy) {\nsuper(null, null, null);\nsortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:intersection(Lorg/apache/commons/math3/geometry/euclidean/threed/Plane;)Lorg/apache/commons/math3/geometry/euclidean/threed/Line;",
            "method_body": "public Line intersection(final Plane other) {\nfinal Vector3D direction = Vector3D.crossProduct(w, other.w);\nif (direction.getNorm() < 1.0e-10) {\nreturn null;\n}\nfinal Vector3D point = intersection(this, other, new Plane(direction));\nreturn new Line(point, point.add(direction));\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple:computeLSB(J)I",
            "method_body": "private static int computeLSB(final long l) {\n\nlong ll = l;\nlong mask  = 0xffffffff00000000L;\nint  scale = 32;\nint  lsb   = 0;\n\nwhile (scale != 0) {\nif ((ll & mask) == ll) {\nlsb |= scale;\nll = ll >> scale;\n}\nscale = scale >> 1;\nmask  = mask >> scale;\n}\n\nreturn lsb;\n\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor:visitInternalNode(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)V",
            "method_body": "public void visitInternalNode(final BSPTree<Euclidean3D> node) {\n@SuppressWarnings(\"unchecked\")\nfinal BoundaryAttribute<Euclidean3D> attribute =\n(BoundaryAttribute<Euclidean3D>) node.getAttribute();\nif (attribute.getPlusOutside() != null) {\naddContribution(attribute.getPlusOutside(), false);\n}\nif (attribute.getPlusInside() != null) {\naddContribution(attribute.getPlusInside(), true);\n}\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder:visitOrder(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)Lorg/apache/commons/math3/geometry/partitioning/BSPTreeVisitor$Order;",
            "method_body": "public Order visitOrder(final BSPTree<Euclidean2D> node) {\nreturn Order.MINUS_SUB_PLUS;\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:rebalanceRightShrunk()Z",
            "method_body": "private boolean rebalanceRightShrunk() {\nswitch (skew) {\ncase RIGHT_HIGH:\nskew = Skew.BALANCED;\nreturn true;\ncase LEFT_HIGH:\nif (left.skew == Skew.LEFT_HIGH) {\nrotateCW();\nskew       = Skew.BALANCED;\nright.skew = Skew.BALANCED;\nreturn true;\n} else if (left.skew == Skew.BALANCED) {\nrotateCW();\nskew       = Skew.RIGHT_HIGH;\nright.skew = Skew.LEFT_HIGH;\nreturn false;\n} else {\nfinal Skew s = left.right.skew;\nleft.rotateCCW();\nrotateCW();\nswitch (s) {\ncase LEFT_HIGH:\nleft.skew  = Skew.BALANCED;\nright.skew = Skew.RIGHT_HIGH;\nbreak;\ncase RIGHT_HIGH:\nleft.skew  = Skew.LEFT_HIGH;\nright.skew = Skew.BALANCED;\nbreak;\ndefault:\nleft.skew  = Skew.BALANCED;\nright.skew = Skew.BALANCED;\n}\nskew = Skew.BALANCED;\nreturn true;\n}\ndefault:\nskew = Skew.LEFT_HIGH;\nreturn false;\n}\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:rotateCCW()V",
            "method_body": "private void rotateCCW() {\n\nfinal T tmpElt        = element;\nelement               = right.element;\nright.element         = tmpElt;\n\nfinal Node tmpNode    = right;\nright                 = tmpNode.right;\ntmpNode.right         = tmpNode.left;\ntmpNode.left          = left;\nleft                  = tmpNode;\n\nif (right != null) {\nright.parent = this;\n}\nif (left.left != null) {\nleft.left.parent = left;\n}\n\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint:<init>(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;Lorg/apache/commons/math3/geometry/partitioning/Region;)V",
            "method_body": "public SubOrientedPoint(final Hyperplane<Euclidean1D> hyperplane,\nfinal Region<Euclidean1D> remainingRegion) {\nsuper(hyperplane, remainingRegion);\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:getX()D",
            "method_body": "public double getX() {\nreturn x;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:<init>(DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\nthis.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x);\nthis.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y);\nthis.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z);\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:buildTree(DD)Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\nif (Double.isInfinite(lower) && (lower < 0)) {\nif (Double.isInfinite(upper) && (upper > 0)) {\n// the tree must cover the whole real line\nreturn new BSPTree<Euclidean1D>(Boolean.TRUE);\n}\n// the tree must be open on the negative infinity side\nfinal SubHyperplane<Euclidean1D> upperCut =\nnew OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\nreturn new BSPTree<Euclidean1D>(upperCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(Boolean.TRUE),\nnull);\n}\nfinal SubHyperplane<Euclidean1D> lowerCut =\nnew OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\nif (Double.isInfinite(upper) && (upper > 0)) {\n// the tree must be open on the positive infinity side\nreturn new BSPTree<Euclidean1D>(lowerCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(Boolean.TRUE),\nnull);\n}\n\n// the tree must be bounded on the two sides\nfinal SubHyperplane<Euclidean1D> upperCut =\nnew OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\nreturn new BSPTree<Euclidean1D>(lowerCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(upperCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(Boolean.TRUE),\nnull),\nnull);\n\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:copySelf()Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "public BSPTree<S> copySelf() {\n\nif (cut == null) {\nreturn new BSPTree<S>(attribute);\n}\n\nreturn new BSPTree<S>(cut.copySelf(), plus.copySelf(), minus.copySelf(),\nattribute);\n\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:getNormSq()D",
            "method_body": "public double getNormSq() {\n// there are no cancellation problems here, so we use the straightforward formula\nreturn x * x + y * y + z * z;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:getZ()D",
            "method_body": "public double getZ() {\nreturn z;\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple:<init>([D)V",
            "method_body": "public OrderedTuple(final double ... components) {\nthis.components = components.clone();\nint msb = Integer.MIN_VALUE;\nlsb     = Integer.MAX_VALUE;\nposInf  = false;\nnegInf  = false;\nnan     = false;\nfor (int i = 0; i < components.length; ++i) {\nif (Double.isInfinite(components[i])) {\nif (components[i] < 0) {\nnegInf = true;\n} else {\nposInf = true;\n}\n} else if (Double.isNaN(components[i])) {\nnan = true;\n} else {\nfinal long b = Double.doubleToLongBits(components[i]);\nfinal long m = mantissa(b);\nif (m != 0) {\nfinal int e = exponent(b);\nmsb = FastMath.max(msb, e + computeMSB(m));\nlsb = FastMath.min(lsb, e + computeLSB(m));\n}\n}\n}\n\nif (posInf && negInf) {\n// instance cannot be sorted logically\nposInf = false;\nnegInf = false;\nnan    = true;\n}\n\nif (lsb <= msb) {\n// encode the T-upple with the specified offset\nencode(msb + 16);\n} else {\nencoding = new long[] {\n0x0L\n};\n}\n\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval:<init>(DD)V",
            "method_body": "public Interval(final double lower, final double upper) {\nthis.lower = lower;\nthis.upper = upper;\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides:rememberMinusFound()V",
            "method_body": "public void rememberMinusFound() {\nminusFound = true;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:copySelf()Lorg/apache/commons/math3/geometry/euclidean/twod/Line;",
            "method_body": "public Line copySelf() {\nreturn new Line(this);\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D:getX()D",
            "method_body": "public double getX() {\nreturn x;\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor:addContribution(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Z)V",
            "method_body": "private void addContribution(final SubHyperplane<Euclidean3D> facet, final boolean reversed) {\n\nfinal Region<Euclidean2D> polygon = ((SubPlane) facet).getRemainingRegion();\nfinal double area    = polygon.getSize();\n\nif (Double.isInfinite(area)) {\nsetSize(Double.POSITIVE_INFINITY);\nsetBarycenter(Vector3D.NaN);\n} else {\n\nfinal Plane    plane  = (Plane) facet.getHyperplane();\nfinal Vector3D facetB = plane.toSpace(polygon.getBarycenter());\ndouble   scaled = area * facetB.dotProduct(plane.getNormal());\nif (reversed) {\nscaled = -scaled;\n}\n\nsetSize(getSize() + scaled);\nsetBarycenter(new Vector3D(1.0, (Vector3D) getBarycenter(), scaled, facetB));\n\n}\n\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.SubHyperplane$SplitSubHyperplane:getMinus()Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "public SubHyperplane<U> getMinus() {\nreturn minus;\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn top == null;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:reset(Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;)V",
            "method_body": "public void reset(final Vector2D p1, final Vector2D p2) {\nfinal double dx = p2.getX() - p1.getX();\nfinal double dy = p2.getY() - p1.getY();\nfinal double d = FastMath.hypot(dx, dy);\nif (d == 0.0) {\nangle        = 0.0;\ncos          = 1.0;\nsin          = 0.0;\noriginOffset = p1.getY();\n} else {\nangle        = FastMath.PI + FastMath.atan2(-dy, -dx);\ncos          = FastMath.cos(angle);\nsin          = FastMath.sin(angle);\noriginOffset = (p2.getX() * p1.getY() - p1.getX() * p2.getY()) / d;\n}\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine:split(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane$SplitSubHyperplane;",
            "method_body": "public SplitSubHyperplane<Euclidean2D> split(final Hyperplane<Euclidean2D> hyperplane) {\n\nfinal Line    thisLine  = (Line) getHyperplane();\nfinal Line    otherLine = (Line) hyperplane;\nfinal Vector2D crossing  = thisLine.intersection(otherLine);\n\nif (crossing == null) {\n// the lines are parallel\nfinal double global = otherLine.getOffset(thisLine);\nreturn (global < -1.0e-10) ?\nnew SplitSubHyperplane<Euclidean2D>(null, this) :\nnew SplitSubHyperplane<Euclidean2D>(this, null);\n}\n\n// the lines do intersect\nfinal boolean direct = FastMath.sin(thisLine.getAngle() - otherLine.getAngle()) < 0;\nfinal Vector1D x      = thisLine.toSubSpace(crossing);\nfinal SubHyperplane<Euclidean1D> subPlus  = new OrientedPoint(x, !direct).wholeHyperplane();\nfinal SubHyperplane<Euclidean1D> subMinus = new OrientedPoint(x,  direct).wholeHyperplane();\n\nfinal BSPTree<Euclidean1D> splitTree = getRemainingRegion().getTree(false).split(subMinus);\nfinal BSPTree<Euclidean1D> plusTree  = getRemainingRegion().isEmpty(splitTree.getPlus()) ?\nnew BSPTree<Euclidean1D>(Boolean.FALSE) :\nnew BSPTree<Euclidean1D>(subPlus, new BSPTree<Euclidean1D>(Boolean.FALSE),\nsplitTree.getPlus(), null);\nfinal BSPTree<Euclidean1D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ?\nnew BSPTree<Euclidean1D>(Boolean.FALSE) :\nnew BSPTree<Euclidean1D>(subMinus, new BSPTree<Euclidean1D>(Boolean.FALSE),\nsplitTree.getMinus(), null);\n\nreturn new SplitSubHyperplane<Euclidean2D>(new SubLine(thisLine.copySelf(), new IntervalsSet(plusTree)),\nnew SubLine(thisLine.copySelf(), new IntervalsSet(minusTree)));\n\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute:getPlusOutside()Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "public SubHyperplane<S> getPlusOutside() {\nreturn plusOutside;\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:wholeHyperplane()Lorg/apache/commons/math3/geometry/euclidean/threed/SubPlane;",
            "method_body": "public SubPlane wholeHyperplane() {\nreturn new SubPlane(this, new PolygonsSet());\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:copySelf()Lorg/apache/commons/math3/geometry/euclidean/threed/Plane;",
            "method_body": "public Plane copySelf() {\nreturn new Plane(this);\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:visit(Lorg/apache/commons/math3/geometry/partitioning/BSPTreeVisitor;)V",
            "method_body": "public void visit(final BSPTreeVisitor<S> visitor) {\nif (cut == null) {\nvisitor.visitLeafNode(this);\n} else {\nswitch (visitor.visitOrder(this)) {\ncase PLUS_MINUS_SUB:\nplus.visit(visitor);\nminus.visit(visitor);\nvisitor.visitInternalNode(this);\nbreak;\ncase PLUS_SUB_MINUS:\nplus.visit(visitor);\nvisitor.visitInternalNode(this);\nminus.visit(visitor);\nbreak;\ncase MINUS_PLUS_SUB:\nminus.visit(visitor);\nplus.visit(visitor);\nvisitor.visitInternalNode(this);\nbreak;\ncase MINUS_SUB_PLUS:\nminus.visit(visitor);\nvisitor.visitInternalNode(this);\nplus.visit(visitor);\nbreak;\ncase SUB_PLUS_MINUS:\nvisitor.visitInternalNode(this);\nplus.visit(visitor);\nminus.visit(visitor);\nbreak;\ncase SUB_MINUS_PLUS:\nvisitor.visitInternalNode(this);\nminus.visit(visitor);\nplus.visit(visitor);\nbreak;\ndefault:\nthrow new MathInternalError();\n}\n\n}\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint:isDirect()Z",
            "method_body": "public boolean isDirect() {\nreturn direct;\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:setFrame()V",
            "method_body": "private void setFrame() {\norigin = new Vector3D(-originOffset, w);\nu = w.orthogonal();\nv = Vector3D.crossProduct(w, u);\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:rebalanceRightGrown()Z",
            "method_body": "private boolean rebalanceRightGrown() {\nswitch (skew) {\ncase LEFT_HIGH:\nskew = Skew.BALANCED;\nreturn false;\ncase RIGHT_HIGH:\nif (right.skew == Skew.RIGHT_HIGH) {\nrotateCCW();\nskew      = Skew.BALANCED;\nleft.skew = Skew.BALANCED;\n} else {\nfinal Skew s = right.left.skew;\nright.rotateCW();\nrotateCCW();\nswitch (s) {\ncase LEFT_HIGH:\nleft.skew  = Skew.BALANCED;\nright.skew = Skew.RIGHT_HIGH;\nbreak;\ncase RIGHT_HIGH:\nleft.skew  = Skew.LEFT_HIGH;\nright.skew = Skew.BALANCED;\nbreak;\ndefault:\nleft.skew  = Skew.BALANCED;\nright.skew = Skew.BALANCED;\n}\nskew = Skew.BALANCED;\n}\nreturn false;\ndefault:\nskew = Skew.RIGHT_HIGH;\nreturn true;\n}\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:scalb(DI)D",
            "method_body": "public static double scalb(final double d, final int n) {\n\n// first simple and fast handling when 2^n can be represented using normal numbers\nif ((n > -1023) && (n < 1024)) {\nreturn d * Double.longBitsToDouble(((long) (n + 1023)) << 52);\n}\n\n// handle special cases\nif (Double.isNaN(d) || Double.isInfinite(d) || (d == 0)) {\nreturn d;\n}\nif (n < -2098) {\nreturn (d > 0) ? 0.0 : -0.0;\n}\nif (n > 2097) {\nreturn (d > 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n}\n\n// decompose d\nfinal long bits = Double.doubleToLongBits(d);\nfinal long sign = bits & 0x8000000000000000L;\nint  exponent   = ((int) (bits >>> 52)) & 0x7ff;\nlong mantissa   = bits & 0x000fffffffffffffL;\n\n// compute scaled exponent\nint scaledExponent = exponent + n;\n\nif (n < 0) {\n// we are really in the case n <= -1023\nif (scaledExponent > 0) {\n// both the input and the result are normal numbers, we only adjust the exponent\nreturn Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n} else if (scaledExponent > -53) {\n// the input is a normal number and the result is a subnormal number\n\n// recover the hidden mantissa bit\nmantissa = mantissa | (1L << 52);\n\n// scales down complete mantissa, hence losing least significant bits\nfinal long mostSignificantLostBit = mantissa & (1L << (-scaledExponent));\nmantissa = mantissa >>> (1 - scaledExponent);\nif (mostSignificantLostBit != 0) {\n// we need to add 1 bit to round up the result\nmantissa++;\n}\nreturn Double.longBitsToDouble(sign | mantissa);\n\n} else {\n// no need to compute the mantissa, the number scales down to 0\nreturn (sign == 0L) ? 0.0 : -0.0;\n}\n} else {\n// we are really in the case n >= 1024\nif (exponent == 0) {\n\n// the input number is subnormal, normalize it\nwhile ((mantissa >>> 52) != 1) {\nmantissa = mantissa << 1;\n--scaledExponent;\n}\n++scaledExponent;\nmantissa = mantissa & 0x000fffffffffffffL;\n\nif (scaledExponent < 2047) {\nreturn Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n} else {\nreturn (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n}\n\n} else if (scaledExponent < 2047) {\nreturn Double.longBitsToDouble(sign | (((long) scaledExponent) << 52) | mantissa);\n} else {\nreturn (sign == 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n}\n}\n\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet:computeGeometricalProperties()V",
            "method_body": "protected void computeGeometricalProperties() {\n\nfinal Vector2D[][] v = getVertices();\n\nif (v.length == 0) {\nfinal BSPTree<Euclidean2D> tree = getTree(false);\nif ((Boolean) tree.getAttribute()) {\n// the instance covers the whole space\nsetSize(Double.POSITIVE_INFINITY);\nsetBarycenter(Vector2D.NaN);\n} else {\nsetSize(0);\nsetBarycenter(new Vector2D(0, 0));\n}\n} else if (v[0][0] == null) {\n// there is at least one open-loop: the polygon is infinite\nsetSize(Double.POSITIVE_INFINITY);\nsetBarycenter(Vector2D.NaN);\n} else {\n// all loops are closed, we compute some integrals around the shape\n\ndouble sum  = 0;\ndouble sumX = 0;\ndouble sumY = 0;\n\nfor (Vector2D[] loop : v) {\ndouble x1 = loop[loop.length - 1].getX();\ndouble y1 = loop[loop.length - 1].getY();\nfor (final Vector2D point : loop) {\nfinal double x0 = x1;\nfinal double y0 = y1;\nx1 = point.getX();\ny1 = point.getY();\nfinal double factor = x0 * y1 - y0 * x1;\nsum  += factor;\nsumX += factor * (x0 + x1);\nsumY += factor * (y0 + y1);\n}\n}\n\nif (sum < 0) {\n// the polygon as a finite outside surrounded by an infinite inside\nsetSize(Double.POSITIVE_INFINITY);\nsetBarycenter(Vector2D.NaN);\n} else {\nsetSize(sum / 2);\nsetBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n}\n\n}\n\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:insert(Ljava/lang/Comparable;)Z",
            "method_body": "boolean insert(final T newElement) {\nif (newElement.compareTo(this.element) < 0) {\n// the inserted element is smaller than the node\nif (left == null) {\nleft = new Node(newElement, this);\nreturn rebalanceLeftGrown();\n}\nreturn left.insert(newElement) ? rebalanceLeftGrown() : false;\n}\n\n// the inserted element is equal to or greater than the node\nif (right == null) {\nright = new Node(newElement, this);\nreturn rebalanceRightGrown();\n}\nreturn right.insert(newElement) ? rebalanceRightGrown() : false;\n\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:sameOrientationAs(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Z",
            "method_body": "public boolean sameOrientationAs(final Hyperplane<Euclidean3D> other) {\nreturn (((Plane) other).w).dotProduct(w) > 0.0;\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:<init>(DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Vector3D(double a, Vector3D u) {\nthis.x = a * u.x;\nthis.y = a * u.y;\nthis.z = a * u.z;\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:<init>(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Plane(final Vector3D p, final Vector3D normal) {\nsetNormal(normal);\noriginOffset = -p.dotProduct(w);\nsetFrame();\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple:compareTo(Lorg/apache/commons/math3/geometry/partitioning/utilities/OrderedTuple;)I",
            "method_body": "public int compareTo(final OrderedTuple ot) {\nif (components.length == ot.components.length) {\nif (nan) {\nreturn +1;\n} else if (ot.nan) {\nreturn -1;\n} else if (negInf || ot.posInf) {\nreturn -1;\n} else if (posInf || ot.negInf) {\nreturn +1;\n} else {\n\nif (offset < ot.offset) {\nencode(ot.offset);\n} else if (offset > ot.offset) {\not.encode(offset);\n}\n\nfinal int limit = FastMath.min(encoding.length, ot.encoding.length);\nfor (int i = 0; i < limit; ++i) {\nif (encoding[i] < ot.encoding[i]) {\nreturn -1;\n} else if (encoding[i] > ot.encoding[i]) {\nreturn +1;\n}\n}\n\nif (encoding.length < ot.encoding.length) {\nreturn -1;\n} else if (encoding.length > ot.encoding.length) {\nreturn +1;\n} else {\nreturn 0;\n}\n\n}\n}\n\nreturn components.length - ot.components.length;\n\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:setNormal(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "private void setNormal(final Vector3D normal) {\nfinal double norm = normal.getNorm();\nif (norm < 1.0e-10) {\nthrow new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n}\nw = new Vector3D(1.0 / norm, normal);\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval:getLower()D",
            "method_body": "public double getLower() {\nreturn lower;\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D:<init>(D)V",
            "method_body": "public Vector1D(double x) {\nthis.x = x;\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:<init>(Ljava/util/Collection;)V",
            "method_body": "protected AbstractRegion(final Collection<SubHyperplane<S>> boundary) {\n\nif (boundary.size() == 0) {\n\n// the tree represents the whole space\ntree = new BSPTree<S>(Boolean.TRUE);\n\n} else {\n\n// sort the boundary elements in decreasing size order\n// (we don't want equal size elements to be removed, so\n// we use a trick to fool the TreeSet)\nfinal TreeSet<SubHyperplane<S>> ordered = new TreeSet<SubHyperplane<S>>(new Comparator<SubHyperplane<S>>() {\npublic int compare(final SubHyperplane<S> o1, final SubHyperplane<S> o2) {\nfinal double size1 = o1.getSize();\nfinal double size2 = o2.getSize();\nreturn (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);\n}\n});\nordered.addAll(boundary);\n\n// build the tree top-down\ntree = new BSPTree<S>();\ninsertCuts(tree, ordered);\n\n// set up the inside/outside flags\ntree.visit(new BSPTreeVisitor<S>() {\n\n/** {@inheritDoc} */\npublic Order visitOrder(final BSPTree<S> node) {\nreturn Order.PLUS_SUB_MINUS;\n}\n\n/** {@inheritDoc} */\npublic void visitInternalNode(final BSPTree<S> node) {\n}\n\n/** {@inheritDoc} */\npublic void visitLeafNode(final BSPTree<S> node) {\nnode.setAttribute((node == node.getParent().getPlus()) ?\nBoolean.FALSE : Boolean.TRUE);\n}\n});\n\n}\n\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:recurseBuildBoundary(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)V",
            "method_body": "private void recurseBuildBoundary(final BSPTree<S> node) {\nif (node.getCut() != null) {\n\nSubHyperplane<S> plusOutside = null;\nSubHyperplane<S> plusInside  = null;\n\n// characterize the cut sub-hyperplane,\n// first with respect to the plus sub-tree\nfinal Characterization<S> plusChar = new Characterization<S>();\ncharacterize(node.getPlus(), node.getCut().copySelf(), plusChar);\n\nif (plusChar.hasOut()) {\n// plusChar.getOut() corresponds to a subset of the cut\n// sub-hyperplane known to have outside cells on its plus\n// side, we want to check if parts of this subset do have\n// inside cells on their minus side\nfinal Characterization<S> minusChar = new Characterization<S>();\ncharacterize(node.getMinus(), plusChar.getOut(), minusChar);\nif (minusChar.hasIn()) {\nplusOutside = minusChar.getIn();\n}\n}\n\nif (plusChar.hasIn()) {\n// plusChar.getIn() corresponds to a subset of the cut\n// sub-hyperplane known to have inside cells on its plus\n// side, we want to check if parts of this subset do have\n// outside cells on their minus side\nfinal Characterization<S> minusChar = new Characterization<S>();\ncharacterize(node.getMinus(), plusChar.getIn(), minusChar);\nif (minusChar.hasOut()) {\nplusInside = minusChar.getOut();\n}\n}\n\nnode.setAttribute(new BoundaryAttribute<S>(plusOutside, plusInside));\nrecurseBuildBoundary(node.getPlus());\nrecurseBuildBoundary(node.getMinus());\n\n}\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder:getSorted()Lorg/apache/commons/math3/geometry/partitioning/utilities/AVLTree;",
            "method_body": "public AVLTree<ComparableSegment> getSorted() {\nreturn sorted;\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$1:compare(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;)I",
            "method_body": "public int compare(final SubHyperplane<S> o1, final SubHyperplane<S> o2) {\nfinal double size1 = o1.getSize();\nfinal double size2 = o2.getSize();\nreturn (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:getExponent(D)I",
            "method_body": "public static int getExponent(final double d) {\nreturn (int) ((Double.doubleToLongBits(d) >>> 52) & 0x7ff) - 1023;\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:wholeHyperplane()Lorg/apache/commons/math3/geometry/euclidean/twod/SubLine;",
            "method_body": "public SubLine wholeHyperplane() {\nreturn new SubLine(this, new IntervalsSet());\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:split(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;)Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "BSPTree<S> merge(BSPTree<S> leaf, BSPTree<S> tree, BSPTree<S> parentTree,\nboolean isPlusChild, boolean leafFromInstance);\n\n}\n\n/** Split a BSP tree by an external sub-hyperplane.\n* <p>Split a tree in two halves, on each side of the\n* sub-hyperplane. The instance is not modified.</p>\n* <p>The tree returned is not upward-consistent: despite all of its\n* sub-trees cut sub-hyperplanes (including its own cut\n* sub-hyperplane) are bounded to the current cell, it is <em>not</em>\n* attached to any parent tree yet. This tree is intended to be\n* later inserted into an higher level tree.</p>\n* <p>The algorithm used here is the one given in Naylor, Amanatides\n* and Thibault paper (section III, Binary Partitioning of a BSP\n* Tree).</p>\n* @param sub partitioning sub-hyperplane, must be already clipped\n* to the convex region represented by the instance, will be used as\n* the cut sub-hyperplane of the returned tree\n* @return a tree having the specified sub-hyperplane as its cut\n* sub-hyperplane, the two parts of the split instance as its two\n* sub-trees and a null parent\n*/\npublic BSPTree<S> split(final SubHyperplane<S> sub) {\n\nif (cut == null) {\nreturn new BSPTree<S>(sub, copySelf(),\nnew BSPTree<S>(attribute), null);\n}\n\nfinal Hyperplane<S> cHyperplane = cut.getHyperplane();\nfinal Hyperplane<S> sHyperplane = sub.getHyperplane();\nswitch (sub.side(cHyperplane)) {\ncase PLUS :\n{ // the partitioning sub-hyperplane is entirely in the plus sub-tree\nfinal BSPTree<S> split = plus.split(sub);\nif (cut.side(sHyperplane) == Side.PLUS) {\nsplit.plus =\nnew BSPTree<S>(cut.copySelf(), split.plus, minus.copySelf(), attribute);\nsplit.plus.condense();\nsplit.plus.parent = split;\n} else {\nsplit.minus =\nnew BSPTree<S>(cut.copySelf(), split.minus, minus.copySelf(), attribute);\nsplit.minus.condense();\nsplit.minus.parent = split;\n}\nreturn split;\n}\ncase MINUS :\n{ // the partitioning sub-hyperplane is entirely in the minus sub-tree\nfinal BSPTree<S> split = minus.split(sub);\nif (cut.side(sHyperplane) == Side.PLUS) {\nsplit.plus =\nnew BSPTree<S>(cut.copySelf(), plus.copySelf(), split.plus, attribute);\nsplit.plus.condense();\nsplit.plus.parent = split;\n} else {\nsplit.minus =\nnew BSPTree<S>(cut.copySelf(), plus.copySelf(), split.minus, attribute);\nsplit.minus.condense();\nsplit.minus.parent = split;\n}\nreturn split;\n}\ncase BOTH :\n{\nfinal SubHyperplane.SplitSubHyperplane<S> cutParts = cut.split(sHyperplane);\nfinal SubHyperplane.SplitSubHyperplane<S> subParts = sub.split(cHyperplane);\nfinal BSPTree<S> split =\nnew BSPTree<S>(sub, plus.split(subParts.getPlus()), minus.split(subParts.getMinus()),\nnull);\nsplit.plus.cut          = cutParts.getPlus();\nsplit.minus.cut         = cutParts.getMinus();\nfinal BSPTree<S> tmp    = split.plus.minus;\nsplit.plus.minus        = split.minus.plus;\nsplit.plus.minus.parent = split.plus;\nsplit.minus.plus        = tmp;\nsplit.minus.plus.parent = split.minus;\nsplit.plus.condense();\nsplit.minus.condense();\nreturn split;\n}\ndefault :\nreturn cHyperplane.sameOrientationAs(sHyperplane) ?\nnew BSPTree<S>(sub, plus.copySelf(),  minus.copySelf(), attribute) :\nnew BSPTree<S>(sub, minus.copySelf(), plus.copySelf(),  attribute);\n}\n\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:getOut()Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "public SubHyperplane<S> getOut() {\nreturn out;\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:getElement()Ljava/lang/Comparable;",
            "method_body": "public T getElement() {\nreturn element;\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:getSmallest()Lorg/apache/commons/math3/geometry/partitioning/utilities/AVLTree$Node;",
            "method_body": "Node getSmallest() {\nNode node = this;\nwhile (node.left != null) {\nnode = node.left;\n}\nreturn node;\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple:getBit(II)I",
            "method_body": "private int getBit(final int i, final int k) {\nfinal long bits = Double.doubleToLongBits(components[i]);\nfinal int e = exponent(bits);\nif ((k < e) || (k > offset)) {\nreturn 0;\n} else if (k == offset) {\nreturn (sign(bits) == 0L) ? 1 : 0;\n} else if (k > (e + 52)) {\nreturn (sign(bits) == 0L) ? 0 : 1;\n} else {\nfinal long m = (sign(bits) == 0L) ? mantissa(bits) : -mantissa(bits);\nreturn (int) ((m >> (k - e)) & 0x1L);\n}\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet:followLoop(Lorg/apache/commons/math3/geometry/partitioning/utilities/AVLTree$Node;Lorg/apache/commons/math3/geometry/partitioning/utilities/AVLTree;)Ljava/util/List;",
            "method_body": "private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node,\nfinal AVLTree<ComparableSegment> sorted) {\n\nfinal ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\nComparableSegment segment = node.getElement();\nloop.add(segment);\nfinal Vector2D globalStart = segment.getStart();\nVector2D end = segment.getEnd();\nnode.delete();\n\n// is this an open or a closed loop ?\nfinal boolean open = segment.getStart() == null;\n\nwhile ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n\n// search the sub-hyperplane starting where the previous one ended\nAVLTree<ComparableSegment>.Node selectedNode = null;\nComparableSegment       selectedSegment  = null;\ndouble                  selectedDistance = Double.POSITIVE_INFINITY;\nfinal ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\nfinal ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\nfor (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n(n != null) && (n.getElement().compareTo(upperRight) <= 0);\nn = n.getNext()) {\nsegment = n.getElement();\nfinal double distance = end.distance(segment.getStart());\nif (distance < selectedDistance) {\nselectedNode     = n;\nselectedSegment  = segment;\nselectedDistance = distance;\n}\n}\n\nif (selectedDistance > 1.0e-10) {\n// this is a degenerated loop, it probably comes from a very\n// tiny region with some segments smaller than the threshold, we\n// simply ignore it\nreturn null;\n}\n\nend = selectedSegment.getEnd();\nloop.add(selectedSegment);\nselectedNode.delete();\n\n}\n\nif ((loop.size() == 2) && !open) {\n// this is a degenerated infinitely thin loop, we simply ignore it\nreturn null;\n}\n\nif ((end == null) && !open) {\nthrow new MathInternalError();\n}\n\nreturn loop;\n\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:getSize()D",
            "method_body": "public double getSize() {\nreturn remainingRegion.getSize();\n}",
            "method_id": 119
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:toSubSpace(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/euclidean/oned/Vector1D;",
            "method_body": "public Vector1D toSubSpace(final Vector<Euclidean2D> point) {\nVector2D p2 = (Vector2D) point;\nreturn new Vector1D(cos * p2.getX() + sin * p2.getY());\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:buildNew(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)Lorg/apache/commons/math3/geometry/euclidean/oned/IntervalsSet;",
            "method_body": "public IntervalsSet buildNew(final BSPTree<Euclidean1D> tree) {\nreturn new IntervalsSet(tree);\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:<init>(Lorg/apache/commons/math3/geometry/euclidean/threed/Plane;)V",
            "method_body": "public Plane(final Plane plane) {\noriginOffset = plane.originOffset;\norigin = plane.origin;\nu      = plane.u;\nv      = plane.v;\nw      = plane.w;\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:insertCut(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Z",
            "method_body": "public boolean insertCut(final Hyperplane<S> hyperplane) {\n\nif (cut != null) {\nplus.parent  = null;\nminus.parent = null;\n}\n\nfinal SubHyperplane<S> chopped = fitToCell(hyperplane.wholeHyperplane());\nif (chopped.isEmpty()) {\ncut          = null;\nplus         = null;\nminus        = null;\nreturn false;\n}\n\ncut          = chopped;\nplus         = new BSPTree<S>();\nplus.parent  = this;\nminus        = new BSPTree<S>();\nminus.parent = this;\nreturn true;\n\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides:<init>()V",
            "method_body": "public Sides() {\nplusFound  = false;\nminusFound = false;\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine:<init>(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;Lorg/apache/commons/math3/geometry/partitioning/Region;)V",
            "method_body": "public SubLine(final Hyperplane<Euclidean2D> hyperplane,\nfinal Region<Euclidean1D> remainingRegion) {\nsuper(hyperplane, remainingRegion);\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine:buildNew(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;Lorg/apache/commons/math3/geometry/partitioning/Region;)Lorg/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane;",
            "method_body": "protected AbstractSubHyperplane<Euclidean2D, Euclidean1D> buildNew(final Hyperplane<Euclidean2D> hyperplane,\nfinal Region<Euclidean1D> remainingRegion) {\nreturn new SubLine(hyperplane, remainingRegion);\n}",
            "method_id": 127
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:getNormal()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D getNormal() {\nreturn w;\n}",
            "method_id": 128
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:floor(D)D",
            "method_body": "public static double floor(double x) {\nlong y;\n\nif (x != x) { // NaN\nreturn x;\n}\n\nif (x >= TWO_POWER_52 || x <= -TWO_POWER_52) {\nreturn x;\n}\n\ny = (long) x;\nif (x < 0 && y != x) {\ny--;\n}\n\nif (y == 0) {\nreturn x*y;\n}\n\nreturn y;\n}",
            "method_id": 129
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:condense()V",
            "method_body": "private void condense() {\nif ((cut != null) && (plus.cut == null) && (minus.cut == null) &&\n(((plus.attribute == null) && (minus.attribute == null)) ||\n((plus.attribute != null) && plus.attribute.equals(minus.attribute)))) {\nattribute = (plus.attribute == null) ? minus.attribute : plus.attribute;\ncut       = null;\nplus      = null;\nminus     = null;\n}\n}",
            "method_id": 130
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:sameOrientationAs(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Z",
            "method_body": "public boolean sameOrientationAs(final Hyperplane<Euclidean2D> other) {\nfinal Line otherL = (Line) other;\nreturn (sin * otherL.sin + cos * otherL.cos) >= 0.0;\n}",
            "method_id": 131
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Segment:<init>(Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Line;)V",
            "method_body": "public Segment(final Vector2D start, final Vector2D end, final Line line) {\nthis.start  = start;\nthis.end    = end;\nthis.line   = line;\n}",
            "method_id": 132
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathArrays:linearCombination(DDDD)D",
            "method_body": "public static double linearCombination(final double a1, final double b1,\nfinal double a2, final double b2) {\n\n// the code below is split in many additions/subtractions that may\n// appear redundant. However, they should NOT be simplified, as they\n// use IEEE754 floating point arithmetic rounding properties.\n// as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n// The variable naming conventions are that xyzHigh contains the most significant\n// bits of xyz and xyzLow contains its least significant bits. So theoretically\n// xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n// be represented in only one double precision number so we preserve two numbers\n// to hold it as long as we can, combining the high and low order bits together\n// only at the end, after cancellation may have occurred on high order bits\n\n// split a1 and b1 as two 26 bits numbers\nfinal double ca1        = SPLIT_FACTOR * a1;\nfinal double a1High     = ca1 - (ca1 - a1);\nfinal double a1Low      = a1 - a1High;\nfinal double cb1        = SPLIT_FACTOR * b1;\nfinal double b1High     = cb1 - (cb1 - b1);\nfinal double b1Low      = b1 - b1High;\n\n// accurate multiplication a1 * b1\nfinal double prod1High  = a1 * b1;\nfinal double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n// split a2 and b2 as two 26 bits numbers\nfinal double ca2        = SPLIT_FACTOR * a2;\nfinal double a2High     = ca2 - (ca2 - a2);\nfinal double a2Low      = a2 - a2High;\nfinal double cb2        = SPLIT_FACTOR * b2;\nfinal double b2High     = cb2 - (cb2 - b2);\nfinal double b2Low      = b2 - b2High;\n\n// accurate multiplication a2 * b2\nfinal double prod2High  = a2 * b2;\nfinal double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n// accurate addition a1 * b1 + a2 * b2\nfinal double s12High    = prod1High + prod2High;\nfinal double s12Prime   = s12High - prod2High;\nfinal double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n// final rounding, s12 may have suffered many cancellations, we try\n// to recover some bits from the extra words we have saved up to now\ndouble result = s12High + (prod1Low + prod2Low + s12Low);\n\nif (Double.isNaN(result)) {\n// either we have split infinite numbers or some coefficients were NaNs,\n// just rely on the naive implementation and let IEEE754 handle this\nresult = a1 * b1 + a2 * b2;\n}\n\nreturn result;\n}",
            "method_id": 133
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:<init>(DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2,\ndouble a3, Vector3D u3) {\nthis.x = MathArrays.linearCombination(a1, u1.x, a2, u2.x, a3, u3.x);\nthis.y = MathArrays.linearCombination(a1, u1.y, a2, u2.y, a3, u3.y);\nthis.z = MathArrays.linearCombination(a1, u1.z, a2, u2.z, a3, u3.z);\n}",
            "method_id": 134
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:crossProduct(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\nreturn v1.crossProduct(v2);\n}",
            "method_id": 135
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:<init>()V",
            "method_body": "public IntervalsSet() {\nsuper();\n}",
            "method_id": 136
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:intersection(Lorg/apache/commons/math3/geometry/euclidean/twod/Line;)Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;",
            "method_body": "public Vector2D intersection(final Line other) {\nfinal double d = sin * other.cos - other.sin * cos;\nif (FastMath.abs(d) < 1.0e-10) {\nreturn null;\n}\nreturn new Vector2D((cos * other.originOffset - other.cos * originOffset) / d,\n(sin * other.originOffset - other.sin * originOffset) / d);\n}",
            "method_id": 137
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:toSpace(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D toSpace(final Vector<Euclidean2D> point) {\nfinal Vector2D p2D = (Vector2D) point;\nreturn new Vector3D(p2D.getX(), u, p2D.getY(), v, -originOffset, w);\n}",
            "method_id": 138
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:add(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Z)V",
            "method_body": "public void add(final SubHyperplane<S> sub, final boolean inside) {\nif (inside) {\nif (in == null) {\nin = sub;\n} else {\nin = in.reunite(sub);\n}\n} else {\nif (out == null) {\nout = sub;\n} else {\nout = out.reunite(sub);\n}\n}\n}",
            "method_id": 139
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:getPlus()Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "public BSPTree<S> getPlus() {\nreturn plus;\n}",
            "method_id": 140
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:pointAt(D)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D pointAt(final double abscissa) {\nreturn new Vector3D(1.0, zero, abscissa, direction);\n}",
            "method_id": 141
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet$FacetsContributionVisitor:<init>(Lorg/apache/commons/math3/geometry/euclidean/threed/PolyhedronsSet;)V",
            "method_body": "public FacetsContributionVisitor() {\nsetSize(0);\nsetBarycenter(new Vector3D(0, 0, 0));\n}",
            "method_id": 142
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple:computeMSB(J)I",
            "method_body": "private static int computeMSB(final long l) {\n\nlong ll = l;\nlong mask  = 0xffffffffL;\nint  scale = 32;\nint  msb   = 0;\n\nwhile (scale != 0) {\nif ((ll & mask) != ll) {\nmsb |= scale;\nll = ll >> scale;\n}\nscale = scale >> 1;\nmask  = mask >> scale;\n}\n\nreturn msb;\n\n}",
            "method_id": 143
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D:getX()D",
            "method_body": "public double getX() {\nreturn x;\n}",
            "method_id": 144
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:copySelf()Lorg/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane;",
            "method_body": "public AbstractSubHyperplane<S, T> copySelf() {\nreturn buildNew(hyperplane, remainingRegion);\n}",
            "method_id": 145
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Interval:getLength()D",
            "method_body": "public double getLength() {\nreturn upper - lower;\n}",
            "method_id": 146
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:rebalanceLeftGrown()Z",
            "method_body": "private boolean rebalanceLeftGrown() {\nswitch (skew) {\ncase LEFT_HIGH:\nif (left.skew == Skew.LEFT_HIGH) {\nrotateCW();\nskew       = Skew.BALANCED;\nright.skew = Skew.BALANCED;\n} else {\nfinal Skew s = left.right.skew;\nleft.rotateCCW();\nrotateCW();\nswitch(s) {\ncase LEFT_HIGH:\nleft.skew  = Skew.BALANCED;\nright.skew = Skew.RIGHT_HIGH;\nbreak;\ncase RIGHT_HIGH:\nleft.skew  = Skew.LEFT_HIGH;\nright.skew = Skew.BALANCED;\nbreak;\ndefault:\nleft.skew  = Skew.BALANCED;\nright.skew = Skew.BALANCED;\n}\nskew = Skew.BALANCED;\n}\nreturn false;\ncase RIGHT_HIGH:\nskew = Skew.BALANCED;\nreturn false;\ndefault:\nskew = Skew.LEFT_HIGH;\nreturn true;\n}\n}",
            "method_id": 147
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:merge(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Lorg/apache/commons/math3/geometry/partitioning/BSPTree$LeafMerger;)Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "public BSPTree<S> merge(final BSPTree<S> tree, final LeafMerger<S> leafMerger) {\nreturn merge(tree, leafMerger, null, false);\n}",
            "method_id": 148
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint:getOffset(Lorg/apache/commons/math3/geometry/Vector;)D",
            "method_body": "public double getOffset(final Vector<Euclidean1D> point) {\nfinal double delta = ((Vector1D) point).getX() - location.getX();\nreturn direct ? delta : -delta;\n}",
            "method_id": 149
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine:<init>(Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;)V",
            "method_body": "public SubLine(final Vector2D start, final Vector2D end) {\nsuper(new Line(start, end), buildIntervalSet(start, end));\n}",
            "method_id": 150
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polySine(D)D",
            "method_body": "private static double polySine(final double x)\n{\ndouble x2 = x*x;\n\ndouble p = 2.7553817452272217E-6;\np = p * x2 + -1.9841269659586505E-4;\np = p * x2 + 0.008333333333329196;\np = p * x2 + -0.16666666666666666;\n//p *= x2;\n//p *= x;\np = p * x2 * x;\n\nreturn p;\n}",
            "method_id": 151
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane:split(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane$SplitSubHyperplane;",
            "method_body": "public SplitSubHyperplane<Euclidean3D> split(Hyperplane<Euclidean3D> hyperplane) {\n\nfinal Plane otherPlane = (Plane) hyperplane;\nfinal Plane thisPlane  = (Plane) getHyperplane();\nfinal Line  inter      = otherPlane.intersection(thisPlane);\n\nif (inter == null) {\n// the hyperplanes are parallel\nfinal double global = otherPlane.getOffset(thisPlane);\nreturn (global < -1.0e-10) ?\nnew SplitSubHyperplane<Euclidean3D>(null, this) :\nnew SplitSubHyperplane<Euclidean3D>(this, null);\n}\n\n// the hyperplanes do intersect\nVector2D p = thisPlane.toSubSpace(inter.toSpace(Vector1D.ZERO));\nVector2D q = thisPlane.toSubSpace(inter.toSpace(Vector1D.ONE));\nVector3D crossP = Vector3D.crossProduct(inter.getDirection(), thisPlane.getNormal());\nif (crossP.dotProduct(otherPlane.getNormal()) < 0) {\nfinal Vector2D tmp = p;\np           = q;\nq           = tmp;\n}\nfinal SubHyperplane<Euclidean2D> l2DMinus =\nnew org.apache.commons.math3.geometry.euclidean.twod.Line(p, q).wholeHyperplane();\nfinal SubHyperplane<Euclidean2D> l2DPlus =\nnew org.apache.commons.math3.geometry.euclidean.twod.Line(q, p).wholeHyperplane();\n\nfinal BSPTree<Euclidean2D> splitTree = getRemainingRegion().getTree(false).split(l2DMinus);\nfinal BSPTree<Euclidean2D> plusTree  = getRemainingRegion().isEmpty(splitTree.getPlus()) ?\nnew BSPTree<Euclidean2D>(Boolean.FALSE) :\nnew BSPTree<Euclidean2D>(l2DPlus, new BSPTree<Euclidean2D>(Boolean.FALSE),\nsplitTree.getPlus(), null);\n\nfinal BSPTree<Euclidean2D> minusTree = getRemainingRegion().isEmpty(splitTree.getMinus()) ?\nnew BSPTree<Euclidean2D>(Boolean.FALSE) :\nnew BSPTree<Euclidean2D>(l2DMinus, new BSPTree<Euclidean2D>(Boolean.FALSE),\nsplitTree.getMinus(), null);\n\nreturn new SplitSubHyperplane<Euclidean3D>(new SubPlane(thisPlane.copySelf(), new PolygonsSet(plusTree)),\nnew SubPlane(thisPlane.copySelf(), new PolygonsSet(minusTree)));\n\n}",
            "method_id": 152
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:<init>()V",
            "method_body": "protected AbstractRegion() {\ntree = new BSPTree<S>(Boolean.TRUE);\n}",
            "method_id": 153
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:<init>(Lorg/apache/commons/math3/geometry/euclidean/twod/Line;)V",
            "method_body": "public Line(final Line line) {\nangle        = MathUtils.normalizeAngle(line.angle, FastMath.PI);\ncos          = FastMath.cos(angle);\nsin          = FastMath.sin(angle);\noriginOffset = line.originOffset;\n}",
            "method_id": 154
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:<init>(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Plane(final Vector3D p1, final Vector3D p2, final Vector3D p3) {\nthis(p1, p2.subtract(p1).crossProduct(p3.subtract(p1)));\n}",
            "method_id": 155
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:<init>(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)V",
            "method_body": "protected AbstractRegion(final BSPTree<S> tree) {\nthis.tree = tree;\n}",
            "method_id": 156
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:hasOut()Z",
            "method_body": "public boolean hasOut() {\nreturn (out != null) && (!out.isEmpty());\n}",
            "method_id": 157
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint:buildNew(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;Lorg/apache/commons/math3/geometry/partitioning/Region;)Lorg/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane;",
            "method_body": "protected AbstractSubHyperplane<Euclidean1D, Euclidean1D> buildNew(final Hyperplane<Euclidean1D> hyperplane,\nfinal Region<Euclidean1D> remainingRegion) {\nreturn new SubOrientedPoint(hyperplane, remainingRegion);\n}",
            "method_id": 158
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet:buildNew(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)Lorg/apache/commons/math3/geometry/euclidean/twod/PolygonsSet;",
            "method_body": "public PolygonsSet buildNew(final BSPTree<Euclidean2D> tree) {\nreturn new PolygonsSet(tree);\n}",
            "method_id": 159
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:rotateCW()V",
            "method_body": "private void rotateCW() {\n\nfinal T tmpElt       = element;\nelement              = left.element;\nleft.element         = tmpElt;\n\nfinal Node tmpNode   = left;\nleft                 = tmpNode.left;\ntmpNode.left         = tmpNode.right;\ntmpNode.right        = right;\nright                = tmpNode;\n\nif (left != null) {\nleft.parent = this;\n}\nif (right.right != null) {\nright.right.parent = right;\n}\n\n}",
            "method_id": 160
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn remainingRegion.isEmpty();\n}",
            "method_id": 161
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:<init>()V",
            "method_body": "public BSPTree() {\ncut       = null;\nplus      = null;\nminus     = null;\nparent    = null;\nattribute = null;\n}",
            "method_id": 162
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:chopOffPlus(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)V",
            "method_body": "private void chopOffPlus(final Hyperplane<S> hyperplane) {\nif (cut != null) {\ncut = cut.split(hyperplane).getMinus();\nplus.chopOffPlus(hyperplane);\nminus.chopOffPlus(hyperplane);\n}\n}",
            "method_id": 163
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:toSpace(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;",
            "method_body": "public Vector2D toSpace(final Vector<Euclidean1D> point) {\nfinal double abscissa = ((Vector1D) point).getX();\nreturn new Vector2D(abscissa * cos - originOffset * sin,\nabscissa * sin + originOffset * cos);\n}",
            "method_id": 164
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Segment:getStart()Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;",
            "method_body": "public Vector2D getStart() {\nreturn start;\n}",
            "method_id": 165
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:rebalanceLeftShrunk()Z",
            "method_body": "private boolean rebalanceLeftShrunk() {\nswitch (skew) {\ncase LEFT_HIGH:\nskew = Skew.BALANCED;\nreturn true;\ncase RIGHT_HIGH:\nif (right.skew == Skew.RIGHT_HIGH) {\nrotateCCW();\nskew      = Skew.BALANCED;\nleft.skew = Skew.BALANCED;\nreturn true;\n} else if (right.skew == Skew.BALANCED) {\nrotateCCW();\nskew      = Skew.LEFT_HIGH;\nleft.skew = Skew.RIGHT_HIGH;\nreturn false;\n} else {\nfinal Skew s = right.left.skew;\nright.rotateCW();\nrotateCCW();\nswitch (s) {\ncase LEFT_HIGH:\nleft.skew  = Skew.BALANCED;\nright.skew = Skew.RIGHT_HIGH;\nbreak;\ncase RIGHT_HIGH:\nleft.skew  = Skew.LEFT_HIGH;\nright.skew = Skew.BALANCED;\nbreak;\ndefault:\nleft.skew  = Skew.BALANCED;\nright.skew = Skew.BALANCED;\n}\nskew = Skew.BALANCED;\nreturn true;\n}\ndefault:\nskew = Skew.RIGHT_HIGH;\nreturn false;\n}\n}",
            "method_id": 166
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BoundaryAttribute:getPlusInside()Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "public SubHyperplane<S> getPlusInside() {\nreturn plusInside;\n}",
            "method_id": 167
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:<init>(Ljava/lang/Object;)V",
            "method_body": "public BSPTree(final Object attribute) {\ncut    = null;\nplus   = null;\nminus  = null;\nparent = null;\nthis.attribute = attribute;\n}",
            "method_id": 168
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides:minusFound()Z",
            "method_body": "public boolean minusFound() {\nreturn minusFound;\n}",
            "method_id": 169
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\n\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\n\nreturn p;\n}",
            "method_id": 170
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:getSize()D",
            "method_body": "public double getSize() {\nif (barycenter == null) {\ncomputeGeometricalProperties();\n}\nreturn size;\n}",
            "method_id": 171
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple:encode(I)V",
            "method_body": "private void encode(final int minOffset) {\n\n// choose an offset with some margins\noffset  = minOffset + 31;\noffset -= offset % 32;\n\nif ((encoding != null) && (encoding.length == 1) && (encoding[0] == 0x0L)) {\n// the components are all zeroes\nreturn;\n}\n\n// allocate an integer array to encode the components (we use only\n// 63 bits per element because there is no unsigned long in Java)\nfinal int neededBits  = offset + 1 - lsb;\nfinal int neededLongs = (neededBits + 62) / 63;\nencoding = new long[components.length * neededLongs];\n\n// mix the bits from all components\nint  eIndex = 0;\nint  shift  = 62;\nlong word   = 0x0L;\nfor (int k = offset; eIndex < encoding.length; --k) {\nfor (int vIndex = 0; vIndex < components.length; ++vIndex) {\nif (getBit(vIndex, k) != 0) {\nword |= 0x1L << shift;\n}\nif (shift-- == 0) {\nencoding[eIndex++] = word;\nword  = 0x0L;\nshift = 62;\n}\n}\n}\n\n}",
            "method_id": 172
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:getCut()Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "public SubHyperplane<S> getCut() {\nreturn cut;\n}",
            "method_id": 173
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree:insert(Ljava/lang/Comparable;)V",
            "method_body": "public void insert(final T element) {\nif (element != null) {\nif (top == null) {\ntop = new Node(element, null);\n} else {\ntop.insert(element);\n}\n}\n}",
            "method_id": 174
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder:addContribution(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Z)V",
            "method_body": "private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n@SuppressWarnings(\"unchecked\")\nfinal AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n(AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\nfinal Line line      = (Line) sub.getHyperplane();\nfinal List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\nfor (final Interval i : intervals) {\nfinal Vector2D start = Double.isInfinite(i.getLower()) ?\nnull : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\nfinal Vector2D end   = Double.isInfinite(i.getUpper()) ?\nnull : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\nif (reversed) {\nsorted.insert(new ComparableSegment(end, start, line.getReverse()));\n} else {\nsorted.insert(new ComparableSegment(start, end, line));\n}\n}\n}",
            "method_id": 175
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane:buildNew(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;Lorg/apache/commons/math3/geometry/partitioning/Region;)Lorg/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane;",
            "method_body": "protected AbstractSubHyperplane<Euclidean3D, Euclidean2D> buildNew(final Hyperplane<Euclidean3D> hyperplane,\nfinal Region<Euclidean2D> remainingRegion) {\nreturn new SubPlane(hyperplane, remainingRegion);\n}",
            "method_id": 176
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:add(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D add(final Vector<Euclidean3D> v) {\nfinal Vector3D v3 = (Vector3D) v;\nreturn new Vector3D(x + v3.x, y + v3.y, z + v3.z);\n}",
            "method_id": 177
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.PolyhedronsSet:<init>(Ljava/util/Collection;)V",
            "method_body": "public PolyhedronsSet(final Collection<SubHyperplane<Euclidean3D>> boundary) {\nsuper(boundary);\n}",
            "method_id": 178
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:<init>(Lorg/apache/commons/math3/geometry/partitioning/utilities/AVLTree;Ljava/lang/Comparable;Lorg/apache/commons/math3/geometry/partitioning/utilities/AVLTree$Node;)V",
            "method_body": "Node(final T element, final Node parent) {\nthis.element = element;\nleft         = null;\nright        = null;\nthis.parent  = parent;\nskew         = Skew.BALANCED;\n}",
            "method_id": 179
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$1:compare(Ljava/lang/Object;Ljava/lang/Object;)I",
            "method_body": "protected AbstractRegion(final Collection<SubHyperplane<S>> boundary) {\nif (boundary.size() == 0) {\nfinal TreeSet<SubHyperplane<S>> ordered = new TreeSet<SubHyperplane<S>>(new Comparator<SubHyperplane<S>>() {\nfinal double size1 = o1.getSize();\nfinal double size2 = o2.getSize();\nreturn (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);\nordered.addAll(boundary);\ntree = new BSPTree<S>();\ninsertCuts(tree, ordered);\ntree.visit(new BSPTreeVisitor<S>() {\nreturn Order.PLUS_SUB_MINUS;\n}\nnode.setAttribute((node == node.getParent().getPlus()) ?\n}\n}",
            "method_id": 180
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:getParent()Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "public BSPTree<S> getParent() {\nreturn parent;\n}",
            "method_id": 181
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:getIn()Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "public SubHyperplane<S> getIn() {\nreturn in;\n}",
            "method_id": 182
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$SegmentsBuilder:<init>()V",
            "method_body": "public SegmentsBuilder() {\nsorted = new AVLTree<ComparableSegment>();\n}",
            "method_id": 183
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree:getSmallest()Lorg/apache/commons/math3/geometry/partitioning/utilities/AVLTree$Node;",
            "method_body": "public Node getSmallest() {\nreturn (top == null) ? null : top.getSmallest();\n}",
            "method_id": 184
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cosQ(DD)D",
            "method_body": "private static double cosQ(double xa, double xb) {\nfinal double pi2a = 1.5707963267948966;\nfinal double pi2b = 6.123233995736766E-17;\n\nfinal double a = pi2a - xa;\ndouble b = -(a - pi2a + xa);\nb += pi2b - xb;\n\nreturn sinQ(a, b);\n}",
            "method_id": 185
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:orthogonal()Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D orthogonal() {\n\ndouble threshold = 0.6 * getNorm();\nif (threshold == 0) {\nthrow new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n}\n\nif ((x >= -threshold) && (x <= threshold)) {\ndouble inverse  = 1 / FastMath.sqrt(y * y + z * z);\nreturn new Vector3D(0, inverse * z, -inverse * y);\n} else if ((y >= -threshold) && (y <= threshold)) {\ndouble inverse  = 1 / FastMath.sqrt(x * x + z * z);\nreturn new Vector3D(-inverse * z, 0, inverse * x);\n}\ndouble inverse  = 1 / FastMath.sqrt(x * x + y * y);\nreturn new Vector3D(inverse * y, -inverse * x, 0);\n\n}",
            "method_id": 186
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:insertCuts(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Ljava/util/Collection;)V",
            "method_body": "public abstract AbstractRegion<S, T> buildNew(BSPTree<S> newTree);\n\n/** Recursively build a tree by inserting cut sub-hyperplanes.\n* @param node current tree node (it is a leaf node at the beginning\n* of the call)\n* @param boundary collection of edges belonging to the cell defined\n* by the node\n*/\nprivate void insertCuts(final BSPTree<S> node, final Collection<SubHyperplane<S>> boundary) {\n\nfinal Iterator<SubHyperplane<S>> iterator = boundary.iterator();\n\n// build the current level\nHyperplane<S> inserted = null;\nwhile ((inserted == null) && iterator.hasNext()) {\ninserted = iterator.next().getHyperplane();\nif (!node.insertCut(inserted.copySelf())) {\ninserted = null;\n}\n}\n\nif (!iterator.hasNext()) {\nreturn;\n}\n\n// distribute the remaining edges in the two sub-trees\nfinal ArrayList<SubHyperplane<S>> plusList  = new ArrayList<SubHyperplane<S>>();\nfinal ArrayList<SubHyperplane<S>> minusList = new ArrayList<SubHyperplane<S>>();\nwhile (iterator.hasNext()) {\nfinal SubHyperplane<S> other = iterator.next();\nswitch (other.side(inserted)) {\ncase PLUS:\nplusList.add(other);\nbreak;\ncase MINUS:\nminusList.add(other);\nbreak;\ncase BOTH:\nfinal SubHyperplane.SplitSubHyperplane<S> split = other.split(inserted);\nplusList.add(split.getPlus());\nminusList.add(split.getMinus());\nbreak;\ndefault:\n// ignore the sub-hyperplanes belonging to the cut hyperplane\n}\n}\n\n// recurse through lower levels\ninsertCuts(node.getPlus(),  plusList);\ninsertCuts(node.getMinus(), minusList);\n\n}",
            "method_id": 187
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 188
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sinQ(DD)D",
            "method_body": "private static double sinQ(double xa, double xb) {\nint idx = (int) ((xa * 8.0) + 0.5);\nfinal double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n// Table lookups\nfinal double sintA = SINE_TABLE_A[idx];\nfinal double sintB = SINE_TABLE_B[idx];\nfinal double costA = COSINE_TABLE_A[idx];\nfinal double costB = COSINE_TABLE_B[idx];\n\n// Polynomial eval of sin(epsilon), cos(epsilon)\ndouble sinEpsA = epsilon;\ndouble sinEpsB = polySine(epsilon);\nfinal double cosEpsA = 1.0;\nfinal double cosEpsB = polyCosine(epsilon);\n\n// Split epsilon   xa + xb = x\nfinal double temp = sinEpsA * HEX_40000000;\ndouble temp2 = (sinEpsA + temp) - temp;\nsinEpsB +=  sinEpsA - temp2;\nsinEpsA = temp2;\n\n/* Compute sin(x) by angle addition formula */\ndouble result;\n\n/* Compute the following sum:\n*\n* result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n*          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n*\n* Ranges of elements\n*\n* xxxtA   0            PI/2\n* xxxtB   -1.5e-9      1.5e-9\n* sinEpsA -0.0625      0.0625\n* sinEpsB -6e-11       6e-11\n* cosEpsA  1.0\n* cosEpsB  0           -0.0625\n*\n*/\n\n//result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n//          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n//result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n//result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\ndouble a = 0;\ndouble b = 0;\n\ndouble t = sintA;\ndouble c = a + t;\ndouble d = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA * sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nb = b + sintA * cosEpsB + costA * sinEpsB;\n/*\nt = sintA*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nb = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n/*\nt = sintB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = sintB*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nif (xb != 0.0) {\nt = ((costA + costB) * (cosEpsA + cosEpsB) -\n(sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n}\n\nresult = a + b;\n\nreturn result;\n}",
            "method_id": 189
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:<init>(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Plane(final Vector3D normal) {\nsetNormal(normal);\noriginOffset = 0;\nsetFrame();\n}",
            "method_id": 190
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet:getVertices()[[Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;",
            "method_body": "public Vector2D[][] getVertices() {\nif (vertices == null) {\nif (getTree(false).getCut() == null) {\nvertices = new Vector2D[0][];\n} else {\n\n// sort the segments according to their start point\nfinal SegmentsBuilder visitor = new SegmentsBuilder();\ngetTree(true).visit(visitor);\nfinal AVLTree<ComparableSegment> sorted = visitor.getSorted();\n\n// identify the loops, starting from the open ones\n// (their start segments are naturally at the sorted set beginning)\nfinal ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>();\nwhile (!sorted.isEmpty()) {\nfinal AVLTree<ComparableSegment>.Node node = sorted.getSmallest();\nfinal List<ComparableSegment> loop = followLoop(node, sorted);\nif (loop != null) {\nloops.add(loop);\n}\n}\n\n// tranform the loops in an array of arrays of points\nvertices = new Vector2D[loops.size()][];\nint i = 0;\n\nfor (final List<ComparableSegment> loop : loops) {\nif (loop.size() < 2) {\n// single infinite line\nfinal Line line = loop.get(0).getLine();\nvertices[i++] = new Vector2D[] {\nnull,\nline.toSpace(new Vector1D(-Float.MAX_VALUE)),\nline.toSpace(new Vector1D(+Float.MAX_VALUE))\n};\n} else if (loop.get(0).getStart() == null) {\n// open loop with at least one real point\nfinal Vector2D[] array = new Vector2D[loop.size() + 2];\nint j = 0;\nfor (Segment segment : loop) {\n\nif (j == 0) {\n// null point and first dummy point\ndouble x = segment.getLine().toSubSpace(segment.getEnd()).getX();\nx -= FastMath.max(1.0, FastMath.abs(x / 2));\narray[j++] = null;\narray[j++] = segment.getLine().toSpace(new Vector1D(x));\n}\n\nif (j < (array.length - 1)) {\n// current point\narray[j++] = segment.getEnd();\n}\n\nif (j == (array.length - 1)) {\n// last dummy point\ndouble x = segment.getLine().toSubSpace(segment.getStart()).getX();\nx += FastMath.max(1.0, FastMath.abs(x / 2));\narray[j++] = segment.getLine().toSpace(new Vector1D(x));\n}\n\n}\nvertices[i++] = array;\n} else {\nfinal Vector2D[] array = new Vector2D[loop.size()];\nint j = 0;\nfor (Segment segment : loop) {\narray[j++] = segment.getStart();\n}\nvertices[i++] = array;\n}\n}\n\n}\n}\n\nreturn vertices.clone();\n\n}",
            "method_id": 191
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$2:<init>(Lorg/apache/commons/math3/geometry/partitioning/AbstractRegion;)V",
            "method_body": "protected AbstractRegion(final Collection<SubHyperplane<S>> boundary) {\nif (boundary.size() == 0) {\nfinal TreeSet<SubHyperplane<S>> ordered = new TreeSet<SubHyperplane<S>>(new Comparator<SubHyperplane<S>>() {\nfinal double size1 = o1.getSize();\nfinal double size2 = o2.getSize();\nreturn (size2 < size1) ? -1 : ((o1 == o2) ? 0 : +1);\nordered.addAll(boundary);\ntree = new BSPTree<S>();\ninsertCuts(tree, ordered);\ntree.visit(new BSPTreeVisitor<S>() {\nreturn Order.PLUS_SUB_MINUS;\n}\nnode.setAttribute((node == node.getParent().getPlus()) ?\n}\n}",
            "method_id": 192
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:hypot(DD)D",
            "method_body": "public static double hypot(final double x, final double y) {\nif (Double.isInfinite(x) || Double.isInfinite(y)) {\nreturn Double.POSITIVE_INFINITY;\n} else if (Double.isNaN(x) || Double.isNaN(y)) {\nreturn Double.NaN;\n} else {\n\nfinal int expX = getExponent(x);\nfinal int expY = getExponent(y);\nif (expX > expY + 27) {\n// y is neglectible with respect to x\nreturn abs(x);\n} else if (expY > expX + 27) {\n// x is neglectible with respect to y\nreturn abs(y);\n} else {\n\n// find an intermediate scale to avoid both overflow and underflow\nfinal int middleExp = (expX + expY) / 2;\n\n// scale parameters without losing precision\nfinal double scaledX = scalb(x, -middleExp);\nfinal double scaledY = scalb(y, -middleExp);\n\n// compute scaled hypotenuse\nfinal double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n\n// remove scaling\nreturn scalb(scaledH, middleExp);\n\n}\n\n}\n}",
            "method_id": 193
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory:union(Lorg/apache/commons/math3/geometry/partitioning/Region;Lorg/apache/commons/math3/geometry/partitioning/Region;)Lorg/apache/commons/math3/geometry/partitioning/Region;",
            "method_body": "public Region<S> union(final Region<S> region1, final Region<S> region2) {\nfinal BSPTree<S> tree =\nregion1.getTree(false).merge(region2.getTree(false), new UnionMerger());\ntree.visit(nodeCleaner);\nreturn region1.buildNew(tree);\n}",
            "method_id": 194
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint:wholeHyperplane()Lorg/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint;",
            "method_body": "public SubOrientedPoint wholeHyperplane() {\nreturn new SubOrientedPoint(this, null);\n}",
            "method_id": 195
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.AVLTree$Node:delete()V",
            "method_body": "public void delete() {\nif ((parent == null) && (left == null) && (right == null)) {\n// this was the last node, the tree is now empty\nelement = null;\ntop     = null;\n} else {\n\nNode node;\nNode child;\nboolean leftShrunk;\nif ((left == null) && (right == null)) {\nnode       = this;\nelement    = null;\nleftShrunk = node == node.parent.left;\nchild      = null;\n} else {\nnode       = (left != null) ? left.getLargest() : right.getSmallest();\nelement    = node.element;\nleftShrunk = node == node.parent.left;\nchild      = (node.left != null) ? node.left : node.right;\n}\n\nnode = node.parent;\nif (leftShrunk) {\nnode.left = child;\n} else {\nnode.right = child;\n}\nif (child != null) {\nchild.parent = node;\n}\n\nwhile (leftShrunk ? node.rebalanceLeftShrunk() : node.rebalanceRightShrunk()) {\nif (node.parent == null) {\nreturn;\n}\nleftShrunk = node == node.parent.left;\nnode = node.parent;\n}\n\n}\n}",
            "method_id": 196
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint:<init>(Lorg/apache/commons/math3/geometry/euclidean/oned/Vector1D;Z)V",
            "method_body": "public OrientedPoint(final Vector1D location, final boolean direct) {\nthis.location = location;\nthis.direct   = direct;\n}",
            "method_id": 197
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:min(II)I",
            "method_body": "public static int min(final int a, final int b) {\nreturn (a <= b) ? a : b;\n}",
            "method_id": 198
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(II)I",
            "method_body": "public static int max(final int a, final int b) {\nreturn (a <= b) ? b : a;\n}",
            "method_id": 199
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:toSubSpace(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;",
            "method_body": "public Vector2D toSubSpace(final Vector<Euclidean3D> point) {\nreturn new Vector2D(point.dotProduct(u), point.dotProduct(v));\n}",
            "method_id": 200
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.utilities.OrderedTuple:mantissa(J)J",
            "method_body": "private static long mantissa(final long bits) {\nreturn ((bits & EXPONENT_MASK) == 0) ?\n((bits & MANTISSA_MASK) << 1) :          // subnormal number\n(IMPLICIT_ONE | (bits & MANTISSA_MASK)); // normal number\n}",
            "method_id": 201
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:toSpace(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D toSpace(final Vector<Euclidean1D> point) {\nreturn pointAt(((Vector1D) point).getX());\n}",
            "method_id": 202
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet$ComparableSegment:compareTo(Lorg/apache/commons/math3/geometry/euclidean/twod/PolygonsSet$ComparableSegment;)I",
            "method_body": "public int compareTo(final ComparableSegment o) {\nreturn sortingKey.compareTo(o.sortingKey);\n}",
            "method_id": 203
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory:<init>()V",
            "method_body": "public RegionFactory() {\nnodeCleaner = new NodesCleaner();\n}",
            "method_id": 204
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:fitToCell(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;)Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;",
            "method_body": "private SubHyperplane<S> fitToCell(final SubHyperplane<S> sub) {\nSubHyperplane<S> s = sub;\nfor (BSPTree<S> tree = this; tree.parent != null; tree = tree.parent) {\nif (tree == tree.parent.plus) {\ns = s.split(tree.parent.cut.getHyperplane()).getPlus();\n} else {\ns = s.split(tree.parent.cut.getHyperplane()).getMinus();\n}\n}\nreturn s;\n}",
            "method_id": 205
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:side(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Lorg/apache/commons/math3/geometry/partitioning/Side;",
            "method_body": "public Side side(final Hyperplane<S> hyperplane) {\nfinal Sides sides = new Sides();\nrecurseSides(tree, hyperplane.wholeHyperplane(), sides);\nreturn sides.plusFound() ?\n(sides.minusFound() ? Side.BOTH  : Side.PLUS) :\n(sides.minusFound() ? Side.MINUS : Side.HYPER);\n}",
            "method_id": 206
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:dotProduct(Lorg/apache/commons/math3/geometry/Vector;)D",
            "method_body": "public double dotProduct(final Vector<Euclidean3D> v) {\nfinal Vector3D v3 = (Vector3D) v;\nreturn MathArrays.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n}",
            "method_id": 207
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.RegionFactory$NodesCleaner:visitInternalNode(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)V",
            "method_body": "public void visitInternalNode(final BSPTree<S> node) {\nnode.setAttribute(null);\n}",
            "method_id": 208
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet:<init>(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)V",
            "method_body": "public PolygonsSet(final BSPTree<Euclidean2D> tree) {\nsuper(tree);\n}",
            "method_id": 209
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:setAttribute(Ljava/lang/Object;)V",
            "method_body": "public void setAttribute(final Object attribute) {\nthis.attribute = attribute;\n}",
            "method_id": 210
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:isEmpty(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)Z",
            "method_body": "public boolean isEmpty(final BSPTree<S> node) {\n\n// we use a recursive function rather than the BSPTreeVisitor\n// interface because we can stop visiting the tree as soon as we\n// have found an inside cell\n\nif (node.getCut() == null) {\n// if we find an inside node, the region is not empty\nreturn !((Boolean) node.getAttribute());\n}\n\n// check both sides of the sub-tree\nreturn isEmpty(node.getMinus()) && isEmpty(node.getPlus());\n\n}",
            "method_id": 211
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$2:visitLeafNode(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)V",
            "method_body": "public void visitLeafNode(final BSPTree<S> node) {\nnode.setAttribute((node == node.getParent().getPlus()) ?\nBoolean.FALSE : Boolean.TRUE);\n}",
            "method_id": 212
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane:side(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Lorg/apache/commons/math3/geometry/partitioning/Side;",
            "method_body": "public Side side(Hyperplane<Euclidean3D> hyperplane) {\n\nfinal Plane otherPlane = (Plane) hyperplane;\nfinal Plane thisPlane  = (Plane) getHyperplane();\nfinal Line  inter      = otherPlane.intersection(thisPlane);\n\nif (inter == null) {\n// the hyperplanes are parallel,\n// any point can be used to check their relative position\nfinal double global = otherPlane.getOffset(thisPlane);\nreturn (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n}\n\n// create a 2D line in the otherPlane canonical 2D frame such that:\n//   - the line is the crossing line of the two planes in 3D\n//   - the line splits the otherPlane in two half planes with an\n//     orientation consistent with the orientation of the instance\n//     (i.e. the 3D half space on the plus side (resp. minus side)\n//      of the instance contains the 2D half plane on the plus side\n//      (resp. minus side) of the 2D line\nVector2D p = thisPlane.toSubSpace(inter.toSpace(Vector1D.ZERO));\nVector2D q = thisPlane.toSubSpace(inter.toSpace(Vector1D.ONE));\nVector3D crossP = Vector3D.crossProduct(inter.getDirection(), thisPlane.getNormal());\nif (crossP.dotProduct(otherPlane.getNormal()) < 0) {\nfinal Vector2D tmp = p;\np           = q;\nq           = tmp;\n}\nfinal org.apache.commons.math3.geometry.euclidean.twod.Line line2D =\nnew org.apache.commons.math3.geometry.euclidean.twod.Line(p, q);\n\n// check the side on the 2D plane\nreturn getRemainingRegion().side(line2D);\n\n}",
            "method_id": 213
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:crossProduct(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D crossProduct(final Vector<Euclidean3D> v) {\nfinal Vector3D v3 = (Vector3D) v;\nreturn new Vector3D(MathArrays.linearCombination(y, v3.z, -z, v3.y),\nMathArrays.linearCombination(z, v3.x, -x, v3.z),\nMathArrays.linearCombination(x, v3.y, -y, v3.x));\n}",
            "method_id": 214
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Plane:intersection(Lorg/apache/commons/math3/geometry/euclidean/threed/Plane;Lorg/apache/commons/math3/geometry/euclidean/threed/Plane;Lorg/apache/commons/math3/geometry/euclidean/threed/Plane;)Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;",
            "method_body": "public static Vector3D intersection(final Plane plane1, final Plane plane2, final Plane plane3) {\n\n// coefficients of the three planes linear equations\nfinal double a1 = plane1.w.getX();\nfinal double b1 = plane1.w.getY();\nfinal double c1 = plane1.w.getZ();\nfinal double d1 = plane1.originOffset;\n\nfinal double a2 = plane2.w.getX();\nfinal double b2 = plane2.w.getY();\nfinal double c2 = plane2.w.getZ();\nfinal double d2 = plane2.originOffset;\n\nfinal double a3 = plane3.w.getX();\nfinal double b3 = plane3.w.getY();\nfinal double c3 = plane3.w.getZ();\nfinal double d3 = plane3.originOffset;\n\n// direct Cramer resolution of the linear system\n// (this is still feasible for a 3x3 system)\nfinal double a23         = b2 * c3 - b3 * c2;\nfinal double b23         = c2 * a3 - c3 * a2;\nfinal double c23         = a2 * b3 - a3 * b2;\nfinal double determinant = a1 * a23 + b1 * b23 + c1 * c23;\nif (FastMath.abs(determinant) < 1.0e-10) {\nreturn null;\n}\n\nfinal double r = 1.0 / determinant;\nreturn new Vector3D(\n(-a23 * d1 - (c1 * b3 - c3 * b1) * d2 - (c2 * b1 - c1 * b2) * d3) * r,\n(-b23 * d1 - (c3 * a1 - c1 * a3) * d2 - (c1 * a2 - c2 * a1) * d3) * r,\n(-c23 * d1 - (b1 * a3 - b3 * a1) * d2 - (b2 * a1 - b1 * a2) * d3) * r);\n\n}",
            "method_id": 215
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:getCell(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "public BSPTree<S> getCell(final Vector<S> point) {\n\nif (cut == null) {\nreturn this;\n}\n\n// position of the point with respect to the cut hyperplane\nfinal double offset = cut.getHyperplane().getOffset(point);\n\nif (FastMath.abs(offset) < 1.0e-10) {\nreturn this;\n} else if (offset <= 0) {\n// point is on the minus side of the cut hyperplane\nreturn minus.getCell(point);\n} else {\n// point is on the plus side of the cut hyperplane\nreturn plus.getCell(point);\n}\n\n}",
            "method_id": 216
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:reset(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public void reset(final Vector3D p1, final Vector3D p2) {\nfinal Vector3D delta = p2.subtract(p1);\nfinal double norm2 = delta.getNormSq();\nif (norm2 == 0.0) {\nthrow new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n}\nthis.direction = new Vector3D(1.0 / FastMath.sqrt(norm2), delta);\nzero = new Vector3D(1.0, p1, -p1.dotProduct(delta) / norm2, delta);\n}",
            "method_id": 217
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D:<init>(DDD)V",
            "method_body": "public Vector3D(double x, double y, double z) {\nthis.x = x;\nthis.y = y;\nthis.z = z;\n}",
            "method_id": 218
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.Characterization:<init>()V",
            "method_body": "public Characterization() {\nin  = null;\nout = null;\n}",
            "method_id": 219
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.PolygonsSet:<init>(Ljava/util/Collection;)V",
            "method_body": "public PolygonsSet(final Collection<SubHyperplane<Euclidean2D>> boundary) {\nsuper(boundary);\n}",
            "method_id": 220
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:chopOffMinus(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)V",
            "method_body": "private void chopOffMinus(final Hyperplane<S> hyperplane) {\nif (cut != null) {\ncut = cut.split(hyperplane).getPlus();\nplus.chopOffMinus(hyperplane);\nminus.chopOffMinus(hyperplane);\n}\n}",
            "method_id": 221
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.SubPlane:<init>(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;Lorg/apache/commons/math3/geometry/partitioning/Region;)V",
            "method_body": "public SubPlane(final Hyperplane<Euclidean3D> hyperplane,\nfinal Region<Euclidean2D> remainingRegion) {\nsuper(hyperplane, remainingRegion);\n}",
            "method_id": 222
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D:<init>(DD)V",
            "method_body": "public Vector2D(double x, double y) {\nthis.x = x;\nthis.y = y;\n}",
            "method_id": 223
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint:side(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;)Lorg/apache/commons/math3/geometry/partitioning/Side;",
            "method_body": "public Side side(final Hyperplane<Euclidean1D> hyperplane) {\nfinal double global = hyperplane.getOffset(((OrientedPoint) getHyperplane()).getLocation());\nreturn (global < -1.0e-10) ? Side.MINUS : ((global > 1.0e-10) ? Side.PLUS : Side.HYPER);\n}",
            "method_id": 224
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion$Sides:rememberPlusFound()V",
            "method_body": "public void rememberPlusFound() {\nplusFound = true;\n}",
            "method_id": 225
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.threed.Line:<init>(Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math3/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Line(final Vector3D p1, final Vector3D p2) {\nreset(p1, p2);\n}",
            "method_id": 226
        }
    ]
}