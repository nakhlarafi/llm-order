{
    "bug_id": 6,
    "test_id": 9,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest.testMaximize2",
    "test_body": "public void testMaximize2() {\nSimplexOptimizer optimizer = new SimplexOptimizer(new SimpleValueChecker(1e-15, 1e-30));\nfinal FourExtrema fourExtrema = new FourExtrema();\nfinal PointValuePair optimum\n= optimizer.optimize(new MaxEval(200),\nnew ObjectiveFunction(fourExtrema),\nGoalType.MAXIMIZE,\nnew InitialGuess(new double[] { 1, 0 }),\nnew MultiDirectionalSimplex(new double[] { 0.2, 0.2 }));\nAssert.assertEquals(fourExtrema.xP, optimum.getPoint()[0], 2e-8);\nAssert.assertEquals(fourExtrema.yP, optimum.getPoint()[1], 3e-6);\nAssert.assertEquals(fourExtrema.valueXpYp, optimum.getValue(), 2e-12);\nAssert.assertTrue(optimizer.getEvaluations() > 180);\nAssert.assertTrue(optimizer.getEvaluations() < 220);\n// Check that the number of iterations is updated (MATH-949).\nAssert.assertTrue(optimizer.getIterations() > 0);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerMultiDirectionalTest.testMaximize2(SimplexOptimizerMultiDirectionalTest.java:129)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPoint()[D",
            "method_body": "public double[] getPoint() {\nfinal double[] p = getKey();\nreturn p == null ? null : p.clone();\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:setPoints([Lorg/apache/commons/math3/optim/PointValuePair;)V",
            "method_body": "protected void setPoints(PointValuePair[] points) {\nif (points.length != simplex.length) {\nthrow new DimensionMismatchException(points.length, simplex.length);\n}\nsimplex = points;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:getMaxEval()I",
            "method_body": "public int getMaxEval() {\nreturn maxEval;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:getSize()I",
            "method_body": "public int getSize() {\nreturn simplex.length;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:<init>([D)V",
            "method_body": "protected AbstractSimplex(final double[] steps) {\nif (steps == null) {\nthrow new NullArgumentException();\n}\nif (steps.length == 0) {\nthrow new ZeroException();\n}\ndimension = steps.length;\n\n// Only the relative position of the n final vertices with respect\n// to the first one are stored.\nstartConfiguration = new double[dimension][dimension];\nfor (int i = 0; i < dimension; i++) {\nfinal double[] vertexI = startConfiguration[i];\nfor (int j = 0; j < i + 1; j++) {\nif (steps[j] == 0) {\nthrow new ZeroException(LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX);\n}\nSystem.arraycopy(steps, 0, vertexI, 0, j + 1);\n}\n}\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\nthis.checker = checker;\n\nevaluations = new Incrementor(0, new MaxEvalCallback());\niterations = new Incrementor(0, new MaxIterCallback());\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:getPoints()[Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair[] getPoints() {\nfinal PointValuePair[] copy = new PointValuePair[simplex.length];\nSystem.arraycopy(simplex, 0, copy, 0, simplex.length);\nreturn copy;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max, MaxCountExceededCallback cb)\nthrows NullArgumentException {\nif (cb == null){\nthrow new NullArgumentException();\n}\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getKey()Ljava/lang/Object;",
            "method_body": "public K getKey() {\nreturn key;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleValueChecker:<init>(DD)V",
            "method_body": "public SimpleValueChecker(final double relativeThreshold,\nfinal double absoluteThreshold) {\nsuper(relativeThreshold, absoluteThreshold);\nmaxIterationCount = ITERATION_CHECK_DISABLED;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
            "method_body": "public Pair(K k, V v) {\nkey = k;\nvalue = v;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\n// Allow base class to register its own data.\nsuper.parseOptimizationData(optData);\n\n// The existing values (as set by the previous call) are reused if\n// not provided in the argument list.\nfor (OptimizationData data : optData) {\nif (data instanceof AbstractSimplex) {\nsimplex = (AbstractSimplex) data;\n// If more data must be parsed, this statement _must_ be\n// changed to \"continue\".\nbreak;\n}\n}\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:<init>([D)V",
            "method_body": "public InitialGuess(double[] startPoint) {\ninit = startPoint.clone();\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex:iterate(Lorg/apache/commons/math3/analysis/MultivariateFunction;Ljava/util/Comparator;)V",
            "method_body": "public void iterate(final MultivariateFunction evaluationFunction,\nfinal Comparator<PointValuePair> comparator) {\n// Save the original simplex.\nfinal PointValuePair[] original = getPoints();\nfinal PointValuePair best = original[0];\n\n// Perform a reflection step.\nfinal PointValuePair reflected = evaluateNewSimplex(evaluationFunction,\noriginal, 1, comparator);\nif (comparator.compare(reflected, best) < 0) {\n// Compute the expanded simplex.\nfinal PointValuePair[] reflectedSimplex = getPoints();\nfinal PointValuePair expanded = evaluateNewSimplex(evaluationFunction,\noriginal, khi, comparator);\nif (comparator.compare(reflected, expanded) <= 0) {\n// Keep the reflected simplex.\nsetPoints(reflectedSimplex);\n}\n// Keep the expanded simplex.\nreturn;\n}\n\n// Compute the contracted simplex.\nevaluateNewSimplex(evaluationFunction, original, gamma, comparator);\n\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair optimize(OptimizationData... optData) {\n// Set up base class and perform computation.\nreturn super.optimize(optData);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (start != null) {\nfinal int dim = start.length;\nif (lowerBound != null) {\nif (lowerBound.length != dim) {\nthrow new DimensionMismatchException(lowerBound.length, dim);\n}\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double lo = lowerBound[i];\nif (v < lo) {\nthrow new NumberIsTooSmallException(v, lo, true);\n}\n}\n}\nif (upperBound != null) {\nif (upperBound.length != dim) {\nthrow new DimensionMismatchException(upperBound.length, dim);\n}\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double hi = upperBound[i];\nif (v > hi) {\nthrow new NumberIsTooLargeException(v, hi, true);\n}\n}\n}\n}\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:atan(D)D",
            "method_body": "public static double atan(double x) {\nreturn atan(x, 0.0, false);\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (simplex == null) {\nthrow new NullArgumentException();\n}\nif (getLowerBound() != null ||\ngetUpperBound() != null) {\nthrow new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n}\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getStartPoint()[D",
            "method_body": "public double[] getStartPoint() {\nreturn start == null ? null : start.clone();\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:getInitialGuess()[D",
            "method_body": "public double[] getInitialGuess() {\nreturn init.clone();\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:getGoalType()Lorg/apache/commons/math3/optim/nonlinear/scalar/GoalType;",
            "method_body": "public GoalType getGoalType() {\nreturn goal;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:computeObjectiveValue([D)D",
            "method_body": "protected double computeObjectiveValue(double[] params) {\nsuper.incrementEvaluationCount();\nreturn function.value(params);\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\n}\nif (a < b) {\nreturn b;\n}\n/* if either arg is NaN, return NaN */\nif (a != b) {\nreturn Double.NaN;\n}\n/* min(+0.0,-0.0) == -0.0 */\n/* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn b;\n}\nreturn a;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected MultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "public SimplexOptimizer(ConvergenceChecker<PointValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:getRelativeThreshold()D",
            "method_body": "public double getRelativeThreshold() {\nreturn relativeThreshold;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseMultivariateOptimizer(ConvergenceChecker<PAIR> checker) {\nsuper(checker);\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:getCount()I",
            "method_body": "public int getCount() {\nreturn count;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\n// The existing values (as set by the previous call) are reused if\n// not provided in the argument list.\nfor (OptimizationData data : optData) {\nif (data instanceof MaxEval) {\nevaluations.setMaximalCount(((MaxEval) data).getMaxEval());\ncontinue;\n}\nif (data instanceof MaxIter) {\niterations.setMaximalCount(((MaxIter) data).getMaxIter());\ncontinue;\n}\n}\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() throws MaxCountExceededException {\nif (++count > maximalCount) {\nmaxCountCallback.trigger(maximalCount);\n}\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex:<init>([DDD)V",
            "method_body": "public MultiDirectionalSimplex(final double[] steps,\nfinal double khi, final double gamma) {\nsuper(steps);\n\nthis.khi   = khi;\nthis.gamma = gamma;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:getPoint(I)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair getPoint(int index) {\nif (index < 0 ||\nindex >= simplex.length) {\nthrow new OutOfRangeException(index, 0, simplex.length - 1);\n}\nreturn simplex[index];\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:getAbsoluteThreshold()D",
            "method_body": "public double getAbsoluteThreshold() {\nreturn absoluteThreshold;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:incrementEvaluationCount()V",
            "method_body": "protected abstract PAIR doOptimize();\n\n/**\n* Increment the evaluation count.\n*\n* @throws TooManyEvaluationsException if the allowed evaluations\n* have been exhausted.\n*/\nprotected void incrementEvaluationCount()\nthrows TooManyEvaluationsException {\nevaluations.incrementCount();\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getLowerBound()[D",
            "method_body": "public double[] getLowerBound() {\nreturn lowerBound == null ? null : lowerBound.clone();\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:<init>(DD)V",
            "method_body": "public AbstractConvergenceChecker(final double relativeThreshold,\nfinal double absoluteThreshold) {\nthis.relativeThreshold = relativeThreshold;\nthis.absoluteThreshold = absoluteThreshold;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:getDimension()I",
            "method_body": "public int getDimension() {\nreturn dimension;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex:<init>([D)V",
            "method_body": "public MultiDirectionalSimplex(final double[] steps) {\nthis(steps, DEFAULT_KHI, DEFAULT_GAMMA);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:<init>([DDZ)V",
            "method_body": "public PointValuePair(final double[] point,\nfinal double value,\nfinal boolean copyArray) {\nsuper(copyArray ? ((point == null) ? null :\npoint.clone()) :\npoint,\nvalue);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:setPoint(ILorg/apache/commons/math3/optim/PointValuePair;)V",
            "method_body": "protected void setPoint(int index, PointValuePair point) {\nif (index < 0 ||\nindex >= simplex.length) {\nthrow new OutOfRangeException(index, 0, simplex.length - 1);\n}\nsimplex[index] = point;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getIterations()I",
            "method_body": "public int getIterations() {\nreturn iterations.getCount();\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair optimize(OptimizationData... optData)\nthrows TooManyEvaluationsException {\n// Set up base class and perform computation.\nreturn super.optimize(optData);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer$1:value([D)D",
            "method_body": "protected PointValuePair doOptimize() {\ncheckParameters();\n\n// Indirect call to \"computeObjectiveValue\" in order to update the\n// evaluations counter.\nfinal MultivariateFunction evalFunc\n= new MultivariateFunction() {\npublic double value(double[] point) {\nreturn computeObjectiveValue(point);\n}\n};\n\nfinal boolean isMinim = getGoalType() == GoalType.MINIMIZE;\nfinal Comparator<PointValuePair> comparator\n= new Comparator<PointValuePair>() {\npublic int compare(final PointValuePair o1,\nfinal PointValuePair o2) {\nfinal double v1 = o1.getValue();\nfinal double v2 = o2.getValue();\nreturn isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n}\n};\n\n// Initialize search.\nsimplex.build(getStartPoint());\nsimplex.evaluate(evalFunc, comparator);\n\nPointValuePair[] previous = null;\nint iteration = 0;\nfinal ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\nwhile (true) {\nif (iteration > 0) {\nboolean converged = true;\nfor (int i = 0; i < simplex.getSize(); i++) {\nPointValuePair prev = previous[i];\nconverged = converged &&\nchecker.converged(iteration, prev, simplex.getPoint(i));\n}\nif (converged) {\n// We have found an optimum.\nreturn simplex.getPoint(0);\n}\n}\n\n// We still need to search.\nprevious = simplex.getPoints();\nsimplex.iterate(evalFunc, comparator);\n\n++iteration;\n}\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getEvaluations()I",
            "method_body": "public int getEvaluations() {\nreturn evaluations.getCount();\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:evaluate(Lorg/apache/commons/math3/analysis/MultivariateFunction;Ljava/util/Comparator;)V",
            "method_body": "public void evaluate(final MultivariateFunction evaluationFunction,\nfinal Comparator<PointValuePair> comparator) {\n// Evaluate the objective function at all non-evaluated simplex points.\nfor (int i = 0; i < simplex.length; i++) {\nfinal PointValuePair vertex = simplex[i];\nfinal double[] point = vertex.getPointRef();\nif (Double.isNaN(vertex.getValue())) {\nsimplex[i] = new PointValuePair(point, evaluationFunction.value(point), false);\n}\n}\n\n// Sort the simplex from best to worst.\nArrays.sort(simplex, comparator);\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getValue()Ljava/lang/Object;",
            "method_body": "public V getValue() {\nreturn value;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData) {\n// Perform optimization.\nreturn super.optimize(optData);\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer:doOptimize()Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "protected PointValuePair doOptimize() {\ncheckParameters();\n\n// Indirect call to \"computeObjectiveValue\" in order to update the\n// evaluations counter.\nfinal MultivariateFunction evalFunc\n= new MultivariateFunction() {\npublic double value(double[] point) {\nreturn computeObjectiveValue(point);\n}\n};\n\nfinal boolean isMinim = getGoalType() == GoalType.MINIMIZE;\nfinal Comparator<PointValuePair> comparator\n= new Comparator<PointValuePair>() {\npublic int compare(final PointValuePair o1,\nfinal PointValuePair o2) {\nfinal double v1 = o1.getValue();\nfinal double v2 = o2.getValue();\nreturn isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n}\n};\n\n// Initialize search.\nsimplex.build(getStartPoint());\nsimplex.evaluate(evalFunc, comparator);\n\nPointValuePair[] previous = null;\nint iteration = 0;\nfinal ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\nwhile (true) {\nif (iteration > 0) {\nboolean converged = true;\nfor (int i = 0; i < simplex.getSize(); i++) {\nPointValuePair prev = previous[i];\nconverged = converged &&\nchecker.converged(iteration, prev, simplex.getPoint(i));\n}\nif (converged) {\n// We have found an optimum.\nreturn simplex.getPoint(0);\n}\n}\n\n// We still need to search.\nprevious = simplex.getPoints();\nsimplex.iterate(evalFunc, comparator);\n\n++iteration;\n}\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:atan(DDZ)D",
            "method_body": "private static double atan(double xa, double xb, boolean leftPlane) {\nboolean negate = false;\nint idx;\n\nif (xa == 0.0) { // Matches +/- 0.0; return correct sign\nreturn leftPlane ? copySign(Math.PI, xa) : xa;\n}\n\nif (xa < 0) {\n// negative\nxa = -xa;\nxb = -xb;\nnegate = true;\n}\n\nif (xa > 1.633123935319537E16) { // Very large input\nreturn (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);\n}\n\n/* Estimate the closest tabulated arctan value, compute eps = xa-tangentTable */\nif (xa < 1) {\nidx = (int) (((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n} else {\nfinal double oneOverXa = 1 / xa;\nidx = (int) (-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\n}\ndouble epsA = xa - TANGENT_TABLE_A[idx];\ndouble epsB = -(epsA - xa + TANGENT_TABLE_A[idx]);\nepsB += xb - TANGENT_TABLE_B[idx];\n\ndouble temp = epsA + epsB;\nepsB = -(temp - epsA - epsB);\nepsA = temp;\n\n/* Compute eps = eps / (1.0 + xa*tangent) */\ntemp = xa * HEX_40000000;\ndouble ya = xa + temp - temp;\ndouble yb = xb + xa - ya;\nxa = ya;\nxb += yb;\n\n//if (idx > 8 || idx == 0)\nif (idx == 0) {\n/* If the slope of the arctan is gentle enough (< 0.45), this approximation will suffice */\n//double denom = 1.0 / (1.0 + xa*tangentTableA[idx] + xb*tangentTableA[idx] + xa*tangentTableB[idx] + xb*tangentTableB[idx]);\nfinal double denom = 1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n//double denom = 1.0 / (1.0 + xa*tangentTableA[idx]);\nya = epsA * denom;\nyb = epsB * denom;\n} else {\ndouble temp2 = xa * TANGENT_TABLE_A[idx];\ndouble za = 1d + temp2;\ndouble zb = -(za - 1d - temp2);\ntemp2 = xb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\ntemp = za + temp2;\nzb += -(temp - za - temp2);\nza = temp;\n\nzb += xb * TANGENT_TABLE_B[idx];\nya = epsA / za;\n\ntemp = ya * HEX_40000000;\nfinal double yaa = (ya + temp) - temp;\nfinal double yab = ya - yaa;\n\ntemp = za * HEX_40000000;\nfinal double zaa = (za + temp) - temp;\nfinal double zab = za - zaa;\n\n/* Correct for rounding in division */\nyb = (epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n\nyb += -epsA * zb / za / za;\nyb += epsB / za;\n}\n\n\nepsA = ya;\nepsB = yb;\n\n/* Evaluate polynomial */\nfinal double epsA2 = epsA * epsA;\n\n/*\nyb = -0.09001346640161823;\nyb = yb * epsA2 + 0.11110718400605211;\nyb = yb * epsA2 + -0.1428571349122913;\nyb = yb * epsA2 + 0.19999999999273194;\nyb = yb * epsA2 + -0.33333333333333093;\nyb = yb * epsA2 * epsA;\n*/\n\nyb = 0.07490822288864472;\nyb = yb * epsA2 + -0.09088450866185192;\nyb = yb * epsA2 + 0.11111095942313305;\nyb = yb * epsA2 + -0.1428571423679182;\nyb = yb * epsA2 + 0.19999999999923582;\nyb = yb * epsA2 + -0.33333333333333287;\nyb = yb * epsA2 * epsA;\n\n\nya = epsA;\n\ntemp = ya + yb;\nyb = -(temp - ya - yb);\nya = temp;\n\n/* Add in effect of epsB.   atan'(x) = 1/(1+x^2) */\nyb += epsB / (1d + epsA * epsA);\n\n//result = yb + eighths[idx] + ya;\ndouble za = EIGHTHS[idx] + ya;\ndouble zb = -(za - EIGHTHS[idx] - ya);\ntemp = za + yb;\nzb += -(temp - za - yb);\nza = temp;\n\ndouble result = za + zb;\ndouble resultb = -(result - za - zb);\n\nif (leftPlane) {\n// Result is in the left plane\nfinal double pia = 1.5707963267948966 * 2;\nfinal double pib = 6.123233995736766E-17 * 2;\n\nza = pia - result;\nzb = -(za - pia + result);\nzb += pib - resultb;\n\nresult = za + zb;\nresultb = -(result - za - zb);\n}\n\n\nif (negate ^ leftPlane) {\nresult = -result;\n}\n\nreturn result;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optim/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<PAIR> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex:build([D)V",
            "method_body": "public abstract void iterate(final MultivariateFunction evaluationFunction,\nfinal Comparator<PointValuePair> comparator);\n\n/**\n* Build an initial simplex.\n*\n* @param startPoint First point of the simplex.\n* @throws DimensionMismatchException if the start point does not match\n* simplex dimension.\n*/\npublic void build(final double[] startPoint) {\nif (dimension != startPoint.length) {\nthrow new DimensionMismatchException(dimension, startPoint.length);\n}\n\n// Set first vertex.\nsimplex = new PointValuePair[dimension + 1];\nsimplex[0] = new PointValuePair(startPoint, Double.NaN);\n\n// Set remaining vertices.\nfor (int i = 0; i < dimension; i++) {\nfinal double[] confI = startConfiguration[i];\nfinal double[] vertexI = new double[dimension];\nfor (int k = 0; k < dimension; k++) {\nvertexI[k] = startPoint[k] + confI[k];\n}\nsimplex[i + 1] = new PointValuePair(vertexI, Double.NaN);\n}\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.MultiDirectionalSimplex:evaluateNewSimplex(Lorg/apache/commons/math3/analysis/MultivariateFunction;[Lorg/apache/commons/math3/optim/PointValuePair;DLjava/util/Comparator;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "private PointValuePair evaluateNewSimplex(final MultivariateFunction evaluationFunction,\nfinal PointValuePair[] original,\nfinal double coeff,\nfinal Comparator<PointValuePair> comparator) {\nfinal double[] xSmallest = original[0].getPointRef();\n// Perform a linear transformation on all the simplex points,\n// except the first one.\nsetPoint(0, original[0]);\nfinal int dim = getDimension();\nfor (int i = 1; i < getSize(); i++) {\nfinal double[] xOriginal = original[i].getPointRef();\nfinal double[] xTransformed = new double[dim];\nfor (int j = 0; j < dim; j++) {\nxTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n}\nsetPoint(i, new PointValuePair(xTransformed, Double.NaN, false));\n}\n\n// Evaluate the simplex.\nevaluate(evaluationFunction, comparator);\n\nreturn getPoint(0);\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer$2:compare(Lorg/apache/commons/math3/optim/PointValuePair;Lorg/apache/commons/math3/optim/PointValuePair;)I",
            "method_body": "protected PointValuePair doOptimize() {\ncheckParameters();\n\n// Indirect call to \"computeObjectiveValue\" in order to update the\n// evaluations counter.\nfinal MultivariateFunction evalFunc\n= new MultivariateFunction() {\npublic double value(double[] point) {\nreturn computeObjectiveValue(point);\n}\n};\n\nfinal boolean isMinim = getGoalType() == GoalType.MINIMIZE;\nfinal Comparator<PointValuePair> comparator\n= new Comparator<PointValuePair>() {\npublic int compare(final PointValuePair o1,\nfinal PointValuePair o2) {\nfinal double v1 = o1.getValue();\nfinal double v2 = o2.getValue();\nreturn isMinim ? Double.compare(v1, v2) : Double.compare(v2, v1);\n}\n};\n\n// Initialize search.\nsimplex.build(getStartPoint());\nsimplex.evaluate(evalFunc, comparator);\n\nPointValuePair[] previous = null;\nint iteration = 0;\nfinal ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\nwhile (true) {\nif (iteration > 0) {\nboolean converged = true;\nfor (int i = 0; i < simplex.getSize(); i++) {\nPointValuePair prev = previous[i];\nconverged = converged &&\nchecker.converged(iteration, prev, simplex.getPoint(i));\n}\nif (converged) {\n// We have found an optimum.\nreturn simplex.getPoint(0);\n}\n}\n\n// We still need to search.\nprevious = simplex.getPoints();\nsimplex.iterate(evalFunc, comparator);\n\n++iteration;\n}\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData)\nthrows TooManyEvaluationsException,\nTooManyIterationsException {\n// Parse options.\nparseOptimizationData(optData);\n\n// Reset counters.\nevaluations.resetCount();\niterations.resetCount();\n// Perform optimization.\nreturn doOptimize();\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\n// Allow base class to register its own data.\nsuper.parseOptimizationData(optData);\n\n// The existing values (as set by the previous call) are reused if\n// not provided in the argument list.\nfor (OptimizationData data : optData) {\nif (data instanceof GoalType) {\ngoal = (GoalType) data;\ncontinue;\n}\nif (data instanceof ObjectiveFunction) {\nfunction = ((ObjectiveFunction) data).getObjectiveFunction();\ncontinue;\n}\n}\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:<init>([DD)V",
            "method_body": "public PointValuePair(final double[] point,\nfinal double value) {\nthis(point, value, true);\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleValueChecker:converged(ILorg/apache/commons/math3/optim/PointValuePair;Lorg/apache/commons/math3/optim/PointValuePair;)Z",
            "method_body": "public boolean converged(final int iteration,\nfinal PointValuePair previous,\nfinal PointValuePair current) {\nif (maxIterationCount != ITERATION_CHECK_DISABLED) {\nif (iteration >= maxIterationCount) {\nreturn true;\n}\n}\n\nfinal double p = previous.getValue();\nfinal double c = current.getValue();\nfinal double difference = FastMath.abs(p - c);\nfinal double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\nreturn difference <= size * getRelativeThreshold() ||\ndifference <= getAbsoluteThreshold();\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction:getObjectiveFunction()Lorg/apache/commons/math3/analysis/MultivariateFunction;",
            "method_body": "public MultivariateFunction getObjectiveFunction() {\nreturn function;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction:<init>(Lorg/apache/commons/math3/analysis/MultivariateFunction;)V",
            "method_body": "public ObjectiveFunction(MultivariateFunction f) {\nfunction = f;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:<init>(I)V",
            "method_body": "public MaxEval(int max) {\nif (max <= 0) {\nthrow new NotStrictlyPositiveException(max);\n}\n\nmaxEval = max;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getUpperBound()[D",
            "method_body": "public double[] getUpperBound() {\nreturn upperBound == null ? null : upperBound.clone();\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPointRef()[D",
            "method_body": "public double[] getPointRef() {\nreturn getKey();\n}",
            "method_id": 64
        }
    ]
}