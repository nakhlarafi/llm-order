{
    "bug_id": 65,
    "test_id": 0,
    "test_name": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest.testCircleFitting",
    "test_body": "public void testCircleFitting() throws FunctionEvaluationException, OptimizationException {\nCircle circle = new Circle();\ncircle.addPoint( 30.0,  68.0);\ncircle.addPoint( 50.0,  -6.0);\ncircle.addPoint(110.0, -20.0);\ncircle.addPoint( 35.0,  15.0);\ncircle.addPoint( 45.0,  97.0);\nLevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer();\nVectorialPointValuePair optimum =\noptimizer.optimize(circle, new double[] { 0, 0, 0, 0, 0 }, new double[] { 1, 1, 1, 1, 1 },\nnew double[] { 98.680, 47.345 });\nassertTrue(optimizer.getEvaluations() < 10);\nassertTrue(optimizer.getJacobianEvaluations() < 10);\ndouble rms = optimizer.getRMS();\nassertEquals(1.768262623567235,  Math.sqrt(circle.getN()) * rms,  1.0e-10);\nPoint2D.Double center = new Point2D.Double(optimum.getPointRef()[0], optimum.getPointRef()[1]);\nassertEquals(69.96016176931406, circle.getRadius(center), 1.0e-10);\nassertEquals(96.07590211815305, center.x,      1.0e-10);\nassertEquals(48.13516790438953, center.y,      1.0e-10);\ndouble[][] cov = optimizer.getCovariances();\nassertEquals(1.839, cov[0][0], 0.001);\nassertEquals(0.731, cov[0][1], 0.001);\nassertEquals(cov[0][1], cov[1][0], 1.0e-14);\nassertEquals(0.786, cov[1][1], 0.001);\ndouble[] errors = optimizer.guessParametersErrors();\nassertEquals(1.384, errors[0], 0.001);\nassertEquals(0.905, errors[1], 0.001);\n// add perfect measurements and check errors are reduced\ndouble  r = circle.getRadius(center);\nfor (double d= 0; d < 2 * Math.PI; d += 0.01) {\ncircle.addPoint(center.x + r * Math.cos(d), center.y + r * Math.sin(d));\n}\ndouble[] target = new double[circle.getN()];\nArrays.fill(target, 0.0);\ndouble[] weights = new double[circle.getN()];\nArrays.fill(weights, 2.0);\noptimizer.optimize(circle, target, weights, new double[] { 98.680, 47.345 });\ncov = optimizer.getCovariances();\nassertEquals(0.0016, cov[0][0], 0.001);\nassertEquals(3.2e-7, cov[0][1], 1.0e-9);\nassertEquals(cov[0][1], cov[1][0], 1.0e-14);\nassertEquals(0.0016, cov[1][1], 0.001);\nerrors = optimizer.guessParametersErrors();\nassertEquals(0.004, errors[0], 0.001);\nassertEquals(0.004, errors[1], 0.001);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<0.004> but was:<0.0019737107108948474>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:120)\nat junit.framework.Assert.assertEquals(Assert.java:129)\nat junit.framework.TestCase.assertEquals(TestCase.java:288)\nat org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizerTest.testCircleFitting(LevenbergMarquardtOptimizerTest.java:442)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:copyIn([[D)V",
            "method_body": "private void copyIn(final double[][] in) {\nsetSubMatrix(in, 0, 0);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:getEvaluations()I",
            "method_body": "public int getEvaluations() {\nreturn objectiveEvaluations;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.linear.LUDecompositionImpl$Solver:solve(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public RealMatrix solve(RealMatrix b)\nthrows IllegalArgumentException, InvalidMatrixException {\n\nfinal int m = pivot.length;\nif (b.getRowDimension() != m) {\nthrow MathRuntimeException.createIllegalArgumentException(\nLocalizedFormats.DIMENSIONS_MISMATCH_2x2,\nb.getRowDimension(), b.getColumnDimension(), m, \"n\");\n}\nif (singular) {\nthrow new SingularMatrixException();\n}\n\nfinal int nColB = b.getColumnDimension();\n\n// Apply permutations to b\nfinal double[][] bp = new double[m][nColB];\nfor (int row = 0; row < m; row++) {\nfinal double[] bpRow = bp[row];\nfinal int pRow = pivot[row];\nfor (int col = 0; col < nColB; col++) {\nbpRow[col] = b.getEntry(pRow, col);\n}\n}\n\n// Solve LY = b\nfor (int col = 0; col < m; col++) {\nfinal double[] bpCol = bp[col];\nfor (int i = col + 1; i < m; i++) {\nfinal double[] bpI = bp[i];\nfinal double luICol = lu[i][col];\nfor (int j = 0; j < nColB; j++) {\nbpI[j] -= bpCol[j] * luICol;\n}\n}\n}\n\n// Solve UX = Y\nfor (int col = m - 1; col >= 0; col--) {\nfinal double[] bpCol = bp[col];\nfinal double luDiag = lu[col][col];\nfor (int j = 0; j < nColB; j++) {\nbpCol[j] /= luDiag;\n}\nfor (int i = 0; i < col; i++) {\nfinal double[] bpI = bp[i];\nfinal double luICol = lu[i][col];\nfor (int j = 0; j < nColB; j++) {\nbpI[j] -= bpCol[j] * luICol;\n}\n}\n}\n\nreturn new Array2DRowRealMatrix(bp, false);\n\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:setCostRelativeTolerance(D)V",
            "method_body": "public void setCostRelativeTolerance(double costRelativeTolerance) {\nthis.costRelativeTolerance = costRelativeTolerance;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.optimization.VectorialPointValuePair:<init>([D[D)V",
            "method_body": "public VectorialPointValuePair(final double[] point, final double[] value) {\nthis.point = (point == null) ? null : point.clone();\nthis.value = (value == null) ? null : value.clone();\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:doOptimize()Lorg/apache/commons/math/optimization/VectorialPointValuePair;",
            "method_body": "protected VectorialPointValuePair doOptimize()\nthrows FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n// arrays shared with the other private methods\nsolvedCols  = Math.min(rows, cols);\ndiagR       = new double[cols];\njacNorm     = new double[cols];\nbeta        = new double[cols];\npermutation = new int[cols];\nlmDir       = new double[cols];\n\n// local point\ndouble   delta   = 0;\ndouble   xNorm   = 0;\ndouble[] diag    = new double[cols];\ndouble[] oldX    = new double[cols];\ndouble[] oldRes  = new double[rows];\ndouble[] work1   = new double[cols];\ndouble[] work2   = new double[cols];\ndouble[] work3   = new double[cols];\n\n// evaluate the function at the starting point and calculate its norm\nupdateResidualsAndCost();\n\n// outer loop\nlmPar = 0;\nboolean firstIteration = true;\nVectorialPointValuePair current = new VectorialPointValuePair(point, objective);\nwhile (true) {\n\nincrementIterationsCounter();\n\n// compute the Q.R. decomposition of the jacobian matrix\nVectorialPointValuePair previous = current;\nupdateJacobian();\nqrDecomposition();\n\n// compute Qt.res\nqTy(residuals);\n\n// now we don't need Q anymore,\n// so let jacobian contain the R matrix with its diagonal elements\nfor (int k = 0; k < solvedCols; ++k) {\nint pk = permutation[k];\njacobian[k][pk] = diagR[pk];\n}\n\nif (firstIteration) {\n\n// scale the point according to the norms of the columns\n// of the initial jacobian\nxNorm = 0;\nfor (int k = 0; k < cols; ++k) {\ndouble dk = jacNorm[k];\nif (dk == 0) {\ndk = 1.0;\n}\ndouble xk = dk * point[k];\nxNorm  += xk * xk;\ndiag[k] = dk;\n}\nxNorm = Math.sqrt(xNorm);\n\n// initialize the step bound delta\ndelta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n\n}\n\n// check orthogonality between function vector and jacobian columns\ndouble maxCosine = 0;\nif (cost != 0) {\nfor (int j = 0; j < solvedCols; ++j) {\nint    pj = permutation[j];\ndouble s  = jacNorm[pj];\nif (s != 0) {\ndouble sum = 0;\nfor (int i = 0; i <= j; ++i) {\nsum += jacobian[i][pj] * residuals[i];\n}\nmaxCosine = Math.max(maxCosine, Math.abs(sum) / (s * cost));\n}\n}\n}\nif (maxCosine <= orthoTolerance) {\n// convergence has been reached\nreturn current;\n}\n\n// rescale if necessary\nfor (int j = 0; j < cols; ++j) {\ndiag[j] = Math.max(diag[j], jacNorm[j]);\n}\n\n// inner loop\nfor (double ratio = 0; ratio < 1.0e-4;) {\n\n// save the state\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\noldX[pj] = point[pj];\n}\ndouble previousCost = cost;\ndouble[] tmpVec = residuals;\nresiduals = oldRes;\noldRes    = tmpVec;\n\n// determine the Levenberg-Marquardt parameter\ndetermineLMParameter(oldRes, delta, diag, work1, work2, work3);\n\n// compute the new point and the norm of the evolution direction\ndouble lmNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nlmDir[pj] = -lmDir[pj];\npoint[pj] = oldX[pj] + lmDir[pj];\ndouble s = diag[pj] * lmDir[pj];\nlmNorm  += s * s;\n}\nlmNorm = Math.sqrt(lmNorm);\n\n// on the first iteration, adjust the initial step bound.\nif (firstIteration) {\ndelta = Math.min(delta, lmNorm);\n}\n\n// evaluate the function at x + p and calculate its norm\nupdateResidualsAndCost();\ncurrent = new VectorialPointValuePair(point, objective);\n\n// compute the scaled actual reduction\ndouble actRed = -1.0;\nif (0.1 * cost < previousCost) {\ndouble r = cost / previousCost;\nactRed = 1.0 - r * r;\n}\n\n// compute the scaled predicted reduction\n// and the scaled directional derivative\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble dirJ = lmDir[pj];\nwork1[j] = 0;\nfor (int i = 0; i <= j; ++i) {\nwork1[i] += jacobian[i][pj] * dirJ;\n}\n}\ndouble coeff1 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\ncoeff1 += work1[j] * work1[j];\n}\ndouble pc2 = previousCost * previousCost;\ncoeff1 = coeff1 / pc2;\ndouble coeff2 = lmPar * lmNorm * lmNorm / pc2;\ndouble preRed = coeff1 + 2 * coeff2;\ndouble dirDer = -(coeff1 + coeff2);\n\n// ratio of the actual to the predicted reduction\nratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n// update the step bound\nif (ratio <= 0.25) {\ndouble tmp =\n(actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\nif ((0.1 * cost >= previousCost) || (tmp < 0.1)) {\ntmp = 0.1;\n}\ndelta = tmp * Math.min(delta, 10.0 * lmNorm);\nlmPar /= tmp;\n} else if ((lmPar == 0) || (ratio >= 0.75)) {\ndelta = 2 * lmNorm;\nlmPar *= 0.5;\n}\n\n// test for successful iteration.\nif (ratio >= 1.0e-4) {\n// successful iteration, update the norm\nfirstIteration = false;\nxNorm = 0;\nfor (int k = 0; k < cols; ++k) {\ndouble xK = diag[k] * point[k];\nxNorm    += xK * xK;\n}\nxNorm = Math.sqrt(xNorm);\n} else {\n// failed iteration, reset the previous values\ncost = previousCost;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\npoint[pj] = oldX[pj];\n}\ntmpVec    = residuals;\nresiduals = oldRes;\noldRes    = tmpVec;\n}\n\n// tests for convergence.\nif (checker != null) {\n// we use the vectorial convergence checker\nif (checker.converged(getIterations(), previous, current)) {\nreturn current;\n}\n} else {\n// we use the Levenberg-Marquardt specific convergence parameters\nif (((Math.abs(actRed) <= costRelativeTolerance) &&\n(preRed <= costRelativeTolerance) &&\n(ratio <= 2.0)) ||\n(delta <= parRelativeTolerance * xNorm)) {\nreturn current;\n}\n}\n\n// tests for termination and stringent tolerances\n// (2.2204e-16 is the machine epsilon for IEEE754)\nif ((Math.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\nthrow new OptimizationException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\ncostRelativeTolerance);\n} else if (delta <= 2.2204e-16 * xNorm) {\nthrow new OptimizationException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\nparRelativeTolerance);\n} else if (maxCosine <= 2.2204e-16)  {\nthrow new OptimizationException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\northoTolerance);\n}\n\n}\n\n}\n\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:<init>(II)V",
            "method_body": "protected AbstractRealMatrix(final int rowDimension, final int columnDimension)\nthrows IllegalArgumentException {\nif (rowDimension < 1 ) {\nthrow MathRuntimeException.createIllegalArgumentException(\nLocalizedFormats.INSUFFICIENT_DIMENSION, rowDimension, 1);\n}\nif (columnDimension <= 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\nLocalizedFormats.INSUFFICIENT_DIMENSION, columnDimension, 1);\n}\nlu = null;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:determineLMParameter([DD[D[D[D[D)V",
            "method_body": "private void determineLMParameter(double[] qy, double delta, double[] diag,\ndouble[] work1, double[] work2, double[] work3) {\n\n// compute and store in x the gauss-newton direction, if the\n// jacobian is rank-deficient, obtain a least squares solution\nfor (int j = 0; j < rank; ++j) {\nlmDir[permutation[j]] = qy[j];\n}\nfor (int j = rank; j < cols; ++j) {\nlmDir[permutation[j]] = 0;\n}\nfor (int k = rank - 1; k >= 0; --k) {\nint pk = permutation[k];\ndouble ypk = lmDir[pk] / diagR[pk];\nfor (int i = 0; i < k; ++i) {\nlmDir[permutation[i]] -= ypk * jacobian[i][pk];\n}\nlmDir[pk] = ypk;\n}\n\n// evaluate the function at the origin, and test\n// for acceptance of the Gauss-Newton direction\ndouble dxNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble s = diag[pj] * lmDir[pj];\nwork1[pj] = s;\ndxNorm += s * s;\n}\ndxNorm = Math.sqrt(dxNorm);\ndouble fp = dxNorm - delta;\nif (fp <= 0.1 * delta) {\nlmPar = 0;\nreturn;\n}\n\n// if the jacobian is not rank deficient, the Newton step provides\n// a lower bound, parl, for the zero of the function,\n// otherwise set this bound to zero\ndouble sum2;\ndouble parl = 0;\nif (rank == solvedCols) {\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] *= diag[pj] / dxNorm;\n}\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = 0; i < j; ++i) {\nsum += jacobian[i][pj] * work1[permutation[i]];\n}\ndouble s = (work1[pj] - sum) / diagR[pj];\nwork1[pj] = s;\nsum2 += s * s;\n}\nparl = fp / (delta * sum2);\n}\n\n// calculate an upper bound, paru, for the zero of the function\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = 0; i <= j; ++i) {\nsum += jacobian[i][pj] * qy[i];\n}\nsum /= diag[pj];\nsum2 += sum * sum;\n}\ndouble gNorm = Math.sqrt(sum2);\ndouble paru = gNorm / delta;\nif (paru == 0) {\n// 2.2251e-308 is the smallest positive real for IEE754\nparu = 2.2251e-308 / Math.min(delta, 0.1);\n}\n\n// if the input par lies outside of the interval (parl,paru),\n// set par to the closer endpoint\nlmPar = Math.min(paru, Math.max(lmPar, parl));\nif (lmPar == 0) {\nlmPar = gNorm / dxNorm;\n}\n\nfor (int countdown = 10; countdown >= 0; --countdown) {\n\n// evaluate the function at the current value of lmPar\nif (lmPar == 0) {\nlmPar = Math.max(2.2251e-308, 0.001 * paru);\n}\ndouble sPar = Math.sqrt(lmPar);\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] = sPar * diag[pj];\n}\ndetermineLMDirection(qy, work1, work2, work3);\n\ndxNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble s = diag[pj] * lmDir[pj];\nwork3[pj] = s;\ndxNorm += s * s;\n}\ndxNorm = Math.sqrt(dxNorm);\ndouble previousFP = fp;\nfp = dxNorm - delta;\n\n// if the function is small enough, accept the current value\n// of lmPar, also test for the exceptional cases where parl is zero\nif ((Math.abs(fp) <= 0.1 * delta) ||\n((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\nreturn;\n}\n\n// compute the Newton correction\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] = work3[pj] * diag[pj] / dxNorm;\n}\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] /= work2[j];\ndouble tmp = work1[pj];\nfor (int i = j + 1; i < solvedCols; ++i) {\nwork1[permutation[i]] -= jacobian[i][pj] * tmp;\n}\n}\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\ndouble s = work1[permutation[j]];\nsum2 += s * s;\n}\ndouble correction = fp / (delta * sum2);\n\n// depending on the sign of the function, update parl or paru.\nif (fp > 0) {\nparl = Math.max(parl, lmPar);\n} else if (fp < 0) {\nparu = Math.min(paru, lmPar);\n}\n\n// compute an improved estimate for lmPar\nlmPar = Math.max(parl, lmPar + correction);\n\n}\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>([[DZ)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\nthrows IllegalArgumentException, NullPointerException {\nif (copyArray) {\ncopyIn(d);\n} else {\nif (d == null) {\nthrow new NullPointerException();\n}\nfinal int nRows = d.length;\nif (nRows == 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\nLocalizedFormats.AT_LEAST_ONE_ROW);\n}\nfinal int nCols = d[0].length;\nif (nCols == 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\nLocalizedFormats.AT_LEAST_ONE_COLUMN);\n}\nfor (int r = 1; r < nRows; r++) {\nif (d[r].length != nCols) {\nthrow MathRuntimeException.createIllegalArgumentException(\nLocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, d[r].length);\n}\n}\ndata = d;\n}\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>([[D)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d)\nthrows IllegalArgumentException, NullPointerException {\ncopyIn(d);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:getRMS()D",
            "method_body": "public double getRMS() {\ndouble criterion = 0;\nfor (int i = 0; i < rows; ++i) {\nfinal double residual = residuals[i];\ncriterion += residual * residual * residualsWeights[i];\n}\nreturn Math.sqrt(criterion / rows);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.optimization.VectorialPointValuePair:getPointRef()[D",
            "method_body": "public double[] getPointRef() {\nreturn point;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.linear.LUDecompositionImpl$Solver:<init>([[D[IZ)V",
            "method_body": "private Solver(final double[][] lu, final int[] pivot, final boolean singular) {\nthis.lu       = lu;\nthis.pivot    = pivot;\nthis.singular = singular;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.linear.LUDecompositionImpl:<init>(Lorg/apache/commons/math/linear/RealMatrix;D)V",
            "method_body": "public LUDecompositionImpl(RealMatrix matrix, double singularityThreshold)\nthrows NonSquareMatrixException {\n\nif (!matrix.isSquare()) {\nthrow new NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());\n}\n\nfinal int m = matrix.getColumnDimension();\nlu = matrix.getData();\npivot = new int[m];\ncachedL = null;\ncachedU = null;\ncachedP = null;\n\n// Initialize permutation array and parity\nfor (int row = 0; row < m; row++) {\npivot[row] = row;\n}\neven     = true;\nsingular = false;\n\n// Loop over columns\nfor (int col = 0; col < m; col++) {\n\ndouble sum = 0;\n\n// upper\nfor (int row = 0; row < col; row++) {\nfinal double[] luRow = lu[row];\nsum = luRow[col];\nfor (int i = 0; i < row; i++) {\nsum -= luRow[i] * lu[i][col];\n}\nluRow[col] = sum;\n}\n\n// lower\nint max = col; // permutation row\ndouble largest = Double.NEGATIVE_INFINITY;\nfor (int row = col; row < m; row++) {\nfinal double[] luRow = lu[row];\nsum = luRow[col];\nfor (int i = 0; i < col; i++) {\nsum -= luRow[i] * lu[i][col];\n}\nluRow[col] = sum;\n\n// maintain best permutation choice\nif (Math.abs(sum) > largest) {\nlargest = Math.abs(sum);\nmax = row;\n}\n}\n\n// Singularity check\nif (Math.abs(lu[max][col]) < singularityThreshold) {\nsingular = true;\nreturn;\n}\n\n// Pivot if necessary\nif (max != col) {\ndouble tmp = 0;\nfinal double[] luMax = lu[max];\nfinal double[] luCol = lu[col];\nfor (int i = 0; i < m; i++) {\ntmp = luMax[i];\nluMax[i] = luCol[i];\nluCol[i] = tmp;\n}\nint temp = pivot[max];\npivot[max] = pivot[col];\npivot[col] = temp;\neven = !even;\n}\n\n// Divide the lower elements by the \"winning\" diagonal elt.\nfinal double luDiag = lu[col][col];\nfor (int row = col + 1; row < m; row++) {\nlu[row][col] /= luDiag;\n}\n}\n\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:setQRRankingThreshold(D)V",
            "method_body": "public void setQRRankingThreshold(final double threshold) {\nthis.qrRankingThreshold = threshold;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:setSubMatrix([[DII)V",
            "method_body": "public void setSubMatrix(final double[][] subMatrix, final int row, final int column)\nthrows MatrixIndexException {\nif (data == null) {\nif (row > 0) {\nthrow MathRuntimeException.createIllegalStateException(\nLocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n}\nif (column > 0) {\nthrow MathRuntimeException.createIllegalStateException(\nLocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n}\nfinal int nRows = subMatrix.length;\nif (nRows == 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\nLocalizedFormats.AT_LEAST_ONE_ROW);\n}\n\nfinal int nCols = subMatrix[0].length;\nif (nCols == 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\nLocalizedFormats.AT_LEAST_ONE_COLUMN);\n}\ndata = new double[subMatrix.length][nCols];\nfor (int i = 0; i < data.length; ++i) {\nif (subMatrix[i].length != nCols) {\nthrow MathRuntimeException.createIllegalArgumentException(\nLocalizedFormats.DIFFERENT_ROWS_LENGTHS, nCols, subMatrix[i].length);\n}\nSystem.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n}\n} else {\nsuper.setSubMatrix(subMatrix, row, column);\n}\n\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:<init>()V",
            "method_body": "protected AbstractRealMatrix() {\nlu = null;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.optimization.SimpleVectorialValueChecker:<init>()V",
            "method_body": "public SimpleVectorialValueChecker() {\nthis.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\nthis.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:<init>()V",
            "method_body": "public LevenbergMarquardtOptimizer() {\n\n// set up the superclass with a default  max cost evaluations setting\nsetMaxIterations(1000);\n\n// default values for the tuning parameters\nsetConvergenceChecker(null);\nsetInitialStepBoundFactor(100.0);\nsetCostRelativeTolerance(1.0e-10);\nsetParRelativeTolerance(1.0e-10);\nsetOrthoTolerance(1.0e-10);\nsetQRRankingThreshold(MathUtils.SAFE_MIN);\n\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:createRealMatrix(II)Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealMatrix(final int rows, final int columns) {\nreturn (rows * columns <= 4096) ?\nnew Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:getChiSquare()D",
            "method_body": "public double getChiSquare() {\ndouble chiSquare = 0;\nfor (int i = 0; i < rows; ++i) {\nfinal double residual = residuals[i];\nchiSquare += residual * residual / residualsWeights[i];\n}\nreturn chiSquare;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:updateJacobian()V",
            "method_body": "protected void updateJacobian() throws FunctionEvaluationException {\n++jacobianEvaluations;\njacobian = jF.value(point);\nif (jacobian.length != rows) {\nthrow new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\njacobian.length, rows);\n}\nfor (int i = 0; i < rows; i++) {\nfinal double[] ji = jacobian[i];\nfinal double factor = -Math.sqrt(residualsWeights[i]);\nfor (int j = 0; j < cols; ++j) {\nji[j] *= factor;\n}\n}\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:createRealIdentityMatrix(I)Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealIdentityMatrix(int dimension) {\nfinal RealMatrix m = createRealMatrix(dimension, dimension);\nfor (int i = 0; i < dimension; ++i) {\nm.setEntry(i, i, 1.0);\n}\nreturn m;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getData()[[D",
            "method_body": "public double[][] getData() {\nreturn copyOut();\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:setEntry(IID)V",
            "method_body": "public void setEntry(final int row, final int column, final double value)\nthrows MatrixIndexException {\ntry {\ndata[row][column] = value;\n} catch (ArrayIndexOutOfBoundsException e) {\nthrow new MatrixIndexException(\nLocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n}\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:incrementIterationsCounter()V",
            "method_body": "protected void incrementIterationsCounter()\nthrows OptimizationException {\nif (++iterations > maxIterations) {\nthrow new OptimizationException(new MaxIterationsExceededException(maxIterations));\n}\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:setConvergenceChecker(Lorg/apache/commons/math/optimization/VectorialConvergenceChecker;)V",
            "method_body": "public void setConvergenceChecker(VectorialConvergenceChecker convergenceChecker) {\nthis.checker = convergenceChecker;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.linear.LUDecompositionImpl:<init>(Lorg/apache/commons/math/linear/RealMatrix;)V",
            "method_body": "public LUDecompositionImpl(RealMatrix matrix)\nthrows InvalidMatrixException {\nthis(matrix, DEFAULT_TOO_SMALL);\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:<init>()V",
            "method_body": "protected AbstractLeastSquaresOptimizer() {\nsetConvergenceChecker(new SimpleVectorialValueChecker());\nsetMaxIterations(DEFAULT_MAX_ITERATIONS);\nsetMaxEvaluations(Integer.MAX_VALUE);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:optimize(Lorg/apache/commons/math/analysis/DifferentiableMultivariateVectorialFunction;[D[D[D)Lorg/apache/commons/math/optimization/VectorialPointValuePair;",
            "method_body": "public VectorialPointValuePair optimize(final DifferentiableMultivariateVectorialFunction f,\nfinal double[] target, final double[] weights,\nfinal double[] startPoint)\nthrows FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\nif (target.length != weights.length) {\nthrow new OptimizationException(LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\ntarget.length, weights.length);\n}\n\n// reset counters\niterations           = 0;\nobjectiveEvaluations = 0;\njacobianEvaluations  = 0;\n\n// store least squares problem characteristics\nfunction         = f;\njF               = f.jacobian();\ntargetValues     = target.clone();\nresidualsWeights = weights.clone();\nthis.point       = startPoint.clone();\nthis.residuals   = new double[target.length];\n\n// arrays shared with the other private methods\nrows      = target.length;\ncols      = point.length;\njacobian  = new double[rows][cols];\n\ncost = Double.POSITIVE_INFINITY;\n\nreturn doOptimize();\n\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:copyOut()[[D",
            "method_body": "private double[][] copyOut() {\nfinal int nRows = this.getRowDimension();\nfinal double[][] out = new double[nRows][this.getColumnDimension()];\n// can't copy 2-d array in one shot, otherwise get row references\nfor (int i = 0; i < nRows; i++) {\nSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\n}\nreturn out;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:createRealMatrix([[D)Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealMatrix(double[][] data) {\nreturn (data.length * data[0].length <= 4096) ?\nnew Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:setOrthoTolerance(D)V",
            "method_body": "public void setOrthoTolerance(double orthoTolerance) {\nthis.orthoTolerance = orthoTolerance;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn (data == null) ? 0 : data.length;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.linear.LUDecompositionImpl:getSolver()Lorg/apache/commons/math/linear/DecompositionSolver;",
            "method_body": "public DecompositionSolver getSolver() {\nreturn new Solver(lu, pivot, singular);\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:getCovariances()[[D",
            "method_body": "public double[][] getCovariances()\nthrows FunctionEvaluationException, OptimizationException {\n\n// set up the jacobian\nupdateJacobian();\n\n// compute transpose(J).J, avoiding building big intermediate matrices\ndouble[][] jTj = new double[cols][cols];\nfor (int i = 0; i < cols; ++i) {\nfor (int j = i; j < cols; ++j) {\ndouble sum = 0;\nfor (int k = 0; k < rows; ++k) {\nsum += jacobian[k][i] * jacobian[k][j];\n}\njTj[i][j] = sum;\njTj[j][i] = sum;\n}\n}\n\ntry {\n// compute the covariances matrix\nRealMatrix inverse =\nnew LUDecompositionImpl(MatrixUtils.createRealMatrix(jTj)).getSolver().getInverse();\nreturn inverse.getData();\n} catch (InvalidMatrixException ime) {\nthrow new OptimizationException(LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM);\n}\n\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:setMaxIterations(I)V",
            "method_body": "public void setMaxIterations(int maxIterations) {\nthis.maxIterations = maxIterations;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:qrDecomposition()V",
            "method_body": "private void qrDecomposition() throws OptimizationException {\n\n// initializations\nfor (int k = 0; k < cols; ++k) {\npermutation[k] = k;\ndouble norm2 = 0;\nfor (int i = 0; i < jacobian.length; ++i) {\ndouble akk = jacobian[i][k];\nnorm2 += akk * akk;\n}\njacNorm[k] = Math.sqrt(norm2);\n}\n\n// transform the matrix column after column\nfor (int k = 0; k < cols; ++k) {\n\n// select the column with the greatest norm on active components\nint nextColumn = -1;\ndouble ak2 = Double.NEGATIVE_INFINITY;\nfor (int i = k; i < cols; ++i) {\ndouble norm2 = 0;\nfor (int j = k; j < jacobian.length; ++j) {\ndouble aki = jacobian[j][permutation[i]];\nnorm2 += aki * aki;\n}\nif (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\nthrow new OptimizationException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\nrows, cols);\n}\nif (norm2 > ak2) {\nnextColumn = i;\nak2        = norm2;\n}\n}\nif (ak2 <= qrRankingThreshold) {\nrank = k;\nreturn;\n}\nint pk                  = permutation[nextColumn];\npermutation[nextColumn] = permutation[k];\npermutation[k]          = pk;\n\n// choose alpha such that Hk.u = alpha ek\ndouble akk   = jacobian[k][pk];\ndouble alpha = (akk > 0) ? -Math.sqrt(ak2) : Math.sqrt(ak2);\ndouble betak = 1.0 / (ak2 - akk * alpha);\nbeta[pk]     = betak;\n\n// transform the current column\ndiagR[pk]        = alpha;\njacobian[k][pk] -= alpha;\n\n// transform the remaining columns\nfor (int dk = cols - 1 - k; dk > 0; --dk) {\ndouble gamma = 0;\nfor (int j = k; j < jacobian.length; ++j) {\ngamma += jacobian[j][pk] * jacobian[j][permutation[k + dk]];\n}\ngamma *= betak;\nfor (int j = k; j < jacobian.length; ++j) {\njacobian[j][permutation[k + dk]] -= gamma * jacobian[j][pk];\n}\n}\n\n}\n\nrank = solvedCols;\n\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:setParRelativeTolerance(D)V",
            "method_body": "public void setParRelativeTolerance(double parRelativeTolerance) {\nthis.parRelativeTolerance = parRelativeTolerance;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:qTy([D)V",
            "method_body": "private void qTy(double[] y) {\nfor (int k = 0; k < cols; ++k) {\nint pk = permutation[k];\ndouble gamma = 0;\nfor (int i = k; i < rows; ++i) {\ngamma += jacobian[i][pk] * y[i];\n}\ngamma *= beta[pk];\nfor (int i = k; i < rows; ++i) {\ny[i] -= gamma * jacobian[i][pk];\n}\n}\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension, final int columnDimension)\nthrows IllegalArgumentException {\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:guessParametersErrors()[D",
            "method_body": "public double[] guessParametersErrors()\nthrows FunctionEvaluationException, OptimizationException {\nif (rows <= cols) {\nthrow new OptimizationException(\nLocalizedFormats.NO_DEGREES_OF_FREEDOM,\nrows, cols);\n}\ndouble[] errors = new double[cols];\nfinal double c = Math.sqrt(getChiSquare() / (rows - cols));\ndouble[][] covar = getCovariances();\nfor (int i = 0; i < errors.length; ++i) {\nerrors[i] = Math.sqrt(covar[i][i]) * c;\n}\nreturn errors;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:isSquare()Z",
            "method_body": "public boolean isSquare() {\nreturn getColumnDimension() == getRowDimension();\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column)\nthrows MatrixIndexException {\ntry {\nreturn data[row][column];\n} catch (ArrayIndexOutOfBoundsException e) {\nthrow new MatrixIndexException(\nLocalizedFormats.NO_SUCH_MATRIX_ENTRY, row, column, getRowDimension(), getColumnDimension());\n}\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math.linear.LUDecompositionImpl$Solver:getInverse()Lorg/apache/commons/math/linear/RealMatrix;",
            "method_body": "public RealMatrix getInverse() throws InvalidMatrixException {\nreturn solve(MatrixUtils.createRealIdentityMatrix(pivot.length));\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:getJacobianEvaluations()I",
            "method_body": "public int getJacobianEvaluations() {\nreturn jacobianEvaluations;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:updateResidualsAndCost()V",
            "method_body": "protected void updateResidualsAndCost()\nthrows FunctionEvaluationException {\n\nif (++objectiveEvaluations > maxEvaluations) {\nthrow new FunctionEvaluationException(new MaxEvaluationsExceededException(maxEvaluations),\npoint);\n}\nobjective = function.value(point);\nif (objective.length != rows) {\nthrow new FunctionEvaluationException(point, LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE,\nobjective.length, rows);\n}\ncost = 0;\nint index = 0;\nfor (int i = 0; i < rows; i++) {\nfinal double residual = targetValues[i] - objective[i];\nresiduals[i] = residual;\ncost += residualsWeights[i] * residual * residual;\nindex += cols;\n}\ncost = Math.sqrt(cost);\n\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.AbstractLeastSquaresOptimizer:setMaxEvaluations(I)V",
            "method_body": "public void setMaxEvaluations(int maxEvaluations) {\nthis.maxEvaluations = maxEvaluations;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer:setInitialStepBoundFactor(D)V",
            "method_body": "public void setInitialStepBoundFactor(double initialStepBoundFactor) {\nthis.initialStepBoundFactor = initialStepBoundFactor;\n}",
            "method_id": 49
        }
    ]
}