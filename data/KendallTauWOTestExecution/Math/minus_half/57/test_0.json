{
    "bug_id": 57,
    "test_id": 0,
    "test_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.testSmallDistances",
    "test_body": "public void testSmallDistances() {\n// Create a bunch of CloseIntegerPoints. Most are identical, but one is different by a\n// small distance.\nint[] repeatedArray = { 0 };\nint[] uniqueArray = { 1 };\nCloseIntegerPoint repeatedPoint =\nnew CloseIntegerPoint(new EuclideanIntegerPoint(repeatedArray));\nCloseIntegerPoint uniquePoint =\nnew CloseIntegerPoint(new EuclideanIntegerPoint(uniqueArray));\nCollection<CloseIntegerPoint> points = new ArrayList<CloseIntegerPoint>();\nfinal int NUM_REPEATED_POINTS = 10 * 1000;\nfor (int i = 0; i < NUM_REPEATED_POINTS; ++i) {\npoints.add(repeatedPoint);\n}\npoints.add(uniquePoint);\n// Ask a KMeansPlusPlusClusterer to run zero iterations (i.e., to simply choose initial\n// cluster centers).\nfinal long RANDOM_SEED = 0;\nfinal int NUM_CLUSTERS = 2;\nfinal int NUM_ITERATIONS = 0;\nKMeansPlusPlusClusterer<CloseIntegerPoint> clusterer =\nnew KMeansPlusPlusClusterer<CloseIntegerPoint>(new Random(RANDOM_SEED));\nList<Cluster<CloseIntegerPoint>> clusters =\nclusterer.cluster(points, NUM_CLUSTERS, NUM_ITERATIONS);\n// Check that one of the chosen centers is the unique point.\nboolean uniquePointIsCenter = false;\nfor (Cluster<CloseIntegerPoint> cluster : clusters) {\nif (cluster.getCenter().equals(uniquePoint)) {\nuniquePointIsCenter = true;\n}\n}\nassertTrue(uniquePointIsCenter);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math.stat.clustering.KMeansPlusPlusClustererTest.testSmallDistances(KMeansPlusPlusClustererTest.java:249)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint:<init>([I)V",
            "method_body": "public EuclideanIntegerPoint(final int[] point) {\nthis.point = point;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer:assignPointsToClusters(Ljava/util/Collection;Ljava/util/Collection;)V",
            "method_body": "private static <T extends Clusterable<T>> void\nassignPointsToClusters(final Collection<Cluster<T>> clusters, final Collection<T> points) {\nfor (final T p : points) {\nCluster<T> cluster = getNearestCluster(clusters, p);\ncluster.addPoint(p);\n}\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer:<init>(Ljava/util/Random;Lorg/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer$EmptyClusterStrategy;)V",
            "method_body": "public KMeansPlusPlusClusterer(final Random random, final EmptyClusterStrategy emptyStrategy) {\nthis.random        = random;\nthis.emptyStrategy = emptyStrategy;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer:getNearestCluster(Ljava/util/Collection;Lorg/apache/commons/math/stat/clustering/Clusterable;)Lorg/apache/commons/math/stat/clustering/Cluster;",
            "method_body": "private static <T extends Clusterable<T>> Cluster<T>\ngetNearestCluster(final Collection<Cluster<T>> clusters, final T point) {\ndouble minDistance = Double.MAX_VALUE;\nCluster<T> minCluster = null;\nfor (final Cluster<T> c : clusters) {\nfinal double distance = point.distanceFrom(c.getCenter());\nif (distance < minDistance) {\nminDistance = distance;\nminCluster = c;\n}\n}\nreturn minCluster;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer:chooseInitialCenters(Ljava/util/Collection;ILjava/util/Random;)Ljava/util/List;",
            "method_body": "private static <T extends Clusterable<T>> List<Cluster<T>>\nchooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\nfinal List<T> pointSet = new ArrayList<T>(points);\nfinal List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n// Choose one center uniformly at random from among the data points.\nfinal T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\nresultSet.add(new Cluster<T>(firstPoint));\n\nfinal double[] dx2 = new double[pointSet.size()];\nwhile (resultSet.size() < k) {\n// For each data point x, compute D(x), the distance between x and\n// the nearest center that has already been chosen.\nint sum = 0;\nfor (int i = 0; i < pointSet.size(); i++) {\nfinal T p = pointSet.get(i);\nfinal Cluster<T> nearest = getNearestCluster(resultSet, p);\nfinal double d = p.distanceFrom(nearest.getCenter());\nsum += d * d;\ndx2[i] = sum;\n}\n\n// Add one new data point as a center. Each point x is chosen with\n// probability proportional to D(x)2\nfinal double r = random.nextDouble() * sum;\nfor (int i = 0 ; i < dx2.length; i++) {\nif (dx2[i] >= r) {\nfinal T p = pointSet.remove(i);\nresultSet.add(new Cluster<T>(p));\nbreak;\n}\n}\n}\n\nreturn resultSet;\n\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer:<init>(Ljava/util/Random;)V",
            "method_body": "public KMeansPlusPlusClusterer(final Random random) {\nthis(random, EmptyClusterStrategy.LARGEST_VARIANCE);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.Cluster:addPoint(Lorg/apache/commons/math/stat/clustering/Clusterable;)V",
            "method_body": "public void addPoint(final T point) {\npoints.add(point);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint:getPoint()[I",
            "method_body": "public int[] getPoint() {\nreturn point;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.util.MathUtils:distance([I[I)D",
            "method_body": "public static double distance(int[] p1, int[] p2) {\ndouble sum = 0;\nfor (int i = 0; i < p1.length; i++) {\nfinal double dp = p1[i] - p2[i];\nsum += dp * dp;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint:distanceFrom(Lorg/apache/commons/math/stat/clustering/EuclideanIntegerPoint;)D",
            "method_body": "public double distanceFrom(final EuclideanIntegerPoint p) {\nreturn MathUtils.distance(point, p.getPoint());\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint:equals(Ljava/lang/Object;)Z",
            "method_body": "public boolean equals(final Object other) {\nif (!(other instanceof EuclideanIntegerPoint)) {\nreturn false;\n}\nfinal int[] otherPoint = ((EuclideanIntegerPoint) other).getPoint();\nif (point.length != otherPoint.length) {\nreturn false;\n}\nfor (int i = 0; i < point.length; i++) {\nif (point[i] != otherPoint[i]) {\nreturn false;\n}\n}\nreturn true;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer:cluster(Ljava/util/Collection;II)Ljava/util/List;",
            "method_body": "public List<Cluster<T>> cluster(final Collection<T> points,\nfinal int k, final int maxIterations) {\n// create the initial clusters\nList<Cluster<T>> clusters = chooseInitialCenters(points, k, random);\nassignPointsToClusters(clusters, points);\n\n// iterate through updating the centers until we're done\nfinal int max = (maxIterations < 0) ? Integer.MAX_VALUE : maxIterations;\nfor (int count = 0; count < max; count++) {\nboolean clusteringChanged = false;\nList<Cluster<T>> newClusters = new ArrayList<Cluster<T>>();\nfor (final Cluster<T> cluster : clusters) {\nfinal T newCenter;\nif (cluster.getPoints().isEmpty()) {\nswitch (emptyStrategy) {\ncase LARGEST_VARIANCE :\nnewCenter = getPointFromLargestVarianceCluster(clusters);\nbreak;\ncase LARGEST_POINTS_NUMBER :\nnewCenter = getPointFromLargestNumberCluster(clusters);\nbreak;\ncase FARTHEST_POINT :\nnewCenter = getFarthestPoint(clusters);\nbreak;\ndefault :\nthrow new ConvergenceException(LocalizedFormats.EMPTY_CLUSTER_IN_K_MEANS);\n}\nclusteringChanged = true;\n} else {\nnewCenter = cluster.getCenter().centroidOf(cluster.getPoints());\nif (!newCenter.equals(cluster.getCenter())) {\nclusteringChanged = true;\n}\n}\nnewClusters.add(new Cluster<T>(newCenter));\n}\nif (!clusteringChanged) {\nreturn clusters;\n}\nassignPointsToClusters(newClusters, points);\nclusters = newClusters;\n}\nreturn clusters;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.Cluster:<init>(Lorg/apache/commons/math/stat/clustering/Clusterable;)V",
            "method_body": "public Cluster(final T center) {\nthis.center = center;\npoints = new ArrayList<T>();\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.stat.clustering.Cluster:getCenter()Lorg/apache/commons/math/stat/clustering/Clusterable;",
            "method_body": "public T getCenter() {\nreturn center;\n}",
            "method_id": 14
        }
    ]
}