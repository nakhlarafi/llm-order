{
    "bug_id": 71,
    "test_id": 1,
    "test_name": "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest.testMissedEndEvent",
    "test_body": "public void testMissedEndEvent() throws IntegratorException, DerivativeException {\nfinal double   t0     = 1878250320.0000029;\nfinal double   tEvent = 1878250379.9999986;\nfinal double[] k      = { 1.0e-4, 1.0e-5, 1.0e-6 };\nFirstOrderDifferentialEquations ode = new FirstOrderDifferentialEquations() {\npublic int getDimension() {\nreturn k.length;\n}\npublic void computeDerivatives(double t, double[] y, double[] yDot) {\nfor (int i = 0; i < y.length; ++i) {\nyDot[i] = k[i] * y[i];\n}\n}\n};\nClassicalRungeKuttaIntegrator integrator = new ClassicalRungeKuttaIntegrator(60.0);\ndouble[] y0   = new double[k.length];\nfor (int i = 0; i < y0.length; ++i) {\ny0[i] = i + 1;\n}\ndouble[] y    = new double[k.length];\ndouble finalT = integrator.integrate(ode, t0, y0, tEvent, y);\nAssert.assertEquals(tEvent, finalT, 5.0e-6);\nfor (int i = 0; i < y.length; ++i) {\nAssert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n}\nintegrator.addEventHandler(new EventHandler() {\npublic void resetState(double t, double[] y) {\n}\npublic double g(double t, double[] y) {\nreturn t - tEvent;\n}\npublic int eventOccurred(double t, double[] y, boolean increasing) {\nAssert.assertEquals(tEvent, t, 5.0e-6);\nreturn CONTINUE;\n}\n}, Double.POSITIVE_INFINITY, 1.0e-20, 100);\nfinalT = integrator.integrate(ode, t0, y0, tEvent + 120, y);\nAssert.assertEquals(tEvent + 120, finalT, 5.0e-6);\nfor (int i = 0; i < y.length; ++i) {\nAssert.assertEquals(y0[i] * Math.exp(k[i] * (finalT - t0)), y[i], 1.0e-9);\n}\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<1.8782503799999986E9> but was:<1.878250439999994E9>\nat junit.framework.Assert.fail(Assert.java:57)\nat junit.framework.Assert.failNotEquals(Assert.java:329)\nat junit.framework.Assert.assertEquals(Assert.java:120)\nat junit.framework.Assert.assertEquals(Assert.java:129)\nat org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegratorTest.testMissedEndEvent(ClassicalRungeKuttaIntegratorTest.java:70)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:resetEvaluations()V",
            "method_body": "protected void resetEvaluations() {\nevaluations = 0;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState$1:<init>(Lorg/apache/commons/math/ode/events/EventState;Lorg/apache/commons/math/ode/sampling/StepInterpolator;)V",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\nfinal double h  = (t1 - t0) / n;\ndouble ta = t0;\ndouble ga = g0;\ndouble tb = t0 + (interpolator.isForward() ? convergence : -convergence);\nfor (int i = 0; i < n; ++i) {\ntb += h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\nif (g0Positive ^ (gb >= 0)) {\nif (ga * gb > 0) {\nincreasing = gb >= ga;\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\nfinal BrentSolver solver = new BrentSolver();\nsolver.setAbsoluteAccuracy(convergence);\nsolver.setMaximalIterationCount(maxIterationCount);\nfinal double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\nif ((Math.abs(root - ta) <= convergence) &&\n} else if (Double.isNaN(previousEventTime) ||\npendingEventTime = root;\nif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\npendingEvent = true;\nreturn true;\nta = tb;\nga = gb;\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:isForward()Z",
            "method_body": "public boolean isForward() {\nreturn forward;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:evaluateStep(Lorg/apache/commons/math/ode/sampling/StepInterpolator;)Z",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nthrows DerivativeException, EventException, ConvergenceException {\n\ntry {\n\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\nfinal double h  = (t1 - t0) / n;\n\ndouble ta = t0;\ndouble ga = g0;\ndouble tb = t0 + (interpolator.isForward() ? convergence : -convergence);\nfor (int i = 0; i < n; ++i) {\n\n// evaluate handler value at the end of the substep\ntb += h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n// check events occurrence\nif (g0Positive ^ (gb >= 0)) {\n// there is a sign change: an event is expected during this step\n\nif (ga * gb > 0) {\n// this is a corner case:\n// - there was an event near ta,\n// - there is another event between ta and tb\n// - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n// this implies that the real sign of ga is the same as gb, so we need to slightly\n// shift ta to make sure ga and gb get opposite signs and the solver won't complain\n// about bracketing\nfinal double epsilon = (forward ? 0.25 : -0.25) * convergence;\nfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\nta += epsilon;\ninterpolator.setInterpolatedTime(ta);\nga = handler.g(ta, interpolator.getInterpolatedState());\n}\nif (ga * gb > 0) {\n// this should never happen\nthrow MathRuntimeException.createInternalError(null);\n}\n}\n\n// variation direction, with respect to the integration direction\nincreasing = gb >= ga;\n\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\npublic double value(final double t) throws FunctionEvaluationException {\ntry {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\n} catch (DerivativeException e) {\nthrow new FunctionEvaluationException(e, t);\n} catch (EventException e) {\nthrow new FunctionEvaluationException(e, t);\n}\n}\n};\nfinal BrentSolver solver = new BrentSolver();\nsolver.setAbsoluteAccuracy(convergence);\nsolver.setMaximalIterationCount(maxIterationCount);\nfinal double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\nif ((Math.abs(root - ta) <= convergence) &&\n(Math.abs(root - previousEventTime) <= convergence)) {\n// we have either found nothing or found (again ?) a past event, we simply ignore it\nta = tb;\nga = gb;\n} else if (Double.isNaN(previousEventTime) ||\n(Math.abs(previousEventTime - root) > convergence)) {\npendingEventTime = root;\nif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n// we were already waiting for this event which was\n// found during a previous call for a step that was\n// rejected, this step must now be accepted since it\n// properly ends exactly at the event occurrence\nreturn false;\n}\n// either we were not waiting for the event or it has\n// moved in such a way the step cannot be accepted\npendingEvent = true;\nreturn true;\n}\n\n} else {\n// no sign change: there is no event for now\nta = tb;\nga = gb;\n}\n\n}\n\n// no event during the whole step\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n\n} catch (FunctionEvaluationException e) {\nfinal Throwable cause = e.getCause();\nif ((cause != null) && (cause instanceof DerivativeException)) {\nthrow (DerivativeException) cause;\n} else if ((cause != null) && (cause instanceof EventException)) {\nthrow (EventException) cause;\n}\nthrow new EventException(e);\n}\n\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator:integrate(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nfinal double t0, final double[] y0,\nfinal double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\nsanityChecks(equations, t0, y0, t, y);\nsetEquations(equations);\nresetEvaluations();\nfinal boolean forward = t > t0;\n\n// create some internal working arrays\nfinal int stages = c.length + 1;\nif (y != y0) {\nSystem.arraycopy(y0, 0, y, 0, y0.length);\n}\nfinal double[][] yDotK = new double[stages][];\nfor (int i = 0; i < stages; ++i) {\nyDotK [i] = new double[y0.length];\n}\nfinal double[] yTmp = new double[y0.length];\n\n// set up an interpolator sharing the integrator arrays\nAbstractStepInterpolator interpolator;\nif (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\nfinal RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\nrki.reinitialize(this, yTmp, yDotK, forward);\ninterpolator = rki;\n} else {\ninterpolator = new DummyStepInterpolator(yTmp, yDotK[stages - 1], forward);\n}\ninterpolator.storeTime(t0);\n\n// set up integration control objects\nstepStart = t0;\nstepSize  = forward ? step : -step;\nfor (StepHandler handler : stepHandlers) {\nhandler.reset();\n}\nCombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\nboolean lastStep = false;\n\n// main integration loop\nwhile (!lastStep) {\n\ninterpolator.shift();\n\nfor (boolean loop = true; loop;) {\n\n// first stage\ncomputeDerivatives(stepStart, y, yDotK[0]);\n\n// next stages\nfor (int k = 1; k < stages; ++k) {\n\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum = a[k-1][0] * yDotK[0][j];\nfor (int l = 1; l < k; ++l) {\nsum += a[k-1][l] * yDotK[l][j];\n}\nyTmp[j] = y[j] + stepSize * sum;\n}\n\ncomputeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n}\n\n// estimate the state at the end of the step\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum    = b[0] * yDotK[0][j];\nfor (int l = 1; l < stages; ++l) {\nsum    += b[l] * yDotK[l][j];\n}\nyTmp[j] = y[j] + stepSize * sum;\n}\n\n// discrete events handling\ninterpolator.storeTime(stepStart + stepSize);\nif (manager.evaluateStep(interpolator)) {\nfinal double dt = manager.getEventTime() - stepStart;\nif (Math.abs(dt) <= Math.ulp(stepStart)) {\n// we cannot simply truncate the step, reject the current computation\n// and let the loop compute another state with the truncated step.\n// it is so small (much probably exactly 0 due to limited accuracy)\n// that the code above would fail handling it.\n// So we set up an artificial 0 size step by copying states\nloop     = false;\n} else {\n// reject the step to match exactly the next switch time\nstepSize = dt;\n}\n} else {\nloop = false;\n}\n\n}\n\n// the step has been accepted\nfinal double nextStep = stepStart + stepSize;\nSystem.arraycopy(yTmp, 0, y, 0, y0.length);\nmanager.stepAccepted(nextStep, y);\nlastStep = manager.stop();\n\n// provide the step data to the step handler\ninterpolator.storeTime(nextStep);\nfor (StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, lastStep);\n}\nstepStart = nextStep;\n\nif (manager.reset(stepStart, y) && ! lastStep) {\n// some events handler has triggered changes that\n// invalidate the derivatives, we need to recompute them\ncomputeDerivatives(stepStart, y, yDotK[0]);\n}\n\n// make sure step size is set to default before next step\nstepSize = forward ? step : -step;\n\n}\n\nfinal double stopTime = stepStart;\nstepStart = Double.NaN;\nstepSize  = Double.NaN;\nreturn stopTime;\n\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:addEventHandler(Lorg/apache/commons/math/ode/events/EventHandler;DDI)V",
            "method_body": "public void addEventHandler(final EventHandler handler, final double maxCheckInterval,\nfinal double convergence, final int maxIterationCount) {\nstates.add(new EventState(handler, maxCheckInterval,\nconvergence, maxIterationCount));\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator:<init>()V",
            "method_body": "protected RungeKuttaStepInterpolator() {\nsuper();\nyDotK      = null;\nintegrator = null;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:isEmpty()Z",
            "method_body": "public boolean isEmpty() {\nreturn states.isEmpty();\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker:g(D[D)D",
            "method_body": "public double g(double t, double[] y) {\nreturn t - endTime;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:evaluateStep(Lorg/apache/commons/math/ode/sampling/StepInterpolator;)Z",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nthrows DerivativeException, IntegratorException {\n\ntry {\n\nfirst = null;\nif (states.isEmpty()) {\n// there is nothing to do, return now to avoid setting the\n// interpolator time (and hence avoid unneeded calls to the\n// user function due to interpolator finalization)\nreturn false;\n}\n\nif (! initialized) {\n\n// initialize the events states\nfinal double t0 = interpolator.getPreviousTime();\ninterpolator.setInterpolatedTime(t0);\nfinal double [] y = interpolator.getInterpolatedState();\nfor (EventState state : states) {\nstate.reinitializeBegin(t0, y);\n}\n\ninitialized = true;\n\n}\n\n// check events occurrence\nfor (EventState state : states) {\n\nif (state.evaluateStep(interpolator)) {\nif (first == null) {\nfirst = state;\n} else {\nif (interpolator.isForward()) {\nif (state.getEventTime() < first.getEventTime()) {\nfirst = state;\n}\n} else {\nif (state.getEventTime() > first.getEventTime()) {\nfirst = state;\n}\n}\n}\n}\n\n}\n\nreturn first != null;\n\n} catch (EventException se) {\nthrow new IntegratorException(se);\n} catch (ConvergenceException ce) {\nthrow new IntegratorException(ce);\n}\n\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.ConvergingAlgorithmImpl:setMaximalIterationCount(I)V",
            "method_body": "public void setMaximalIterationCount(int count) {\nmaximalIterationCount = count;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:verifyInterval(DD)V",
            "method_body": "protected void verifyInterval(final double lower, final double upper) {\nif (lower >= upper) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"endpoints do not specify an interval: [{0}, {1}]\",\nlower, upper);\n}\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getPreviousTime()D",
            "method_body": "public double getPreviousTime() {\nreturn previousTime;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState$1:value(D)D",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nthrows DerivativeException, EventException, ConvergenceException {\n\ntry {\n\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\nfinal double h  = (t1 - t0) / n;\n\ndouble ta = t0;\ndouble ga = g0;\ndouble tb = t0 + (interpolator.isForward() ? convergence : -convergence);\nfor (int i = 0; i < n; ++i) {\n\n// evaluate handler value at the end of the substep\ntb += h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n// check events occurrence\nif (g0Positive ^ (gb >= 0)) {\n// there is a sign change: an event is expected during this step\n\nif (ga * gb > 0) {\n// this is a corner case:\n// - there was an event near ta,\n// - there is another event between ta and tb\n// - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n// this implies that the real sign of ga is the same as gb, so we need to slightly\n// shift ta to make sure ga and gb get opposite signs and the solver won't complain\n// about bracketing\nfinal double epsilon = (forward ? 0.25 : -0.25) * convergence;\nfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\nta += epsilon;\ninterpolator.setInterpolatedTime(ta);\nga = handler.g(ta, interpolator.getInterpolatedState());\n}\nif (ga * gb > 0) {\n// this should never happen\nthrow MathRuntimeException.createInternalError(null);\n}\n}\n\n// variation direction, with respect to the integration direction\nincreasing = gb >= ga;\n\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\npublic double value(final double t) throws FunctionEvaluationException {\ntry {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\n} catch (DerivativeException e) {\nthrow new FunctionEvaluationException(e, t);\n} catch (EventException e) {\nthrow new FunctionEvaluationException(e, t);\n}\n}\n};\nfinal BrentSolver solver = new BrentSolver();\nsolver.setAbsoluteAccuracy(convergence);\nsolver.setMaximalIterationCount(maxIterationCount);\nfinal double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\nif ((Math.abs(root - ta) <= convergence) &&\n(Math.abs(root - previousEventTime) <= convergence)) {\n// we have either found nothing or found (again ?) a past event, we simply ignore it\nta = tb;\nga = gb;\n} else if (Double.isNaN(previousEventTime) ||\n(Math.abs(previousEventTime - root) > convergence)) {\npendingEventTime = root;\nif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n// we were already waiting for this event which was\n// found during a previous call for a step that was\n// rejected, this step must now be accepted since it\n// properly ends exactly at the event occurrence\nreturn false;\n}\n// either we were not waiting for the event or it has\n// moved in such a way the step cannot be accepted\npendingEvent = true;\nreturn true;\n}\n\n} else {\n// no sign change: there is no event for now\nta = tb;\nga = gb;\n}\n\n}\n\n// no event during the whole step\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n\n} catch (FunctionEvaluationException e) {\nfinal Throwable cause = e.getCause();\nif ((cause != null) && (cause instanceof DerivativeException)) {\nthrow (DerivativeException) cause;\n} else if ((cause != null) && (cause instanceof EventException)) {\nthrow (EventException) cause;\n}\nthrow new EventException(e);\n}\n\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:getEventTime()D",
            "method_body": "public double getEventTime() {\nreturn pendingEventTime;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:computeDerivatives(D[D[D)V",
            "method_body": "public void computeDerivatives(final double t, final double[] y, final double[] yDot)\nthrows DerivativeException {\nif (++evaluations > maxEvaluations) {\nthrow new DerivativeException(new MaxEvaluationsExceededException(maxEvaluations));\n}\nequations.computeDerivatives(t, y, yDot);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.DummyStepInterpolator:computeInterpolatedStateAndDerivatives(DD)V",
            "method_body": "protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH)\nthrows DerivativeException {\nSystem.arraycopy(currentState,      0, interpolatedState,       0, currentState.length);\nSystem.arraycopy(currentDerivative, 0, interpolatedDerivatives, 0, currentDerivative.length);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaIntegrator:<init>(Ljava/lang/String;[D[[D[DLorg/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator;D)V",
            "method_body": "protected RungeKuttaIntegrator(final String name,\nfinal double[] c, final double[][] a, final double[] b,\nfinal RungeKuttaStepInterpolator prototype,\nfinal double step) {\nsuper(name);\nthis.c          = c;\nthis.a          = a;\nthis.b          = b;\nthis.prototype  = prototype;\nthis.step       = Math.abs(step);\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setMaxEvaluations(I)V",
            "method_body": "public void setMaxEvaluations(int maxEvaluations) {\nthis.maxEvaluations = (maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:<init>([DZ)V",
            "method_body": "protected AbstractStepInterpolator(final double[] y, final boolean forward) {\n\npreviousTime      = Double.NaN;\ncurrentTime       = Double.NaN;\nh                 = Double.NaN;\ninterpolatedTime  = Double.NaN;\n\ncurrentState            = y;\ninterpolatedState       = new double[y.length];\ninterpolatedDerivatives = new double[y.length];\n\nfinalized         = false;\nthis.forward      = forward;\nthis.dirtyState   = true;\n\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:solve(Lorg/apache/commons/math/analysis/UnivariateRealFunction;DD)D",
            "method_body": "public double solve(final UnivariateRealFunction f,\nfinal double min, final double max)\nthrows MaxIterationsExceededException,\nFunctionEvaluationException {\n\nclearResult();\nverifyInterval(min, max);\n\ndouble ret = Double.NaN;\n\ndouble yMin = f.value(min);\ndouble yMax = f.value(max);\n\n// Verify bracketing\ndouble sign = yMin * yMax;\nif (sign > 0) {\n// check if either value is close to a zero\nif (Math.abs(yMin) <= functionValueAccuracy) {\nsetResult(min, 0);\nret = min;\n} else if (Math.abs(yMax) <= functionValueAccuracy) {\nsetResult(max, 0);\nret = max;\n} else {\n// neither value is close to zero and min and max do not bracket root.\nthrow MathRuntimeException.createIllegalArgumentException(\nNON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n}\n} else if (sign < 0){\n// solve using only the first endpoint as initial guess\nret = solve(f, min, yMin, max, yMax, min, yMin);\n} else {\n// either min or max is a root\nif (yMin == 0.0) {\nret = min;\n} else {\nret = max;\n}\n}\n\nreturn ret;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:<init>(ID)V",
            "method_body": "protected UnivariateRealSolverImpl(final int defaultMaximalIterationCount,\nfinal double defaultAbsoluteAccuracy) {\nsuper(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\nthis.defaultFunctionValueAccuracy = 1.0e-15;\nthis.functionValueAccuracy = defaultFunctionValueAccuracy;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:reset(D[D)Z",
            "method_body": "public boolean reset(final double t, final double[] y)\nthrows IntegratorException {\ntry {\nboolean resetDerivatives = false;\nfor (EventState state : states) {\nif (state.reset(t, y)) {\nresetDerivatives = true;\n}\n}\nreturn resetDerivatives;\n} catch (EventException se) {\nthrow new IntegratorException(se);\n}\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getCurrentTime()D",
            "method_body": "public double getCurrentTime() {\nreturn currentTime;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:setResult(DI)V",
            "method_body": "protected final void setResult(final double newResult, final int iterationCount) {\nthis.result         = newResult;\nthis.iterationCount = iterationCount;\nthis.resultComputed = true;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:<init>()V",
            "method_body": "public CombinedEventsManager() {\nstates      = new ArrayList<EventState>();\nfirst       = null;\ninitialized = false;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:getEventsStates()Ljava/util/Collection;",
            "method_body": "public Collection<EventState> getEventsStates() {\nreturn states;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:setInterpolatedTime(D)V",
            "method_body": "public void setInterpolatedTime(final double time) {\ninterpolatedTime = time;\ndirtyState       = true;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:<init>()V",
            "method_body": "public BrentSolver() {\nsuper(DEFAULT_MAXIMUM_ITERATIONS, DEFAULT_ABSOLUTE_ACCURACY);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.ConvergingAlgorithmImpl:<init>(ID)V",
            "method_body": "protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\nfinal double defaultAbsoluteAccuracy) {\nthis.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\nthis.defaultRelativeAccuracy = 1.0e-14;\nthis.absoluteAccuracy = defaultAbsoluteAccuracy;\nthis.relativeAccuracy = defaultRelativeAccuracy;\nthis.defaultMaximalIterationCount = defaultMaximalIterationCount;\nthis.maximalIterationCount = defaultMaximalIterationCount;\nthis.iterationCount = 0;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker:<init>(D)V",
            "method_body": "public EndTimeChecker(final double endTime) {\nthis.endTime = endTime;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getInterpolatedState()[D",
            "method_body": "public double[] getInterpolatedState() throws DerivativeException {\n\n// lazy evaluation of the state\nif (dirtyState) {\nfinal double oneMinusThetaH = currentTime - interpolatedTime;\nfinal double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\ncomputeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\ndirtyState = false;\n}\n\nreturn interpolatedState;\n\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:stepAccepted(D[D)V",
            "method_body": "public void stepAccepted(final double t, final double[] y)\nthrows IntegratorException {\ntry {\nfor (EventState state : states) {\nstate.stepAccepted(t, y);\n}\n} catch (EventException se) {\nthrow new IntegratorException(se);\n}\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setEquations(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;)V",
            "method_body": "protected void setEquations(final FirstOrderDifferentialEquations equations) {\nthis.equations = equations;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:reinitializeBegin(D[D)V",
            "method_body": "public void reinitializeBegin(final double tStart, final double[] yStart)\nthrows EventException {\nt0 = tStart;\ng0 = handler.g(tStart, yStart);\ng0Positive = g0 >= 0;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:shift()V",
            "method_body": "public void shift() {\npreviousTime = currentTime;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:sanityChecks(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)V",
            "method_body": "protected void sanityChecks(final FirstOrderDifferentialEquations ode,\nfinal double t0, final double[] y0,\nfinal double t, final double[] y)\nthrows IntegratorException {\n\nif (ode.getDimension() != y0.length) {\nthrow new IntegratorException(\n\"dimensions mismatch: ODE problem has dimension {0},\" +\n\" initial state vector has dimension {1}\",\node.getDimension(), y0.length);\n}\n\nif (ode.getDimension() != y.length) {\nthrow new IntegratorException(\n\"dimensions mismatch: ODE problem has dimension {0},\" +\n\" final state vector has dimension {1}\",\node.getDimension(), y.length);\n}\n\nif (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\nthrow new IntegratorException(\n\"too small integration interval: length = {0}\",\nMath.abs(t - t0));\n}\n\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.ClassicalRungeKuttaIntegrator:<init>(D)V",
            "method_body": "public ClassicalRungeKuttaIntegrator(final double step) {\nsuper(\"classical Runge-Kutta\", STATIC_C, STATIC_A, STATIC_B,\nnew ClassicalRungeKuttaStepInterpolator(), step);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker:eventOccurred(D[DZ)I",
            "method_body": "public int eventOccurred(double t, double[] y, boolean increasing) {\nreturn STOP;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:clearResult()V",
            "method_body": "protected final void clearResult() {\nthis.iterationCount = 0;\nthis.resultComputed = false;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:stop()Z",
            "method_body": "public boolean stop() {\nreturn nextAction == EventHandler.STOP;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:requiresDenseOutput()Z",
            "method_body": "protected boolean requiresDenseOutput() {\nfor (StepHandler handler : stepHandlers) {\nif (handler.requiresDenseOutput()) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:storeTime(D)V",
            "method_body": "public void storeTime(final double t) {\n\ncurrentTime = t;\nh           = currentTime - previousTime;\nsetInterpolatedTime(t);\n\n// the step is not finalized anymore\nfinalized  = false;\n\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.DummyStepInterpolator:<init>([D[DZ)V",
            "method_body": "public DummyStepInterpolator(final double[] y, final double[] yDot, final boolean forward) {\nsuper(y, forward);\ncurrentDerivative = yDot;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:reset(D[D)Z",
            "method_body": "public boolean reset(final double t, final double[] y)\nthrows EventException {\n\nif (! pendingEvent) {\nreturn false;\n}\n\nif (nextAction == EventHandler.RESET_STATE) {\nhandler.resetState(t, y);\n}\npendingEvent      = false;\npendingEventTime  = Double.NaN;\n\nreturn (nextAction == EventHandler.RESET_STATE) ||\n(nextAction == EventHandler.RESET_DERIVATIVES);\n\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:<init>()V",
            "method_body": "protected AbstractStepInterpolator() {\npreviousTime            = Double.NaN;\ncurrentTime             = Double.NaN;\nh                       = Double.NaN;\ninterpolatedTime        = Double.NaN;\ncurrentState            = null;\ninterpolatedState       = null;\ninterpolatedDerivatives = null;\nfinalized               = false;\nthis.forward            = true;\nthis.dirtyState         = true;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:<init>(Lorg/apache/commons/math/ode/events/EventHandler;DDI)V",
            "method_body": "public EventState(final EventHandler handler, final double maxCheckInterval,\nfinal double convergence, final int maxIterationCount) {\nthis.handler           = handler;\nthis.maxCheckInterval  = maxCheckInterval;\nthis.convergence       = Math.abs(convergence);\nthis.maxIterationCount = maxIterationCount;\n\n// some dummy values ...\nt0                = Double.NaN;\ng0                = Double.NaN;\ng0Positive        = true;\npendingEvent      = false;\npendingEventTime  = Double.NaN;\npreviousEventTime = Double.NaN;\nincreasing        = true;\nnextAction        = EventHandler.CONTINUE;\n\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:stop()Z",
            "method_body": "public boolean stop() {\nfor (EventState state : states) {\nif (state.stop()) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:solve(Lorg/apache/commons/math/analysis/UnivariateRealFunction;DDDDDD)D",
            "method_body": "private double solve(final UnivariateRealFunction f,\ndouble x0, double y0,\ndouble x1, double y1,\ndouble x2, double y2)\nthrows MaxIterationsExceededException, FunctionEvaluationException {\n\ndouble delta = x1 - x0;\ndouble oldDelta = delta;\n\nint i = 0;\nwhile (i < maximalIterationCount) {\nif (Math.abs(y2) < Math.abs(y1)) {\n// use the bracket point if is better than last approximation\nx0 = x1;\nx1 = x2;\nx2 = x0;\ny0 = y1;\ny1 = y2;\ny2 = y0;\n}\nif (Math.abs(y1) <= functionValueAccuracy) {\n// Avoid division by very small values. Assume\n// the iteration has converged (the problem may\n// still be ill conditioned)\nsetResult(x1, i);\nreturn result;\n}\ndouble dx = x2 - x1;\ndouble tolerance =\nMath.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\nif (Math.abs(dx) <= tolerance) {\nsetResult(x1, i);\nreturn result;\n}\nif ((Math.abs(oldDelta) < tolerance) ||\n(Math.abs(y0) <= Math.abs(y1))) {\n// Force bisection.\ndelta = 0.5 * dx;\noldDelta = delta;\n} else {\ndouble r3 = y1 / y0;\ndouble p;\ndouble p1;\n// the equality test (x0 == x2) is intentional,\n// it is part of the original Brent's method,\n// it should NOT be replaced by proximity test\nif (x0 == x2) {\n// Linear interpolation.\np = dx * r3;\np1 = 1.0 - r3;\n} else {\n// Inverse quadratic interpolation.\ndouble r1 = y0 / y2;\ndouble r2 = y1 / y2;\np = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\np1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n}\nif (p > 0.0) {\np1 = -p1;\n} else {\np = -p;\n}\nif (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\np >= Math.abs(0.5 * oldDelta * p1)) {\n// Inverse quadratic interpolation gives a value\n// in the wrong direction, or progress is slow.\n// Fall back to bisection.\ndelta = 0.5 * dx;\noldDelta = delta;\n} else {\noldDelta = delta;\ndelta = p / p1;\n}\n}\n// Save old X1, Y1\nx0 = x1;\ny0 = y1;\n// Compute new X1, Y1\nif (Math.abs(delta) > tolerance) {\nx1 = x1 + delta;\n} else if (dx > 0.0) {\nx1 = x1 + 0.5 * tolerance;\n} else if (dx <= 0.0) {\nx1 = x1 - 0.5 * tolerance;\n}\ny1 = f.value(x1);\nif ((y1 > 0) == (y2 > 0)) {\nx2 = x0;\ny2 = y0;\ndelta = x1 - x0;\noldDelta = delta;\n}\ni++;\n}\nthrow new MaxIterationsExceededException(maximalIterationCount);\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:addEndTimeChecker(DDLorg/apache/commons/math/ode/events/CombinedEventsManager;)Lorg/apache/commons/math/ode/events/CombinedEventsManager;",
            "method_body": "protected CombinedEventsManager addEndTimeChecker(final double startTime,\nfinal double endTime,\nfinal CombinedEventsManager manager) {\nCombinedEventsManager newManager = new CombinedEventsManager();\nfor (final EventState state : manager.getEventsStates()) {\nnewManager.addEventHandler(state.getEventHandler(),\nstate.getMaxCheckInterval(),\nstate.getConvergence(),\nstate.getMaxIterationCount());\n}\nnewManager.addEventHandler(new EndTimeChecker(endTime),\nDouble.POSITIVE_INFINITY,\nMath.ulp(Math.max(Math.abs(startTime), Math.abs(endTime))),\n100);\nreturn newManager;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:<init>(Ljava/lang/String;)V",
            "method_body": "public AbstractIntegrator(final String name) {\nthis.name = name;\nstepHandlers = new ArrayList<StepHandler>();\nstepStart = Double.NaN;\nstepSize  = Double.NaN;\neventsHandlersManager = new CombinedEventsManager();\nsetMaxEvaluations(-1);\nresetEvaluations();\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:stepAccepted(D[D)V",
            "method_body": "public void stepAccepted(final double t, final double[] y)\nthrows EventException {\n\nt0 = t;\ng0 = handler.g(t, y);\n\nif (pendingEvent) {\n// force the sign to its value \"just after the event\"\npreviousEventTime = t;\ng0Positive        = increasing;\nnextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n} else {\ng0Positive = g0 >= 0;\nnextAction = EventHandler.CONTINUE;\n}\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:getEventTime()D",
            "method_body": "public double getEventTime() {\nreturn (first == null) ? Double.NaN : first.getEventTime();\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math.ConvergingAlgorithmImpl:setAbsoluteAccuracy(D)V",
            "method_body": "public void setAbsoluteAccuracy(double accuracy) {\nabsoluteAccuracy = accuracy;\n}",
            "method_id": 53
        }
    ]
}