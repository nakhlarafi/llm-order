{
    "bug_id": 60,
    "test_id": 0,
    "test_name": "org.apache.commons.math.distribution.NormalDistributionTest.testExtremeValues",
    "test_body": "public void testExtremeValues() throws Exception {\nNormalDistribution distribution = new NormalDistributionImpl(0, 1);\nfor (int i = 0; i < 100; i++) { // make sure no convergence exception\ndouble lowerTail = distribution.cumulativeProbability(-i);\ndouble upperTail = distribution.cumulativeProbability(i);\nif (i < 9) { // make sure not top-coded \n// For i = 10, due to bad tail precision in erf (MATH-364), 1 is returned\n// TODO: once MATH-364 is resolved, replace 9 with 30\nassertTrue(lowerTail > 0.0d);\nassertTrue(upperTail < 1.0d);\n}\nelse { // make sure top coding not reversed\nassertTrue(lowerTail < 0.00001);\nassertTrue(upperTail > 0.99999);\n}\n}\nassertEquals(distribution.cumulativeProbability(Double.MAX_VALUE), 1, 0);\nassertEquals(distribution.cumulativeProbability(-Double.MAX_VALUE), 0, 0);\nassertEquals(distribution.cumulativeProbability(Double.POSITIVE_INFINITY), 1, 0);\nassertEquals(distribution.cumulativeProbability(Double.NEGATIVE_INFINITY), 0, 0);\n}\n",
    "stack_trace": "org.apache.commons.math.ConvergenceException: Continued fraction diverged to NaN for value \u221e\nat org.apache.commons.math.util.ContinuedFraction.evaluate(ContinuedFraction.java:186)\nat org.apache.commons.math.special.Gamma.regularizedGammaQ(Gamma.java:266)\nat org.apache.commons.math.special.Gamma.regularizedGammaP(Gamma.java:173)\nat org.apache.commons.math.special.Erf.erf(Erf.java:51)\nat org.apache.commons.math.distribution.NormalDistributionImpl.cumulativeProbability(NormalDistributionImpl.java:127)\nat org.apache.commons.math.distribution.NormalDistributionTest.testExtremeValues(NormalDistributionTest.java:174)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.distribution.NormalDistributionImpl:<init>(DDD)V",
            "method_body": "public NormalDistributionImpl(double mean, double sd, double inverseCumAccuracy) {\nif (sd <= 0) {\nthrow new NotStrictlyPositiveException(LocalizedFormats.STANDARD_DEVIATION, sd);\n}\n\nthis.mean = mean;\nstandardDeviation = sd;\nsolverAbsoluteAccuracy = inverseCumAccuracy;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.special.Erf:erf(D)D",
            "method_body": "public static double erf(double x) throws MathException {\ndouble ret = Gamma.regularizedGammaP(0.5, x * x, 1.0e-15, 10000);\nif (x < 0) {\nret = -ret;\n}\nreturn ret;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:log(D)D",
            "method_body": "public static double log(final double x) {\nreturn log(x, null);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.distribution.NormalDistributionImpl:cumulativeProbability(D)D",
            "method_body": "public double cumulativeProbability(double x) throws MathException {\nfinal double dev = x - mean;\ntry {\nreturn 0.5 * (1.0 + Erf.erf((dev) /\n(standardDeviation * FastMath.sqrt(2.0))));\n} catch (MaxIterationsExceededException ex) {\nif (x < (mean - 20 * standardDeviation)) { // JDK 1.5 blows at 38\nreturn 0;\n} else if (x > (mean + 20 * standardDeviation)) {\nreturn 1;\n} else {\nthrow ex;\n}\n}\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:log(D[D)D",
            "method_body": "private static double log(final double x, final double[] hiPrec) {\nlong bits = Double.doubleToLongBits(x);\n\n/* Handle special cases of negative input, and NaN */\nif ((bits & 0x8000000000000000L) != 0 || x != x) {\nif (x != 0.0) {\nif (hiPrec != null) {\nhiPrec[0] = Double.NaN;\n}\n\nreturn Double.NaN;\n}\n}\n\n/* Handle special cases of Positive infinity. */\nif (x == Double.POSITIVE_INFINITY) {\nif (hiPrec != null) {\nhiPrec[0] = Double.POSITIVE_INFINITY;\n}\n\nreturn Double.POSITIVE_INFINITY;\n}\n\n/* Extract the exponent */\nint exp = (int)(bits >> 52)-1023;\n\nif ((bits & 0x7ff0000000000000L) == 0) {\n// Subnormal!\nif (x == 0) {\n// Zero\nif (hiPrec != null) {\nhiPrec[0] = Double.NEGATIVE_INFINITY;\n}\n\nreturn Double.NEGATIVE_INFINITY;\n}\n\n/* Normalize the subnormal number. */\nbits <<= 1;\nwhile ( (bits & 0x0010000000000000L) == 0) {\nexp--;\nbits <<= 1;\n}\n}\n\n\nif (exp == -1 || exp == 0) {\nif (x < 1.01 && x > 0.99 && hiPrec == null) {\n/* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\npolynomial expansion in higer precision. */\n\n/* Compute x - 1.0 and split it */\ndouble xa = x - 1.0;\ndouble xb = xa - x + 1.0;\ndouble tmp = xa * 1073741824.0;\ndouble aa = xa + tmp - tmp;\ndouble ab = xa - aa;\nxa = aa;\nxb = ab;\n\ndouble ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\ndouble yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n\nfor (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * 1073741824.0;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\n/* Add  a = y + lnQuickCoef */\naa = ya + LN_QUICK_COEF[i][0];\nab = yb + LN_QUICK_COEF[i][1];\n/* Split y = a */\ntmp = aa * 1073741824.0;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n}\n\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * 1073741824.0;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\nreturn ya + yb;\n}\n}\n\n// lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\ndouble lnm[] = LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n/*\ndouble epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\nepsilon -= 1.0;\n*/\n\n// y is the most significant 10 bits of the mantissa\n//double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n//double epsilon = (x - y) / y;\ndouble epsilon = (double)(bits & 0x3ffffffffffL) / (4503599627370496.0 + (bits & 0x000ffc0000000000L));\n\ndouble lnza = 0.0;\ndouble lnzb = 0.0;\n\nif (hiPrec != null) {\n/* split epsilon -> x */\ndouble tmp = epsilon * 1073741824.0;\ndouble aa = epsilon + tmp - tmp;\ndouble ab = epsilon - aa;\ndouble xa = aa;\ndouble xb = ab;\n\n/* Need a more accurate epsilon, so adjust the division. */\ndouble numer = (double)(bits & 0x3ffffffffffL);\ndouble denom = 4503599627370496.0 + (bits & 0x000ffc0000000000L);\naa = numer - xa*denom - xb * denom;\nxb += aa / denom;\n\n/* Remez polynomial evaluation */\ndouble ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\ndouble yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n\nfor (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * 1073741824.0;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\n/* Add  a = y + lnHiPrecCoef */\naa = ya + LN_HI_PREC_COEF[i][0];\nab = yb + LN_HI_PREC_COEF[i][1];\n/* Split y = a */\ntmp = aa * 1073741824.0;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n}\n\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n\n/* split, so now lnz = a */\n/*\ntmp = aa * 1073741824.0;\nlnza = aa + tmp - tmp;\nlnzb = aa - lnza + ab;\n*/\nlnza = aa + ab;\nlnzb = -(lnza - aa - ab);\n} else {\n/* High precision not required.  Eval Remez polynomial\nusing standard double precision */\nlnza = -0.16624882440418567;\nlnza = lnza * epsilon + 0.19999954120254515;\nlnza = lnza * epsilon + -0.2499999997677497;\nlnza = lnza * epsilon + 0.3333333333332802;\nlnza = lnza * epsilon + -0.5;\nlnza = lnza * epsilon + 1.0;\nlnza = lnza * epsilon;\n}\n\n/* Relative sizes:\n* lnzb     [0, 2.33E-10]\n* lnm[1]   [0, 1.17E-7]\n* ln2B*exp [0, 1.12E-4]\n* lnza      [0, 9.7E-4]\n* lnm[0]   [0, 0.692]\n* ln2A*exp [0, 709]\n*/\n\n/* Compute the following sum:\n* lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n*/\n\n//return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\ndouble a = LN_2_A*exp;\ndouble b = 0.0;\ndouble c = a+lnm[0];\ndouble d = -(c-a-lnm[0]);\na = c;\nb = b + d;\n\nc = a + lnza;\nd = -(c - a - lnza);\na = c;\nb = b + d;\n\nc = a + LN_2_B*exp;\nd = -(c - a - LN_2_B*exp);\na = c;\nb = b + d;\n\nc = a + lnm[1];\nd = -(c - a - lnm[1]);\na = c;\nb = b + d;\n\nc = a + lnzb;\nd = -(c - a - lnzb);\na = c;\nb = b + d;\n\nif (hiPrec != null) {\nhiPrec[0] = a;\nhiPrec[1] = b;\n}\n\nreturn a + b;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.distribution.AbstractDistribution:<init>()V",
            "method_body": "protected AbstractDistribution() {\nsuper();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:exp(DD[D)D",
            "method_body": "private static double exp(double x, double extra, double[] hiPrec) {\ndouble intPartA;\ndouble intPartB;\nint intVal;\n\n/* Lookup exp(floor(x)).\n* intPartA will have the upper 22 bits, intPartB will have the lower\n* 52 bits.\n*/\nif (x < 0.0) {\nintVal = (int) -x;\n\nif (intVal > 746) {\nif (hiPrec != null) {\nhiPrec[0] = 0.0;\nhiPrec[1] = 0.0;\n}\nreturn 0.0;\n}\n\nif (intVal > 709) {\n/* This will produce a subnormal output */\nfinal double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\nif (hiPrec != null) {\nhiPrec[0] /= 285040095144011776.0;\nhiPrec[1] /= 285040095144011776.0;\n}\nreturn result;\n}\n\nif (intVal == 709) {\n/* exp(1.494140625) is nearly a machine number... */\nfinal double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\nif (hiPrec != null) {\nhiPrec[0] /= 4.455505956692756620;\nhiPrec[1] /= 4.455505956692756620;\n}\nreturn result;\n}\n\nintVal++;\n\nintPartA = EXP_INT_TABLE_A[750-intVal];\nintPartB = EXP_INT_TABLE_B[750-intVal];\n\nintVal = -intVal;\n} else {\nintVal = (int) x;\n\nif (intVal > 709) {\nif (hiPrec != null) {\nhiPrec[0] = Double.POSITIVE_INFINITY;\nhiPrec[1] = 0.0;\n}\nreturn Double.POSITIVE_INFINITY;\n}\n\nintPartA = EXP_INT_TABLE_A[750+intVal];\nintPartB = EXP_INT_TABLE_B[750+intVal];\n}\n\n/* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n* x and look up the exp function of it.\n* fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n*/\nfinal int intFrac = (int) ((x - intVal) * 1024.0);\nfinal double fracPartA = EXP_FRAC_TABLE_A[intFrac];\nfinal double fracPartB = EXP_FRAC_TABLE_B[intFrac];\n\n/* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n* has a value in the range 0 <= epsilon < 2^-10.\n* Do the subtraction from x as the last step to avoid possible loss of percison.\n*/\nfinal double epsilon = x - (intVal + intFrac / 1024.0);\n\n/* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\nfull double precision (52 bits).  Since z < 2^-10, we will have\n62 bits of precision when combined with the contant 1.  This will be\nused in the last addition below to get proper rounding. */\n\n/* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\nis less than 0.5 ULP */\ndouble z = 0.04168701738764507;\nz = z * epsilon + 0.1666666505023083;\nz = z * epsilon + 0.5000000000042687;\nz = z * epsilon + 1.0;\nz = z * epsilon + -3.940510424527919E-20;\n\n/* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\nexpansion.\ntempA is exact since intPartA and intPartB only have 22 bits each.\ntempB will have 52 bits of precision.\n*/\ndouble tempA = intPartA * fracPartA;\ndouble tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n/* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\nimportant.  For accuracy add by increasing size.  tempA is exact and\nmuch larger than the others.  If there are extra bits specified from the\npow() function, use them. */\nfinal double tempC = tempB + tempA;\nfinal double result;\nif (extra != 0.0) {\nresult = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n} else {\nresult = tempC*z + tempB + tempA;\n}\n\nif (hiPrec != null) {\n// If requesting high precision\nhiPrec[0] = tempA;\nhiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n}\n\nreturn result;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.distribution.NormalDistributionImpl:<init>(DD)V",
            "method_body": "public NormalDistributionImpl(double mean, double sd){\nthis(mean, sd, DEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.special.Gamma:logGamma(D)D",
            "method_body": "public static double logGamma(double x) {\ndouble ret;\n\nif (Double.isNaN(x) || (x <= 0.0)) {\nret = Double.NaN;\n} else {\ndouble g = 607.0 / 128.0;\n\ndouble sum = 0.0;\nfor (int i = LANCZOS.length - 1; i > 0; --i) {\nsum = sum + (LANCZOS[i] / (x + i));\n}\nsum = sum + LANCZOS[0];\n\ndouble tmp = x + g + .5;\nret = ((x + .5) * FastMath.log(tmp)) - tmp +\nHALF_LOG_2_PI + FastMath.log(sum / x);\n}\n\nreturn ret;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.special.Gamma:regularizedGammaP(DDDI)D",
            "method_body": "public static double regularizedGammaP(double a,\ndouble x,\ndouble epsilon,\nint maxIterations)\nthrows MathException\n{\ndouble ret;\n\nif (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\nret = Double.NaN;\n} else if (x == 0.0) {\nret = 0.0;\n} else if (x >= a + 1) {\n// use regularizedGammaQ because it should converge faster in this\n// case.\nret = 1.0 - regularizedGammaQ(a, x, epsilon, maxIterations);\n} else {\n// calculate series\ndouble n = 0.0; // current element index\ndouble an = 1.0 / a; // n-th element in the series\ndouble sum = an; // partial sum\nwhile (FastMath.abs(an/sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) {\n// compute next element in the series\nn = n + 1.0;\nan = an * (x / (a + n));\n\n// update partial sum\nsum = sum + an;\n}\nif (n >= maxIterations) {\nthrow new MaxIterationsExceededException(maxIterations);\n} else if (Double.isInfinite(sum)) {\nret = 1.0;\n} else {\nret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * sum;\n}\n}\n\nreturn ret;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.special.Gamma$1:getB(ID)D",
            "method_body": "public static double regularizedGammaQ(final double a,\ndouble x,\ndouble epsilon,\nint maxIterations)\nthrows MathException\n{\ndouble ret;\n\nif (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\nret = Double.NaN;\n} else if (x == 0.0) {\nret = 1.0;\n} else if (x < a + 1.0) {\n// use regularizedGammaP because it should converge faster in this\n// case.\nret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n} else {\n// create continued fraction\nContinuedFraction cf = new ContinuedFraction() {\n\n@Override\nprotected double getA(int n, double x) {\nreturn ((2.0 * n) + 1.0) - a + x;\n}\n\n@Override\nprotected double getB(int n, double x) {\nreturn n * (a - n);\n}\n};\n\nret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\nret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret;\n}\n\nreturn ret;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:exp(D)D",
            "method_body": "public static double exp(double x) {\nreturn exp(x, 0.0, null);\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.special.Gamma$1:<init>(D)V",
            "method_body": "public static double regularizedGammaQ(final double a,\nif (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n} else if (x == 0.0) {\n} else if (x < a + 1.0) {\nContinuedFraction cf = new ContinuedFraction() {\nreturn ((2.0 * n) + 1.0) - a + x;\nreturn n * (a - n);\nret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\nret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret;\nreturn ret;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.special.Gamma:regularizedGammaQ(DDDI)D",
            "method_body": "public static double regularizedGammaQ(final double a,\ndouble x,\ndouble epsilon,\nint maxIterations)\nthrows MathException\n{\ndouble ret;\n\nif (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\nret = Double.NaN;\n} else if (x == 0.0) {\nret = 1.0;\n} else if (x < a + 1.0) {\n// use regularizedGammaP because it should converge faster in this\n// case.\nret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n} else {\n// create continued fraction\nContinuedFraction cf = new ContinuedFraction() {\n\n@Override\nprotected double getA(int n, double x) {\nreturn ((2.0 * n) + 1.0) - a + x;\n}\n\n@Override\nprotected double getB(int n, double x) {\nreturn n * (a - n);\n}\n};\n\nret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\nret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret;\n}\n\nreturn ret;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nreturn (a <= b) ? b : (Double.isNaN(a + b) ? Double.NaN : a);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.MathException:<init>(Lorg/apache/commons/math/exception/util/Localizable;[Ljava/lang/Object;)V",
            "method_body": "public MathException(Localizable pattern, Object ... arguments) {\nthis.pattern   = pattern;\nthis.arguments = (arguments == null) ? new Object[0] : arguments.clone();\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : x;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.util.ContinuedFraction:evaluate(DDI)D",
            "method_body": "public double evaluate(double x, double epsilon, int maxIterations)\nthrows MathException\n{\ndouble p0 = 1.0;\ndouble p1 = getA(0, x);\ndouble q0 = 0.0;\ndouble q1 = 1.0;\ndouble c = p1 / q1;\nint n = 0;\ndouble relativeError = Double.MAX_VALUE;\nwhile (n < maxIterations && relativeError > epsilon) {\n++n;\ndouble a = getA(n, x);\ndouble b = getB(n, x);\ndouble p2 = a * p1 + b * p0;\ndouble q2 = a * q1 + b * q0;\nboolean infinite = false;\nif (Double.isInfinite(p2) || Double.isInfinite(q2)) {\n/*\n* Need to scale. Try successive powers of the larger of a or b\n* up to 5th power. Throw ConvergenceException if one or both\n* of p2, q2 still overflow.\n*/\ndouble scaleFactor = 1d;\ndouble lastScaleFactor = 1d;\nfinal int maxPower = 5;\nfinal double scale = FastMath.max(a,b);\nif (scale <= 0) {  // Can't scale\nthrow new ConvergenceException(\nLocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\nx);\n}\ninfinite = true;\nfor (int i = 0; i < maxPower; i++) {\nlastScaleFactor = scaleFactor;\nscaleFactor *= scale;\nif (a != 0.0 && a > b) {\np2 = p1 / lastScaleFactor + (b / scaleFactor * p0);\nq2 = q1 / lastScaleFactor + (b / scaleFactor * q0);\n} else if (b != 0) {\np2 = (a / scaleFactor * p1) + p0 / lastScaleFactor;\nq2 = (a / scaleFactor * q1) + q0 / lastScaleFactor;\n}\ninfinite = Double.isInfinite(p2) || Double.isInfinite(q2);\nif (!infinite) {\nbreak;\n}\n}\n}\n\nif (infinite) {\n// Scaling failed\nthrow new ConvergenceException(\nLocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\nx);\n}\n\ndouble r = p2 / q2;\n\nif (Double.isNaN(r)) {\nthrow new ConvergenceException(\nLocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\nx);\n}\nrelativeError = FastMath.abs(r / c - 1.0);\n\n// prepare for next iteration\nc = p2 / q2;\np0 = p1;\np1 = p2;\nq0 = q1;\nq1 = q2;\n}\n\nif (n >= maxIterations) {\nthrow new MaxIterationsExceededException(maxIterations,\nLocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\nx);\n}\n\nreturn c;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.util.ContinuedFraction:<init>()V",
            "method_body": "protected ContinuedFraction() {\nsuper();\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math.special.Gamma$1:getA(ID)D",
            "method_body": "public static double regularizedGammaQ(final double a,\ndouble x,\ndouble epsilon,\nint maxIterations)\nthrows MathException\n{\ndouble ret;\n\nif (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\nret = Double.NaN;\n} else if (x == 0.0) {\nret = 1.0;\n} else if (x < a + 1.0) {\n// use regularizedGammaP because it should converge faster in this\n// case.\nret = 1.0 - regularizedGammaP(a, x, epsilon, maxIterations);\n} else {\n// create continued fraction\nContinuedFraction cf = new ContinuedFraction() {\n\n@Override\nprotected double getA(int n, double x) {\nreturn ((2.0 * n) + 1.0) - a + x;\n}\n\n@Override\nprotected double getB(int n, double x) {\nreturn n * (a - n);\n}\n};\n\nret = 1.0 / cf.evaluate(x, epsilon, maxIterations);\nret = FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * ret;\n}\n\nreturn ret;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.ConvergenceException:<init>(Lorg/apache/commons/math/exception/util/Localizable;[Ljava/lang/Object;)V",
            "method_body": "public ConvergenceException(Localizable pattern, Object ... arguments) {\nsuper(pattern, arguments);\n}",
            "method_id": 21
        }
    ]
}