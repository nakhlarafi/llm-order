{
    "bug_id": 6,
    "test_id": 19,
    "test_name": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest.testTrivial",
    "test_body": "public void testTrivial() {\nLinearProblem problem\n= new LinearProblem(new double[][] { { 2 } }, new double[] { 3 });\nNonLinearConjugateGradientOptimizer optimizer\n= new NonLinearConjugateGradientOptimizer(NonLinearConjugateGradientOptimizer.Formula.POLAK_RIBIERE,\nnew SimpleValueChecker(1e-6, 1e-6));\nPointValuePair optimum\n= optimizer.optimize(new MaxEval(100),\nproblem.getObjectiveFunction(),\nproblem.getObjectiveFunctionGradient(),\nGoalType.MINIMIZE,\nnew InitialGuess(new double[] { 0 }));\nAssert.assertEquals(1.5, optimum.getPoint()[0], 1.0e-10);\nAssert.assertEquals(0.0, optimum.getValue(), 1.0e-10);\n// Check that the number of iterations is updated (MATH-949).\nAssert.assertTrue(optimizer.getIterations() > 0);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizerTest.testTrivial(NonLinearConjugateGradientOptimizerTest.java:141)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleValueChecker:<init>(DD)V",
            "method_body": "public SimpleValueChecker(final double relativeThreshold,\nfinal double absoluteThreshold) {\nsuper(relativeThreshold, absoluteThreshold);\nmaxIterationCount = ITERATION_CHECK_DISABLED;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer:<init>(Lorg/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer$Formula;Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "public NonLinearConjugateGradientOptimizer(final Formula updateFormula,\nConvergenceChecker<PointValuePair> checker) {\nthis(updateFormula,\nchecker,\nnew BrentSolver(),\nnew IdentityPreconditioner());\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\n// Allow base class to register its own data.\nsuper.parseOptimizationData(optData);\n\n// The existing values (as set by the previous call) are reused if\n// not provided in the argument list.\nfor (OptimizationData data : optData) {\nif  (data instanceof BracketingStep) {\ninitialStep = ((BracketingStep) data).getBracketingStep();\n// If more data must be parsed, this statement _must_ be\n// changed to \"continue\".\nbreak;\n}\n}\n\ncheckParameters();\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:operate([D)[D",
            "method_body": "public double[] operate(final double[] v)\nthrows DimensionMismatchException {\nif (v.length != columns) {\nthrow new DimensionMismatchException(v.length, columns);\n}\nfinal double[] out = new double[rows];\n\n// perform multiplication block-wise, to ensure good cache behavior\nfor (int iBlock = 0; iBlock < blockRows; ++iBlock) {\nfinal int pStart = iBlock * BLOCK_SIZE;\nfinal int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\nfor (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\nfinal double[] block  = blocks[iBlock * blockColumns + jBlock];\nfinal int qStart = jBlock * BLOCK_SIZE;\nfinal int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\nint k = 0;\nfor (int p = pStart; p < pEnd; ++p) {\ndouble sum = 0;\nint q = qStart;\nwhile (q < qEnd - 3) {\nsum += block[k]     * v[q]     +\nblock[k + 1] * v[q + 1] +\nblock[k + 2] * v[q + 2] +\nblock[k + 3] * v[q + 3];\nk += 4;\nq += 4;\n}\nwhile (q < qEnd) {\nsum += block[k++] * v[q++];\n}\nout[p] += sum;\n}\n}\n}\n\nreturn out;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:computeObjectiveValue([D)D",
            "method_body": "protected double computeObjectiveValue(double[] params) {\nsuper.incrementEvaluationCount();\nreturn function.value(params);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:<init>(DDD)V",
            "method_body": "protected BaseAbstractUnivariateSolver(final double relativeAccuracy,\nfinal double absoluteAccuracy,\nfinal double functionValueAccuracy) {\nthis.absoluteAccuracy = absoluteAccuracy;\nthis.relativeAccuracy = relativeAccuracy;\nthis.functionValueAccuracy = functionValueAccuracy;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer:doOptimize()Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "protected PointValuePair doOptimize() {\nfinal ConvergenceChecker<PointValuePair> checker = getConvergenceChecker();\nfinal double[] point = getStartPoint();\nfinal GoalType goal = getGoalType();\nfinal int n = point.length;\ndouble[] r = computeObjectiveGradient(point);\nif (goal == GoalType.MINIMIZE) {\nfor (int i = 0; i < n; i++) {\nr[i] = -r[i];\n}\n}\n\n// Initial search direction.\ndouble[] steepestDescent = preconditioner.precondition(point, r);\ndouble[] searchDirection = steepestDescent.clone();\n\ndouble delta = 0;\nfor (int i = 0; i < n; ++i) {\ndelta += r[i] * searchDirection[i];\n}\n\nPointValuePair current = null;\nint iter = 0;\nint maxEval = getMaxEvaluations();\nwhile (true) {\n++iter;\n\nfinal double objective = computeObjectiveValue(point);\nPointValuePair previous = current;\ncurrent = new PointValuePair(point, objective);\nif (previous != null) {\nif (checker.converged(iter, previous, current)) {\n// We have found an optimum.\nreturn current;\n}\n}\n\n// Find the optimal step in the search direction.\nfinal UnivariateFunction lsf = new LineSearchFunction(point, searchDirection);\nfinal double uB = findUpperBound(lsf, 0, initialStep);\n// XXX Last parameters is set to a value close to zero in order to\n// work around the divergence problem in the \"testCircleFitting\"\n// unit test (see MATH-439).\nfinal double step = solver.solve(maxEval, lsf, 0, uB, 1e-15);\nmaxEval -= solver.getEvaluations(); // Subtract used up evaluations.\n\n// Validate new point.\nfor (int i = 0; i < point.length; ++i) {\npoint[i] += step * searchDirection[i];\n}\n\nr = computeObjectiveGradient(point);\nif (goal == GoalType.MINIMIZE) {\nfor (int i = 0; i < n; ++i) {\nr[i] = -r[i];\n}\n}\n\n// Compute beta.\nfinal double deltaOld = delta;\nfinal double[] newSteepestDescent = preconditioner.precondition(point, r);\ndelta = 0;\nfor (int i = 0; i < n; ++i) {\ndelta += r[i] * newSteepestDescent[i];\n}\n\nfinal double beta;\nswitch (updateFormula) {\ncase FLETCHER_REEVES:\nbeta = delta / deltaOld;\nbreak;\ncase POLAK_RIBIERE:\ndouble deltaMid = 0;\nfor (int i = 0; i < r.length; ++i) {\ndeltaMid += r[i] * steepestDescent[i];\n}\nbeta = (delta - deltaMid) / deltaOld;\nbreak;\ndefault:\n// Should never happen.\nthrow new MathInternalError();\n}\nsteepestDescent = newSteepestDescent;\n\n// Compute conjugate search direction.\nif (iter % n == 0 ||\nbeta < 0) {\n// Break conjugation: reset search direction.\nsearchDirection = steepestDescent.clone();\n} else {\n// Compute new conjugate search direction.\nfor (int i = 0; i < n; ++i) {\nsearchDirection[i] = steepestDescent[i] + beta * searchDirection[i];\n}\n}\n}\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer:<init>(Lorg/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer$Formula;Lorg/apache/commons/math3/optim/ConvergenceChecker;Lorg/apache/commons/math3/analysis/solvers/UnivariateSolver;Lorg/apache/commons/math3/optim/nonlinear/scalar/gradient/Preconditioner;)V",
            "method_body": "public NonLinearConjugateGradientOptimizer(final Formula updateFormula,\nConvergenceChecker<PointValuePair> checker,\nfinal UnivariateSolver lineSearchSolver,\nfinal Preconditioner preconditioner) {\nsuper(checker);\n\nthis.updateFormula = updateFormula;\nsolver = lineSearchSolver;\nthis.preconditioner = preconditioner;\ninitialStep = 1;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:toBlocksLayout([[D)[[D",
            "method_body": "public static double[][] toBlocksLayout(final double[][] rawData)\nthrows DimensionMismatchException {\nfinal int rows = rawData.length;\nfinal int columns = rawData[0].length;\nfinal int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\nfinal int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n// safety checks\nfor (int i = 0; i < rawData.length; ++i) {\nfinal int length = rawData[i].length;\nif (length != columns) {\nthrow new DimensionMismatchException(columns, length);\n}\n}\n\n// convert array\nfinal double[][] blocks = new double[blockRows * blockColumns][];\nint blockIndex = 0;\nfor (int iBlock = 0; iBlock < blockRows; ++iBlock) {\nfinal int pStart = iBlock * BLOCK_SIZE;\nfinal int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\nfinal int iHeight = pEnd - pStart;\nfor (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\nfinal int qStart = jBlock * BLOCK_SIZE;\nfinal int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\nfinal int jWidth = qEnd - qStart;\n\n// allocate new block\nfinal double[] block = new double[iHeight * jWidth];\nblocks[blockIndex] = block;\n\n// copy data\nint index = 0;\nfor (int p = pStart; p < pEnd; ++p) {\nSystem.arraycopy(rawData[p], qStart, block, index, jWidth);\nindex += jWidth;\n}\n++blockIndex;\n}\n}\n\nreturn blocks;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BrentSolver:<init>(D)V",
            "method_body": "public BrentSolver(double absoluteAccuracy) {\nsuper(absoluteAccuracy);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getMin()D",
            "method_body": "public double getMin() {\nreturn searchMin;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer$IdentityPreconditioner:precondition([D[D)[D",
            "method_body": "public double[] precondition(double[] variables, double[] r) {\nreturn r.clone();\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:<init>(II)V",
            "method_body": "protected AbstractRealMatrix(final int rowDimension,\nfinal int columnDimension)\nthrows NotStrictlyPositiveException {\nif (rowDimension < 1) {\nthrow new NotStrictlyPositiveException(rowDimension);\n}\nif (columnDimension < 1) {\nthrow new NotStrictlyPositiveException(columnDimension);\n}\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getStartValue()D",
            "method_body": "public double getStartValue() {\nreturn searchStart;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseMultivariateOptimizer(ConvergenceChecker<PAIR> checker) {\nsuper(checker);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(I)V",
            "method_body": "public Incrementor(int max) {\nthis(max,\nnew MaxCountExceededCallback() {\n/** {@inheritDoc} */\npublic void trigger(int max) throws MaxCountExceededException {\nthrow new MaxCountExceededException(max);\n}\n});\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:<init>(II)V",
            "method_body": "public BlockRealMatrix(final int rows, final int columns)\nthrows NotStrictlyPositiveException {\nsuper(rows, columns);\nthis.rows = rows;\nthis.columns = columns;\n\n// number of blocks\nblockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\nblockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\n// allocate storage blocks, taking care of smaller ones at right and bottom\nblocks = createBlocksLayout(rows, columns);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BrentSolver:<init>()V",
            "method_body": "public BrentSolver() {\nthis(DEFAULT_ABSOLUTE_ACCURACY);\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:createBlocksLayout(II)[[D",
            "method_body": "public static double[][] createBlocksLayout(final int rows, final int columns) {\nfinal int blockRows = (rows    + BLOCK_SIZE - 1) / BLOCK_SIZE;\nfinal int blockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\nfinal double[][] blocks = new double[blockRows * blockColumns][];\nint blockIndex = 0;\nfor (int iBlock = 0; iBlock < blockRows; ++iBlock) {\nfinal int pStart = iBlock * BLOCK_SIZE;\nfinal int pEnd = FastMath.min(pStart + BLOCK_SIZE, rows);\nfinal int iHeight = pEnd - pStart;\nfor (int jBlock = 0; jBlock < blockColumns; ++jBlock) {\nfinal int qStart = jBlock * BLOCK_SIZE;\nfinal int qEnd = FastMath.min(qStart + BLOCK_SIZE, columns);\nfinal int jWidth = qEnd - qStart;\nblocks[blockIndex] = new double[iHeight * jWidth];\n++blockIndex;\n}\n}\n\nreturn blocks;\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DD)Z",
            "method_body": "public static boolean equals(double x, double y) {\nreturn equals(x, y, 1);\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\n// Allow base class to register its own data.\nsuper.parseOptimizationData(optData);\n\n// The existing values (as set by the previous call) are reused if\n// not provided in the argument list.\nfor (OptimizationData data : optData) {\nif (data instanceof GoalType) {\ngoal = (GoalType) data;\ncontinue;\n}\nif (data instanceof ObjectiveFunction) {\nfunction = ((ObjectiveFunction) data).getObjectiveFunction();\ncontinue;\n}\n}\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer$LineSearchFunction:value(D)D",
            "method_body": "public double value(double x) {\n// current point in the search direction\nfinal double[] shiftedPoint = currentPoint.clone();\nfor (int i = 0; i < shiftedPoint.length; ++i) {\nshiftedPoint[i] += x * searchDirection[i];\n}\n\n// gradient of the objective function\nfinal double[] gradient = computeObjectiveGradient(shiftedPoint);\n\n// dot product with the search direction\ndouble dotProduct = 0;\nfor (int i = 0; i < gradient.length; ++i) {\ndotProduct += gradient[i] * searchDirection[i];\n}\n\nreturn dotProduct;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:setup(ILorg/apache/commons/math3/analysis/UnivariateFunction;DDD)V",
            "method_body": "protected void setup(int maxEval,\nFUNC f,\ndouble min, double max,\ndouble startValue)\nthrows NullArgumentException {\n// Checks.\nMathUtils.checkNotNull(f);\n\n// Reset.\nsearchMin = min;\nsearchMax = max;\nsearchStart = startValue;\nfunction = f;\nevaluations.setMaximalCount(maxEval);\nevaluations.resetCount();\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:<init>(II[[DZ)V",
            "method_body": "public BlockRealMatrix(final int rows, final int columns,\nfinal double[][] blockData, final boolean copyArray)\nthrows DimensionMismatchException, NotStrictlyPositiveException {\nsuper(rows, columns);\nthis.rows = rows;\nthis.columns = columns;\n\n// number of blocks\nblockRows = (rows + BLOCK_SIZE - 1) / BLOCK_SIZE;\nblockColumns = (columns + BLOCK_SIZE - 1) / BLOCK_SIZE;\n\nif (copyArray) {\n// allocate storage blocks, taking care of smaller ones at right and bottom\nblocks = new double[blockRows * blockColumns][];\n} else {\n// reference existing array\nblocks = blockData;\n}\n\nint index = 0;\nfor (int iBlock = 0; iBlock < blockRows; ++iBlock) {\nfinal int iHeight = blockHeight(iBlock);\nfor (int jBlock = 0; jBlock < blockColumns; ++jBlock, ++index) {\nif (blockData[index].length != iHeight * blockWidth(jBlock)) {\nthrow new DimensionMismatchException(blockData[index].length,\niHeight * blockWidth(jBlock));\n}\nif (copyArray) {\nblocks[index] = blockData[index].clone();\n}\n}\n}\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>()V",
            "method_body": "public Incrementor() {\nthis(0);\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getFunctionValueAccuracy()D",
            "method_body": "public double getFunctionValueAccuracy() {\nreturn functionValueAccuracy;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction:getObjectiveFunction()Lorg/apache/commons/math3/analysis/MultivariateFunction;",
            "method_body": "public MultivariateFunction getObjectiveFunction() {\nreturn function;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer:findUpperBound(Lorg/apache/commons/math3/analysis/UnivariateFunction;DD)D",
            "method_body": "private double findUpperBound(final UnivariateFunction f,\nfinal double a, final double h) {\nfinal double yA = f.value(a);\ndouble yB = yA;\nfor (double step = h; step < Double.MAX_VALUE; step *= FastMath.max(2, yA / yB)) {\nfinal double b = a + step;\nyB = f.value(b);\nif (yA * yB <= 0) {\nreturn b;\n}\n}\nthrow new MathIllegalStateException(LocalizedFormats.UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH);\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:<init>([DD)V",
            "method_body": "public PointValuePair(final double[] point,\nfinal double value) {\nthis(point, value, true);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getMaxEvaluations()I",
            "method_body": "public int getMaxEvaluations() {\nreturn evaluations.getMaximalCount();\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getStartPoint()[D",
            "method_body": "public double[] getStartPoint() {\nreturn start == null ? null : start.clone();\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:<init>(D)V",
            "method_body": "protected BaseAbstractUnivariateSolver(final double absoluteAccuracy) {\nthis(DEFAULT_RELATIVE_ACCURACY,\nabsoluteAccuracy,\nDEFAULT_FUNCTION_VALUE_ACCURACY);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getKey()Ljava/lang/Object;",
            "method_body": "public K getKey() {\nreturn key;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() throws MaxCountExceededException {\nif (++count > maximalCount) {\nmaxCountCallback.trigger(maximalCount);\n}\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:solve(ILorg/apache/commons/math3/analysis/UnivariateFunction;DDD)D",
            "method_body": "public double solve(int maxEval, FUNC f, double min, double max, double startValue)\nthrows TooManyEvaluationsException,\nNoBracketingException {\n// Initialization.\nsetup(maxEval, f, min, max, startValue);\n\n// Perform computation.\nreturn doSolve();\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:getGoalType()Lorg/apache/commons/math3/optim/nonlinear/scalar/GoalType;",
            "method_body": "public GoalType getGoalType() {\nreturn goal;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:blockWidth(I)I",
            "method_body": "private int blockWidth(final int blockColumn) {\nreturn (blockColumn == blockColumns - 1) ? columns - blockColumn * BLOCK_SIZE : BLOCK_SIZE;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:incrementEvaluationCount()V",
            "method_body": "protected void incrementEvaluationCount()\nthrows TooManyEvaluationsException {\ntry {\nevaluations.incrementCount();\n} catch (MaxCountExceededException e) {\nthrow new TooManyEvaluationsException(e.getMax());\n}\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optim/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<PAIR> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer:computeObjectiveGradient([D)[D",
            "method_body": "protected double[] computeObjectiveGradient(final double[] params) {\nreturn gradient.value(params);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max, MaxCountExceededCallback cb)\nthrows NullArgumentException {\nif (cb == null){\nthrow new NullArgumentException();\n}\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient:<init>(Lorg/apache/commons/math3/analysis/MultivariateVectorFunction;)V",
            "method_body": "public ObjectiveFunctionGradient(MultivariateVectorFunction g) {\ngradient = g;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver:<init>(D)V",
            "method_body": "protected AbstractUnivariateSolver(final double absoluteAccuracy) {\nsuper(absoluteAccuracy);\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction:<init>(Lorg/apache/commons/math3/analysis/MultivariateFunction;)V",
            "method_body": "public ObjectiveFunction(MultivariateFunction f) {\nfunction = f;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getRelativeAccuracy()D",
            "method_body": "public double getRelativeAccuracy() {\nreturn relativeAccuracy;\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getEvaluations()I",
            "method_body": "public int getEvaluations() {\nreturn evaluations.getCount();\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:incrementEvaluationCount()V",
            "method_body": "protected abstract PAIR doOptimize();\n\n/**\n* Increment the evaluation count.\n*\n* @throws TooManyEvaluationsException if the allowed evaluations\n* have been exhausted.\n*/\nprotected void incrementEvaluationCount()\nthrows TooManyEvaluationsException {\nevaluations.incrementCount();\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn columns;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:min(II)I",
            "method_body": "public static int min(final int a, final int b) {\nreturn (a <= b) ? a : b;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:<init>([DDZ)V",
            "method_body": "public PointValuePair(final double[] point,\nfinal double value,\nfinal boolean copyArray) {\nsuper(copyArray ? ((point == null) ? null :\npoint.clone()) :\npoint,\nvalue);\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getMax()D",
            "method_body": "public double getMax() {\nreturn searchMax;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getLowerBound()[D",
            "method_body": "public double[] getLowerBound() {\nreturn lowerBound == null ? null : lowerBound.clone();\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointValuePair:getPoint()[D",
            "method_body": "public double[] getPoint() {\nfinal double[] p = getKey();\nreturn p == null ? null : p.clone();\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunctionGradient:getObjectiveFunctionGradient()Lorg/apache/commons/math3/analysis/MultivariateVectorFunction;",
            "method_body": "public MultivariateVectorFunction getObjectiveFunctionGradient() {\nreturn gradient;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:getMaximalCount()I",
            "method_body": "public int getMaximalCount() {\nreturn maximalCount;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:<init>([[D)V",
            "method_body": "public BlockRealMatrix(final double[][] rawData)\nthrows DimensionMismatchException, NotStrictlyPositiveException {\nthis(rawData.length, rawData[0].length, toBlocksLayout(rawData), false);\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:getMaxEval()I",
            "method_body": "public int getMaxEval() {\nreturn maxEval;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData)\nthrows TooManyEvaluationsException,\nTooManyIterationsException {\n// Parse options.\nparseOptimizationData(optData);\n\n// Reset counters.\nevaluations.resetCount();\niterations.resetCount();\n// Perform optimization.\nreturn doOptimize();\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:getAbsoluteThreshold()D",
            "method_body": "public double getAbsoluteThreshold() {\nreturn absoluteThreshold;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair optimize(OptimizationData... optData)\nthrows TooManyEvaluationsException {\n// Set up base class and perform computation.\nreturn super.optimize(optData);\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (getLowerBound() != null ||\ngetUpperBound() != null) {\nthrow new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n}\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected GradientMultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils:verifySequence(DDD)V",
            "method_body": "public static void verifySequence(final double lower,\nfinal double initial,\nfinal double upper)\nthrows NumberIsTooLargeException {\nverifyInterval(lower, initial);\nverifyInterval(initial, upper);\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils:verifyInterval(DD)V",
            "method_body": "public static void verifyInterval(final double lower,\nfinal double upper)\nthrows NumberIsTooLargeException {\nif (lower >= upper) {\nthrow new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\nlower, upper, false);\n}\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:<init>(DD)V",
            "method_body": "public AbstractConvergenceChecker(final double relativeThreshold,\nfinal double absoluteThreshold) {\nthis.relativeThreshold = relativeThreshold;\nthis.absoluteThreshold = absoluteThreshold;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (start != null) {\nfinal int dim = start.length;\nif (lowerBound != null) {\nif (lowerBound.length != dim) {\nthrow new DimensionMismatchException(lowerBound.length, dim);\n}\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double lo = lowerBound[i];\nif (v < lo) {\nthrow new NumberIsTooSmallException(v, lo, true);\n}\n}\n}\nif (upperBound != null) {\nif (upperBound.length != dim) {\nthrow new DimensionMismatchException(upperBound.length, dim);\n}\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double hi = upperBound[i];\nif (v > hi) {\nthrow new NumberIsTooLargeException(v, hi, true);\n}\n}\n}\n}\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math3.optim.SimpleValueChecker:converged(ILorg/apache/commons/math3/optim/PointValuePair;Lorg/apache/commons/math3/optim/PointValuePair;)Z",
            "method_body": "public boolean converged(final int iteration,\nfinal PointValuePair previous,\nfinal PointValuePair current) {\nif (maxIterationCount != ITERATION_CHECK_DISABLED) {\nif (iteration >= maxIterationCount) {\nreturn true;\n}\n}\n\nfinal double p = previous.getValue();\nfinal double c = current.getValue();\nfinal double difference = FastMath.abs(p - c);\nfinal double size = FastMath.max(FastMath.abs(p), FastMath.abs(c));\nreturn difference <= size * getRelativeThreshold() ||\ndifference <= getAbsoluteThreshold();\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math3.util.Precision:equals(DDI)Z",
            "method_body": "public static boolean equals(double x, double y, int maxUlps) {\nlong xInt = Double.doubleToLongBits(x);\nlong yInt = Double.doubleToLongBits(y);\n\n// Make lexicographically ordered as a two's-complement integer.\nif (xInt < 0) {\nxInt = SGN_MASK - xInt;\n}\nif (yInt < 0) {\nyInt = SGN_MASK - yInt;\n}\n\nfinal boolean isEqual = FastMath.abs(xInt - yInt) <= maxUlps;\n\nreturn isEqual && !Double.isNaN(x) && !Double.isNaN(y);\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math3.optim.AbstractConvergenceChecker:getRelativeThreshold()D",
            "method_body": "public double getRelativeThreshold() {\nreturn relativeThreshold;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:blockHeight(I)I",
            "method_body": "private int blockHeight(final int blockRow) {\nreturn (blockRow == blockRows - 1) ? rows - blockRow * BLOCK_SIZE : BLOCK_SIZE;\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:computeObjectiveValue(D)D",
            "method_body": "protected double computeObjectiveValue(double point)\nthrows TooManyEvaluationsException {\nincrementEvaluationCount();\nreturn function.value(point);\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:getValue()Ljava/lang/Object;",
            "method_body": "public V getValue() {\nreturn value;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn rows;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair optimize(OptimizationData... optData)\nthrows TooManyEvaluationsException {\n// Set up base class and perform computation.\nreturn super.optimize(optData);\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:<init>([D)V",
            "method_body": "public InitialGuess(double[] startPoint) {\ninit = startPoint.clone();\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getUpperBound()[D",
            "method_body": "public double[] getUpperBound() {\nreturn upperBound == null ? null : upperBound.clone();\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData) {\n// Perform optimization.\nreturn super.optimize(optData);\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected MultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.GradientMultivariateOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\n// Allow base class to register its own data.\nsuper.parseOptimizationData(optData);\n\n// The existing values (as set by the previous call) are reused if\n// not provided in the argument list.\nfor (OptimizationData data : optData) {\nif  (data instanceof ObjectiveFunctionGradient) {\ngradient = ((ObjectiveFunctionGradient) data).getObjectiveFunctionGradient();\n// If more data must be parsed, this statement _must_ be\n// changed to \"continue\".\nbreak;\n}\n}\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(J)J",
            "method_body": "public static long abs(final long x) {\nreturn (x < 0l) ? -x : x;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BrentSolver:doSolve()D",
            "method_body": "protected double doSolve()\nthrows NoBracketingException,\nTooManyEvaluationsException,\nNumberIsTooLargeException {\ndouble min = getMin();\ndouble max = getMax();\nfinal double initial = getStartValue();\nfinal double functionValueAccuracy = getFunctionValueAccuracy();\n\nverifySequence(min, initial, max);\n\n// Return the initial guess if it is good enough.\ndouble yInitial = computeObjectiveValue(initial);\nif (FastMath.abs(yInitial) <= functionValueAccuracy) {\nreturn initial;\n}\n\n// Return the first endpoint if it is good enough.\ndouble yMin = computeObjectiveValue(min);\nif (FastMath.abs(yMin) <= functionValueAccuracy) {\nreturn min;\n}\n\n// Reduce interval if min and initial bracket the root.\nif (yInitial * yMin < 0) {\nreturn brent(min, initial, yMin, yInitial);\n}\n\n// Return the second endpoint if it is good enough.\ndouble yMax = computeObjectiveValue(max);\nif (FastMath.abs(yMax) <= functionValueAccuracy) {\nreturn max;\n}\n\n// Reduce interval if initial and max bracket the root.\nif (yInitial * yMax < 0) {\nreturn brent(initial, max, yInitial, yMax);\n}\n\nthrow new NoBracketingException(min, max, yMin, yMax);\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:getInitialGuess()[D",
            "method_body": "public double[] getInitialGuess() {\nreturn init.clone();\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BrentSolver:brent(DDDD)D",
            "method_body": "private double brent(double lo, double hi,\ndouble fLo, double fHi) {\ndouble a = lo;\ndouble fa = fLo;\ndouble b = hi;\ndouble fb = fHi;\ndouble c = a;\ndouble fc = fa;\ndouble d = b - a;\ndouble e = d;\n\nfinal double t = getAbsoluteAccuracy();\nfinal double eps = getRelativeAccuracy();\n\nwhile (true) {\nif (FastMath.abs(fc) < FastMath.abs(fb)) {\na = b;\nb = c;\nc = a;\nfa = fb;\nfb = fc;\nfc = fa;\n}\n\nfinal double tol = 2 * eps * FastMath.abs(b) + t;\nfinal double m = 0.5 * (c - b);\n\nif (FastMath.abs(m) <= tol ||\nPrecision.equals(fb, 0))  {\nreturn b;\n}\nif (FastMath.abs(e) < tol ||\nFastMath.abs(fa) <= FastMath.abs(fb)) {\n// Force bisection.\nd = m;\ne = d;\n} else {\ndouble s = fb / fa;\ndouble p;\ndouble q;\n// The equality test (a == c) is intentional,\n// it is part of the original Brent's method and\n// it should NOT be replaced by proximity test.\nif (a == c) {\n// Linear interpolation.\np = 2 * m * s;\nq = 1 - s;\n} else {\n// Inverse quadratic interpolation.\nq = fa / fc;\nfinal double r = fb / fc;\np = s * (2 * m * q * (q - r) - (b - a) * (r - 1));\nq = (q - 1) * (r - 1) * (s - 1);\n}\nif (p > 0) {\nq = -q;\n} else {\np = -p;\n}\ns = e;\ne = d;\nif (p >= 1.5 * m * q - FastMath.abs(tol * q) ||\np >= FastMath.abs(0.5 * s * q)) {\n// Inverse quadratic interpolation gives a value\n// in the wrong direction, or progress is slow.\n// Fall back to bisection.\nd = m;\ne = d;\n} else {\nd = p / q;\n}\n}\na = b;\nfa = fb;\n\nif (FastMath.abs(d) > tol) {\nb += d;\n} else if (m > 0) {\nb += tol;\n} else {\nb -= tol;\n}\nfb = computeObjectiveValue(b);\nif ((fb > 0 && fc > 0) ||\n(fb <= 0 && fc <= 0)) {\nc = a;\nfc = fa;\nd = b - a;\ne = d;\n}\n}\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\nthis.checker = checker;\n\nevaluations = new Incrementor(0, new MaxEvalCallback());\niterations = new Incrementor(0, new MaxIterCallback());\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\n}\nif (a < b) {\nreturn b;\n}\n/* if either arg is NaN, return NaN */\nif (a != b) {\nreturn Double.NaN;\n}\n/* min(+0.0,-0.0) == -0.0 */\n/* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn b;\n}\nreturn a;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointValuePair;",
            "method_body": "public PointValuePair optimize(OptimizationData... optData)\nthrows TooManyEvaluationsException {\n// Set up base class and perform computation.\nreturn super.optimize(optData);\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:<init>(I)V",
            "method_body": "public MaxEval(int max) {\nif (max <= 0) {\nthrow new NotStrictlyPositiveException(max);\n}\n\nmaxEval = max;\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.apache.commons.math3.linear.BlockRealMatrix:transpose()Lorg/apache/commons/math3/linear/BlockRealMatrix;",
            "method_body": "public BlockRealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal BlockRealMatrix out = new BlockRealMatrix(nCols, nRows);\n\n// perform transpose block-wise, to ensure good cache behavior\nint blockIndex = 0;\nfor (int iBlock = 0; iBlock < blockColumns; ++iBlock) {\nfor (int jBlock = 0; jBlock < blockRows; ++jBlock) {\n// transpose current block\nfinal double[] outBlock = out.blocks[blockIndex];\nfinal double[] tBlock = blocks[jBlock * blockColumns + iBlock];\nfinal int pStart = iBlock * BLOCK_SIZE;\nfinal int pEnd = FastMath.min(pStart + BLOCK_SIZE, columns);\nfinal int qStart = jBlock * BLOCK_SIZE;\nfinal int qEnd = FastMath.min(qStart + BLOCK_SIZE, rows);\nint k = 0;\nfor (int p = pStart; p < pEnd; ++p) {\nfinal int lInc = pEnd - pStart;\nint l = p - pStart;\nfor (int q = qStart; q < qEnd; ++q) {\noutBlock[k] = tBlock[l];\n++k;\nl+= lInc;\n}\n}\n// go to next block\n++blockIndex;\n}\n}\n\nreturn out;\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getIterations()I",
            "method_body": "public int getIterations() {\nreturn iterations.getCount();\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:getCount()I",
            "method_body": "public int getCount() {\nreturn count;\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:verifySequence(DDD)V",
            "method_body": "protected void verifySequence(final double lower,\nfinal double initial,\nfinal double upper)\nthrows NumberIsTooLargeException {\nUnivariateSolverUtils.verifySequence(lower, initial, upper);\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\n// The existing values (as set by the previous call) are reused if\n// not provided in the argument list.\nfor (OptimizationData data : optData) {\nif (data instanceof MaxEval) {\nevaluations.setMaximalCount(((MaxEval) data).getMaxEval());\ncontinue;\n}\nif (data instanceof MaxIter) {\niterations.setMaximalCount(((MaxIter) data).getMaxIter());\ncontinue;\n}\n}\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.scalar.gradient.NonLinearConjugateGradientOptimizer$LineSearchFunction:<init>(Lorg/apache/commons/math3/optim/nonlinear/scalar/gradient/NonLinearConjugateGradientOptimizer;[D[D)V",
            "method_body": "public LineSearchFunction(double[] point,\ndouble[] direction) {\ncurrentPoint = point.clone();\nsearchDirection = direction.clone();\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
            "method_body": "public Pair(K k, V v) {\nkey = k;\nvalue = v;\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getAbsoluteAccuracy()D",
            "method_body": "public double getAbsoluteAccuracy() {\nreturn absoluteAccuracy;\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathUtils:checkNotNull(Ljava/lang/Object;)V",
            "method_body": "public static void checkNotNull(Object o)\nthrows NullArgumentException {\nif (o == null) {\nthrow new NullArgumentException();\n}\n}",
            "method_id": 98
        }
    ]
}