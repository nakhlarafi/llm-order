{
    "bug_id": 19,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testBoundaryRangeTooLarge",
    "test_body": "public void testBoundaryRangeTooLarge() {\nfinal CMAESOptimizer optimizer = new CMAESOptimizer();\nfinal MultivariateFunction fitnessFunction = new MultivariateFunction() {\npublic double value(double[] parameters) {\nif (Double.isNaN(parameters[0])) {\nthrow new MathIllegalStateException();\n}\nfinal double target = 1;\nfinal double error = target - parameters[0];\nreturn error * error;\n}\n};\nfinal double[] start = { 0 };\n// The difference between upper and lower bounds is used to used\n// normalize the variables: In case of overflow, NaN is produced.\nfinal double max = Double.MAX_VALUE / 2;\nfinal double tooLarge = FastMath.nextUp(max);\nfinal double[] lower = { -tooLarge };\nfinal double[] upper = { tooLarge };\nfinal double[] result = optimizer.optimize(10000, fitnessFunction, GoalType.MINIMIZE,\nstart, lower, upper).getPoint();\n}\n",
    "stack_trace": "java.lang.Exception: Unexpected exception, expected<org.apache.commons.math3.exception.NumberIsTooLargeException> but was<org.apache.commons.math3.exception.MathIllegalStateException>\nat org.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:28)\nat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\nat junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:38)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\nat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\nat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\nat org.apache.tools.ant.Task.perform(Task.java:348)\nat org.apache.tools.ant.Target.execute(Target.java:392)\nat org.apache.tools.ant.Target.performTasks(Target.java:413)\nat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\nat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\nat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\nat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\nat org.apache.tools.ant.Main.runBuild(Main.java:811)\nat org.apache.tools.ant.Main.startAnt(Main.java:217)\nat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\nat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)\nCaused by: org.apache.commons.math3.exception.MathIllegalStateException: illegal state\nat org.apache.commons.math3.optimization.direct.CMAESOptimizerTest$2.value(CMAESOptimizerTest.java:414)\nat org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.computeObjectiveValue(BaseAbstractMultivariateOptimizer.java:99)\nat org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction.value(CMAESOptimizer.java:958)\nat org.apache.commons.math3.optimization.direct.CMAESOptimizer.doOptimize(CMAESOptimizer.java:365)\nat org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.optimizeInternal(BaseAbstractMultivariateOptimizer.java:148)\nat org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer.optimize(BaseAbstractMultivariateOptimizer.java:105)\nat org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.optimize(BaseAbstractMultivariateSimpleBoundsOptimizer.java:140)\nat org.apache.commons.math3.optimization.direct.CMAESOptimizerTest.testBoundaryRangeTooLarge(CMAESOptimizerTest.java:430)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension,\nfinal int columnDimension)\nthrows NotStrictlyPositiveException {\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:nextUp(D)D",
            "method_body": "public static double nextUp(final double a) {\nreturn nextAfter(a, Double.POSITIVE_INFINITY);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:<init>(I[DIDZIILorg/apache/commons/math3/random/RandomGenerator;Z)V",
            "method_body": "public CMAESOptimizer(int lambda, double[] inputSigma,\nint maxIterations, double stopFitness,\nboolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\nRandomGenerator random, boolean generateStatistics) {\nthis(lambda, inputSigma, maxIterations, stopFitness, isActiveCMA,\ndiagonalOnly, checkFeasableCount, random, generateStatistics,\nnew SimpleValueChecker());\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:sequence(DDD)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix sequence(double start, double end, double step) {\nint size = (int) ((end - start) / step + 1);\ndouble[][] d = new double[size][1];\ndouble value = start;\nfor (int r = 0; r < size; r++) {\nd[r][0] = value;\nvalue += step;\n}\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer:getGoalType()Lorg/apache/commons/math3/optimization/GoalType;",
            "method_body": "public GoalType getGoalType() {\nreturn goal;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkMatrixIndex(Lorg/apache/commons/math3/linear/AnyMatrix;II)V",
            "method_body": "public static void checkMatrixIndex(final AnyMatrix m,\nfinal int row, final int column)\nthrows OutOfRangeException {\ncheckRowIndex(m, row);\ncheckColumnIndex(m, column);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:end()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n\n/** Sum of squared entries. */\nprivate double sum;\n\n/** {@inheritDoc} */\npublic void start(final int rows, final int columns,\nfinal int startRow, final int endRow,\nfinal int startColumn, final int endColumn) {\nsum = 0;\n}\n\n/** {@inheritDoc} */\npublic void visit(final int row, final int column, final double value) {\nsum += value * value;\n}\n\n/** {@inheritDoc} */\npublic double end() {\nreturn FastMath.sqrt(sum);\n}\n});\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:walkInOptimizedOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor) {\nreturn walkInRowOrder(visitor);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:optimize(ILorg/apache/commons/math3/analysis/MultivariateFunction;Lorg/apache/commons/math3/optimization/GoalType;[D[D[D)Lorg/apache/commons/math3/optimization/PointValuePair;",
            "method_body": "public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\ndouble[] startPoint,\ndouble[] lower, double[] upper) {\n// Checks.\nfinal int dim = startPoint.length;\nif (lower != null) {\nif (lower.length != dim) {\nthrow new DimensionMismatchException(lower.length, dim);\n}\nfor (int i = 0; i < dim; i++) {\nfinal double v = startPoint[i];\nfinal double lo = lower[i];\nif (v < lo) {\nthrow new NumberIsTooSmallException(v, lo, true);\n}\n}\n}\nif (upper != null) {\nif (upper.length != dim) {\nthrow new DimensionMismatchException(upper.length, dim);\n}\nfor (int i = 0; i < dim; i++) {\nfinal double v = startPoint[i];\nfinal double hi = upper[i];\nif (v > hi) {\nthrow new NumberIsTooLargeException(v, hi, true);\n}\n}\n}\n\n// Initialization.\nif (lower == null) {\nlowerBound = new double[dim];\nfor (int i = 0; i < dim; i++) {\nlowerBound[i] = Double.NEGATIVE_INFINITY;\n}\n} else {\nlowerBound = lower.clone();\n}\nif (upper == null) {\nupperBound = new double[dim];\nfor (int i = 0; i < dim; i++) {\nupperBound[i] = Double.POSITIVE_INFINITY;\n}\n} else {\nupperBound = upper.clone();\n}\n\n// Base class method performs the non bound-specific initializations.\nreturn super.optimize(maxEval, f, goalType, startPoint);\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createColumnRealMatrix([D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createColumnRealMatrix(double[] columnData)\nthrows NoDataException, NullArgumentException {\nif (columnData == null) {\nthrow new NullArgumentException();\n}\nfinal int nRows = columnData.length;\nfinal RealMatrix m = createRealMatrix(nRows, 1);\nfor (int i = 0; i < nRows; ++i) {\nm.setEntry(i, 0, columnData[i]);\n}\nreturn m;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nfinal double[] init = getStartPoint();\nfinal double[] lB = getLowerBound();\nfinal double[] uB = getUpperBound();\n\n// Checks whether there is at least one finite bound value.\nboolean hasFiniteBounds = false;\nfor (int i = 0; i < lB.length; i++) {\nif (!Double.isInfinite(lB[i]) ||\n!Double.isInfinite(uB[i])) {\nhasFiniteBounds = true;\nbreak;\n}\n}\n// Checks whether there is at least one infinite bound value.\nboolean hasInfiniteBounds = false;\nif (hasFiniteBounds) {\nfor (int i = 0; i < lB.length; i++) {\nif (Double.isInfinite(lB[i]) ||\nDouble.isInfinite(uB[i])) {\nhasInfiniteBounds = true;\nbreak;\n}\n}\n\nif (hasInfiniteBounds) {\n// If there is at least one finite bound, none can be infinite,\n// because mixed cases are not supported by the current code.\nthrow new MathUnsupportedOperationException();\n} else {\n// Convert API to internal handling of boundaries.\nboundaries = new double[2][];\nboundaries[0] = lB;\nboundaries[1] = uB;\n\n// Abort early if the normalization will overflow (cf. \"encode\" method).\n}\n} else {\n// Convert API to internal handling of boundaries.\nboundaries = null;\n}\n\nif (inputSigma != null) {\nif (inputSigma.length != init.length) {\nthrow new DimensionMismatchException(inputSigma.length, init.length);\n}\nfor (int i = 0; i < init.length; i++) {\nif (inputSigma[i] < 0) {\nthrow new NotPositiveException(inputSigma[i]);\n}\nif (boundaries != null) {\nif (inputSigma[i] > boundaries[1][i] - boundaries[0][i]) {\nthrow new OutOfRangeException(inputSigma[i], 0, boundaries[1][i] - boundaries[0][i]);\n}\n}\n}\n}\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:<init>(Lorg/apache/commons/math3/optimization/ConvergenceChecker;)V",
            "method_body": "protected BaseAbstractMultivariateSimpleBoundsOptimizer(ConvergenceChecker<PointValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer:<init>(Lorg/apache/commons/math3/optimization/ConvergenceChecker;)V",
            "method_body": "protected BaseAbstractMultivariateOptimizer(ConvergenceChecker<PointValuePair> checker) {\nthis.checker = checker;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createRealMatrix(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealMatrix(final int rows, final int columns) {\nreturn (rows * columns <= 4096) ?\nnew Array2DRowRealMatrix(rows, columns) : new BlockRealMatrix(rows, columns);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:scalarMultiply(D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix scalarMultiply(final double d) {\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) * d);\n}\n}\n\nreturn out;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer:optimize(ILorg/apache/commons/math3/analysis/MultivariateFunction;Lorg/apache/commons/math3/optimization/GoalType;[D)Lorg/apache/commons/math3/optimization/PointValuePair;",
            "method_body": "public PointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\ndouble[] startPoint) {\nreturn optimizeInternal(maxEval, f, goalType, startPoint);\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:nextAfter(DD)D",
            "method_body": "public static double nextAfter(double d, double direction) {\n\n// handling of some important special cases\nif (Double.isNaN(d) || Double.isNaN(direction)) {\nreturn Double.NaN;\n} else if (d == direction) {\nreturn direction;\n} else if (Double.isInfinite(d)) {\nreturn (d < 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n} else if (d == 0) {\nreturn (direction < 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n}\n// special cases MAX_VALUE to infinity and  MIN_VALUE to 0\n// are handled just as normal numbers\n\nfinal long bits = Double.doubleToLongBits(d);\nfinal long sign = bits & 0x8000000000000000L;\nif ((direction < d) ^ (sign == 0L)) {\nreturn Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) + 1));\n} else {\nreturn Double.longBitsToDouble(sign | ((bits & 0x7fffffffffffffffL) - 1));\n}\n\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.AbstractConvergenceChecker:<init>()V",
            "method_body": "public AbstractConvergenceChecker() {\nthis.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\nthis.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer:getMaxEvaluations()I",
            "method_body": "public int getMaxEvaluations() {\nreturn evaluations.getMaximalCount();\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:<init>(Lorg/apache/commons/math3/linear/AbstractRealMatrix;)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\nsum = 0;\n}\nsum += value * value;\n}\nreturn FastMath.sqrt(sum);\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.exception.util.ExceptionContext:<init>(Ljava/lang/Throwable;)V",
            "method_body": "public ExceptionContext(final Throwable throwable) {\nthis.throwable = throwable;\nmsgPatterns    = new ArrayList<Localizable>();\nmsgArguments   = new ArrayList<Object[]>();\ncontext        = new HashMap<String, Object>();\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:multiply(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix multiply(final RealMatrix m)\nthrows DimensionMismatchException {\nMatrixUtils.checkMultiplicationCompatible(this, m);\n\nfinal int nRows = getRowDimension();\nfinal int nCols = m.getColumnDimension();\nfinal int nSum  = getColumnDimension();\nfinal RealMatrix out = createMatrix(nRows, nCols);\nfor (int row = 0; row < nRows; ++row) {\nfor (int col = 0; col < nCols; ++col) {\ndouble sum = 0;\nfor (int i = 0; i < nSum; ++i) {\nsum += getEntry(row, i) * m.getEntry(i, col);\n}\nout.setEntry(row, col, sum);\n}\n}\n\nreturn out;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:transpose()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n/** {@inheritDoc} */\n@Override\npublic void visit(final int row, final int column, final double value) {\nout.setEntry(column, row, value);\n}\n\n});\n\nreturn out;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction:<init>(Lorg/apache/commons/math3/optimization/direct/CMAESOptimizer;)V",
            "method_body": "public FitnessFunction() {\nvalueRange = 1.0;\nisRepairMode = true;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$5:<init>(Lorg/apache/commons/math3/linear/AbstractRealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\nout.setEntry(column, row, value);\n}\nreturn out;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer:getStartPoint()[D",
            "method_body": "public double[] getStartPoint() {\nreturn start.clone();\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkMultiplicationCompatible(Lorg/apache/commons/math3/linear/AnyMatrix;Lorg/apache/commons/math3/linear/AnyMatrix;)V",
            "method_body": "public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\nthrows DimensionMismatchException {\n\nif (left.getColumnDimension() != right.getRowDimension()) {\nthrow new DimensionMismatchException(left.getColumnDimension(),\nright.getRowDimension());\n}\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:getLowerBound()[D",
            "method_body": "public double[] getLowerBound() {\nreturn lowerBound.clone();\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:max(Lorg/apache/commons/math3/linear/RealMatrix;)D",
            "method_body": "private static double max(final RealMatrix m) {\ndouble max = -Double.MAX_VALUE;\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble e = m.getEntry(r, c);\nif (max < e) {\nmax = e;\n}\n}\n}\nreturn max;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer:computeObjectiveValue([D)D",
            "method_body": "protected double computeObjectiveValue(double[] point) {\ntry {\nevaluations.incrementCount();\n} catch (MaxCountExceededException e) {\nthrow new TooManyEvaluationsException(e.getMax());\n}\nreturn function.value(point);\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateOptimizer:optimizeInternal(ILorg/apache/commons/math3/analysis/MultivariateFunction;Lorg/apache/commons/math3/optimization/GoalType;[D)Lorg/apache/commons/math3/optimization/PointValuePair;",
            "method_body": "protected PointValuePair optimizeInternal(int maxEval, MultivariateFunction f, GoalType goalType,\ndouble[] startPoint) {\n// Checks.\nif (f == null) {\nthrow new NullArgumentException();\n}\nif (goalType == null) {\nthrow new NullArgumentException();\n}\nif (startPoint == null) {\nthrow new NullArgumentException();\n}\n\n// Reset.\nevaluations.setMaximalCount(maxEval);\nevaluations.resetCount();\n\n// Store optimization problem characteristics.\nfunction = f;\ngoal = goalType;\nstart = startPoint.clone();\n\n// Perform computation.\nreturn doOptimize();\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:repmat(Lorg/apache/commons/math3/linear/RealMatrix;II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix repmat(final RealMatrix mat, int n, int m) {\nint rd = mat.getRowDimension();\nint cd = mat.getColumnDimension();\ndouble[][] d = new double[n * rd][m * cd];\nfor (int r = 0; r < n * rd; r++) {\nfor (int c = 0; c < m * cd; c++) {\nd[r][c] = mat.getEntry(r % rd, c % cd);\n}\n}\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:getUpperBound()[D",
            "method_body": "public double[] getUpperBound() {\nreturn upperBound.clone();\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkColumnIndex(Lorg/apache/commons/math3/linear/AnyMatrix;I)V",
            "method_body": "public static void checkColumnIndex(final AnyMatrix m, final int column)\nthrows OutOfRangeException {\nif (column < 0 || column >= m.getColumnDimension()) {\nthrow new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\ncolumn, 0, m.getColumnDimension() - 1);\n}\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn (data == null) ? 0 : data.length;\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:getMaximalCount()I",
            "method_body": "public int getMaximalCount() {\nreturn maximalCount;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$5:visit(IID)V",
            "method_body": "public RealMatrix transpose() {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nfinal RealMatrix out = createMatrix(nCols, nRows);\nwalkInOptimizedOrder(new DefaultRealMatrixPreservingVisitor() {\n\n/** {@inheritDoc} */\n@Override\npublic void visit(final int row, final int column, final double value) {\nout.setEntry(column, row, value);\n}\n\n});\n\nreturn out;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:walkInRowOrder(Lorg/apache/commons/math3/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInRowOrder(final RealMatrixPreservingVisitor visitor) {\nfinal int rows    = getRowDimension();\nfinal int columns = getColumnDimension();\nvisitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\nfor (int i = 0; i < rows; ++i) {\nfinal double[] rowI = data[i];\nfor (int j = 0; j < columns; ++j) {\nvisitor.visit(i, j, rowI[j]);\n}\n}\nreturn visitor.end();\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:getFrobeniusNorm()D",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n\n/** Sum of squared entries. */\nprivate double sum;\n\n/** {@inheritDoc} */\npublic void start(final int rows, final int columns,\nfinal int startRow, final int endRow,\nfinal int startColumn, final int endColumn) {\nsum = 0;\n}\n\n/** {@inheritDoc} */\npublic void visit(final int row, final int column, final double value) {\nsum += value * value;\n}\n\n/** {@inheritDoc} */\npublic double end() {\nreturn FastMath.sqrt(sum);\n}\n});\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.exception.MathIllegalStateException:<init>()V",
            "method_body": "public MathIllegalStateException() {\nthis(LocalizedFormats.ILLEGAL_STATE);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkRowIndex(Lorg/apache/commons/math3/linear/AnyMatrix;I)V",
            "method_body": "public static void checkRowIndex(final AnyMatrix m, final int row)\nthrows OutOfRangeException {\nif (row < 0 ||\nrow >= m.getRowDimension()) {\nthrow new OutOfRangeException(LocalizedFormats.ROW_INDEX,\nrow, 0, m.getRowDimension() - 1);\n}\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:diag(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix diag(final RealMatrix m) {\nif (m.getColumnDimension() == 1) {\ndouble[][] d = new double[m.getRowDimension()][m.getRowDimension()];\nfor (int i = 0; i < m.getRowDimension(); i++) {\nd[i][i] = m.getEntry(i, 0);\n}\nreturn new Array2DRowRealMatrix(d, false);\n} else {\ndouble[][] d = new double[m.getRowDimension()][1];\nfor (int i = 0; i < m.getColumnDimension(); i++) {\nd[i][0] = m.getEntry(i, i);\n}\nreturn new Array2DRowRealMatrix(d, false);\n}\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:scalarAdd(D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix scalarAdd(final double d) {\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) + d);\n}\n}\n\nreturn out;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.exception.util.ExceptionContext:addMessage(Lorg/apache/commons/math3/exception/util/Localizable;[Ljava/lang/Object;)V",
            "method_body": "public void addMessage(Localizable pattern,\nObject ... arguments) {\nmsgPatterns.add(pattern);\nmsgArguments.add(ArgUtils.flatten(arguments));\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:<init>(I)V",
            "method_body": "public CMAESOptimizer(int lambda) {\nthis(lambda, null, DEFAULT_MAXITERATIONS, DEFAULT_STOPFITNESS,\nDEFAULT_ISACTIVECMA, DEFAULT_DIAGONALONLY,\nDEFAULT_CHECKFEASABLECOUNT, DEFAULT_RANDOMGENERATOR, false);\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max,\nMaxCountExceededCallback cb) {\nif (cb == null){\nthrow new NullArgumentException();\n}\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction:repair([D)[D",
            "method_body": "private double[] repair(final double[] x) {\ndouble[] repaired = new double[x.length];\nfor (int i = 0; i < x.length; i++) {\nif (x[i] < 0) {\nrepaired[i] = 0;\n} else if (x[i] > 1.0) {\nrepaired[i] = 1.0;\n} else {\nrepaired[i] = x[i];\n}\n}\nreturn repaired;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:<init>(II)V",
            "method_body": "protected AbstractRealMatrix(final int rowDimension,\nfinal int columnDimension)\nthrows NotStrictlyPositiveException {\nif (rowDimension < 1) {\nthrow new NotStrictlyPositiveException(rowDimension);\n}\nif (columnDimension < 1) {\nthrow new NotStrictlyPositiveException(columnDimension);\n}\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:ones(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix ones(int n, int m) {\ndouble[][] d = new double[n][m];\nfor (int r = 0; r < n; r++) {\nArrays.fill(d[r], 1.0);\n}\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>([[DZ)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\nthrows DimensionMismatchException, NoDataException,\nNullArgumentException {\nif (copyArray) {\ncopyIn(d);\n} else {\nif (d == null) {\nthrow new NullArgumentException();\n}\nfinal int nRows = d.length;\nif (nRows == 0) {\nthrow new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n}\nfinal int nCols = d[0].length;\nif (nCols == 0) {\nthrow new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n}\nfor (int r = 1; r < nRows; r++) {\nif (d[r].length != nCols) {\nthrow new DimensionMismatchException(d[r].length, nCols);\n}\n}\ndata = d;\n}\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>()V",
            "method_body": "public Incrementor() {\nthis(0);\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:times(Lorg/apache/commons/math3/linear/RealMatrix;Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix times(final RealMatrix m, final RealMatrix n) {\ndouble[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\nd[r][c] = m.getEntry(r, c) * n.getEntry(r, c);\n}\n}\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.exception.MathIllegalStateException:<init>(Lorg/apache/commons/math3/exception/util/Localizable;[Ljava/lang/Object;)V",
            "method_body": "public MathIllegalStateException(Localizable pattern,\nObject ... args) {\ncontext = new ExceptionContext(this);\ncontext.addMessage(pattern, args);\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:initializeCMA([D)V",
            "method_body": "private void initializeCMA(double[] guess) {\nif (lambda <= 0) {\nlambda = 4 + (int) (3. * Math.log(dimension));\n}\n// initialize sigma\ndouble[][] sigmaArray = new double[guess.length][1];\nfor (int i = 0; i < guess.length; i++) {\nfinal double range =  (boundaries == null) ? 1.0 : boundaries[1][i] - boundaries[0][i];\nsigmaArray[i][0]   = ((inputSigma == null) ? 0.3 : inputSigma[i]) / range;\n}\nRealMatrix insigma = new Array2DRowRealMatrix(sigmaArray, false);\nsigma = max(insigma); // overall standard deviation\n\n// initialize termination criteria\nstopTolUpX = 1e3 * max(insigma);\nstopTolX = 1e-11 * max(insigma);\nstopTolFun = 1e-12;\nstopTolHistFun = 1e-13;\n\n// initialize selection strategy parameters\nmu = lambda / 2; // number of parents/points for recombination\nlogMu2 = Math.log(mu + 0.5);\nweights = log(sequence(1, mu, 1)).scalarMultiply(-1.).scalarAdd(logMu2);\ndouble sumw = 0;\ndouble sumwq = 0;\nfor (int i = 0; i < mu; i++) {\ndouble w = weights.getEntry(i, 0);\nsumw += w;\nsumwq += w * w;\n}\nweights = weights.scalarMultiply(1. / sumw);\nmueff = sumw * sumw / sumwq; // variance-effectiveness of sum w_i x_i\n\n// initialize dynamic strategy parameters and constants\ncc = (4. + mueff / dimension) /\n(dimension + 4. + 2. * mueff / dimension);\ncs = (mueff + 2.) / (dimension + mueff + 3.);\ndamps = (1. + 2. * Math.max(0, Math.sqrt((mueff - 1.) /\n(dimension + 1.)) - 1.)) *\nMath.max(0.3, 1. - dimension /\n(1e-6 + Math.min(maxIterations, getMaxEvaluations() /\nlambda))) + cs; // minor increment\nccov1 = 2. / ((dimension + 1.3) * (dimension + 1.3) + mueff);\nccovmu = Math.min(1 - ccov1, 2. * (mueff - 2. + 1. / mueff) /\n((dimension + 2.) * (dimension + 2.) + mueff));\nccov1Sep = Math.min(1, ccov1 * (dimension + 1.5) / 3.);\nccovmuSep = Math.min(1 - ccov1, ccovmu * (dimension + 1.5) / 3.);\nchiN = Math.sqrt(dimension) *\n(1. - 1. / (4. * dimension) + 1 / (21. * dimension * dimension));\n// intialize CMA internal values - updated each generation\nxmean = MatrixUtils.createColumnRealMatrix(guess); // objective\n// variables\ndiagD = insigma.scalarMultiply(1. / sigma);\ndiagC = square(diagD);\npc = zeros(dimension, 1); // evolution paths for C and sigma\nps = zeros(dimension, 1); // B defines the coordinate system\nnormps = ps.getFrobeniusNorm();\n\nB = eye(dimension, dimension);\nD = ones(dimension, 1); // diagonal D defines the scaling\nBD = times(B, repmat(diagD.transpose(), dimension, 1));\nC = B.multiply(diag(square(D)).multiply(B.transpose())); // covariance\nhistorySize = 10 + (int) (3. * 10. * dimension / lambda);\nfitnessHistory = new double[historySize]; // history of fitness values\nfor (int i = 0; i < historySize; i++) {\nfitnessHistory[i] = Double.MAX_VALUE;\n}\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:setEntry(IID)V",
            "method_body": "public void setEntry(final int row, final int column, final double value)\nthrows OutOfRangeException {\nMatrixUtils.checkMatrixIndex(this, row, column);\ndata[row][column] = value;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:zeros(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix zeros(int n, int m) {\nreturn new Array2DRowRealMatrix(n, m);\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:square(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix square(final RealMatrix m) {\ndouble[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\ndouble e = m.getEntry(r, c);\nd[r][c] = e * e;\n}\n}\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(I)V",
            "method_body": "public Incrementor(int max) {\nthis(max,\nnew MaxCountExceededCallback() {\n/** {@inheritDoc} */\npublic void trigger(int max) {\nthrow new MaxCountExceededException(max);\n}\n});\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:<init>(I[DIDZIILorg/apache/commons/math3/random/RandomGenerator;ZLorg/apache/commons/math3/optimization/ConvergenceChecker;)V",
            "method_body": "public CMAESOptimizer(int lambda, double[] inputSigma,\nint maxIterations, double stopFitness,\nboolean isActiveCMA, int diagonalOnly, int checkFeasableCount,\nRandomGenerator random, boolean generateStatistics,\nConvergenceChecker<PointValuePair> checker) {\nsuper(checker);\nthis.lambda = lambda;\nthis.inputSigma = inputSigma == null ? null : (double[]) inputSigma.clone();\nthis.maxIterations = maxIterations;\nthis.stopFitness = stopFitness;\nthis.isActiveCMA = isActiveCMA;\nthis.diagonalOnly = diagonalOnly;\nthis.checkFeasableCount = checkFeasableCount;\nthis.random = random;\nthis.generateStatistics = generateStatistics;\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math3.exception.util.ArgUtils:flatten([Ljava/lang/Object;)[Ljava/lang/Object;",
            "method_body": "public static Object[] flatten(Object[] array) {\nfinal List<Object> list = new ArrayList<Object>();\nif (array != null) {\nfor (Object o : array) {\nif (o instanceof Object[]) {\nfor (Object oR : flatten((Object[]) o)) {\nlist.add(oR);\n}\n} else {\nlist.add(o);\n}\n}\n}\nreturn list.toArray();\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:log(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix log(final RealMatrix m) {\ndouble[][] d = new double[m.getRowDimension()][m.getColumnDimension()];\nfor (int r = 0; r < m.getRowDimension(); r++) {\nfor (int c = 0; c < m.getColumnDimension(); c++) {\nd[r][c] = Math.log(m.getEntry(r, c));\n}\n}\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DefaultRealMatrixPreservingVisitor:end()D",
            "method_body": "public double end() {\nreturn 0;\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:eye(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private static RealMatrix eye(int n, int m) {\ndouble[][] d = new double[n][m];\nfor (int r = 0; r < n; r++) {\nif (r < m) {\nd[r][r] = 1;\n}\n}\nreturn new Array2DRowRealMatrix(d, false);\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column)\nthrows OutOfRangeException {\nMatrixUtils.checkMatrixIndex(this, row, column);\nreturn data[row][column];\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction:encode([D)[D",
            "method_body": "public double[] encode(final double[] x) {\nif (boundaries == null) {\nreturn x;\n}\ndouble[] res = new double[x.length];\nfor (int i = 0; i < x.length; i++) {\ndouble diff = boundaries[1][i] - boundaries[0][i];\nres[i] = (x[i] - boundaries[0][i]) / diff;\n}\nreturn res;\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction:value([D)D",
            "method_body": "public double value(final double[] point) {\ndouble value;\nif (boundaries != null && isRepairMode) {\ndouble[] repaired = repair(point);\nvalue = CMAESOptimizer.this\n.computeObjectiveValue(decode(repaired)) +\npenalty(point, repaired);\n} else {\nvalue = CMAESOptimizer.this\n.computeObjectiveValue(decode(point));\n}\nreturn isMinimize ? value : -value;\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:start(IIIIII)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n\n/** Sum of squared entries. */\nprivate double sum;\n\n/** {@inheritDoc} */\npublic void start(final int rows, final int columns,\nfinal int startRow, final int endRow,\nfinal int startColumn, final int endColumn) {\nsum = 0;\n}\n\n/** {@inheritDoc} */\npublic void visit(final int row, final int column, final double value) {\nsum += value * value;\n}\n\n/** {@inheritDoc} */\npublic double end() {\nreturn FastMath.sqrt(sum);\n}\n});\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:createMatrix(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix createMatrix(final int rowDimension,\nfinal int columnDimension)\nthrows NotStrictlyPositiveException {\nreturn new Array2DRowRealMatrix(rowDimension, columnDimension);\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:doOptimize()Lorg/apache/commons/math3/optimization/PointValuePair;",
            "method_body": "protected PointValuePair doOptimize() {\ncheckParameters();\n// -------------------- Initialization --------------------------------\nisMinimize = getGoalType().equals(GoalType.MINIMIZE);\nfinal FitnessFunction fitfun = new FitnessFunction();\nfinal double[] guess = fitfun.encode(getStartPoint());\n// number of objective variables/problem dimension\ndimension = guess.length;\ninitializeCMA(guess);\niterations = 0;\ndouble bestValue = fitfun.value(guess);\npush(fitnessHistory, bestValue);\nPointValuePair optimum = new PointValuePair(getStartPoint(),\nisMinimize ? bestValue : -bestValue);\nPointValuePair lastResult = null;\n\n// -------------------- Generation Loop --------------------------------\n\ngenerationLoop:\nfor (iterations = 1; iterations <= maxIterations; iterations++) {\n// Generate and evaluate lambda offspring\nRealMatrix arz = randn1(dimension, lambda);\nRealMatrix arx = zeros(dimension, lambda);\ndouble[] fitness = new double[lambda];\n// generate random offspring\nfor (int k = 0; k < lambda; k++) {\nRealMatrix arxk = null;\nfor (int i = 0; i < checkFeasableCount+1; i++) {\nif (diagonalOnly <= 0) {\narxk = xmean.add(BD.multiply(arz.getColumnMatrix(k))\n.scalarMultiply(sigma)); // m + sig * Normal(0,C)\n} else {\narxk = xmean.add(times(diagD,arz.getColumnMatrix(k))\n.scalarMultiply(sigma));\n}\nif (i >= checkFeasableCount || fitfun.isFeasible(arxk.getColumn(0))) {\nbreak;\n}\n// regenerate random arguments for row\narz.setColumn(k, randn(dimension));\n}\ncopyColumn(arxk, 0, arx, k);\ntry {\nfitness[k] = fitfun.value(arx.getColumn(k)); // compute fitness\n} catch (TooManyEvaluationsException e) {\nbreak generationLoop;\n}\n}\n// Sort by fitness and compute weighted mean into xmean\nint[] arindex = sortedIndices(fitness);\n// Calculate new xmean, this is selection and recombination\nRealMatrix xold = xmean; // for speed up of Eq. (2) and (3)\nRealMatrix bestArx = selectColumns(arx, MathArrays.copyOf(arindex, mu));\nxmean = bestArx.multiply(weights);\nRealMatrix bestArz = selectColumns(arz, MathArrays.copyOf(arindex, mu));\nRealMatrix zmean = bestArz.multiply(weights);\nboolean hsig = updateEvolutionPaths(zmean, xold);\nif (diagonalOnly <= 0) {\nupdateCovariance(hsig, bestArx, arz, arindex, xold);\n} else {\nupdateCovarianceDiagonalOnly(hsig, bestArz, xold);\n}\n// Adapt step size sigma - Eq. (5)\nsigma *= Math.exp(Math.min(1.0,(normps/chiN - 1.)*cs/damps));\ndouble bestFitness = fitness[arindex[0]];\ndouble worstFitness = fitness[arindex[arindex.length-1]];\nif (bestValue > bestFitness) {\nbestValue = bestFitness;\nlastResult = optimum;\noptimum = new PointValuePair(\nfitfun.repairAndDecode(bestArx.getColumn(0)),\nisMinimize ? bestFitness : -bestFitness);\nif (getConvergenceChecker() != null && lastResult != null) {\nif (getConvergenceChecker().converged(iterations, optimum, lastResult)) {\nbreak generationLoop;\n}\n}\n}\n// handle termination criteria\n// Break, if fitness is good enough\nif (stopFitness != 0) { // only if stopFitness is defined\nif (bestFitness < (isMinimize ? stopFitness : -stopFitness)) {\nbreak generationLoop;\n}\n}\ndouble[] sqrtDiagC = sqrt(diagC).getColumn(0);\ndouble[] pcCol = pc.getColumn(0);\nfor (int i = 0; i < dimension; i++) {\nif (sigma*(Math.max(Math.abs(pcCol[i]), sqrtDiagC[i])) > stopTolX) {\nbreak;\n}\nif (i >= dimension-1) {\nbreak generationLoop;\n}\n}\nfor (int i = 0; i < dimension; i++) {\nif (sigma*sqrtDiagC[i] > stopTolUpX) {\nbreak generationLoop;\n}\n}\ndouble historyBest = min(fitnessHistory);\ndouble historyWorst = max(fitnessHistory);\nif (iterations > 2 && Math.max(historyWorst, worstFitness) -\nMath.min(historyBest, bestFitness) < stopTolFun) {\nbreak generationLoop;\n}\nif (iterations > fitnessHistory.length &&\nhistoryWorst-historyBest < stopTolHistFun) {\nbreak generationLoop;\n}\n// condition number of the covariance matrix exceeds 1e14\nif (max(diagD)/min(diagD) > 1e7) {\nbreak generationLoop;\n}\n// user defined termination\nif (getConvergenceChecker() != null) {\nPointValuePair current =\nnew PointValuePair(bestArx.getColumn(0),\nisMinimize ? bestFitness : -bestFitness);\nif (lastResult != null &&\ngetConvergenceChecker().converged(iterations, current, lastResult)) {\nbreak generationLoop;\n}\nlastResult = current;\n}\n// Adjust step size in case of equal function values (flat fitness)\nif (bestValue == fitness[arindex[(int)(0.1+lambda/4.)]]) {\nsigma = sigma * Math.exp(0.2+cs/damps);\n}\nif (iterations > 2 && Math.max(historyWorst, bestFitness) -\nMath.min(historyBest, bestFitness) == 0) {\nsigma = sigma * Math.exp(0.2+cs/damps);\n}\n// store best in history\npush(fitnessHistory,bestFitness);\nfitfun.setValueRange(worstFitness-bestFitness);\nif (generateStatistics) {\nstatisticsSigmaHistory.add(sigma);\nstatisticsFitnessHistory.add(bestFitness);\nstatisticsMeanHistory.add(xmean.transpose());\nstatisticsDHistory.add(diagD.transpose().scalarMultiply(1E5));\n}\n}\nreturn optimum;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() {\nif (++count > maximalCount) {\nmaxCountCallback.trigger(maximalCount);\n}\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer:<init>()V",
            "method_body": "public CMAESOptimizer() {\nthis(0);\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix$2:visit(IID)V",
            "method_body": "public double getFrobeniusNorm() {\nreturn walkInOptimizedOrder(new RealMatrixPreservingVisitor() {\n\n/** Sum of squared entries. */\nprivate double sum;\n\n/** {@inheritDoc} */\npublic void start(final int rows, final int columns,\nfinal int startRow, final int endRow,\nfinal int startColumn, final int endColumn) {\nsum = 0;\n}\n\n/** {@inheritDoc} */\npublic void visit(final int row, final int column, final double value) {\nsum += value * value;\n}\n\n/** {@inheritDoc} */\npublic double end() {\nreturn FastMath.sqrt(sum);\n}\n});\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.direct.CMAESOptimizer$FitnessFunction:decode([D)[D",
            "method_body": "public double[] decode(final double[] x) {\nif (boundaries == null) {\nreturn x;\n}\ndouble[] res = new double[x.length];\nfor (int i = 0; i < x.length; i++) {\ndouble diff = boundaries[1][i] - boundaries[0][i];\nres[i] = diff * x[i] + boundaries[0][i];\n}\nreturn res;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 76
        }
    ]
}