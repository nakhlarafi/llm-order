{
    "bug_id": 74,
    "test_id": 0,
    "test_name": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial",
    "test_body": "public void polynomial() throws DerivativeException, IntegratorException {\nTestProblem6 pb = new TestProblem6();\ndouble range = Math.abs(pb.getFinalTime() - pb.getInitialTime());\nfor (int nSteps = 1; nSteps < 7; ++nSteps) {\nAdamsMoultonIntegrator integ =\nnew AdamsMoultonIntegrator(nSteps, 1.0e-6 * range, 0.1 * range, 1.0e-9, 1.0e-9);\nTestProblemHandler handler = new TestProblemHandler(pb, integ);\ninteg.addStepHandler(handler);\ninteg.integrate(pb, pb.getInitialTime(), pb.getInitialState(),\npb.getFinalTime(), new double[pb.getDimension()]);\nif (nSteps < 4) {\nassertTrue(integ.getEvaluations() > 140);\n} else {\nassertTrue(integ.getEvaluations() < 90);\n}\n}\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegratorTest.polynomial(AdamsMoultonIntegratorTest.java:150)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:resetInternalState()V",
            "method_body": "protected void resetInternalState() {\nstepStart = Double.NaN;\nstepSize  = Math.sqrt(minStep * maxStep);\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:shift()V",
            "method_body": "public void shift() {\npreviousTime = currentTime;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getDataRef()[[D",
            "method_body": "public double[][] getDataRef() {\nreturn data;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:checkMultiplicationCompatible(Lorg/apache/commons/math/linear/AnyMatrix;Lorg/apache/commons/math/linear/AnyMatrix;)V",
            "method_body": "public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\nthrows IllegalArgumentException {\nif (left.getColumnDimension() != right.getRowDimension()) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"{0}x{1} and {2}x{3} matrices are not multiplication compatible\",\nleft.getRowDimension(), left.getColumnDimension(),\nright.getRowDimension(), right.getColumnDimension());\n}\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:initializeStep(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;ZI[DD[D[D[D[D)D",
            "method_body": "public double initializeStep(final FirstOrderDifferentialEquations equations,\nfinal boolean forward, final int order, final double[] scale,\nfinal double t0, final double[] y0, final double[] yDot0,\nfinal double[] y1, final double[] yDot1)\nthrows DerivativeException {\n\nif (initialStep > 0) {\n// use the user provided value\nreturn forward ? initialStep : -initialStep;\n}\n\n// very rough first guess : h = 0.01 * ||y/scale|| / ||y'/scale||\n// this guess will be used to perform an Euler step\ndouble ratio;\ndouble yOnScale2 = 0;\ndouble yDotOnScale2 = 0;\nfor (int j = 0; j < y0.length; ++j) {\nratio         = y0[j] / scale[j];\nyOnScale2    += ratio * ratio;\nratio         = yDot0[j] / scale[j];\nyDotOnScale2 += ratio * ratio;\n}\n\ndouble h = ((yOnScale2 < 1.0e-10) || (yDotOnScale2 < 1.0e-10)) ?\n1.0e-6 : (0.01 * Math.sqrt(yOnScale2 / yDotOnScale2));\nif (! forward) {\nh = -h;\n}\n\n// perform an Euler step using the preceding rough guess\nfor (int j = 0; j < y0.length; ++j) {\ny1[j] = y0[j] + h * yDot0[j];\n}\ncomputeDerivatives(t0 + h, y1, yDot1);\n\n// estimate the second derivative of the solution\ndouble yDDotOnScale = 0;\nfor (int j = 0; j < y0.length; ++j) {\nratio         = (yDot1[j] - yDot0[j]) / scale[j];\nyDDotOnScale += ratio * ratio;\n}\nyDDotOnScale = Math.sqrt(yDDotOnScale) / h;\n\n// step size is computed such that\n// h^order * max (||y'/tol||, ||y''/tol||) = 0.01\nfinal double maxInv2 = Math.max(Math.sqrt(yDotOnScale2), yDDotOnScale);\nfinal double h1 = (maxInv2 < 1.0e-15) ?\nMath.max(1.0e-6, 0.001 * Math.abs(h)) :\nMath.pow(0.01 / maxInv2, 1.0 / order);\nh = Math.min(100.0 * Math.abs(h), h1);\nh = Math.max(h, 1.0e-12 * Math.abs(t0));  // avoids cancellation when computing t1 - t0\nif (h < getMinStep()) {\nh = getMinStep();\n}\nif (h > getMaxStep()) {\nh = getMaxStep();\n}\nif (! forward) {\nh = -h;\n}\n\nreturn h;\n\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector:<init>(Lorg/apache/commons/math/ode/nonstiff/AdamsMoultonIntegrator;[D[D[D)V",
            "method_body": "public Corrector(final double[] previous, final double[] scaled, final double[] state) {\nthis.previous = previous;\nthis.scaled   = scaled;\nthis.after    = state;\nthis.before   = state.clone();\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator:computeInterpolatedStateAndDerivatives(DD)V",
            "method_body": "protected void computeInterpolatedStateAndDerivatives(final double theta, final double oneMinusThetaH) {\n\nfinal double x = interpolatedTime - referenceTime;\nfinal double normalizedAbscissa = x / scalingH;\n\nArrays.fill(stateVariation, 0.0);\nArrays.fill(interpolatedDerivatives, 0.0);\n\n// apply Taylor formula from high order to low order,\n// for the sake of numerical accuracy\nfinal double[][] nData = nordsieck.getDataRef();\nfor (int i = nData.length - 1; i >= 0; --i) {\nfinal int order = i + 2;\nfinal double[] nDataI = nData[i];\nfinal double power = Math.pow(normalizedAbscissa, order);\nfor (int j = 0; j < nDataI.length; ++j) {\nfinal double d = nDataI[j] * power;\nstateVariation[j]          += d;\ninterpolatedDerivatives[j] += order * d;\n}\n}\n\nfor (int j = 0; j < currentState.length; ++j) {\nstateVariation[j] += scaled[j] * normalizedAbscissa;\ninterpolatedState[j] = currentState[j] + stateVariation[j];\ninterpolatedDerivatives[j] =\n(interpolatedDerivatives[j] + scaled[j] * normalizedAbscissa) / x;\n}\n\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:getEventsStates()Ljava/util/Collection;",
            "method_body": "public Collection<EventState> getEventsStates() {\nreturn states;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator:<init>()V",
            "method_body": "protected RungeKuttaStepInterpolator() {\nsuper();\nyDotK      = null;\nintegrator = null;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:storeTime(D)V",
            "method_body": "public void storeTime(final double t) {\n\ncurrentTime = t;\nh           = currentTime - previousTime;\nsetInterpolatedTime(t);\n\n// the step is not finalized anymore\nfinalized  = false;\n\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMinReduction(D)V",
            "method_body": "public void setMinReduction(final double minReduction) {\nthis.minReduction = minReduction;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.MathException:getMessage()Ljava/lang/String;",
            "method_body": "public String getMessage() {\nreturn getMessage(Locale.US);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:clearResult()V",
            "method_body": "protected final void clearResult() {\nthis.iterationCount = 0;\nthis.resultComputed = false;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:clearStepHandlers()V",
            "method_body": "public void clearStepHandlers() {\nstepHandlers.clear();\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:getMaxStep()D",
            "method_body": "public double getMaxStep() {\nreturn maxStep;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$NordsieckInitializer:handleStep(Lorg/apache/commons/math/ode/sampling/StepInterpolator;Z)V",
            "method_body": "RealMatrix initializeHighOrderDerivatives(double[] first, double[][] multistep);\n}\n\n/** Specialized step handler storing the first step. */\nprivate class NordsieckInitializer implements StepHandler {\n\n/** Problem dimension. */\nprivate final int n;\n\n/** Simple constructor.\n* @param n problem dimension\n*/\npublic NordsieckInitializer(final int n) {\nthis.n = n;\n}\n\n/** {@inheritDoc} */\npublic void handleStep(StepInterpolator interpolator, boolean isLast)\nthrows DerivativeException {\n\nfinal double prev = interpolator.getPreviousTime();\nfinal double curr = interpolator.getCurrentTime();\nstepStart = prev;\nstepSize  = (curr - prev) / (nSteps + 1);\n\n// compute the first scaled derivative\ninterpolator.setInterpolatedTime(prev);\nscaled = interpolator.getInterpolatedDerivatives().clone();\nfor (int j = 0; j < n; ++j) {\nscaled[j] *= stepSize;\n}\n\n// compute the high order scaled derivatives\nfinal double[][] multistep = new double[nSteps][];\nfor (int i = 1; i <= nSteps; ++i) {\ninterpolator.setInterpolatedTime(prev + stepSize * i);\nfinal double[] msI = interpolator.getInterpolatedDerivatives().clone();\nfor (int j = 0; j < n; ++j) {\nmsI[j] *= stepSize;\n}\nmultistep[i - 1] = msI;\n}\nnordsieck = initializeHighOrderDerivatives(scaled, multistep);\n\n// stop the integrator after the first step has been handled\nthrow new InitializationCompletedMarkerException();\n\n}\n\n/** {@inheritDoc} */\npublic boolean requiresDenseOutput() {\nreturn true;\n}\n\n/** {@inheritDoc} */\npublic void reset() {\n// nothing to do\n}\n\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:getCurrentStepStart()D",
            "method_body": "public double getCurrentStepStart() {\nreturn stepStart;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:getEventTime()D",
            "method_body": "public double getEventTime() {\nreturn (first == null) ? Double.NaN : first.getEventTime();\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:computeDerivatives(D[D[D)V",
            "method_body": "public void computeDerivatives(final double t, final double[] y, final double[] yDot)\nthrows DerivativeException {\nif (++evaluations > maxEvaluations) {\nthrow new DerivativeException(new MaxEvaluationsExceededException(maxEvaluations));\n}\nequations.computeDerivatives(t, y, yDot);\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$NordsieckInitializer:requiresDenseOutput()Z",
            "method_body": "RealMatrix initializeHighOrderDerivatives(double[] first, double[][] multistep);\n}\n\n/** Specialized step handler storing the first step. */\nprivate class NordsieckInitializer implements StepHandler {\n\n/** Problem dimension. */\nprivate final int n;\n\n/** Simple constructor.\n* @param n problem dimension\n*/\npublic NordsieckInitializer(final int n) {\nthis.n = n;\n}\n\n/** {@inheritDoc} */\npublic void handleStep(StepInterpolator interpolator, boolean isLast)\nthrows DerivativeException {\n\nfinal double prev = interpolator.getPreviousTime();\nfinal double curr = interpolator.getCurrentTime();\nstepStart = prev;\nstepSize  = (curr - prev) / (nSteps + 1);\n\n// compute the first scaled derivative\ninterpolator.setInterpolatedTime(prev);\nscaled = interpolator.getInterpolatedDerivatives().clone();\nfor (int j = 0; j < n; ++j) {\nscaled[j] *= stepSize;\n}\n\n// compute the high order scaled derivatives\nfinal double[][] multistep = new double[nSteps][];\nfor (int i = 1; i <= nSteps; ++i) {\ninterpolator.setInterpolatedTime(prev + stepSize * i);\nfinal double[] msI = interpolator.getInterpolatedDerivatives().clone();\nfor (int j = 0; j < n; ++j) {\nmsI[j] *= stepSize;\n}\nmultistep[i - 1] = msI;\n}\nnordsieck = initializeHighOrderDerivatives(scaled, multistep);\n\n// stop the integrator after the first step has been handled\nthrow new InitializationCompletedMarkerException();\n\n}\n\n/** {@inheritDoc} */\npublic boolean requiresDenseOutput() {\nreturn true;\n}\n\n/** {@inheritDoc} */\npublic void reset() {\n// nothing to do\n}\n\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:stop()Z",
            "method_body": "public boolean stop() {\nfor (EventState state : states) {\nif (state.stop()) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getInterpolatedState()[D",
            "method_body": "public double[] getInterpolatedState() throws DerivativeException {\n\n// lazy evaluation of the state\nif (dirtyState) {\nfinal double oneMinusThetaH = currentTime - interpolatedTime;\nfinal double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\ncomputeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\ndirtyState = false;\n}\n\nreturn interpolatedState;\n\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator:setMaxGrowth(D)V",
            "method_body": "public void setMaxGrowth(final double maxGrowth) {\nthis.maxGrowth = maxGrowth;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getInterpolatedTime()D",
            "method_body": "public double getInterpolatedTime() {\nreturn interpolatedTime;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:estimateError([[D[D[DD)D",
            "method_body": "protected double estimateError(final double[][] yDotK,\nfinal double[] y0, final double[] y1,\nfinal double h) {\ndouble error1 = 0;\ndouble error2 = 0;\n\nfor (int j = 0; j < y0.length; ++j) {\nfinal double errSum1 = E1_01 * yDotK[0][j]  + E1_06 * yDotK[5][j] +\nE1_07 * yDotK[6][j]  + E1_08 * yDotK[7][j] +\nE1_09 * yDotK[8][j]  + E1_10 * yDotK[9][j] +\nE1_11 * yDotK[10][j] + E1_12 * yDotK[11][j];\nfinal double errSum2 = E2_01 * yDotK[0][j]  + E2_06 * yDotK[5][j] +\nE2_07 * yDotK[6][j]  + E2_08 * yDotK[7][j] +\nE2_09 * yDotK[8][j]  + E2_10 * yDotK[9][j] +\nE2_11 * yDotK[10][j] + E2_12 * yDotK[11][j];\n\nfinal double yScale = Math.max(Math.abs(y0[j]), Math.abs(y1[j]));\nfinal double tol = (vecAbsoluteTolerance == null) ?\n(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n(vecAbsoluteTolerance[j] + vecRelativeTolerance[j] * yScale);\nfinal double ratio1  = errSum1 / tol;\nerror1        += ratio1 * ratio1;\nfinal double ratio2  = errSum2 / tol;\nerror2        += ratio2 * ratio2;\n}\n\ndouble den = error1 + 0.01 * error2;\nif (den <= 0.0) {\nden = 1.0;\n}\n\nreturn Math.abs(h) * error1 / Math.sqrt(y0.length * den);\n\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:<init>()V",
            "method_body": "public BrentSolver() {\nsuper(100, 1E-6);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:getCurrentSignedStepsize()D",
            "method_body": "public double getCurrentSignedStepsize() {\nreturn stepSize;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$NordsieckInitializer:<init>(Lorg/apache/commons/math/ode/MultistepIntegrator;I)V",
            "method_body": "RealMatrix initializeHighOrderDerivatives(double[] first, double[][] multistep);\n}\n\n/** Specialized step handler storing the first step. */\nprivate class NordsieckInitializer implements StepHandler {\n\n/** Problem dimension. */\nprivate final int n;\n\n/** Simple constructor.\n* @param n problem dimension\n*/\npublic NordsieckInitializer(final int n) {\nthis.n = n;\n}\n\n/** {@inheritDoc} */\npublic void handleStep(StepInterpolator interpolator, boolean isLast)\nthrows DerivativeException {\n\nfinal double prev = interpolator.getPreviousTime();\nfinal double curr = interpolator.getCurrentTime();\nstepStart = prev;\nstepSize  = (curr - prev) / (nSteps + 1);\n\n// compute the first scaled derivative\ninterpolator.setInterpolatedTime(prev);\nscaled = interpolator.getInterpolatedDerivatives().clone();\nfor (int j = 0; j < n; ++j) {\nscaled[j] *= stepSize;\n}\n\n// compute the high order scaled derivatives\nfinal double[][] multistep = new double[nSteps][];\nfor (int i = 1; i <= nSteps; ++i) {\ninterpolator.setInterpolatedTime(prev + stepSize * i);\nfinal double[] msI = interpolator.getInterpolatedDerivatives().clone();\nfor (int j = 0; j < n; ++j) {\nmsI[j] *= stepSize;\n}\nmultistep[i - 1] = msI;\n}\nnordsieck = initializeHighOrderDerivatives(scaled, multistep);\n\n// stop the integrator after the first step has been handled\nthrow new InitializationCompletedMarkerException();\n\n}\n\n/** {@inheritDoc} */\npublic boolean requiresDenseOutput() {\nreturn true;\n}\n\n/** {@inheritDoc} */\npublic void reset() {\n// nothing to do\n}\n\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:addEventHandler(Lorg/apache/commons/math/ode/events/EventHandler;DDI)V",
            "method_body": "public void addEventHandler(final EventHandler handler, final double maxCheckInterval,\nfinal double convergence, final int maxIterationCount) {\nstates.add(new EventState(handler, maxCheckInterval,\nconvergence, maxIterationCount));\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:storeTime(D)V",
            "method_body": "public void storeTime(final double t) {\nsuper.storeTime(t);\nvectorsInitialized = false;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setMaxEvaluations(I)V",
            "method_body": "public void setMaxEvaluations(int maxEvaluations) {\nthis.maxEvaluations = (maxEvaluations < 0) ? Integer.MAX_VALUE : maxEvaluations;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:solve(Lorg/apache/commons/math/analysis/UnivariateRealFunction;DD)D",
            "method_body": "public double solve(final UnivariateRealFunction f,\nfinal double min, final double max)\nthrows MaxIterationsExceededException,\nFunctionEvaluationException {\n\nclearResult();\nverifyInterval(min, max);\n\ndouble ret = Double.NaN;\n\ndouble yMin = f.value(min);\ndouble yMax = f.value(max);\n\n// Verify bracketing\ndouble sign = yMin * yMax;\nif (sign > 0) {\n// check if either value is close to a zero\nif (Math.abs(yMin) <= functionValueAccuracy) {\nsetResult(min, 0);\nret = min;\n} else if (Math.abs(yMax) <= functionValueAccuracy) {\nsetResult(max, 0);\nret = max;\n} else {\n// neither value is close to zero and min and max do not bracket root.\nthrow MathRuntimeException.createIllegalArgumentException(\n\"function values at endpoints do not have different signs.  \" +\n\"Endpoints: [{0}, {1}], Values: [{2}, {3}]\",\nmin, max, yMin, yMax);\n}\n} else if (sign < 0){\n// solve using only the first endpoint as initial guess\nret = solve(f, min, yMin, max, yMax, min, yMin);\n} else {\n// either min or max is a root\nif (yMin == 0.0) {\nret = min;\n} else {\nret = max;\n}\n}\n\nreturn ret;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:getOrder()I",
            "method_body": "public int getOrder() {\nreturn 8;\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState$1:<init>(Lorg/apache/commons/math/ode/events/EventState;Lorg/apache/commons/math/ode/sampling/StepInterpolator;)V",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\nfinal double h  = (t1 - t0) / n;\ndouble ta = t0;\ndouble ga = g0;\ndouble tb = t0 + (interpolator.isForward() ? convergence : -convergence);\nfor (int i = 0; i < n; ++i) {\ntb += h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\nif (g0Positive ^ (gb >= 0)) {\nif (ga * gb > 0) {\nincreasing = gb >= ga;\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\nfinal BrentSolver solver = new BrentSolver();\nsolver.setAbsoluteAccuracy(convergence);\nsolver.setMaximalIterationCount(maxIterationCount);\nfinal double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\nif ((Math.abs(root - ta) <= convergence) &&\n} else if (Double.isNaN(previousEventTime) ||\npendingEventTime = root;\nif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\nreturn false;\npendingEvent = true;\nreturn true;\nta = tb;\nga = gb;\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:<init>()V",
            "method_body": "public DormandPrince853StepInterpolator() {\nsuper();\nyDotKLast = null;\nv         = null;\nvectorsInitialized = false;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState$1:value(D)D",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nthrows DerivativeException, EventException, ConvergenceException {\n\ntry {\n\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\nfinal double h  = (t1 - t0) / n;\n\ndouble ta = t0;\ndouble ga = g0;\ndouble tb = t0 + (interpolator.isForward() ? convergence : -convergence);\nfor (int i = 0; i < n; ++i) {\n\n// evaluate handler value at the end of the substep\ntb += h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n// check events occurrence\nif (g0Positive ^ (gb >= 0)) {\n// there is a sign change: an event is expected during this step\n\nif (ga * gb > 0) {\n// this is a corner case:\n// - there was an event near ta,\n// - there is another event between ta and tb\n// - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n// this implies that the real sign of ga is the same as gb, so we need to slightly\n// shift ta to make sure ga and gb get opposite signs and the solver won't complain\n// about bracketing\nfinal double epsilon = (forward ? 0.25 : -0.25) * convergence;\nfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\nta += epsilon;\ninterpolator.setInterpolatedTime(ta);\nga = handler.g(ta, interpolator.getInterpolatedState());\n}\nif (ga * gb > 0) {\n// this should never happen\nthrow MathRuntimeException.createInternalError(null);\n}\n}\n\n// variation direction, with respect to the integration direction\nincreasing = gb >= ga;\n\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\npublic double value(final double t) throws FunctionEvaluationException {\ntry {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\n} catch (DerivativeException e) {\nthrow new FunctionEvaluationException(e, t);\n} catch (EventException e) {\nthrow new FunctionEvaluationException(e, t);\n}\n}\n};\nfinal BrentSolver solver = new BrentSolver();\nsolver.setAbsoluteAccuracy(convergence);\nsolver.setMaximalIterationCount(maxIterationCount);\nfinal double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\nif ((Math.abs(root - ta) <= convergence) &&\n(Math.abs(root - previousEventTime) <= convergence)) {\n// we have either found nothing or found (again ?) a past event, we simply ignore it\nta = tb;\nga = gb;\n} else if (Double.isNaN(previousEventTime) ||\n(Math.abs(previousEventTime - root) > convergence)) {\npendingEventTime = root;\nif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n// we were already waiting for this event which was\n// found during a previous call for a step that was\n// rejected, this step must now be accepted since it\n// properly ends exactly at the event occurrence\nreturn false;\n}\n// either we were not waiting for the event or it has\n// moved in such a way the step cannot be accepted\npendingEvent = true;\nreturn true;\n}\n\n} else {\n// no sign change: there is no event for now\nta = tb;\nga = gb;\n}\n\n}\n\n// no event during the whole step\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n\n} catch (FunctionEvaluationException e) {\nfinal Throwable cause = e.getCause();\nif ((cause != null) && (cause instanceof DerivativeException)) {\nthrow (DerivativeException) cause;\n} else if ((cause != null) && (cause instanceof EventException)) {\nthrow (EventException) cause;\n}\nthrow new EventException(e);\n}\n\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector:visit(IID)V",
            "method_body": "public void visit(int row, int column, double value)\nthrows MatrixVisitorException {\nif ((row & 0x1) == 0) {\nafter[column] -= value;\n} else {\nafter[column] += value;\n}\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:requiresDenseOutput()Z",
            "method_body": "protected boolean requiresDenseOutput() {\nfor (StepHandler handler : stepHandlers) {\nif (handler.requiresDenseOutput()) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:isForward()Z",
            "method_body": "public boolean isForward() {\nreturn forward;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker:<init>(D)V",
            "method_body": "public EndTimeChecker(final double endTime) {\nthis.endTime = endTime;\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$CountingDifferentialEquations:computeDerivatives(D[D[D)V",
            "method_body": "public void computeDerivatives(double t, double[] y, double[] dot)\nthrows DerivativeException {\nMultistepIntegrator.this.computeDerivatives(t, y, dot);\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator:updateHighOrderDerivativesPhase2([D[DLorg/apache/commons/math/linear/Array2DRowRealMatrix;)V",
            "method_body": "public void updateHighOrderDerivativesPhase2(final double[] start,\nfinal double[] end,\nfinal Array2DRowRealMatrix highOrder) {\ntransformer.updateHighOrderDerivativesPhase2(start, end, highOrder);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getInterpolatedDerivatives()[D",
            "method_body": "public double[] getInterpolatedDerivatives() throws DerivativeException {\n\n// lazy evaluation of the state\nif (dirtyState) {\nfinal double oneMinusThetaH = currentTime - interpolatedTime;\nfinal double theta = (h == 0) ? 0 : (h - oneMinusThetaH) / h;\ncomputeInterpolatedStateAndDerivatives(theta, oneMinusThetaH);\ndirtyState = false;\n}\n\nreturn interpolatedDerivatives;\n\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:getEventTime()D",
            "method_body": "public double getEventTime() {\nreturn pendingEventTime;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:reset(D[D)Z",
            "method_body": "public boolean reset(final double t, final double[] y)\nthrows IntegratorException {\ntry {\nboolean resetDerivatives = false;\nfor (EventState state : states) {\nif (state.reset(t, y)) {\nresetDerivatives = true;\n}\n}\nreturn resetDerivatives;\n} catch (EventException se) {\nthrow new IntegratorException(se);\n}\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>([[DZ)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\nthrows IllegalArgumentException, NullPointerException {\nif (copyArray) {\ncopyIn(d);\n} else {\nif (d == null) {\nthrow new NullPointerException();\n}\nfinal int nRows = d.length;\nif (nRows == 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\nAT_LEAST_ONE_ROW_MESSAGE);\n}\nfinal int nCols = d[0].length;\nif (nCols == 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\nAT_LEAST_ONE_COLUMN_MESSAGE);\n}\nfor (int r = 1; r < nRows; r++) {\nif (d[r].length != nCols) {\nthrow MathRuntimeException.createIllegalArgumentException(\nDIFFERENT_ROWS_LENGTHS_MESSAGE, nCols, d[r].length);\n}\n}\ndata = d;\n}\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:sanityChecks(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)V",
            "method_body": "protected void sanityChecks(final FirstOrderDifferentialEquations ode,\nfinal double t0, final double[] y0,\nfinal double t, final double[] y)\nthrows IntegratorException {\n\nif (ode.getDimension() != y0.length) {\nthrow new IntegratorException(\n\"dimensions mismatch: ODE problem has dimension {0},\" +\n\" initial state vector has dimension {1}\",\node.getDimension(), y0.length);\n}\n\nif (ode.getDimension() != y.length) {\nthrow new IntegratorException(\n\"dimensions mismatch: ODE problem has dimension {0},\" +\n\" final state vector has dimension {1}\",\node.getDimension(), y.length);\n}\n\nif (Math.abs(t - t0) <= 1.0e-12 * Math.max(Math.abs(t0), Math.abs(t))) {\nthrow new IntegratorException(\n\"too small integration interval: length = {0}\",\nMath.abs(t - t0));\n}\n\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator:updateHighOrderDerivativesPhase1(Lorg/apache/commons/math/linear/Array2DRowRealMatrix;)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\nreturn transformer.updateHighOrderDerivativesPhase1(highOrder);\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator:reinitialize(Lorg/apache/commons/math/ode/AbstractIntegrator;[D[[DZ)V",
            "method_body": "public void reinitialize(final AbstractIntegrator rkIntegrator,\nfinal double[] y, final double[][] yDotArray, final boolean forward) {\nreinitialize(y, forward);\nthis.yDotK = yDotArray;\nthis.integrator = rkIntegrator;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:resetEvaluations()V",
            "method_body": "protected void resetEvaluations() {\nevaluations = 0;\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math.ConvergingAlgorithmImpl:setAbsoluteAccuracy(D)V",
            "method_body": "public void setAbsoluteAccuracy(double accuracy) {\nabsoluteAccuracy = accuracy;\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:setInterpolatedTime(D)V",
            "method_body": "public void setInterpolatedTime(final double time) {\ninterpolatedTime = time;\ndirtyState       = true;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:<init>()V",
            "method_body": "protected AbstractRealMatrix() {\nlu = null;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getCurrentTime()D",
            "method_body": "public double getCurrentTime() {\nreturn currentTime;\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector:start(IIIIII)V",
            "method_body": "public void start(int rows, int columns,\nint startRow, int endRow, int startColumn, int endColumn) {\nArrays.fill(after, 0.0);\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:<init>(Lorg/apache/commons/math/ode/nonstiff/DormandPrince853StepInterpolator;)V",
            "method_body": "public DormandPrince853StepInterpolator(final DormandPrince853StepInterpolator interpolator) {\n\nsuper(interpolator);\n\nif (interpolator.currentState == null) {\n\nyDotKLast = null;\nv         = null;\nvectorsInitialized = false;\n\n} else {\n\nfinal int dimension = interpolator.currentState.length;\n\nyDotKLast    = new double[3][];\nfor (int k = 0; k < yDotKLast.length; ++k) {\nyDotKLast[k] = new double[dimension];\nSystem.arraycopy(interpolator.yDotKLast[k], 0, yDotKLast[k], 0,\ndimension);\n}\n\nv = new double[7][];\nfor (int k = 0; k < v.length; ++k) {\nv[k] = new double[dimension];\nSystem.arraycopy(interpolator.v[k], 0, v[k], 0, dimension);\n}\n\nvectorsInitialized = interpolator.vectorsInitialized;\n\n}\n\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$CountingDifferentialEquations:getDimension()I",
            "method_body": "public int getDimension() {\nreturn dimension;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:<init>()V",
            "method_body": "protected AbstractStepInterpolator() {\npreviousTime            = Double.NaN;\ncurrentTime             = Double.NaN;\nh                       = Double.NaN;\ninterpolatedTime        = Double.NaN;\ncurrentState            = null;\ninterpolatedState       = null;\ninterpolatedDerivatives = null;\nfinalized               = false;\nthis.forward            = true;\nthis.dirtyState         = true;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:reset(D[D)Z",
            "method_body": "public boolean reset(final double t, final double[] y)\nthrows EventException {\n\nif (! pendingEvent) {\nreturn false;\n}\n\nif (nextAction == EventHandler.RESET_STATE) {\nhandler.resetState(t, y);\n}\npendingEvent      = false;\npendingEventTime  = Double.NaN;\n\nreturn (nextAction == EventHandler.RESET_STATE) ||\n(nextAction == EventHandler.RESET_DERIVATIVES);\n\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:stop()Z",
            "method_body": "public boolean stop() {\nreturn nextAction == EventHandler.STOP;\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:copy()Lorg/apache/commons/math/ode/sampling/StepInterpolator;",
            "method_body": "public StepInterpolator copy() throws DerivativeException {\n\n// finalize the step before performing copy\nfinalizeStep();\n\n// create the new independent instance\nreturn doCopy();\n\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:getPreviousTime()D",
            "method_body": "public double getPreviousTime() {\nreturn previousTime;\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:<init>(Lorg/apache/commons/math/ode/events/EventHandler;DDI)V",
            "method_body": "public EventState(final EventHandler handler, final double maxCheckInterval,\nfinal double convergence, final int maxIterationCount) {\nthis.handler           = handler;\nthis.maxCheckInterval  = maxCheckInterval;\nthis.convergence       = Math.abs(convergence);\nthis.maxIterationCount = maxIterationCount;\n\n// some dummy values ...\nt0                = Double.NaN;\ng0                = Double.NaN;\ng0Positive        = true;\npendingEvent      = false;\npendingEventTime  = Double.NaN;\npreviousEventTime = Double.NaN;\nincreasing        = true;\nnextAction        = EventHandler.CONTINUE;\n\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:walkInOptimizedOrder(Lorg/apache/commons/math/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInOptimizedOrder(final RealMatrixPreservingVisitor visitor)\nthrows MatrixVisitorException {\nreturn walkInRowOrder(visitor);\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:addStepHandler(Lorg/apache/commons/math/ode/sampling/StepHandler;)V",
            "method_body": "public void addStepHandler(final StepHandler handler) {\nstepHandlers.add(handler);\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:<init>()V",
            "method_body": "public CombinedEventsManager() {\nstates      = new ArrayList<EventState>();\nfirst       = null;\ninitialized = false;\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator:<init>(Ljava/lang/String;IIDDDD)V",
            "method_body": "protected MultistepIntegrator(final String name, final int nSteps,\nfinal int order,\nfinal double minStep, final double maxStep,\nfinal double scalAbsoluteTolerance,\nfinal double scalRelativeTolerance) {\n\nsuper(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\nif (nSteps <= 0) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"{0} method needs at least one previous point\",\nname);\n}\n\nstarter = new DormandPrince853Integrator(minStep, maxStep,\nscalAbsoluteTolerance,\nscalRelativeTolerance);\nthis.nSteps = nSteps;\n\nexp = -1.0 / order;\n\n// set the default values of the algorithm control parameters\nsetSafety(0.9);\nsetMinReduction(0.2);\nsetMaxGrowth(Math.pow(2.0, -exp));\n\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator:initializeHighOrderDerivatives([D[[D)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "protected Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\nfinal double[][] multistep) {\nreturn transformer.initializeHighOrderDerivatives(first, multistep);\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:evaluateStep(Lorg/apache/commons/math/ode/sampling/StepInterpolator;)Z",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nthrows DerivativeException, EventException, ConvergenceException {\n\ntry {\n\nforward = interpolator.isForward();\nfinal double t1 = interpolator.getCurrentTime();\nfinal int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\nfinal double h  = (t1 - t0) / n;\n\ndouble ta = t0;\ndouble ga = g0;\ndouble tb = t0 + (interpolator.isForward() ? convergence : -convergence);\nfor (int i = 0; i < n; ++i) {\n\n// evaluate handler value at the end of the substep\ntb += h;\ninterpolator.setInterpolatedTime(tb);\nfinal double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n// check events occurrence\nif (g0Positive ^ (gb >= 0)) {\n// there is a sign change: an event is expected during this step\n\nif (ga * gb > 0) {\n// this is a corner case:\n// - there was an event near ta,\n// - there is another event between ta and tb\n// - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n// this implies that the real sign of ga is the same as gb, so we need to slightly\n// shift ta to make sure ga and gb get opposite signs and the solver won't complain\n// about bracketing\nfinal double epsilon = (forward ? 0.25 : -0.25) * convergence;\nfor (int k = 0; (k < 4) && (ga * gb > 0); ++k) {\nta += epsilon;\ninterpolator.setInterpolatedTime(ta);\nga = handler.g(ta, interpolator.getInterpolatedState());\n}\nif (ga * gb > 0) {\n// this should never happen\nthrow MathRuntimeException.createInternalError(null);\n}\n}\n\n// variation direction, with respect to the integration direction\nincreasing = gb >= ga;\n\nfinal UnivariateRealFunction f = new UnivariateRealFunction() {\npublic double value(final double t) throws FunctionEvaluationException {\ntry {\ninterpolator.setInterpolatedTime(t);\nreturn handler.g(t, interpolator.getInterpolatedState());\n} catch (DerivativeException e) {\nthrow new FunctionEvaluationException(e, t);\n} catch (EventException e) {\nthrow new FunctionEvaluationException(e, t);\n}\n}\n};\nfinal BrentSolver solver = new BrentSolver();\nsolver.setAbsoluteAccuracy(convergence);\nsolver.setMaximalIterationCount(maxIterationCount);\nfinal double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\nif ((Math.abs(root - ta) <= convergence) &&\n(Math.abs(root - previousEventTime) <= convergence)) {\n// we have either found nothing or found (again ?) a past event, we simply ignore it\nta = tb;\nga = gb;\n} else if (Double.isNaN(previousEventTime) ||\n(Math.abs(previousEventTime - root) > convergence)) {\npendingEventTime = root;\nif (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n// we were already waiting for this event which was\n// found during a previous call for a step that was\n// rejected, this step must now be accepted since it\n// properly ends exactly at the event occurrence\nreturn false;\n}\n// either we were not waiting for the event or it has\n// moved in such a way the step cannot be accepted\npendingEvent = true;\nreturn true;\n}\n\n} else {\n// no sign change: there is no event for now\nta = tb;\nga = gb;\n}\n\n}\n\n// no event during the whole step\npendingEvent     = false;\npendingEventTime = Double.NaN;\nreturn false;\n\n} catch (FunctionEvaluationException e) {\nfinal Throwable cause = e.getCause();\nif ((cause != null) && (cause instanceof DerivativeException)) {\nthrow (DerivativeException) cause;\n} else if ((cause != null) && (cause instanceof EventException)) {\nthrow (EventException) cause;\n}\nthrow new EventException(e);\n}\n\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker:eventOccurred(D[DZ)I",
            "method_body": "public int eventOccurred(double t, double[] y, boolean increasing) {\nreturn STOP;\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer:initializeHighOrderDerivatives([D[[D)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "public Array2DRowRealMatrix initializeHighOrderDerivatives(final double[] first,\nfinal double[][] multistep) {\nfor (int i = 0; i < multistep.length; ++i) {\nfinal double[] msI = multistep[i];\nfor (int j = 0; j < first.length; ++j) {\nmsI[j] -= first[j];\n}\n}\nreturn initialization.multiply(new Array2DRowRealMatrix(multistep, false));\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:<init>(Ljava/lang/String;Z[D[[D[DLorg/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator;DDDD)V",
            "method_body": "protected EmbeddedRungeKuttaIntegrator(final String name, final boolean fsal,\nfinal double[] c, final double[][] a, final double[] b,\nfinal RungeKuttaStepInterpolator prototype,\nfinal double minStep, final double maxStep,\nfinal double scalAbsoluteTolerance,\nfinal double scalRelativeTolerance) {\n\nsuper(name, minStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n\nthis.fsal      = fsal;\nthis.c         = c;\nthis.a         = a;\nthis.b         = b;\nthis.prototype = prototype;\n\nexp = -1.0 / getOrder();\n\n// set the default values of the algorithm control parameters\nsetSafety(0.9);\nsetMinReduction(0.2);\nsetMaxGrowth(10.0);\n\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853Integrator:<init>(DDDD)V",
            "method_body": "public DormandPrince853Integrator(final double minStep, final double maxStep,\nfinal double scalAbsoluteTolerance,\nfinal double scalRelativeTolerance) {\nsuper(METHOD_NAME, true, STATIC_C, STATIC_A, STATIC_B,\nnew DormandPrince853StepInterpolator(),\nminStep, maxStep, scalAbsoluteTolerance, scalRelativeTolerance);\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator:setSafety(D)V",
            "method_body": "public void setSafety(final double safety) {\nthis.safety = safety;\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:filterStep(DZZ)D",
            "method_body": "protected double filterStep(final double h, final boolean forward, final boolean acceptSmall)\nthrows IntegratorException {\n\ndouble filteredH = h;\nif (Math.abs(h) < minStep) {\nif (acceptSmall) {\nfilteredH = forward ? minStep : -minStep;\n} else {\nthrow new IntegratorException(\n\"minimal step size ({0,number,0.00E00}) reached, integration needs {1,number,0.00E00}\",\nminStep, Math.abs(h));\n}\n}\n\nif (filteredH > maxStep) {\nfilteredH = maxStep;\n} else if (filteredH < -maxStep) {\nfilteredH = -maxStep;\n}\n\nreturn filteredH;\n\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator:start(D[DD)V",
            "method_body": "protected void start(final double t0, final double[] y0, final double t)\nthrows DerivativeException, IntegratorException {\n\n// make sure NO user event nor user step handler is triggered,\n// this is the task of the top level integrator, not the task\n// of the starter integrator\nstarter.clearEventHandlers();\nstarter.clearStepHandlers();\n\n// set up one specific step handler to extract initial Nordsieck vector\nstarter.addStepHandler(new NordsieckInitializer(y0.length));\n\n// start integration, expecting a InitializationCompletedMarkerException\ntry {\nstarter.integrate(new CountingDifferentialEquations(y0.length),\nt0, y0, t, new double[y0.length]);\n} catch (DerivativeException de) {\nif (!(de instanceof InitializationCompletedMarkerException)) {\n// this is not the expected nominal interruption of the start integrator\nthrow de;\n}\n}\n\n// remove the specific step handler\nstarter.clearStepHandlers();\n\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer:updateHighOrderDerivativesPhase1(Lorg/apache/commons/math/linear/Array2DRowRealMatrix;)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "public Array2DRowRealMatrix updateHighOrderDerivativesPhase1(final Array2DRowRealMatrix highOrder) {\nreturn update.multiply(highOrder);\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn (data == null) ? 0 : data.length;\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.BrentSolver:solve(Lorg/apache/commons/math/analysis/UnivariateRealFunction;DDDDDD)D",
            "method_body": "private double solve(final UnivariateRealFunction f,\ndouble x0, double y0,\ndouble x1, double y1,\ndouble x2, double y2)\nthrows MaxIterationsExceededException, FunctionEvaluationException {\n\ndouble delta = x1 - x0;\ndouble oldDelta = delta;\n\nint i = 0;\nwhile (i < maximalIterationCount) {\nif (Math.abs(y2) < Math.abs(y1)) {\n// use the bracket point if is better than last approximation\nx0 = x1;\nx1 = x2;\nx2 = x0;\ny0 = y1;\ny1 = y2;\ny2 = y0;\n}\nif (Math.abs(y1) <= functionValueAccuracy) {\n// Avoid division by very small values. Assume\n// the iteration has converged (the problem may\n// still be ill conditioned)\nsetResult(x1, i);\nreturn result;\n}\ndouble dx = x2 - x1;\ndouble tolerance =\nMath.max(relativeAccuracy * Math.abs(x1), absoluteAccuracy);\nif (Math.abs(dx) <= tolerance) {\nsetResult(x1, i);\nreturn result;\n}\nif ((Math.abs(oldDelta) < tolerance) ||\n(Math.abs(y0) <= Math.abs(y1))) {\n// Force bisection.\ndelta = 0.5 * dx;\noldDelta = delta;\n} else {\ndouble r3 = y1 / y0;\ndouble p;\ndouble p1;\n// the equality test (x0 == x2) is intentional,\n// it is part of the original Brent's method,\n// it should NOT be replaced by proximity test\nif (x0 == x2) {\n// Linear interpolation.\np = dx * r3;\np1 = 1.0 - r3;\n} else {\n// Inverse quadratic interpolation.\ndouble r1 = y0 / y2;\ndouble r2 = y1 / y2;\np = r3 * (dx * r1 * (r1 - r2) - (x1 - x0) * (r2 - 1.0));\np1 = (r1 - 1.0) * (r2 - 1.0) * (r3 - 1.0);\n}\nif (p > 0.0) {\np1 = -p1;\n} else {\np = -p;\n}\nif (2.0 * p >= 1.5 * dx * p1 - Math.abs(tolerance * p1) ||\np >= Math.abs(0.5 * oldDelta * p1)) {\n// Inverse quadratic interpolation gives a value\n// in the wrong direction, or progress is slow.\n// Fall back to bisection.\ndelta = 0.5 * dx;\noldDelta = delta;\n} else {\noldDelta = delta;\ndelta = p / p1;\n}\n}\n// Save old X1, Y1\nx0 = x1;\ny0 = y1;\n// Compute new X1, Y1\nif (Math.abs(delta) > tolerance) {\nx1 = x1 + delta;\n} else if (dx > 0.0) {\nx1 = x1 + 0.5 * tolerance;\n} else if (dx <= 0.0) {\nx1 = x1 - 0.5 * tolerance;\n}\ny1 = f.value(x1);\nif ((y1 > 0) == (y2 > 0)) {\nx2 = x0;\ny2 = y0;\ndelta = x1 - x0;\noldDelta = delta;\n}\ni++;\n}\nthrow new MaxIterationsExceededException(maximalIterationCount);\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:setResult(DI)V",
            "method_body": "protected final void setResult(final double newResult, final int iterationCount) {\nthis.result         = newResult;\nthis.iterationCount = iterationCount;\nthis.resultComputed = true;\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:clearEventHandlers()V",
            "method_body": "public void clearEventHandlers() {\neventsHandlersManager.clearEventsHandlers();\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.math.MathException:getMessage(Ljava/util/Locale;)Ljava/lang/String;",
            "method_body": "public String getMessage(final Locale locale) {\nreturn (pattern == null) ? \"\" : new MessageFormat(translate(pattern, locale), locale).format(arguments);\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator:<init>(IDDDD)V",
            "method_body": "public AdamsMoultonIntegrator(final int nSteps,\nfinal double minStep, final double maxStep,\nfinal double scalAbsoluteTolerance,\nfinal double scalRelativeTolerance)\nthrows IllegalArgumentException {\nsuper(\"Adams-Moulton\", nSteps, nSteps + 1, minStep, maxStep,\nscalAbsoluteTolerance, scalRelativeTolerance);\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:<init>(ID)V",
            "method_body": "protected UnivariateRealSolverImpl(final int defaultMaximalIterationCount,\nfinal double defaultAbsoluteAccuracy) {\nsuper(defaultMaximalIterationCount, defaultAbsoluteAccuracy);\nthis.defaultFunctionValueAccuracy = 1.0e-15;\nthis.functionValueAccuracy = defaultFunctionValueAccuracy;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:walkInRowOrder(Lorg/apache/commons/math/linear/RealMatrixPreservingVisitor;)D",
            "method_body": "public double walkInRowOrder(final RealMatrixPreservingVisitor visitor)\nthrows MatrixVisitorException {\nfinal int rows    = getRowDimension();\nfinal int columns = getColumnDimension();\nvisitor.start(rows, columns, 0, rows - 1, 0, columns - 1);\nfor (int i = 0; i < rows; ++i) {\nfinal double[] rowI = data[i];\nfor (int j = 0; j < columns; ++j) {\nvisitor.visit(i, j, rowI[j]);\n}\n}\nreturn visitor.end();\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:reinitializeBegin(D[D)V",
            "method_body": "public void reinitializeBegin(final double tStart, final double[] yStart)\nthrows EventException {\nt0 = tStart;\ng0 = handler.g(tStart, yStart);\ng0Positive = g0 >= 0;\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setMaxGrowth(D)V",
            "method_body": "public void setMaxGrowth(final double maxGrowth) {\nthis.maxGrowth = maxGrowth;\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:doFinalize()V",
            "method_body": "protected void doFinalize()\nthrows DerivativeException {\n\nif (currentState == null) {\n// we are finalizing an uninitialized instance\nreturn;\n}\n\ndouble s;\nfinal double[] yTmp = new double[currentState.length];\n\n// k14\nfor (int j = 0; j < currentState.length; ++j) {\ns = K14_01 * yDotK[0][j]  + K14_06 * yDotK[5][j]  + K14_07 * yDotK[6][j] +\nK14_08 * yDotK[7][j]  + K14_09 * yDotK[8][j]  + K14_10 * yDotK[9][j] +\nK14_11 * yDotK[10][j] + K14_12 * yDotK[11][j] + K14_13 * yDotK[12][j];\nyTmp[j] = currentState[j] + h * s;\n}\nintegrator.computeDerivatives(previousTime + C14 * h, yTmp, yDotKLast[0]);\n\n// k15\nfor (int j = 0; j < currentState.length; ++j) {\ns = K15_01 * yDotK[0][j]  + K15_06 * yDotK[5][j]  + K15_07 * yDotK[6][j] +\nK15_08 * yDotK[7][j]  + K15_09 * yDotK[8][j]  + K15_10 * yDotK[9][j] +\nK15_11 * yDotK[10][j] + K15_12 * yDotK[11][j] + K15_13 * yDotK[12][j] +\nK15_14 * yDotKLast[0][j];\nyTmp[j] = currentState[j] + h * s;\n}\nintegrator.computeDerivatives(previousTime + C15 * h, yTmp, yDotKLast[1]);\n\n// k16\nfor (int j = 0; j < currentState.length; ++j) {\ns = K16_01 * yDotK[0][j]  + K16_06 * yDotK[5][j]  + K16_07 * yDotK[6][j] +\nK16_08 * yDotK[7][j]  + K16_09 * yDotK[8][j]  + K16_10 * yDotK[9][j] +\nK16_11 * yDotK[10][j] + K16_12 * yDotK[11][j] + K16_13 * yDotK[12][j] +\nK16_14 * yDotKLast[0][j] +  K16_15 * yDotKLast[1][j];\nyTmp[j] = currentState[j] + h * s;\n}\nintegrator.computeDerivatives(previousTime + C16 * h, yTmp, yDotKLast[2]);\n\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.math.ConvergingAlgorithmImpl:setMaximalIterationCount(I)V",
            "method_body": "public void setMaximalIterationCount(int count) {\nmaximalIterationCount = count;\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$CountingDifferentialEquations:<init>(Lorg/apache/commons/math/ode/MultistepIntegrator;I)V",
            "method_body": "public CountingDifferentialEquations(final int dimension) {\nthis.dimension = dimension;\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator$Corrector:end()D",
            "method_body": "public double end() {\n\ndouble error = 0;\nfor (int i = 0; i < after.length; ++i) {\nafter[i] += previous[i] + scaled[i];\nfinal double yScale = Math.max(Math.abs(previous[i]), Math.abs(after[i]));\nfinal double tol = (vecAbsoluteTolerance == null) ?\n(scalAbsoluteTolerance + scalRelativeTolerance * yScale) :\n(vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * yScale);\nfinal double ratio  = (after[i] - before[i]) / tol;\nerror += ratio * ratio;\n}\n\nreturn Math.sqrt(error / after.length);\n\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer:getInstance(I)Lorg/apache/commons/math/ode/nonstiff/AdamsNordsieckTransformer;",
            "method_body": "public static AdamsNordsieckTransformer getInstance(final int nSteps) {\nsynchronized(CACHE) {\nAdamsNordsieckTransformer t = CACHE.get(nSteps);\nif (t == null) {\nt = new AdamsNordsieckTransformer(nSteps);\nCACHE.put(nSteps, t);\n}\nreturn t;\n}\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:multiply(Lorg/apache/commons/math/linear/Array2DRowRealMatrix;)Lorg/apache/commons/math/linear/Array2DRowRealMatrix;",
            "method_body": "public Array2DRowRealMatrix multiply(final Array2DRowRealMatrix m)\nthrows IllegalArgumentException {\n\n// safety check\nMatrixUtils.checkMultiplicationCompatible(this, m);\n\nfinal int nRows = this.getRowDimension();\nfinal int nCols = m.getColumnDimension();\nfinal int nSum = this.getColumnDimension();\nfinal double[][] outData = new double[nRows][nCols];\nfor (int row = 0; row < nRows; row++) {\nfinal double[] dataRow    = data[row];\nfinal double[] outDataRow = outData[row];\nfor (int col = 0; col < nCols; col++) {\ndouble sum = 0;\nfor (int i = 0; i < nSum; i++) {\nsum += dataRow[i] * m.data[i][col];\n}\noutDataRow[col] = sum;\n}\n}\n\nreturn new Array2DRowRealMatrix(outData, false);\n\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:computeInterpolatedStateAndDerivatives(DD)V",
            "method_body": "protected void computeInterpolatedStateAndDerivatives(final double theta,\nfinal double oneMinusThetaH)\nthrows DerivativeException {\n\nif (! vectorsInitialized) {\n\nif (v == null) {\nv = new double[7][];\nfor (int k = 0; k < 7; ++k) {\nv[k] = new double[interpolatedState.length];\n}\n}\n\n// perform the last evaluations if they have not been done yet\nfinalizeStep();\n\n// compute the interpolation vectors for this time step\nfor (int i = 0; i < interpolatedState.length; ++i) {\nfinal double yDot1  = yDotK[0][i];\nfinal double yDot6  = yDotK[5][i];\nfinal double yDot7  = yDotK[6][i];\nfinal double yDot8  = yDotK[7][i];\nfinal double yDot9  = yDotK[8][i];\nfinal double yDot10 = yDotK[9][i];\nfinal double yDot11 = yDotK[10][i];\nfinal double yDot12 = yDotK[11][i];\nfinal double yDot13 = yDotK[12][i];\nfinal double yDot14 = yDotKLast[0][i];\nfinal double yDot15 = yDotKLast[1][i];\nfinal double yDot16 = yDotKLast[2][i];\nv[0][i] = B_01 * yDot1  + B_06 * yDot6 + B_07 * yDot7 +\nB_08 * yDot8  + B_09 * yDot9 + B_10 * yDot10 +\nB_11 * yDot11 + B_12 * yDot12;\nv[1][i] = yDot1 - v[0][i];\nv[2][i] = v[0][i] - v[1][i] - yDotK[12][i];\nfor (int k = 0; k < D.length; ++k) {\nv[k+3][i] = D[k][0] * yDot1  + D[k][1]  * yDot6  + D[k][2]  * yDot7  +\nD[k][3] * yDot8  + D[k][4]  * yDot9  + D[k][5]  * yDot10 +\nD[k][6] * yDot11 + D[k][7]  * yDot12 + D[k][8]  * yDot13 +\nD[k][9] * yDot14 + D[k][10] * yDot15 + D[k][11] * yDot16;\n}\n}\n\nvectorsInitialized = true;\n\n}\n\nfinal double eta      = 1 - theta;\nfinal double twoTheta = 2 * theta;\nfinal double theta2   = theta * theta;\nfinal double dot1 = 1 - twoTheta;\nfinal double dot2 = theta * (2 - 3 * theta);\nfinal double dot3 = twoTheta * (1 + theta * (twoTheta -3));\nfinal double dot4 = theta2 * (3 + theta * (5 * theta - 8));\nfinal double dot5 = theta2 * (3 + theta * (-12 + theta * (15 - 6 * theta)));\nfinal double dot6 = theta2 * theta * (4 + theta * (-15 + theta * (18 - 7 * theta)));\n\nfor (int i = 0; i < interpolatedState.length; ++i) {\ninterpolatedState[i] = currentState[i] -\noneMinusThetaH * (v[0][i] -\ntheta * (v[1][i] +\ntheta * (v[2][i] +\neta * (v[3][i] +\ntheta * (v[4][i] +\neta * (v[5][i] +\ntheta * (v[6][i])))))));\ninterpolatedDerivatives[i] =  v[0][i] + dot1 * v[1][i] + dot2 * v[2][i] +\ndot3 * v[3][i] + dot4 * v[4][i] +\ndot5 * v[5][i] + dot6 * v[6][i];\n}\n\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator:computeStepGrowShrinkFactor(D)D",
            "method_body": "protected double computeStepGrowShrinkFactor(final double error) {\nreturn Math.min(maxGrowth, Math.max(minReduction, safety * Math.pow(error, exp)));\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:<init>(Ljava/lang/String;)V",
            "method_body": "public AbstractIntegrator(final String name) {\nthis.name = name;\nstepHandlers = new ArrayList<StepHandler>();\nstepStart = Double.NaN;\nstepSize  = Double.NaN;\neventsHandlersManager = new CombinedEventsManager();\nsetMaxEvaluations(-1);\nresetEvaluations();\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsNordsieckTransformer:updateHighOrderDerivativesPhase2([D[DLorg/apache/commons/math/linear/Array2DRowRealMatrix;)V",
            "method_body": "public void updateHighOrderDerivativesPhase2(final double[] start,\nfinal double[] end,\nfinal Array2DRowRealMatrix highOrder) {\nfinal double[][] data = highOrder.getDataRef();\nfor (int i = 0; i < data.length; ++i) {\nfinal double[] dataI = data[i];\nfinal double c1I = c1[i];\nfor (int j = 0; j < dataI.length; ++j) {\ndataI[j] += c1I * (start[j] - end[j]);\n}\n}\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.math.ode.DerivativeException:<init>(Ljava/lang/Throwable;)V",
            "method_body": "public DerivativeException(final Throwable cause) {\nsuper(cause);\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:setEquations(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;)V",
            "method_body": "protected void setEquations(final FirstOrderDifferentialEquations equations) {\nthis.equations = equations;\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator:rescale(D)V",
            "method_body": "public void rescale(final double stepSize) {\n\nfinal double ratio = stepSize / scalingH;\nfor (int i = 0; i < scaled.length; ++i) {\nscaled[i] *= ratio;\n}\n\nfinal double[][] nData = nordsieck.getDataRef();\ndouble power = ratio;\nfor (int i = 0; i < nData.length; ++i) {\npower *= ratio;\nfinal double[] nDataI = nData[i];\nfor (int j = 0; j < nDataI.length; ++j) {\nnDataI[j] *= power;\n}\n}\n\nscalingH = stepSize;\n\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:doCopy()Lorg/apache/commons/math/ode/sampling/StepInterpolator;",
            "method_body": "protected StepInterpolator doCopy() {\nreturn new DormandPrince853StepInterpolator(this);\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:reinitialize([DZ)V",
            "method_body": "protected void reinitialize(final double[] y, final boolean isForward) {\n\npreviousTime      = Double.NaN;\ncurrentTime       = Double.NaN;\nh                 = Double.NaN;\ninterpolatedTime  = Double.NaN;\n\ncurrentState            = y;\ninterpolatedState       = new double[y.length];\ninterpolatedDerivatives = new double[y.length];\n\nfinalized         = false;\nthis.forward      = isForward;\nthis.dirtyState   = true;\n\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:setSafety(D)V",
            "method_body": "public void setSafety(final double safety) {\nthis.safety = safety;\n}",
            "method_id": 103
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator$EndTimeChecker:g(D[D)D",
            "method_body": "public double g(double t, double[] y) {\nreturn t - endTime;\n}",
            "method_id": 104
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:<init>(Lorg/apache/commons/math/ode/sampling/AbstractStepInterpolator;)V",
            "method_body": "protected AbstractStepInterpolator(final AbstractStepInterpolator interpolator) {\n\npreviousTime      = interpolator.previousTime;\ncurrentTime       = interpolator.currentTime;\nh                 = interpolator.h;\ninterpolatedTime  = interpolator.interpolatedTime;\n\nif (interpolator.currentState != null) {\ncurrentState            = interpolator.currentState.clone();\ninterpolatedState       = interpolator.interpolatedState.clone();\ninterpolatedDerivatives = interpolator.interpolatedDerivatives.clone();\n} else {\ncurrentState            = null;\ninterpolatedState       = null;\ninterpolatedDerivatives = null;\n}\n\nfinalized  = interpolator.finalized;\nforward    = interpolator.forward;\ndirtyState = interpolator.dirtyState;\n\n}",
            "method_id": 105
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.EmbeddedRungeKuttaIntegrator:integrate(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nfinal double t0, final double[] y0,\nfinal double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\nsanityChecks(equations, t0, y0, t, y);\nsetEquations(equations);\nresetEvaluations();\nfinal boolean forward = t > t0;\n\n// create some internal working arrays\nfinal int stages = c.length + 1;\nif (y != y0) {\nSystem.arraycopy(y0, 0, y, 0, y0.length);\n}\nfinal double[][] yDotK = new double[stages][y0.length];\nfinal double[] yTmp = new double[y0.length];\n\n// set up an interpolator sharing the integrator arrays\nAbstractStepInterpolator interpolator;\nif (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\nfinal RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\nrki.reinitialize(this, yTmp, yDotK, forward);\ninterpolator = rki;\n} else {\ninterpolator = new DummyStepInterpolator(yTmp, forward);\n}\ninterpolator.storeTime(t0);\n\n// set up integration control objects\nstepStart         = t0;\ndouble  hNew      = 0;\nboolean firstTime = true;\nfor (StepHandler handler : stepHandlers) {\nhandler.reset();\n}\nCombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\nboolean lastStep = false;\n\n// main integration loop\nwhile (!lastStep) {\n\ninterpolator.shift();\n\ndouble error = 0;\nfor (boolean loop = true; loop;) {\n\nif (firstTime || !fsal) {\n// first stage\ncomputeDerivatives(stepStart, y, yDotK[0]);\n}\n\nif (firstTime) {\nfinal double[] scale;\nif (vecAbsoluteTolerance == null) {\nscale = new double[y0.length];\njava.util.Arrays.fill(scale, scalAbsoluteTolerance);\n} else {\nscale = vecAbsoluteTolerance;\n}\nhNew = initializeStep(equations, forward, getOrder(), scale,\nstepStart, y, yDotK[0], yTmp, yDotK[1]);\nfirstTime = false;\n}\n\nstepSize = hNew;\n\n// next stages\nfor (int k = 1; k < stages; ++k) {\n\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum = a[k-1][0] * yDotK[0][j];\nfor (int l = 1; l < k; ++l) {\nsum += a[k-1][l] * yDotK[l][j];\n}\nyTmp[j] = y[j] + stepSize * sum;\n}\n\ncomputeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n}\n\n// estimate the state at the end of the step\nfor (int j = 0; j < y0.length; ++j) {\ndouble sum    = b[0] * yDotK[0][j];\nfor (int l = 1; l < stages; ++l) {\nsum    += b[l] * yDotK[l][j];\n}\nyTmp[j] = y[j] + stepSize * sum;\n}\n\n// estimate the error at the end of the step\nerror = estimateError(yDotK, y, yTmp, stepSize);\nif (error <= 1.0) {\n\n// discrete events handling\ninterpolator.storeTime(stepStart + stepSize);\nif (manager.evaluateStep(interpolator)) {\nfinal double dt = manager.getEventTime() - stepStart;\nif (Math.abs(dt) <= Math.ulp(stepStart)) {\n// rejecting the step would lead to a too small next step, we accept it\nloop = false;\n} else {\n// reject the step to match exactly the next switch time\nhNew = dt;\n}\n} else {\n// accept the step\nloop = false;\n}\n\n} else {\n// reject the step and attempt to reduce error by stepsize control\nfinal double factor =\nMath.min(maxGrowth,\nMath.max(minReduction, safety * Math.pow(error, exp)));\nhNew = filterStep(stepSize * factor, forward, false);\n}\n\n}\n\n// the step has been accepted\nfinal double nextStep = stepStart + stepSize;\nSystem.arraycopy(yTmp, 0, y, 0, y0.length);\nmanager.stepAccepted(nextStep, y);\nlastStep = manager.stop();\n\n// provide the step data to the step handler\ninterpolator.storeTime(nextStep);\nfor (StepHandler handler : stepHandlers) {\nhandler.handleStep(interpolator, lastStep);\n}\nstepStart = nextStep;\n\nif (fsal) {\n// save the last evaluation for the next step\nSystem.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n}\n\nif (manager.reset(stepStart, y) && ! lastStep) {\n// some event handler has triggered changes that\n// invalidate the derivatives, we need to recompute them\ncomputeDerivatives(stepStart, y, yDotK[0]);\n}\n\nif (! lastStep) {\n// in some rare cases we may get here with stepSize = 0, for example\n// when an event occurs at integration start, reducing the first step\n// to zero; we have to reset the step to some safe non zero value\nstepSize = filterStep(stepSize, forward, true);\n\n// stepsize control for next step\nfinal double factor = Math.min(maxGrowth,\nMath.max(minReduction,\nsafety * Math.pow(error, exp)));\nfinal double  scaledH    = stepSize * factor;\nfinal double  nextT      = stepStart + scaledH;\nfinal boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\nhNew = filterStep(scaledH, forward, nextIsLast);\n}\n\n}\n\nfinal double stopTime = stepStart;\nresetInternalState();\nreturn stopTime;\n\n}",
            "method_id": 106
        },
        {
            "method_signature": "org.apache.commons.math.analysis.solvers.UnivariateRealSolverImpl:verifyInterval(DD)V",
            "method_body": "protected void verifyInterval(final double lower, final double upper) {\nif (lower >= upper) {\nthrow MathRuntimeException.createIllegalArgumentException(\n\"endpoints do not specify an interval: [{0}, {1}]\",\nlower, upper);\n}\n}",
            "method_id": 107
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator:reinitialize([DZ)V",
            "method_body": "public void reinitialize(final double[] y, final boolean forward) {\nsuper.reinitialize(y, forward);\nstateVariation = new double[y.length];\n}",
            "method_id": 108
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:getEvaluations()I",
            "method_body": "public int getEvaluations() {\nreturn evaluations;\n}",
            "method_id": 109
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.AbstractStepInterpolator:finalizeStep()V",
            "method_body": "public final void finalizeStep()\nthrows DerivativeException {\nif (! finalized) {\ndoFinalize();\nfinalized = true;\n}\n}",
            "method_id": 110
        },
        {
            "method_signature": "org.apache.commons.math.ode.AbstractIntegrator:addEndTimeChecker(DDLorg/apache/commons/math/ode/events/CombinedEventsManager;)Lorg/apache/commons/math/ode/events/CombinedEventsManager;",
            "method_body": "protected CombinedEventsManager addEndTimeChecker(final double startTime,\nfinal double endTime,\nfinal CombinedEventsManager manager) {\nCombinedEventsManager newManager = new CombinedEventsManager();\nfor (final EventState state : manager.getEventsStates()) {\nnewManager.addEventHandler(state.getEventHandler(),\nstate.getMaxCheckInterval(),\nstate.getConvergence(),\nstate.getMaxIterationCount());\n}\nnewManager.addEventHandler(new EndTimeChecker(endTime),\nDouble.POSITIVE_INFINITY,\nMath.ulp(Math.max(Math.abs(startTime), Math.abs(endTime))),\n100);\nreturn newManager;\n}",
            "method_id": 111
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.RungeKuttaStepInterpolator:<init>(Lorg/apache/commons/math/ode/nonstiff/RungeKuttaStepInterpolator;)V",
            "method_body": "public RungeKuttaStepInterpolator(final RungeKuttaStepInterpolator interpolator) {\n\nsuper(interpolator);\n\nif (interpolator.currentState != null) {\nfinal int dimension = currentState.length;\n\nyDotK = new double[interpolator.yDotK.length][];\nfor (int k = 0; k < interpolator.yDotK.length; ++k) {\nyDotK[k] = new double[dimension];\nSystem.arraycopy(interpolator.yDotK[k], 0,\nyDotK[k], 0, dimension);\n}\n\n} else {\nyDotK = null;\n}\n\n// we cannot keep any reference to the equations in the copy\n// the interpolator should have been finalized before\nintegrator = null;\n\n}",
            "method_id": 112
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsIntegrator:<init>(Ljava/lang/String;IIDDDD)V",
            "method_body": "public AdamsIntegrator(final String name, final int nSteps, final int order,\nfinal double minStep, final double maxStep,\nfinal double scalAbsoluteTolerance,\nfinal double scalRelativeTolerance)\nthrows IllegalArgumentException {\nsuper(name, nSteps, order, minStep, maxStep,\nscalAbsoluteTolerance, scalRelativeTolerance);\ntransformer = AdamsNordsieckTransformer.getInstance(nSteps);\n}",
            "method_id": 113
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.EventState:stepAccepted(D[D)V",
            "method_body": "public void stepAccepted(final double t, final double[] y)\nthrows EventException {\n\nt0 = t;\ng0 = handler.g(t, y);\n\nif (pendingEvent) {\n// force the sign to its value \"just after the event\"\npreviousEventTime = t;\ng0Positive        = increasing;\nnextAction        = handler.eventOccurred(t, y, !(increasing ^ forward));\n} else {\ng0Positive = g0 >= 0;\nnextAction = EventHandler.CONTINUE;\n}\n}",
            "method_id": 114
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdamsMoultonIntegrator:integrate(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)D",
            "method_body": "public double integrate(final FirstOrderDifferentialEquations equations,\nfinal double t0, final double[] y0,\nfinal double t, final double[] y)\nthrows DerivativeException, IntegratorException {\n\nfinal int n = y0.length;\nsanityChecks(equations, t0, y0, t, y);\nsetEquations(equations);\nresetEvaluations();\nfinal boolean forward = t > t0;\n\n// initialize working arrays\nif (y != y0) {\nSystem.arraycopy(y0, 0, y, 0, n);\n}\nfinal double[] yDot = new double[y0.length];\nfinal double[] yTmp = new double[y0.length];\n\n// set up two interpolators sharing the integrator arrays\nfinal NordsieckStepInterpolator interpolator = new NordsieckStepInterpolator();\ninterpolator.reinitialize(y, forward);\nfinal NordsieckStepInterpolator interpolatorTmp = new NordsieckStepInterpolator();\ninterpolatorTmp.reinitialize(yTmp, forward);\n\n// set up integration control objects\nfor (StepHandler handler : stepHandlers) {\nhandler.reset();\n}\nCombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n\n\n// compute the initial Nordsieck vector using the configured starter integrator\nstart(t0, y, t);\ninterpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\ninterpolator.storeTime(stepStart);\n\ndouble hNew = stepSize;\ninterpolator.rescale(hNew);\n\nboolean lastStep = false;\nwhile (!lastStep) {\n\n// shift all data\ninterpolator.shift();\n\ndouble error = 0;\nfor (boolean loop = true; loop;) {\n\nstepSize = hNew;\n\n// predict a first estimate of the state at step end (P in the PECE sequence)\nfinal double stepEnd = stepStart + stepSize;\ninterpolator.setInterpolatedTime(stepEnd);\nSystem.arraycopy(interpolator.getInterpolatedState(), 0, yTmp, 0, y0.length);\n\n// evaluate a first estimate of the derivative (first E in the PECE sequence)\ncomputeDerivatives(stepEnd, yTmp, yDot);\n\n// update Nordsieck vector\nfinal double[] predictedScaled = new double[y0.length];\nfor (int j = 0; j < y0.length; ++j) {\npredictedScaled[j] = stepSize * yDot[j];\n}\nfinal Array2DRowRealMatrix nordsieckTmp = updateHighOrderDerivativesPhase1(nordsieck);\nupdateHighOrderDerivativesPhase2(scaled, predictedScaled, nordsieckTmp);\n\n// apply correction (C in the PECE sequence)\nerror = nordsieckTmp.walkInOptimizedOrder(new Corrector(y, predictedScaled, yTmp));\n\nif (error <= 1.0) {\n\n// evaluate a final estimate of the derivative (second E in the PECE sequence)\ncomputeDerivatives(stepEnd, yTmp, yDot);\n\n// update Nordsieck vector\nfinal double[] correctedScaled = new double[y0.length];\nfor (int j = 0; j < y0.length; ++j) {\ncorrectedScaled[j] = stepSize * yDot[j];\n}\nupdateHighOrderDerivativesPhase2(predictedScaled, correctedScaled, nordsieckTmp);\n\n// discrete events handling\ninterpolatorTmp.reinitialize(stepEnd, stepSize, correctedScaled, nordsieckTmp);\ninterpolatorTmp.storeTime(stepStart);\ninterpolatorTmp.shift();\ninterpolatorTmp.storeTime(stepEnd);\nif (manager.evaluateStep(interpolatorTmp)) {\nfinal double dt = manager.getEventTime() - stepStart;\nif (Math.abs(dt) <= Math.ulp(stepStart)) {\n// rejecting the step would lead to a too small next step, we accept it\nloop = false;\n} else {\n// reject the step to match exactly the next switch time\nhNew = dt;\ninterpolator.rescale(hNew);\n}\n} else {\n// accept the step\nscaled    = correctedScaled;\nnordsieck = nordsieckTmp;\ninterpolator.reinitialize(stepEnd, stepSize, scaled, nordsieck);\nloop = false;\n}\n\n} else {\n// reject the step and attempt to reduce error by stepsize control\nfinal double factor = computeStepGrowShrinkFactor(error);\nhNew = filterStep(stepSize * factor, forward, false);\ninterpolator.rescale(hNew);\n}\n\n}\n\n// the step has been accepted (may have been truncated)\nfinal double nextStep = stepStart + stepSize;\nSystem.arraycopy(yTmp, 0, y, 0, n);\ninterpolator.storeTime(nextStep);\nmanager.stepAccepted(nextStep, y);\nlastStep = manager.stop();\n\n// provide the step data to the step handler\nfor (StepHandler handler : stepHandlers) {\ninterpolator.setInterpolatedTime(nextStep);\nhandler.handleStep(interpolator, lastStep);\n}\nstepStart = nextStep;\n\nif (!lastStep && manager.reset(stepStart, y)) {\n\n// some events handler has triggered changes that\n// invalidate the derivatives, we need to restart from scratch\nstart(stepStart, y, t);\ninterpolator.reinitialize(stepStart, stepSize, scaled, nordsieck);\n\n}\n\nif (! lastStep) {\n// in some rare cases we may get here with stepSize = 0, for example\n// when an event occurs at integration start, reducing the first step\n// to zero; we have to reset the step to some safe non zero value\nstepSize = filterStep(stepSize, forward, true);\n\n// stepsize control for next step\nfinal double  factor     = computeStepGrowShrinkFactor(error);\nfinal double  scaledH    = stepSize * factor;\nfinal double  nextT      = stepStart + scaledH;\nfinal boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\nhNew = filterStep(scaledH, forward, nextIsLast);\ninterpolator.rescale(hNew);\n}\n\n}\n\nfinal double stopTime  = stepStart;\nstepStart = Double.NaN;\nstepSize  = Double.NaN;\nreturn stopTime;\n\n}",
            "method_id": 115
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:evaluateStep(Lorg/apache/commons/math/ode/sampling/StepInterpolator;)Z",
            "method_body": "public boolean evaluateStep(final StepInterpolator interpolator)\nthrows DerivativeException, IntegratorException {\n\ntry {\n\nfirst = null;\nif (states.isEmpty()) {\n// there is nothing to do, return now to avoid setting the\n// interpolator time (and hence avoid unneeded calls to the\n// user function due to interpolator finalization)\nreturn false;\n}\n\nif (! initialized) {\n\n// initialize the events states\nfinal double t0 = interpolator.getPreviousTime();\ninterpolator.setInterpolatedTime(t0);\nfinal double [] y = interpolator.getInterpolatedState();\nfor (EventState state : states) {\nstate.reinitializeBegin(t0, y);\n}\n\ninitialized = true;\n\n}\n\n// check events occurrence\nfor (EventState state : states) {\n\nif (state.evaluateStep(interpolator)) {\nif (first == null) {\nfirst = state;\n} else {\nif (interpolator.isForward()) {\nif (state.getEventTime() < first.getEventTime()) {\nfirst = state;\n}\n} else {\nif (state.getEventTime() > first.getEventTime()) {\nfirst = state;\n}\n}\n}\n}\n\n}\n\nreturn first != null;\n\n} catch (EventException se) {\nthrow new IntegratorException(se);\n} catch (ConvergenceException ce) {\nthrow new IntegratorException(ce);\n}\n\n}",
            "method_id": 116
        },
        {
            "method_signature": "org.apache.commons.math.ConvergingAlgorithmImpl:<init>(ID)V",
            "method_body": "protected ConvergingAlgorithmImpl(final int defaultMaximalIterationCount,\nfinal double defaultAbsoluteAccuracy) {\nthis.defaultAbsoluteAccuracy = defaultAbsoluteAccuracy;\nthis.defaultRelativeAccuracy = 1.0e-14;\nthis.absoluteAccuracy = defaultAbsoluteAccuracy;\nthis.relativeAccuracy = defaultRelativeAccuracy;\nthis.defaultMaximalIterationCount = defaultMaximalIterationCount;\nthis.maximalIterationCount = defaultMaximalIterationCount;\nthis.iterationCount = 0;\n}",
            "method_id": 117
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:sanityChecks(Lorg/apache/commons/math/ode/FirstOrderDifferentialEquations;D[DD[D)V",
            "method_body": "protected void sanityChecks(final FirstOrderDifferentialEquations equations,\nfinal double t0, final double[] y0,\nfinal double t, final double[] y)\nthrows IntegratorException {\n\nsuper.sanityChecks(equations, t0, y0, t, y);\n\nif ((vecAbsoluteTolerance != null) && (vecAbsoluteTolerance.length != y0.length)) {\nthrow new IntegratorException(\n\"dimensions mismatch: state vector has dimension {0},\" +\n\" absolute tolerance vector has dimension {1}\",\ny0.length, vecAbsoluteTolerance.length);\n}\n\nif ((vecRelativeTolerance != null) && (vecRelativeTolerance.length != y0.length)) {\nthrow new IntegratorException(\n\"dimensions mismatch: state vector has dimension {0},\" +\n\" relative tolerance vector has dimension {1}\",\ny0.length, vecRelativeTolerance.length);\n}\n\n}",
            "method_id": 118
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:<init>(Ljava/lang/String;DDDD)V",
            "method_body": "public AdaptiveStepsizeIntegrator(final String name,\nfinal double minStep, final double maxStep,\nfinal double scalAbsoluteTolerance,\nfinal double scalRelativeTolerance) {\n\nsuper(name);\n\nthis.minStep     = Math.abs(minStep);\nthis.maxStep     = Math.abs(maxStep);\nthis.initialStep = -1.0;\n\nthis.scalAbsoluteTolerance = scalAbsoluteTolerance;\nthis.scalRelativeTolerance = scalRelativeTolerance;\nthis.vecAbsoluteTolerance  = null;\nthis.vecRelativeTolerance  = null;\n\nresetInternalState();\n\n}",
            "method_id": 119
        },
        {
            "method_signature": "org.apache.commons.math.MathException:<init>(Ljava/lang/Throwable;)V",
            "method_body": "public MathException(Throwable rootCause) {\nsuper(rootCause);\nthis.pattern   = getMessage();\nthis.arguments = new Object[0];\n}",
            "method_id": 120
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.DormandPrince853StepInterpolator:reinitialize(Lorg/apache/commons/math/ode/AbstractIntegrator;[D[[DZ)V",
            "method_body": "public void reinitialize(final AbstractIntegrator integrator,\nfinal double[] y, final double[][] yDotK, final boolean forward) {\n\nsuper.reinitialize(integrator, y, yDotK, forward);\n\nfinal int dimension = currentState.length;\n\nyDotKLast = new double[3][];\nfor (int k = 0; k < yDotKLast.length; ++k) {\nyDotKLast[k] = new double[dimension];\n}\n\nv = new double[7][];\nfor (int k = 0; k < v.length; ++k) {\nv[k]  = new double[dimension];\n}\n\nvectorsInitialized = false;\n\n}",
            "method_id": 121
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:clearEventsHandlers()V",
            "method_body": "public void clearEventsHandlers() {\nstates.clear();\n}",
            "method_id": 122
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator:setMinReduction(D)V",
            "method_body": "public void setMinReduction(final double minReduction) {\nthis.minReduction = minReduction;\n}",
            "method_id": 123
        },
        {
            "method_signature": "org.apache.commons.math.ode.nonstiff.AdaptiveStepsizeIntegrator:getMinStep()D",
            "method_body": "public double getMinStep() {\nreturn minStep;\n}",
            "method_id": 124
        },
        {
            "method_signature": "org.apache.commons.math.ode.events.CombinedEventsManager:stepAccepted(D[D)V",
            "method_body": "public void stepAccepted(final double t, final double[] y)\nthrows IntegratorException {\ntry {\nfor (EventState state : states) {\nstate.stepAccepted(t, y);\n}\n} catch (EventException se) {\nthrow new IntegratorException(se);\n}\n}",
            "method_id": 125
        },
        {
            "method_signature": "org.apache.commons.math.ode.sampling.NordsieckStepInterpolator:reinitialize(DD[DLorg/apache/commons/math/linear/Array2DRowRealMatrix;)V",
            "method_body": "public void reinitialize(final double time, final double stepSize,\nfinal double[] scaledDerivative,\nfinal Array2DRowRealMatrix nordsieckVector) {\nthis.referenceTime = time;\nthis.scalingH      = stepSize;\nthis.scaled        = scaledDerivative;\nthis.nordsieck     = nordsieckVector;\n\n// make sure the state and derivatives will depend on the new arrays\nsetInterpolatedTime(getInterpolatedTime());\n\n}",
            "method_id": 126
        },
        {
            "method_signature": "org.apache.commons.math.ode.MultistepIntegrator$InitializationCompletedMarkerException:<init>()V",
            "method_body": "public InitializationCompletedMarkerException() {\nsuper((Throwable) null);\n}",
            "method_id": 127
        }
    ]
}