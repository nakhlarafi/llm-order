{
    "bug_id": 25,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.optimization.fitting.HarmonicFitterTest.testMath844",
    "test_body": "public void testMath844() {\nfinal double[] y = { 0, 1, 2, 3, 2, 1,\n0, -1, -2, -3, -2, -1,\n0, 1, 2, 3, 2, 1,\n0, -1, -2, -3, -2, -1,\n0, 1, 2, 3, 2, 1, 0 };\nfinal int len = y.length;\nfinal WeightedObservedPoint[] points = new WeightedObservedPoint[len];\nfor (int i = 0; i < len; i++) {\npoints[i] = new WeightedObservedPoint(1, i, y[i]);\n}\nfinal HarmonicFitter.ParameterGuesser guesser\n= new HarmonicFitter.ParameterGuesser(points);\n// The guesser fails because the function is far from an harmonic\n// function: It is a triangular periodic function with amplitude 3\n// and period 12, and all sample points are taken at integer abscissae\n// so function values all belong to the integer subset {-3, -2, -1, 0,\n// 1, 2, 3}.\nguesser.guess();\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: Expected exception: org.apache.commons.math3.exception.MathIllegalStateException\nat org.junit.internal.runners.statements.ExpectException.evaluate(ExpectException.java:32)\nat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:271)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:70)\nat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:50)\nat org.junit.runners.ParentRunner$3.run(ParentRunner.java:238)\nat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:63)\nat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:236)\nat org.junit.runners.ParentRunner.access$000(ParentRunner.java:53)\nat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:229)\nat org.junit.runners.ParentRunner.run(ParentRunner.java:309)\nat junit.framework.JUnit4TestAdapter.run(JUnit4TestAdapter.java:38)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTestRunner.run(JUnitTestRunner.java:520)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeInVM(JUnitTask.java:1484)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:872)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.executeOrQueue(JUnitTask.java:1972)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute1(JUnitTask.java:824)\nat org.apache.tools.ant.taskdefs.optional.junit.JUnitTask.execute(JUnitTask.java:2277)\nat org.apache.tools.ant.UnknownElement.execute(UnknownElement.java:291)\nat sun.reflect.GeneratedMethodAccessor4.invoke(Unknown Source)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.apache.tools.ant.dispatch.DispatchUtils.execute(DispatchUtils.java:106)\nat org.apache.tools.ant.Task.perform(Task.java:348)\nat org.apache.tools.ant.Target.execute(Target.java:392)\nat org.apache.tools.ant.Target.performTasks(Target.java:413)\nat org.apache.tools.ant.Project.executeSortedTargets(Project.java:1399)\nat org.apache.tools.ant.Project.executeTarget(Project.java:1368)\nat org.apache.tools.ant.helper.DefaultExecutor.executeTargets(DefaultExecutor.java:41)\nat org.apache.tools.ant.Project.executeTargets(Project.java:1251)\nat org.apache.tools.ant.Main.runBuild(Main.java:811)\nat org.apache.tools.ant.Main.startAnt(Main.java:217)\nat org.apache.tools.ant.launch.Launcher.run(Launcher.java:280)\nat org.apache.tools.ant.launch.Launcher.main(Launcher.java:109)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optimization.fitting.HarmonicFitter$ParameterGuesser:guessAOmega()V",
            "method_body": "private void guessAOmega() {\n// initialize the sums for the linear model between the two integrals\ndouble sx2 = 0;\ndouble sy2 = 0;\ndouble sxy = 0;\ndouble sxz = 0;\ndouble syz = 0;\n\ndouble currentX = observations[0].getX();\ndouble currentY = observations[0].getY();\ndouble f2Integral = 0;\ndouble fPrime2Integral = 0;\nfinal double startX = currentX;\nfor (int i = 1; i < observations.length; ++i) {\n// one step forward\nfinal double previousX = currentX;\nfinal double previousY = currentY;\ncurrentX = observations[i].getX();\ncurrentY = observations[i].getY();\n\n// update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n// considering a linear model for f (and therefore constant f')\nfinal double dx = currentX - previousX;\nfinal double dy = currentY - previousY;\nfinal double f2StepIntegral =\ndx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\nfinal double fPrime2StepIntegral = dy * dy / dx;\n\nfinal double x = currentX - startX;\nf2Integral += f2StepIntegral;\nfPrime2Integral += fPrime2StepIntegral;\n\nsx2 += x * x;\nsy2 += f2Integral * f2Integral;\nsxy += x * f2Integral;\nsxz += x * fPrime2Integral;\nsyz += f2Integral * fPrime2Integral;\n}\n\n// compute the amplitude and pulsation coefficients\ndouble c1 = sy2 * sxz - sxy * syz;\ndouble c2 = sxy * sxz - sx2 * syz;\ndouble c3 = sx2 * sy2 - sxy * sxy;\nif ((c1 / c2 < 0) || (c2 / c3 < 0)) {\nfinal int last = observations.length - 1;\n// Range of the observations, assuming that the\n// observations are sorted.\nfinal double xRange = observations[last].getX() - observations[0].getX();\nif (xRange == 0) {\nthrow new ZeroException();\n}\nomega = 2 * Math.PI / xRange;\n\ndouble yMin = Double.POSITIVE_INFINITY;\ndouble yMax = Double.NEGATIVE_INFINITY;\nfor (int i = 1; i < observations.length; ++i) {\nfinal double y = observations[i].getY();\nif (y < yMin) {\nyMin = y;\n}\nif (y > yMax) {\nyMax = y;\n}\n}\na = 0.5 * (yMax - yMin);\n} else {\n// In some ill-conditioned cases (cf. MATH-844), the guesser\n// procedure cannot produce sensible results.\n\na = FastMath.sqrt(c1 / c2);\nomega = FastMath.sqrt(c2 / c3);\n}\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.fitting.HarmonicFitter$ParameterGuesser:<init>([Lorg/apache/commons/math3/optimization/fitting/WeightedObservedPoint;)V",
            "method_body": "public ParameterGuesser(WeightedObservedPoint[] observations) {\nif (observations.length < 4) {\nthrow new NumberIsTooSmallException(LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE,\nobservations.length, 4, true);\n}\n\nthis.observations = observations.clone();\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polySine(D)D",
            "method_body": "private static double polySine(final double x)\n{\ndouble x2 = x*x;\n\ndouble p = 2.7553817452272217E-6;\np = p * x2 + -1.9841269659586505E-4;\np = p * x2 + 0.008333333333329196;\np = p * x2 + -0.16666666666666666;\n//p *= x2;\n//p *= x;\np = p * x2 * x;\n\nreturn p;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.fitting.WeightedObservedPoint:<init>(DDD)V",
            "method_body": "public WeightedObservedPoint(final double weight, final double x, final double y) {\nthis.weight = weight;\nthis.x      = x;\nthis.y      = y;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:atan2(DD)D",
            "method_body": "public static double atan2(double y, double x) {\nif (x != x || y != y) {\nreturn Double.NaN;\n}\n\nif (y == 0) {\nfinal double result = x * y;\nfinal double invx = 1d / x;\nfinal double invy = 1d / y;\n\nif (invx == 0) { // X is infinite\nif (x > 0) {\nreturn y; // return +/- 0.0\n} else {\nreturn copySign(Math.PI, y);\n}\n}\n\nif (x < 0 || invx < 0) {\nif (y < 0 || invy < 0) {\nreturn -Math.PI;\n} else {\nreturn Math.PI;\n}\n} else {\nreturn result;\n}\n}\n\n// y cannot now be zero\n\nif (y == Double.POSITIVE_INFINITY) {\nif (x == Double.POSITIVE_INFINITY) {\nreturn Math.PI * F_1_4;\n}\n\nif (x == Double.NEGATIVE_INFINITY) {\nreturn Math.PI * F_3_4;\n}\n\nreturn Math.PI * F_1_2;\n}\n\nif (y == Double.NEGATIVE_INFINITY) {\nif (x == Double.POSITIVE_INFINITY) {\nreturn -Math.PI * F_1_4;\n}\n\nif (x == Double.NEGATIVE_INFINITY) {\nreturn -Math.PI * F_3_4;\n}\n\nreturn -Math.PI * F_1_2;\n}\n\nif (x == Double.POSITIVE_INFINITY) {\nif (y > 0 || 1 / y > 0) {\nreturn 0d;\n}\n\nif (y < 0 || 1 / y < 0) {\nreturn -0d;\n}\n}\n\nif (x == Double.NEGATIVE_INFINITY)\n{\nif (y > 0.0 || 1 / y > 0.0) {\nreturn Math.PI;\n}\n\nif (y < 0 || 1 / y < 0) {\nreturn -Math.PI;\n}\n}\n\n// Neither y nor x can be infinite or NAN here\n\nif (x == 0) {\nif (y > 0 || 1 / y > 0) {\nreturn Math.PI * F_1_2;\n}\n\nif (y < 0 || 1 / y < 0) {\nreturn -Math.PI * F_1_2;\n}\n}\n\n// Compute ratio r = y/x\nfinal double r = y / x;\nif (Double.isInfinite(r)) { // bypass calculations that can create NaN\nreturn atan(r, 0, x < 0);\n}\n\ndouble ra = doubleHighPart(r);\ndouble rb = r - ra;\n\n// Split x\nfinal double xa = doubleHighPart(x);\nfinal double xb = x - xa;\n\nrb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\nfinal double temp = ra + rb;\nrb = -(temp - ra - rb);\nra = temp;\n\nif (ra == 0) { // Fix up the sign so atan works correctly\nra = copySign(0d, y);\n}\n\n// Call atan\nfinal double result = atan(ra, rb, x < 0);\n\nreturn result;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sinQ(DD)D",
            "method_body": "private static double sinQ(double xa, double xb) {\nint idx = (int) ((xa * 8.0) + 0.5);\nfinal double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n// Table lookups\nfinal double sintA = SINE_TABLE_A[idx];\nfinal double sintB = SINE_TABLE_B[idx];\nfinal double costA = COSINE_TABLE_A[idx];\nfinal double costB = COSINE_TABLE_B[idx];\n\n// Polynomial eval of sin(epsilon), cos(epsilon)\ndouble sinEpsA = epsilon;\ndouble sinEpsB = polySine(epsilon);\nfinal double cosEpsA = 1.0;\nfinal double cosEpsB = polyCosine(epsilon);\n\n// Split epsilon   xa + xb = x\nfinal double temp = sinEpsA * HEX_40000000;\ndouble temp2 = (sinEpsA + temp) - temp;\nsinEpsB +=  sinEpsA - temp2;\nsinEpsA = temp2;\n\n/* Compute sin(x) by angle addition formula */\ndouble result;\n\n/* Compute the following sum:\n*\n* result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n*          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n*\n* Ranges of elements\n*\n* xxxtA   0            PI/2\n* xxxtB   -1.5e-9      1.5e-9\n* sinEpsA -0.0625      0.0625\n* sinEpsB -6e-11       6e-11\n* cosEpsA  1.0\n* cosEpsB  0           -0.0625\n*\n*/\n\n//result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n//          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n//result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n//result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\ndouble a = 0;\ndouble b = 0;\n\ndouble t = sintA;\ndouble c = a + t;\ndouble d = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA * sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nb = b + sintA * cosEpsB + costA * sinEpsB;\n/*\nt = sintA*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nb = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n/*\nt = sintB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = sintB*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nif (xb != 0.0) {\nt = ((costA + costB) * (cosEpsA + cosEpsB) -\n(sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n}\n\nresult = a + b;\n\nreturn result;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.fitting.WeightedObservedPoint:getX()D",
            "method_body": "public double getX() {\nreturn x;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xa;\ndouble xb = 0.0;\n\n/* Take absolute value of the input */\nxa = x;\nif (x < 0) {\nnegative = true;\nxa = -xa;\n}\n\n/* Check for zero and negative zero */\nif (xa == 0.0) {\nlong bits = Double.doubleToLongBits(x);\nif (bits < 0) {\nreturn -0.0;\n}\nreturn 0.0;\n}\n\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nreturn Double.NaN;\n}\n\n/* Perform any argument reduction */\nif (xa > 3294198.0) {\n// PI * (2**20)\n// Argument too big for CodyWaite reduction.  Must use\n// PayneHanek.\ndouble reduceResults[] = new double[3];\nreducePayneHanek(xa, reduceResults);\nquadrant = ((int) reduceResults[0]) & 3;\nxa = reduceResults[1];\nxb = reduceResults[2];\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa, xb);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\n}\n\nif (negative) {\nquadrant ^= 2;  // Flip bit 1\n}\n\nswitch (quadrant) {\ncase 0:\nreturn sinQ(xa, xb);\ncase 1:\nreturn cosQ(xa, xb);\ncase 2:\nreturn -sinQ(xa, xb);\ncase 3:\nreturn -cosQ(xa, xb);\ndefault:\nreturn Double.NaN;\n}\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.fitting.WeightedObservedPoint:getY()D",
            "method_body": "public double getY() {\nreturn y;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\n\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\n\nreturn p;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cosQ(DD)D",
            "method_body": "private static double cosQ(double xa, double xb) {\nfinal double pi2a = 1.5707963267948966;\nfinal double pi2b = 6.123233995736766E-17;\n\nfinal double a = pi2a - xa;\ndouble b = -(a - pi2a + xa);\nb += pi2b - xb;\n\nreturn sinQ(a, b);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cos(D)D",
            "method_body": "public static double cos(double x) {\nint quadrant = 0;\n\n/* Take absolute value of the input */\ndouble xa = x;\nif (x < 0) {\nxa = -xa;\n}\n\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nreturn Double.NaN;\n}\n\n/* Perform any argument reduction */\ndouble xb = 0;\nif (xa > 3294198.0) {\n// PI * (2**20)\n// Argument too big for CodyWaite reduction.  Must use\n// PayneHanek.\ndouble reduceResults[] = new double[3];\nreducePayneHanek(xa, reduceResults);\nquadrant = ((int) reduceResults[0]) & 3;\nxa = reduceResults[1];\nxb = reduceResults[2];\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa, xb);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\n}\n\n//if (negative)\n//  quadrant = (quadrant + 2) % 4;\n\nswitch (quadrant) {\ncase 0:\nreturn cosQ(xa, xb);\ncase 1:\nreturn -sinQ(xa, xb);\ncase 2:\nreturn -cosQ(xa, xb);\ncase 3:\nreturn sinQ(xa, xb);\ndefault:\nreturn Double.NaN;\n}\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.fitting.HarmonicFitter$ParameterGuesser:guessPhi()V",
            "method_body": "private void guessPhi() {\n// initialize the means\ndouble fcMean = 0;\ndouble fsMean = 0;\n\ndouble currentX = observations[0].getX();\ndouble currentY = observations[0].getY();\nfor (int i = 1; i < observations.length; ++i) {\n// one step forward\nfinal double previousX = currentX;\nfinal double previousY = currentY;\ncurrentX = observations[i].getX();\ncurrentY = observations[i].getY();\nfinal double currentYPrime = (currentY - previousY) / (currentX - previousX);\n\ndouble omegaX = omega * currentX;\ndouble cosine = FastMath.cos(omegaX);\ndouble sine = FastMath.sin(omegaX);\nfcMean += omega * currentY * cosine - currentYPrime * sine;\nfsMean += omega * currentY * sine + currentYPrime * cosine;\n}\n\nphi = FastMath.atan2(-fsMean, fcMean);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.fitting.HarmonicFitter$ParameterGuesser:sortObservations()V",
            "method_body": "private void sortObservations() {\n// Since the samples are almost always already sorted, this\n// method is implemented as an insertion sort that reorders the\n// elements in place. Insertion sort is very efficient in this case.\nWeightedObservedPoint curr = observations[0];\nfor (int j = 1; j < observations.length; ++j) {\nWeightedObservedPoint prec = curr;\ncurr = observations[j];\nif (curr.getX() < prec.getX()) {\n// the current element should be inserted closer to the beginning\nint i = j - 1;\nWeightedObservedPoint mI = observations[i];\nwhile ((i >= 0) && (curr.getX() < mI.getX())) {\nobservations[i + 1] = mI;\nif (i-- != 0) {\nmI = observations[i];\n}\n}\nobservations[i + 1] = curr;\ncurr = observations[j];\n}\n}\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.optimization.fitting.HarmonicFitter$ParameterGuesser:guess()[D",
            "method_body": "public double[] guess() {\nsortObservations();\nguessAOmega();\nguessPhi();\nreturn new double[] { a, omega, phi };\n}",
            "method_id": 15
        }
    ]
}