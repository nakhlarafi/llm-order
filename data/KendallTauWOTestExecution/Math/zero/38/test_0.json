{
    "bug_id": 38,
    "test_id": 0,
    "test_name": "org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest.testConstrainedRosenWithMoreInterpolationPoints",
    "test_body": "public void testConstrainedRosenWithMoreInterpolationPoints() {\nfinal double[] startPoint = point(DIM, 0.1);\nfinal double[][] boundaries = boundaries(DIM, -1, 2);\nfinal RealPointValuePair expected = new RealPointValuePair(point(DIM, 1.0), 0.0);\n// This should have been 78 because in the code the hard limit is\n// said to be\n//   ((DIM + 1) * (DIM + 2)) / 2 - (2 * DIM + 1)\n// i.e. 78 in this case, but the test fails for 48, 59, 62, 63, 64,\n// 65, 66, ...\nfinal int maxAdditionalPoints = 47;\nfor (int num = 1; num <= maxAdditionalPoints; num++) {\ndoTest(new Rosen(), startPoint, boundaries,\nGoalType.MINIMIZE,\n1e-12, 1e-6, 2000,\nnum,\nexpected,\n\"num=\" + num);\n}\n}\n",
    "stack_trace": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer$PathIsExploredException: If this exception is thrown, just remove it from the code prelim (at line 1752)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.prelim(BOBYQAOptimizer.java:1752)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.bobyqb(BOBYQAOptimizer.java:407)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.bobyqa(BOBYQAOptimizer.java:332)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizer.doOptimize(BOBYQAOptimizer.java:244)\nat org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer.optimize(BaseAbstractMultivariateOptimizer.java:125)\nat org.apache.commons.math.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer.optimize(BaseAbstractMultivariateSimpleBoundsOptimizer.java:138)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest.doTest(BOBYQAOptimizerTest.java:327)\nat org.apache.commons.math.optimization.direct.BOBYQAOptimizerTest.testConstrainedRosenWithMoreInterpolationPoints(BOBYQAOptimizerTest.java:255)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:getDimension()I",
            "method_body": "public int getDimension() {\nreturn data.length;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:setEntry(IID)V",
            "method_body": "public void setEntry(final int row, final int column, final double value) {\nMatrixUtils.checkMatrixIndex(this, row, column);\ndata[row][column] = value;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column) {\nMatrixUtils.checkMatrixIndex(this, row, column);\nreturn data[row][column];\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:optimize(ILorg/apache/commons/math/analysis/MultivariateFunction;Lorg/apache/commons/math/optimization/GoalType;[D[D[D)Lorg/apache/commons/math/optimization/RealPointValuePair;",
            "method_body": "public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\ndouble[] startPoint,\ndouble[] lower, double[] upper) {\n// Checks.\nfinal int dim = startPoint.length;\nif (lower != null) {\nif (lower.length != dim) {\nthrow new DimensionMismatchException(lower.length, dim);\n}\nfor (int i = 0; i < dim; i++) {\nfinal double v = startPoint[i];\nfinal double lo = lower[i];\nif (v < lo) {\nthrow new NumberIsTooSmallException(v, lo, true);\n}\n}\n}\nif (upper != null) {\nif (upper.length != dim) {\nthrow new DimensionMismatchException(upper.length, dim);\n}\nfor (int i = 0; i < dim; i++) {\nfinal double v = startPoint[i];\nfinal double hi = upper[i];\nif (v > hi) {\nthrow new NumberIsTooLargeException(v, hi, true);\n}\n}\n}\n\n// Initialization.\nif (lower == null) {\nlowerBound = new double[dim];\nfor (int i = 0; i < dim; i++) {\nlowerBound[i] = Double.NEGATIVE_INFINITY;\n}\n} else {\nlowerBound = lower.clone();\n}\nif (upper == null) {\nupperBound = new double[dim];\nfor (int i = 0; i < dim; i++) {\nupperBound[i] = Double.POSITIVE_INFINITY;\n}\n} else {\nupperBound = upper.clone();\n}\n\n// Base class method performs the non bound-specific initializations.\nreturn super.optimize(maxEval, f, goalType, startPoint);\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:getGoalType()Lorg/apache/commons/math/optimization/GoalType;",
            "method_body": "public GoalType getGoalType() {\nreturn goal;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:checkMatrixIndex(Lorg/apache/commons/math/linear/AnyMatrix;II)V",
            "method_body": "public static void checkMatrixIndex(final AnyMatrix m,\nfinal int row, final int column) {\ncheckRowIndex(m, row);\ncheckColumnIndex(m, column);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:getStartPoint()[D",
            "method_body": "public double[] getStartPoint() {\nreturn start.clone();\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.linear.AbstractRealMatrix:<init>(II)V",
            "method_body": "protected AbstractRealMatrix(final int rowDimension, final int columnDimension) {\nif (rowDimension < 1) {\nthrow new NotStrictlyPositiveException(rowDimension);\n}\nif (columnDimension < 1) {\nthrow new NotStrictlyPositiveException(columnDimension);\n}\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension, final int columnDimension) {\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() {\nif (++count > maximalCount) {\nmaxCountCallback.trigger(maximalCount);\n}\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:getUpperBound()[D",
            "method_body": "public double[] getUpperBound() {\nreturn upperBound.clone();\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:<init>([D)V",
            "method_body": "public ArrayRealVector(double[] d) {\ndata = d.clone();\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:caller(I)Ljava/lang/String;",
            "method_body": "private static String caller(int n) {\nfinal Throwable t = new Throwable();\nfinal StackTraceElement[] elements = t.getStackTrace();\nfinal StackTraceElement e = elements[n];\nreturn e.getMethodName() + \" (at line \" + e.getLineNumber() + \")\";\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:prelim([D[D)V",
            "method_body": "private void prelim(double[] lowerBound,\ndouble[] upperBound) {\nprintMethod(); // XXX\n\nfinal int n = currentBest.getDimension();\nfinal int npt = numberOfInterpolationPoints;\nfinal int ndim = bMatrix.getRowDimension();\n\nfinal double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\nfinal double recip = 1d / rhosq;\nfinal int np = n + 1;\n\n// Set XBASE to the initial vector of variables, and set the initial\n// elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n\nfor (int j = 0; j < n; j++) {\noriginShift.setEntry(j, currentBest.getEntry(j));\nfor (int k = 0; k < npt; k++) {\ninterpolationPoints.setEntry(k, j, ZERO);\n}\nfor (int i = 0; i < ndim; i++) {\nbMatrix.setEntry(i, j, ZERO);\n}\n}\nfor (int i = 0, max = n * np / 2; i < max; i++) {\nmodelSecondDerivativesValues.setEntry(i, ZERO);\n}\nfor (int k = 0; k < npt; k++) {\nmodelSecondDerivativesParameters.setEntry(k, ZERO);\nfor (int j = 0, max = npt - np; j < max; j++) {\nzMatrix.setEntry(k, j, ZERO);\n}\n}\n\n// Begin the initialization procedure. NF becomes one more than the number\n// of function values so far. The coordinates of the displacement of the\n// next initial interpolation point from XBASE are set in XPT(NF+1,.).\n\nint ipt = 0;\nint jpt = 0;\ndouble fbeg = Double.NaN;\ndo {\nfinal int nfm = getEvaluations();\nfinal int nfx = nfm - n;\nfinal int nfmm = nfm - 1;\nfinal int nfxm = nfx - 1;\ndouble stepa = 0;\ndouble stepb = 0;\nif (nfm <= 2 * n) {\nif (nfm >= 1 &&\nnfm <= n) {\nstepa = initialTrustRegionRadius;\nif (upperDifference.getEntry(nfmm) == ZERO) {\nstepa = -stepa;\nthrow new PathIsExploredException(); // XXX\n}\ninterpolationPoints.setEntry(nfm, nfmm, stepa);\n} else if (nfm > n) {\nstepa = interpolationPoints.getEntry(nfx, nfxm);\nstepb = -initialTrustRegionRadius;\nif (lowerDifference.getEntry(nfxm) == ZERO) {\nstepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\nthrow new PathIsExploredException(); // XXX\n}\nif (upperDifference.getEntry(nfxm) == ZERO) {\nstepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\nthrow new PathIsExploredException(); // XXX\n}\ninterpolationPoints.setEntry(nfm, nfxm, stepb);\n}\n} else {\nfinal int tmp1 = (nfm - np) / n;\njpt = nfm - tmp1 * n - n;\nipt = jpt + tmp1;\nif (ipt > n) {\nfinal int tmp2 = jpt;\njpt = ipt - n;\nipt = tmp2;\nthrow new PathIsExploredException(); // XXX\n}\nfinal int iptMinus1 = ipt;\nfinal int jptMinus1 = jpt;\ninterpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\ninterpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n}\n\n// Calculate the next value of F. The least function value so far and\n// its index are required.\n\nfor (int j = 0; j < n; j++) {\ncurrentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\noriginShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\nupperBound[j]));\nif (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\ncurrentBest.setEntry(j, lowerBound[j]);\n}\nif (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\ncurrentBest.setEntry(j, upperBound[j]);\n}\n}\n\nfinal double objectiveValue = computeObjectiveValue(currentBest.toArray());\nfinal double f = isMinimize ? objectiveValue : -objectiveValue;\nfinal int numEval = getEvaluations(); // nfm + 1\nfAtInterpolationPoints.setEntry(nfm, f);\n\nif (numEval == 1) {\nfbeg = f;\ntrustRegionCenterInterpolationPointIndex = 0;\n} else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\ntrustRegionCenterInterpolationPointIndex = nfm;\n}\n\n// Set the nonzero initial elements of BMAT and the quadratic model in the\n// cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n// of the NF-th and (NF-N)-th interpolation points may be switched, in\n// order that the function value at the first of them contributes to the\n// off-diagonal second derivative terms of the initial quadratic model.\n\nif (numEval <= 2 * n + 1) {\nif (numEval >= 2 &&\nnumEval <= n + 1) {\ngradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\nif (npt < numEval + n) {\nfinal double oneOverStepA = ONE / stepa;\nbMatrix.setEntry(0, nfmm, -oneOverStepA);\nbMatrix.setEntry(nfm, nfmm, oneOverStepA);\nbMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\nthrow new PathIsExploredException(); // XXX\n}\n} else if (numEval >= n + 2) {\nfinal int ih = nfx * (nfx + 1) / 2 - 1;\nfinal double tmp = (f - fbeg) / stepb;\nfinal double diff = stepb - stepa;\nmodelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\ngradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\nif (stepa * stepb < ZERO) {\nif (f < fAtInterpolationPoints.getEntry(nfm - n)) {\nfAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\nfAtInterpolationPoints.setEntry(nfm - n, f);\nif (trustRegionCenterInterpolationPointIndex == nfm) {\ntrustRegionCenterInterpolationPointIndex = nfm - n;\n}\ninterpolationPoints.setEntry(nfm - n, nfxm, stepb);\ninterpolationPoints.setEntry(nfm, nfxm, stepa);\n}\n}\nbMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\nbMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\nbMatrix.setEntry(nfm - n, nfxm,\n-bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\nzMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\nzMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n// zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\nzMatrix.setEntry(nfm - n, nfxm,\n-zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n}\n\n// Set the off-diagonal second derivatives of the Lagrange functions and\n// the initial quadratic model.\n\n} else {\nzMatrix.setEntry(0, nfxm, recip);\nzMatrix.setEntry(nfm, nfxm, recip);\nzMatrix.setEntry(ipt, nfxm, -recip);\nzMatrix.setEntry(jpt, nfxm, -recip);\n\nfinal int ih = ipt * (ipt - 1) / 2 + jpt - 1;\nfinal double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\nmodelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\nthrow new PathIsExploredException(); // XXX\n}\n} while (getEvaluations() < npt);\n} // prelim",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:getCount()I",
            "method_body": "public int getCount() {\nreturn count;\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:<init>(I)V",
            "method_body": "public BOBYQAOptimizer(int numberOfInterpolationPoints) {\nthis(numberOfInterpolationPoints,\nDEFAULT_INITIAL_RADIUS,\nDEFAULT_STOPPING_RADIUS);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer$PathIsExploredException:<init>()V",
            "method_body": "PathIsExploredException() {\nsuper(PATH_IS_EXPLORED + \" \" + BOBYQAOptimizer.caller(3));\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:<init>(I)V",
            "method_body": "public ArrayRealVector(int size) {\ndata = new double[size];\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math.optimization.AbstractConvergenceChecker:<init>()V",
            "method_body": "public AbstractConvergenceChecker() {\nthis.relativeThreshold = DEFAULT_RELATIVE_THRESHOLD;\nthis.absoluteThreshold = DEFAULT_ABSOLUTE_THRESHOLD;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:getEvaluations()I",
            "method_body": "public int getEvaluations() {\nreturn evaluations.getCount();\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:toArray()[D",
            "method_body": "public double[] toArray(){\nreturn data.clone();\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:<init>(Lorg/apache/commons/math/optimization/ConvergenceChecker;)V",
            "method_body": "protected BaseAbstractMultivariateOptimizer(ConvergenceChecker<RealPointValuePair> checker) {\nthis.checker = checker;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:<init>()V",
            "method_body": "protected BaseAbstractMultivariateOptimizer() {\nthis(new SimpleScalarValueChecker());\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:getEntry(I)D",
            "method_body": "public double getEntry(int index) {\nreturn data[index];\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn (data == null) ? 0 : data.length;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:computeObjectiveValue([D)D",
            "method_body": "protected double computeObjectiveValue(double[] point) {\ntry {\nevaluations.incrementCount();\n} catch (MaxCountExceededException e) {\nthrow new TooManyEvaluationsException(e.getMax());\n}\nreturn function.value(point);\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math.linear.Array2DRowRealMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:checkRowIndex(Lorg/apache/commons/math/linear/AnyMatrix;I)V",
            "method_body": "public static void checkRowIndex(final AnyMatrix m, final int row) {\nif (row < 0 ||\nrow >= m.getRowDimension()) {\nthrow new OutOfRangeException(LocalizedFormats.ROW_INDEX,\nrow, 0, m.getRowDimension() - 1);\n}\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:<init>(ILorg/apache/commons/math/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max,\nMaxCountExceededCallback cb) {\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:<init>(IDD)V",
            "method_body": "public BOBYQAOptimizer(int numberOfInterpolationPoints,\ndouble initialTrustRegionRadius,\ndouble stoppingTrustRegionRadius) {\nthis.numberOfInterpolationPoints = numberOfInterpolationPoints;\nthis.initialTrustRegionRadius = initialTrustRegionRadius;\nthis.stoppingTrustRegionRadius = stoppingTrustRegionRadius;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:bobyqb([D[D)D",
            "method_body": "private double bobyqb(double[] lowerBound,\ndouble[] upperBound) {\nprintMethod(); // XXX\n\nfinal int n = currentBest.getDimension();\nfinal int npt = numberOfInterpolationPoints;\nfinal int np = n + 1;\nfinal int nptm = npt - np;\nfinal int nh = n * np / 2;\n\nfinal ArrayRealVector work1 = new ArrayRealVector(n);\nfinal ArrayRealVector work2 = new ArrayRealVector(npt);\nfinal ArrayRealVector work3 = new ArrayRealVector(npt);\n\ndouble cauchy = Double.NaN;\ndouble alpha = Double.NaN;\ndouble dsq = Double.NaN;\ndouble crvmin = Double.NaN;\n\n// Set some constants.\n// Parameter adjustments\n\n// Function Body\n\n// The call of PRELIM sets the elements of XBASE, XPT, FVAL, GOPT, HQ, PQ,\n// BMAT and ZMAT for the first iteration, with the corresponding values of\n// of NF and KOPT, which are the number of calls of CALFUN so far and the\n// index of the interpolation point at the trust region centre. Then the\n// initial XOPT is set too. The branch to label 720 occurs if MAXFUN is\n// less than NPT. GOPT will be updated if KOPT is different from KBASE.\n\ntrustRegionCenterInterpolationPointIndex = 0;\n\nprelim(lowerBound, upperBound);\ndouble xoptsq = ZERO;\nfor (int i = 0; i < n; i++) {\ntrustRegionCenterOffset.setEntry(i, interpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex, i));\n// Computing 2nd power\nfinal double deltaOne = trustRegionCenterOffset.getEntry(i);\nxoptsq += deltaOne * deltaOne;\n}\ndouble fsave = fAtInterpolationPoints.getEntry(0);\nfinal int kbase = 0;\n\n// Complete the settings that are required for the iterative procedure.\n\nint ntrits = 0;\nint itest = 0;\nint knew = 0;\nint nfsav = getEvaluations();\ndouble rho = initialTrustRegionRadius;\ndouble delta = rho;\ndouble diffa = ZERO;\ndouble diffb = ZERO;\ndouble diffc = ZERO;\ndouble f = ZERO;\ndouble beta = ZERO;\ndouble adelt = ZERO;\ndouble denom = ZERO;\ndouble ratio = ZERO;\ndouble dnorm = ZERO;\ndouble scaden = ZERO;\ndouble biglsq = ZERO;\ndouble distsq = ZERO;\n\n// Update GOPT if necessary before the first iteration and after each\n// call of RESCUE that makes a call of CALFUN.\n\nint state = 20;\nfor(;;) switch (state) {\ncase 20: {\nprintState(20); // XXX\nif (trustRegionCenterInterpolationPointIndex != kbase) {\nint ih = 0;\nfor (int j = 0; j < n; j++) {\nfor (int i = 0; i <= j; i++) {\nif (i < j) {\ngradientAtTrustRegionCenter.setEntry(j,  gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(i));\n}\ngradientAtTrustRegionCenter.setEntry(i,  gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trustRegionCenterOffset.getEntry(j));\nih++;\n}\n}\nif (getEvaluations() > npt) {\nfor (int k = 0; k < npt; k++) {\ndouble temp = ZERO;\nfor (int j = 0; j < n; j++) {\ntemp += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n}\ntemp *= modelSecondDerivativesParameters.getEntry(k);\nfor (int i = 0; i < n; i++) {\ngradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n}\n}\nthrow new PathIsExploredException(); // XXX\n}\n}\n\n// Generate the next point in the trust region that provides a small value\n// of the quadratic model subject to the constraints on the variables.\n// The int NTRITS is set to the number \"trust region\" iterations that\n// have occurred since the last \"alternative\" iteration. If the length\n// of XNEW-XOPT is less than HALF*RHO, however, then there is a branch to\n// label 650 or 680 with NTRITS=-1, instead of calculating F at XNEW.\n\n}\ncase 60: {\nprintState(60); // XXX\nfinal ArrayRealVector gnew = new ArrayRealVector(n);\nfinal ArrayRealVector xbdi = new ArrayRealVector(n);\nfinal ArrayRealVector s = new ArrayRealVector(n);\nfinal ArrayRealVector hs = new ArrayRealVector(n);\nfinal ArrayRealVector hred = new ArrayRealVector(n);\n\nfinal double[] dsqCrvmin = trsbox(delta, gnew, xbdi, s,\nhs, hred);\ndsq = dsqCrvmin[0];\ncrvmin = dsqCrvmin[1];\n\n// Computing MIN\ndouble deltaOne = delta;\ndouble deltaTwo = Math.sqrt(dsq);\ndnorm = Math.min(deltaOne, deltaTwo);\nif (dnorm < HALF * rho) {\nntrits = -1;\n// Computing 2nd power\ndeltaOne = TEN * rho;\ndistsq = deltaOne * deltaOne;\nif (getEvaluations() <= nfsav + 2) {\nstate = 650; break;\n}\n\n// The following choice between labels 650 and 680 depends on whether or\n// not our work with the current RHO seems to be complete. Either RHO is\n// decreased or termination occurs if the errors in the quadratic model at\n// the last three interpolation points compare favourably with predictions\n// of likely improvements to the model within distance HALF*RHO of XOPT.\n\n// Computing MAX\ndeltaOne = Math.max(diffa, diffb);\nfinal double errbig = Math.max(deltaOne, diffc);\nfinal double frhosq = rho * ONE_OVER_EIGHT * rho;\nif (crvmin > ZERO &&\nerrbig > frhosq * crvmin) {\nstate = 650; break;\n}\nfinal double bdtol = errbig / rho;\nfor (int j = 0; j < n; j++) {\ndouble bdtest = bdtol;\nif (newPoint.getEntry(j) == lowerDifference.getEntry(j)) {\nbdtest = work1.getEntry(j);\n}\nif (newPoint.getEntry(j) == upperDifference.getEntry(j)) {\nbdtest = -work1.getEntry(j);\n}\nif (bdtest < bdtol) {\ndouble curv = modelSecondDerivativesValues.getEntry((j + j * j) / 2);\nfor (int k = 0; k < npt; k++) {\n// Computing 2nd power\nfinal double d1 = interpolationPoints.getEntry(k, j);\ncurv += modelSecondDerivativesParameters.getEntry(k) * (d1 * d1);\n}\nbdtest += HALF * curv * rho;\nif (bdtest < bdtol) {\nstate = 650; break;\n}\nthrow new PathIsExploredException(); // XXX\n}\n}\nstate = 680; break;\n}\n++ntrits;\n\n// Severe cancellation is likely to occur if XOPT is too far from XBASE.\n// If the following test holds, then XBASE is shifted so that XOPT becomes\n// zero. The appropriate changes are made to BMAT and to the second\n// derivatives of the current model, beginning with the changes to BMAT\n// that do not depend on ZMAT. VLAG is used temporarily for working space.\n\n}\ncase 90: {\nprintState(90); // XXX\nif (dsq <= xoptsq * ONE_OVER_A_THOUSAND) {\nfinal double fracsq = xoptsq * ONE_OVER_FOUR;\ndouble sumpq = ZERO;\n// final RealVector sumVector\n//     = new ArrayRealVector(npt, -HALF * xoptsq).add(interpolationPoints.operate(trustRegionCenter));\nfor (int k = 0; k < npt; k++) {\nsumpq += modelSecondDerivativesParameters.getEntry(k);\ndouble sum = -HALF * xoptsq;\nfor (int i = 0; i < n; i++) {\nsum += interpolationPoints.getEntry(k, i) * trustRegionCenterOffset.getEntry(i);\n}\n// sum = sumVector.getEntry(k); // XXX \"testAckley\" and \"testDiffPow\" fail.\nwork2.setEntry(k, sum);\nfinal double temp = fracsq - HALF * sum;\nfor (int i = 0; i < n; i++) {\nwork1.setEntry(i, bMatrix.getEntry(k, i));\nlagrangeValuesAtNewPoint.setEntry(i, sum * interpolationPoints.getEntry(k, i) + temp * trustRegionCenterOffset.getEntry(i));\nfinal int ip = npt + i;\nfor (int j = 0; j <= i; j++) {\nbMatrix.setEntry(ip, j,\nbMatrix.getEntry(ip, j)\n+ work1.getEntry(i) * lagrangeValuesAtNewPoint.getEntry(j)\n+ lagrangeValuesAtNewPoint.getEntry(i) * work1.getEntry(j));\n}\n}\n}\n\n// Then the revisions of BMAT that depend on ZMAT are calculated.\n\nfor (int m = 0; m < nptm; m++) {\ndouble sumz = ZERO;\ndouble sumw = ZERO;\nfor (int k = 0; k < npt; k++) {\nsumz += zMatrix.getEntry(k, m);\nlagrangeValuesAtNewPoint.setEntry(k, work2.getEntry(k) * zMatrix.getEntry(k, m));\nsumw += lagrangeValuesAtNewPoint.getEntry(k);\n}\nfor (int j = 0; j < n; j++) {\ndouble sum = (fracsq * sumz - HALF * sumw) * trustRegionCenterOffset.getEntry(j);\nfor (int k = 0; k < npt; k++) {\nsum += lagrangeValuesAtNewPoint.getEntry(k) * interpolationPoints.getEntry(k, j);\n}\nwork1.setEntry(j, sum);\nfor (int k = 0; k < npt; k++) {\nbMatrix.setEntry(k, j,\nbMatrix.getEntry(k, j)\n+ sum * zMatrix.getEntry(k, m));\n}\n}\nfor (int i = 0; i < n; i++) {\nfinal int ip = i + npt;\nfinal double temp = work1.getEntry(i);\nfor (int j = 0; j <= i; j++) {\nbMatrix.setEntry(ip, j,\nbMatrix.getEntry(ip, j)\n+ temp * work1.getEntry(j));\n}\n}\n}\n\n// The following instructions complete the shift, including the changes\n// to the second derivative parameters of the quadratic model.\n\nint ih = 0;\nfor (int j = 0; j < n; j++) {\nwork1.setEntry(j, -HALF * sumpq * trustRegionCenterOffset.getEntry(j));\nfor (int k = 0; k < npt; k++) {\nwork1.setEntry(j, work1.getEntry(j) + modelSecondDerivativesParameters.getEntry(k) * interpolationPoints.getEntry(k, j));\ninterpolationPoints.setEntry(k, j, interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j));\n}\nfor (int i = 0; i <= j; i++) {\nmodelSecondDerivativesValues.setEntry(ih,\nmodelSecondDerivativesValues.getEntry(ih)\n+ work1.getEntry(i) * trustRegionCenterOffset.getEntry(j)\n+ trustRegionCenterOffset.getEntry(i) * work1.getEntry(j));\nbMatrix.setEntry(npt + i, j, bMatrix.getEntry(npt + j, i));\nih++;\n}\n}\nfor (int i = 0; i < n; i++) {\noriginShift.setEntry(i, originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i));\nnewPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\nlowerDifference.setEntry(i, lowerDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\nupperDifference.setEntry(i, upperDifference.getEntry(i) - trustRegionCenterOffset.getEntry(i));\ntrustRegionCenterOffset.setEntry(i, ZERO);\n}\nxoptsq = ZERO;\n}\nif (ntrits == 0) {\nstate = 210; break;\n}\nstate = 230; break;\n\n// XBASE is also moved to XOPT by a call of RESCUE. This calculation is\n// more expensive than the previous shift, because new matrices BMAT and\n// ZMAT are generated from scratch, which may include the replacement of\n// interpolation points whose positions seem to be causing near linear\n// dependence in the interpolation conditions. Therefore RESCUE is called\n// only if rounding errors have reduced by at least a factor of two the\n// denominator of the formula for updating the H matrix. It provides a\n// useful safeguard, but is not invoked in most applications of BOBYQA.\n\n}\ncase 210: {\nprintState(210); // XXX\n// Pick two alternative vectors of variables, relative to XBASE, that\n// are suitable as new positions of the KNEW-th interpolation point.\n// Firstly, XNEW is set to the point on a line through XOPT and another\n// interpolation point that minimizes the predicted value of the next\n// denominator, subject to ||XNEW - XOPT|| .LEQ. ADELT and to the SL\n// and SU bounds. Secondly, XALT is set to the best feasible point on\n// a constrained version of the Cauchy step of the KNEW-th Lagrange\n// function, the corresponding value of the square of this function\n// being returned in CAUCHY. The choice between these alternatives is\n// going to be made when the denominator is calculated.\n\nfinal double[] alphaCauchy = altmov(knew, adelt);\nalpha = alphaCauchy[0];\ncauchy = alphaCauchy[1];\n\nfor (int i = 0; i < n; i++) {\ntrialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n}\n\n// Calculate VLAG and BETA for the current choice of D. The scalar\n// product of D with XPT(K,.) is going to be held in W(NPT+K) for\n// use when VQUAD is calculated.\n\n}\ncase 230: {\nprintState(230); // XXX\nfor (int k = 0; k < npt; k++) {\ndouble suma = ZERO;\ndouble sumb = ZERO;\ndouble sum = ZERO;\nfor (int j = 0; j < n; j++) {\nsuma += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\nsumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\nsum += bMatrix.getEntry(k, j) * trialStepPoint.getEntry(j);\n}\nwork3.setEntry(k, suma * (HALF * suma + sumb));\nlagrangeValuesAtNewPoint.setEntry(k, sum);\nwork2.setEntry(k, suma);\n}\nbeta = ZERO;\nfor (int m = 0; m < nptm; m++) {\ndouble sum = ZERO;\nfor (int k = 0; k < npt; k++) {\nsum += zMatrix.getEntry(k, m) * work3.getEntry(k);\n}\nbeta -= sum * sum;\nfor (int k = 0; k < npt; k++) {\nlagrangeValuesAtNewPoint.setEntry(k, lagrangeValuesAtNewPoint.getEntry(k) + sum * zMatrix.getEntry(k, m));\n}\n}\ndsq = ZERO;\ndouble bsum = ZERO;\ndouble dx = ZERO;\nfor (int j = 0; j < n; j++) {\n// Computing 2nd power\nfinal double d1 = trialStepPoint.getEntry(j);\ndsq += d1 * d1;\ndouble sum = ZERO;\nfor (int k = 0; k < npt; k++) {\nsum += work3.getEntry(k) * bMatrix.getEntry(k, j);\n}\nbsum += sum * trialStepPoint.getEntry(j);\nfinal int jp = npt + j;\nfor (int i = 0; i < n; i++) {\nsum += bMatrix.getEntry(jp, i) * trialStepPoint.getEntry(i);\n}\nlagrangeValuesAtNewPoint.setEntry(jp, sum);\nbsum += sum * trialStepPoint.getEntry(j);\ndx += trialStepPoint.getEntry(j) * trustRegionCenterOffset.getEntry(j);\n}\n\nbeta = dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) + beta - bsum; // Original\n// beta += dx * dx + dsq * (xoptsq + dx + dx + HALF * dsq) - bsum; // XXX \"testAckley\" and \"testDiffPow\" fail.\n// beta = dx * dx + dsq * (xoptsq + 2 * dx + HALF * dsq) + beta - bsum; // XXX \"testDiffPow\" fails.\n\nlagrangeValuesAtNewPoint.setEntry(trustRegionCenterInterpolationPointIndex,\nlagrangeValuesAtNewPoint.getEntry(trustRegionCenterInterpolationPointIndex) + ONE);\n\n// If NTRITS is zero, the denominator may be increased by replacing\n// the step D of ALTMOV by a Cauchy step. Then RESCUE may be called if\n// rounding errors have damaged the chosen denominator.\n\nif (ntrits == 0) {\n// Computing 2nd power\nfinal double d1 = lagrangeValuesAtNewPoint.getEntry(knew);\ndenom = d1 * d1 + alpha * beta;\nif (denom < cauchy && cauchy > ZERO) {\nfor (int i = 0; i < n; i++) {\nnewPoint.setEntry(i, alternativeNewPoint.getEntry(i));\ntrialStepPoint.setEntry(i, newPoint.getEntry(i) - trustRegionCenterOffset.getEntry(i));\n}\ncauchy = ZERO; // XXX Useful statement?\nstate = 230; break;\n}\n// Alternatively, if NTRITS is positive, then set KNEW to the index of\n// the next interpolation point to be deleted to make room for a trust\n// region step. Again RESCUE may be called if rounding errors have damaged_\n// the chosen denominator, which is the reason for attempting to select\n// KNEW before calculating the next value of the objective function.\n\n} else {\nfinal double delsq = delta * delta;\nscaden = ZERO;\nbiglsq = ZERO;\nknew = 0;\nfor (int k = 0; k < npt; k++) {\nif (k == trustRegionCenterInterpolationPointIndex) {\ncontinue;\n}\ndouble hdiag = ZERO;\nfor (int m = 0; m < nptm; m++) {\n// Computing 2nd power\nfinal double d1 = zMatrix.getEntry(k, m);\nhdiag += d1 * d1;\n}\n// Computing 2nd power\nfinal double d2 = lagrangeValuesAtNewPoint.getEntry(k);\nfinal double den = beta * hdiag + d2 * d2;\ndistsq = ZERO;\nfor (int j = 0; j < n; j++) {\n// Computing 2nd power\nfinal double d3 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\ndistsq += d3 * d3;\n}\n// Computing MAX\n// Computing 2nd power\nfinal double d4 = distsq / delsq;\nfinal double temp = Math.max(ONE, d4 * d4);\nif (temp * den > scaden) {\nscaden = temp * den;\nknew = k;\ndenom = den;\n}\n// Computing MAX\n// Computing 2nd power\nfinal double d5 = lagrangeValuesAtNewPoint.getEntry(k);\nbiglsq = Math.max(biglsq, temp * (d5 * d5));\n}\n}\n\n// Put the variables for the next calculation of the objective function\n//   in XNEW, with any adjustments for the bounds.\n\n// Calculate the value of the objective function at XBASE+XNEW, unless\n//   the limit on the number of calculations of F has been reached.\n\n}\ncase 360: {\nprintState(360); // XXX\nfor (int i = 0; i < n; i++) {\n// Computing MIN\n// Computing MAX\nfinal double d3 = lowerBound[i];\nfinal double d4 = originShift.getEntry(i) + newPoint.getEntry(i);\nfinal double d1 = Math.max(d3, d4);\nfinal double d2 = upperBound[i];\ncurrentBest.setEntry(i, Math.min(d1, d2));\nif (newPoint.getEntry(i) == lowerDifference.getEntry(i)) {\ncurrentBest.setEntry(i, lowerBound[i]);\n}\nif (newPoint.getEntry(i) == upperDifference.getEntry(i)) {\ncurrentBest.setEntry(i, upperBound[i]);\n}\n}\n\nf = computeObjectiveValue(currentBest.toArray());\n\nif (!isMinimize)\nf = -f;\nif (ntrits == -1) {\nfsave = f;\nstate = 720; break;\n}\n\n// Use the quadratic model to predict the change in F due to the step D,\n//   and set DIFF to the error of this prediction.\n\nfinal double fopt = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\ndouble vquad = ZERO;\nint ih = 0;\nfor (int j = 0; j < n; j++) {\nvquad += trialStepPoint.getEntry(j) * gradientAtTrustRegionCenter.getEntry(j);\nfor (int i = 0; i <= j; i++) {\ndouble temp = trialStepPoint.getEntry(i) * trialStepPoint.getEntry(j);\nif (i == j) {\ntemp *= HALF;\n}\nvquad += modelSecondDerivativesValues.getEntry(ih) * temp;\nih++;\n}\n}\nfor (int k = 0; k < npt; k++) {\n// Computing 2nd power\nfinal double d1 = work2.getEntry(k);\nfinal double d2 = d1 * d1; // \"d1\" must be squared first to prevent test failures.\nvquad += HALF * modelSecondDerivativesParameters.getEntry(k) * d2;\n}\nfinal double diff = f - fopt - vquad;\ndiffc = diffb;\ndiffb = diffa;\ndiffa = Math.abs(diff);\nif (dnorm > rho) {\nnfsav = getEvaluations();\n}\n\n// Pick the next value of DELTA after a trust region step.\n\nif (ntrits > 0) {\nif (vquad >= ZERO) {\nthrow new MathIllegalStateException(LocalizedFormats.TRUST_REGION_STEP_FAILED, vquad);\n}\nratio = (f - fopt) / vquad;\nfinal double hDelta = HALF * delta;\nif (ratio <= ONE_OVER_TEN) {\n// Computing MIN\ndelta = Math.min(hDelta, dnorm);\n} else if (ratio <= .7) {\n// Computing MAX\ndelta = Math.max(hDelta, dnorm);\n} else {\n// Computing MAX\ndelta = Math.max(hDelta, 2 * dnorm);\n}\nif (delta <= rho * 1.5) {\ndelta = rho;\n}\n\n// Recalculate KNEW and DENOM if the new F is less than FOPT.\n\nif (f < fopt) {\nfinal int ksav = knew;\nfinal double densav = denom;\nfinal double delsq = delta * delta;\nscaden = ZERO;\nbiglsq = ZERO;\nknew = 0;\nfor (int k = 0; k < npt; k++) {\ndouble hdiag = ZERO;\nfor (int m = 0; m < nptm; m++) {\n// Computing 2nd power\nfinal double d1 = zMatrix.getEntry(k, m);\nhdiag += d1 * d1;\n}\n// Computing 2nd power\nfinal double d1 = lagrangeValuesAtNewPoint.getEntry(k);\nfinal double den = beta * hdiag + d1 * d1;\ndistsq = ZERO;\nfor (int j = 0; j < n; j++) {\n// Computing 2nd power\nfinal double d2 = interpolationPoints.getEntry(k, j) - newPoint.getEntry(j);\ndistsq += d2 * d2;\n}\n// Computing MAX\n// Computing 2nd power\nfinal double d3 = distsq / delsq;\nfinal double temp = Math.max(ONE, d3 * d3);\nif (temp * den > scaden) {\nscaden = temp * den;\nknew = k;\ndenom = den;\n}\n// Computing MAX\n// Computing 2nd power\nfinal double d4 = lagrangeValuesAtNewPoint.getEntry(k);\nfinal double d5 = temp * (d4 * d4);\nbiglsq = Math.max(biglsq, d5);\n}\nif (scaden <= HALF * biglsq) {\nknew = ksav;\ndenom = densav;\n}\n}\n}\n\n// Update BMAT and ZMAT, so that the KNEW-th interpolation point can be\n// moved. Also update the second derivative terms of the model.\n\nupdate(beta, denom, knew);\n\nih = 0;\nfinal double pqold = modelSecondDerivativesParameters.getEntry(knew);\nmodelSecondDerivativesParameters.setEntry(knew, ZERO);\nfor (int i = 0; i < n; i++) {\nfinal double temp = pqold * interpolationPoints.getEntry(knew, i);\nfor (int j = 0; j <= i; j++) {\nmodelSecondDerivativesValues.setEntry(ih, modelSecondDerivativesValues.getEntry(ih) + temp * interpolationPoints.getEntry(knew, j));\nih++;\n}\n}\nfor (int m = 0; m < nptm; m++) {\nfinal double temp = diff * zMatrix.getEntry(knew, m);\nfor (int k = 0; k < npt; k++) {\nmodelSecondDerivativesParameters.setEntry(k, modelSecondDerivativesParameters.getEntry(k) + temp * zMatrix.getEntry(k, m));\n}\n}\n\n// Include the new interpolation point, and make the changes to GOPT at\n// the old XOPT that are caused by the updating of the quadratic model.\n\nfAtInterpolationPoints.setEntry(knew,  f);\nfor (int i = 0; i < n; i++) {\ninterpolationPoints.setEntry(knew, i, newPoint.getEntry(i));\nwork1.setEntry(i, bMatrix.getEntry(knew, i));\n}\nfor (int k = 0; k < npt; k++) {\ndouble suma = ZERO;\nfor (int m = 0; m < nptm; m++) {\nsuma += zMatrix.getEntry(knew, m) * zMatrix.getEntry(k, m);\n}\ndouble sumb = ZERO;\nfor (int j = 0; j < n; j++) {\nsumb += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n}\nfinal double temp = suma * sumb;\nfor (int i = 0; i < n; i++) {\nwork1.setEntry(i, work1.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n}\n}\nfor (int i = 0; i < n; i++) {\ngradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + diff * work1.getEntry(i));\n}\n\n// Update XOPT, GOPT and KOPT if the new calculated F is less than FOPT.\n\nif (f < fopt) {\ntrustRegionCenterInterpolationPointIndex = knew;\nxoptsq = ZERO;\nih = 0;\nfor (int j = 0; j < n; j++) {\ntrustRegionCenterOffset.setEntry(j, newPoint.getEntry(j));\n// Computing 2nd power\nfinal double d1 = trustRegionCenterOffset.getEntry(j);\nxoptsq += d1 * d1;\nfor (int i = 0; i <= j; i++) {\nif (i < j) {\ngradientAtTrustRegionCenter.setEntry(j, gradientAtTrustRegionCenter.getEntry(j) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(i));\n}\ngradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + modelSecondDerivativesValues.getEntry(ih) * trialStepPoint.getEntry(j));\nih++;\n}\n}\nfor (int k = 0; k < npt; k++) {\ndouble temp = ZERO;\nfor (int j = 0; j < n; j++) {\ntemp += interpolationPoints.getEntry(k, j) * trialStepPoint.getEntry(j);\n}\ntemp *= modelSecondDerivativesParameters.getEntry(k);\nfor (int i = 0; i < n; i++) {\ngradientAtTrustRegionCenter.setEntry(i, gradientAtTrustRegionCenter.getEntry(i) + temp * interpolationPoints.getEntry(k, i));\n}\n}\n}\n\n// Calculate the parameters of the least Frobenius norm interpolant to\n// the current data, the gradient of this interpolant at XOPT being put\n// into VLAG(NPT+I), I=1,2,...,N.\n\nif (ntrits > 0) {\nfor (int k = 0; k < npt; k++) {\nlagrangeValuesAtNewPoint.setEntry(k, fAtInterpolationPoints.getEntry(k) - fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex));\nwork3.setEntry(k, ZERO);\n}\nfor (int j = 0; j < nptm; j++) {\ndouble sum = ZERO;\nfor (int k = 0; k < npt; k++) {\nsum += zMatrix.getEntry(k, j) * lagrangeValuesAtNewPoint.getEntry(k);\n}\nfor (int k = 0; k < npt; k++) {\nwork3.setEntry(k, work3.getEntry(k) + sum * zMatrix.getEntry(k, j));\n}\n}\nfor (int k = 0; k < npt; k++) {\ndouble sum = ZERO;\nfor (int j = 0; j < n; j++) {\nsum += interpolationPoints.getEntry(k, j) * trustRegionCenterOffset.getEntry(j);\n}\nwork2.setEntry(k, work3.getEntry(k));\nwork3.setEntry(k, sum * work3.getEntry(k));\n}\ndouble gqsq = ZERO;\ndouble gisq = ZERO;\nfor (int i = 0; i < n; i++) {\ndouble sum = ZERO;\nfor (int k = 0; k < npt; k++) {\nsum += bMatrix.getEntry(k, i) *\nlagrangeValuesAtNewPoint.getEntry(k) + interpolationPoints.getEntry(k, i) * work3.getEntry(k);\n}\nif (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\n// Computing MIN\n// Computing 2nd power\nfinal double d1 = Math.min(ZERO, gradientAtTrustRegionCenter.getEntry(i));\ngqsq += d1 * d1;\n// Computing 2nd power\nfinal double d2 = Math.min(ZERO, sum);\ngisq += d2 * d2;\n} else if (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\n// Computing MAX\n// Computing 2nd power\nfinal double d1 = Math.max(ZERO, gradientAtTrustRegionCenter.getEntry(i));\ngqsq += d1 * d1;\n// Computing 2nd power\nfinal double d2 = Math.max(ZERO, sum);\ngisq += d2 * d2;\n} else {\n// Computing 2nd power\nfinal double d1 = gradientAtTrustRegionCenter.getEntry(i);\ngqsq += d1 * d1;\ngisq += sum * sum;\n}\nlagrangeValuesAtNewPoint.setEntry(npt + i, sum);\n}\n\n// Test whether to replace the new quadratic model by the least Frobenius\n// norm interpolant, making the replacement if the test is satisfied.\n\n++itest;\nif (gqsq < TEN * gisq) {\nitest = 0;\n}\nif (itest >= 3) {\nfor (int i = 0, max = Math.max(npt, nh); i < max; i++) {\nif (i < n) {\ngradientAtTrustRegionCenter.setEntry(i, lagrangeValuesAtNewPoint.getEntry(npt + i));\n}\nif (i < npt) {\nmodelSecondDerivativesParameters.setEntry(i, work2.getEntry(i));\n}\nif (i < nh) {\nmodelSecondDerivativesValues.setEntry(i, ZERO);\n}\nitest = 0;\n}\n}\n}\n\n// If a trust region step has provided a sufficient decrease in F, then\n// branch for another trust region calculation. The case NTRITS=0 occurs\n// when the new interpolation point was reached by an alternative step.\n\nif (ntrits == 0) {\nstate = 60; break;\n}\nif (f <= fopt + ONE_OVER_TEN * vquad) {\nstate = 60; break;\n}\n\n// Alternatively, find out if the interpolation points are close enough\n//   to the best point so far.\n\n// Computing MAX\n// Computing 2nd power\nfinal double d1 = TWO * delta;\n// Computing 2nd power\nfinal double d2 = TEN * rho;\ndistsq = Math.max(d1 * d1, d2 * d2);\n}\ncase 650: {\nprintState(650); // XXX\nknew = -1;\nfor (int k = 0; k < npt; k++) {\ndouble sum = ZERO;\nfor (int j = 0; j < n; j++) {\n// Computing 2nd power\nfinal double d1 = interpolationPoints.getEntry(k, j) - trustRegionCenterOffset.getEntry(j);\nsum += d1 * d1;\n}\nif (sum > distsq) {\nknew = k;\ndistsq = sum;\n}\n}\n\n// If KNEW is positive, then ALTMOV finds alternative new positions for\n// the KNEW-th interpolation point within distance ADELT of XOPT. It is\n// reached via label 90. Otherwise, there is a branch to label 60 for\n// another trust region iteration, unless the calculations with the\n// current RHO are complete.\n\nif (knew >= 0) {\nfinal double dist = Math.sqrt(distsq);\nif (ntrits == -1) {\n// Computing MIN\ndelta = Math.min(ONE_OVER_TEN * delta, HALF * dist);\nif (delta <= rho * 1.5) {\ndelta = rho;\n}\n}\nntrits = 0;\n// Computing MAX\n// Computing MIN\nfinal double d1 = Math.min(ONE_OVER_TEN * dist, delta);\nadelt = Math.max(d1, rho);\ndsq = adelt * adelt;\nstate = 90; break;\n}\nif (ntrits == -1) {\nstate = 680; break;\n}\nif (ratio > ZERO) {\nstate = 60; break;\n}\nif (Math.max(delta, dnorm) > rho) {\nstate = 60; break;\n}\n\n// The calculations with the current value of RHO are complete. Pick the\n//   next values of RHO and DELTA.\n}\ncase 680: {\nprintState(680); // XXX\nif (rho > stoppingTrustRegionRadius) {\ndelta = HALF * rho;\nratio = rho / stoppingTrustRegionRadius;\nif (ratio <= SIXTEEN) {\nrho = stoppingTrustRegionRadius;\n} else if (ratio <= TWO_HUNDRED_FIFTY) {\nrho = Math.sqrt(ratio) * stoppingTrustRegionRadius;\n} else {\nrho *= ONE_OVER_TEN;\n}\ndelta = Math.max(delta, rho);\nntrits = 0;\nnfsav = getEvaluations();\nstate = 60; break;\n}\n\n// Return from the calculation, after another Newton-Raphson step, if\n//   it is too short to have been tried before.\n\nif (ntrits == -1) {\nstate = 360; break;\n}\n}\ncase 720: {\nprintState(720); // XXX\nif (fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex) <= fsave) {\nfor (int i = 0; i < n; i++) {\n// Computing MIN\n// Computing MAX\nfinal double d3 = lowerBound[i];\nfinal double d4 = originShift.getEntry(i) + trustRegionCenterOffset.getEntry(i);\nfinal double d1 = Math.max(d3, d4);\nfinal double d2 = upperBound[i];\ncurrentBest.setEntry(i, Math.min(d1, d2));\nif (trustRegionCenterOffset.getEntry(i) == lowerDifference.getEntry(i)) {\ncurrentBest.setEntry(i, lowerBound[i]);\n}\nif (trustRegionCenterOffset.getEntry(i) == upperDifference.getEntry(i)) {\ncurrentBest.setEntry(i, upperBound[i]);\n}\n}\nf = fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex);\n}\nreturn f;\n}\ndefault: {\nthrow new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, \"bobyqb\");\n}}\n} // bobyqb",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:<init>()V",
            "method_body": "public Incrementor() {\nthis(0);\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:setup([D[D)V",
            "method_body": "private void setup(double[] lowerBound,\ndouble[] upperBound) {\nprintMethod(); // XXX\n\ndouble[] init = getStartPoint();\nfinal int dimension = init.length;\n\n// Check problem dimension.\nif (dimension < MINIMUM_PROBLEM_DIMENSION) {\nthrow new NumberIsTooSmallException(dimension, MINIMUM_PROBLEM_DIMENSION, true);\n}\n// Check number of interpolation points.\nfinal int[] nPointsInterval = { dimension + 2, (dimension + 2) * (dimension + 1) / 2 };\nif (numberOfInterpolationPoints < nPointsInterval[0] ||\nnumberOfInterpolationPoints > nPointsInterval[1]) {\nthrow new OutOfRangeException(LocalizedFormats.NUMBER_OF_INTERPOLATION_POINTS,\nnumberOfInterpolationPoints,\nnPointsInterval[0],\nnPointsInterval[1]);\n}\n\n// Initialize bound differences.\nboundDifference = new double[dimension];\n\ndouble requiredMinDiff = 2 * initialTrustRegionRadius;\ndouble minDiff = Double.POSITIVE_INFINITY;\nfor (int i = 0; i < dimension; i++) {\nboundDifference[i] = upperBound[i] - lowerBound[i];\nminDiff = Math.min(minDiff, boundDifference[i]);\n}\nif (minDiff < requiredMinDiff) {\ninitialTrustRegionRadius = minDiff / 3.0;\n}\n\n// Initialize the data structures used by the \"bobyqa\" method.\nbMatrix = new Array2DRowRealMatrix(dimension + numberOfInterpolationPoints,\ndimension);\nzMatrix = new Array2DRowRealMatrix(numberOfInterpolationPoints,\nnumberOfInterpolationPoints - dimension - 1);\ninterpolationPoints = new Array2DRowRealMatrix(numberOfInterpolationPoints,\ndimension);\noriginShift = new ArrayRealVector(dimension);\nfAtInterpolationPoints = new ArrayRealVector(numberOfInterpolationPoints);\ntrustRegionCenterOffset = new ArrayRealVector(dimension);\ngradientAtTrustRegionCenter = new ArrayRealVector(dimension);\nlowerDifference = new ArrayRealVector(dimension);\nupperDifference = new ArrayRealVector(dimension);\nmodelSecondDerivativesParameters = new ArrayRealVector(numberOfInterpolationPoints);\nnewPoint = new ArrayRealVector(dimension);\nalternativeNewPoint = new ArrayRealVector(dimension);\ntrialStepPoint = new ArrayRealVector(dimension);\nlagrangeValuesAtNewPoint = new ArrayRealVector(dimension + numberOfInterpolationPoints);\nmodelSecondDerivativesValues = new ArrayRealVector(dimension * (dimension + 1) / 2);\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math.optimization.RealPointValuePair:<init>([DD)V",
            "method_body": "public RealPointValuePair(final double[] point, final double value) {\nthis.point = (point == null) ? null : point.clone();\nthis.value = value;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math.util.Incrementor:<init>(I)V",
            "method_body": "public Incrementor(int max) {\nthis(max,\nnew MaxCountExceededCallback() {\n/** {@inheritDoc} */\npublic void trigger(int max) {\nthrow new MaxCountExceededException(max);\n}\n});\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math.linear.MatrixUtils:checkColumnIndex(Lorg/apache/commons/math/linear/AnyMatrix;I)V",
            "method_body": "public static void checkColumnIndex(final AnyMatrix m, final int column) {\nif (column < 0 || column >= m.getColumnDimension()) {\nthrow new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\ncolumn, 0, m.getColumnDimension() - 1);\n}\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math.linear.ArrayRealVector:setEntry(ID)V",
            "method_body": "public void setEntry(int index, double value) {\ntry {\ndata[index] = value;\n} catch (IndexOutOfBoundsException e) {\ncheckIndex(index);\n}\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateOptimizer:optimize(ILorg/apache/commons/math/analysis/MultivariateFunction;Lorg/apache/commons/math/optimization/GoalType;[D)Lorg/apache/commons/math/optimization/RealPointValuePair;",
            "method_body": "public RealPointValuePair optimize(int maxEval, FUNC f, GoalType goalType,\ndouble[] startPoint) {\n// Checks.\nif (f == null) {\nthrow new NullArgumentException();\n}\nif (goalType == null) {\nthrow new NullArgumentException();\n}\nif (startPoint == null) {\nthrow new NullArgumentException();\n}\n\n// Reset.\nevaluations.setMaximalCount(maxEval);\nevaluations.resetCount();\n\n// Store optimization problem characteristics.\nfunction = f;\ngoal = goalType;\nstart = startPoint.clone();\n\n// Perform computation.\nreturn doOptimize();\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:bobyqa([D[D)D",
            "method_body": "private double bobyqa(double[] lowerBound,\ndouble[] upperBound) {\nprintMethod(); // XXX\n\nfinal int n = currentBest.getDimension();\n\n// Return if there is insufficient space between the bounds. Modify the\n// initial X if necessary in order to avoid conflicts between the bounds\n// and the construction of the first quadratic model. The lower and upper\n// bounds on moves from the updated X are set now, in the ISL and ISU\n// partitions of W, in order to provide useful and exact information about\n// components of X that become within distance RHOBEG from their bounds.\n\nfor (int j = 0; j < n; j++) {\nfinal double boundDiff = boundDifference[j];\nlowerDifference.setEntry(j, lowerBound[j] - currentBest.getEntry(j));\nupperDifference.setEntry(j, upperBound[j] - currentBest.getEntry(j));\nif (lowerDifference.getEntry(j) >= -initialTrustRegionRadius) {\nif (lowerDifference.getEntry(j) >= ZERO) {\ncurrentBest.setEntry(j, lowerBound[j]);\nlowerDifference.setEntry(j, ZERO);\nupperDifference.setEntry(j, boundDiff);\n} else {\ncurrentBest.setEntry(j, lowerBound[j] + initialTrustRegionRadius);\nlowerDifference.setEntry(j, -initialTrustRegionRadius);\n// Computing MAX\nfinal double deltaOne = upperBound[j] - currentBest.getEntry(j);\nupperDifference.setEntry(j, Math.max(deltaOne, initialTrustRegionRadius));\n}\n} else if (upperDifference.getEntry(j) <= initialTrustRegionRadius) {\nif (upperDifference.getEntry(j) <= ZERO) {\ncurrentBest.setEntry(j, upperBound[j]);\nlowerDifference.setEntry(j, -boundDiff);\nupperDifference.setEntry(j, ZERO);\n} else {\ncurrentBest.setEntry(j, upperBound[j] - initialTrustRegionRadius);\n// Computing MIN\nfinal double deltaOne = lowerBound[j] - currentBest.getEntry(j);\nfinal double deltaTwo = -initialTrustRegionRadius;\nlowerDifference.setEntry(j, Math.min(deltaOne, deltaTwo));\nupperDifference.setEntry(j, initialTrustRegionRadius);\n}\n}\n}\n\n// Make the call of BOBYQB.\n\nreturn bobyqb(lowerBound, upperBound);\n} // bobyqa",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BOBYQAOptimizer:doOptimize()Lorg/apache/commons/math/optimization/RealPointValuePair;",
            "method_body": "protected RealPointValuePair doOptimize() {\nfinal double[] lowerBound = getLowerBound();\nfinal double[] upperBound = getUpperBound();\n\n// Validity checks.\nsetup(lowerBound, upperBound);\n\nisMinimize = (getGoalType() == GoalType.MINIMIZE);\ncurrentBest = new ArrayRealVector(getStartPoint());\n\nfinal double value = bobyqa(lowerBound, upperBound);\n\nreturn new RealPointValuePair(currentBest.getDataRef(),\nisMinimize ? value : -value);\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math.optimization.direct.BaseAbstractMultivariateSimpleBoundsOptimizer:getLowerBound()[D",
            "method_body": "public double[] getLowerBound() {\nreturn lowerBound.clone();\n}",
            "method_id": 42
        }
    ]
}