{
    "bug_id": 4,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLineTest.testIntersectionParallel",
    "test_body": "public void testIntersectionParallel() {\nfinal SubLine sub1 = new SubLine(new Vector2D(0, 1), new Vector2D(0, 2));\nfinal SubLine sub2 = new SubLine(new Vector2D(66, 3), new Vector2D(66, 4));\nAssert.assertNull(sub1.intersection(sub2, true));\nAssert.assertNull(sub1.intersection(sub2, false));\n}\n",
    "stack_trace": "java.lang.NullPointerException\nat org.apache.commons.math3.geometry.euclidean.twod.Line.toSubSpace(Line.java:182)\nat org.apache.commons.math3.geometry.euclidean.twod.SubLine.intersection(SubLine.java:120)\nat org.apache.commons.math3.geometry.euclidean.twod.SubLineTest.testIntersectionParallel(SubLineTest.java:151)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine:intersection(Lorg/apache/commons/math3/geometry/euclidean/twod/SubLine;Z)Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;",
            "method_body": "public Vector2D intersection(final SubLine subLine, final boolean includeEndPoints) {\n\n// retrieve the underlying lines\nLine line1 = (Line) getHyperplane();\nLine line2 = (Line) subLine.getHyperplane();\n\n// compute the intersection on infinite line\nVector2D v2D = line1.intersection(line2);\n\n// check location of point with respect to first sub-line\nLocation loc1 = getRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n\n// check location of point with respect to second sub-line\nLocation loc2 = subLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n\nif (includeEndPoints) {\nreturn ((loc1 != Location.OUTSIDE) && (loc2 != Location.OUTSIDE)) ? v2D : null;\n} else {\nreturn ((loc1 == Location.INSIDE) && (loc2 == Location.INSIDE)) ? v2D : null;\n}\n\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D:<init>(DD)V",
            "method_body": "public Vector2D(double x, double y) {\nthis.x = x;\nthis.y = y;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:hypot(DD)D",
            "method_body": "public static double hypot(final double x, final double y) {\nif (Double.isInfinite(x) || Double.isInfinite(y)) {\nreturn Double.POSITIVE_INFINITY;\n} else if (Double.isNaN(x) || Double.isNaN(y)) {\nreturn Double.NaN;\n} else {\n\nfinal int expX = getExponent(x);\nfinal int expY = getExponent(y);\nif (expX > expY + 27) {\n// y is neglectible with respect to x\nreturn abs(x);\n} else if (expY > expX + 27) {\n// x is neglectible with respect to y\nreturn abs(y);\n} else {\n\n// find an intermediate scale to avoid both overflow and underflow\nfinal int middleExp = (expX + expY) / 2;\n\n// scale parameters without losing precision\nfinal double scaledX = scalb(x, -middleExp);\nfinal double scaledY = scalb(y, -middleExp);\n\n// compute scaled hypotenuse\nfinal double scaledH = sqrt(scaledX * scaledX + scaledY * scaledY);\n\n// remove scaling\nreturn scalb(scaledH, middleExp);\n\n}\n\n}\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:getExponent(D)I",
            "method_body": "public static int getExponent(final double d) {\n// NaN and Infinite will return 1024 anywho so can use raw bits\nreturn (int) ((Double.doubleToRawLongBits(d) >>> 52) & 0x7ff) - 1023;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn Double.longBitsToDouble(MASK_NON_SIGN_LONG & Double.doubleToRawLongBits(x));\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:atan2(DD)D",
            "method_body": "public static double atan2(double y, double x) {\nif (x != x || y != y) {\nreturn Double.NaN;\n}\n\nif (y == 0) {\nfinal double result = x * y;\nfinal double invx = 1d / x;\nfinal double invy = 1d / y;\n\nif (invx == 0) { // X is infinite\nif (x > 0) {\nreturn y; // return +/- 0.0\n} else {\nreturn copySign(Math.PI, y);\n}\n}\n\nif (x < 0 || invx < 0) {\nif (y < 0 || invy < 0) {\nreturn -Math.PI;\n} else {\nreturn Math.PI;\n}\n} else {\nreturn result;\n}\n}\n\n// y cannot now be zero\n\nif (y == Double.POSITIVE_INFINITY) {\nif (x == Double.POSITIVE_INFINITY) {\nreturn Math.PI * F_1_4;\n}\n\nif (x == Double.NEGATIVE_INFINITY) {\nreturn Math.PI * F_3_4;\n}\n\nreturn Math.PI * F_1_2;\n}\n\nif (y == Double.NEGATIVE_INFINITY) {\nif (x == Double.POSITIVE_INFINITY) {\nreturn -Math.PI * F_1_4;\n}\n\nif (x == Double.NEGATIVE_INFINITY) {\nreturn -Math.PI * F_3_4;\n}\n\nreturn -Math.PI * F_1_2;\n}\n\nif (x == Double.POSITIVE_INFINITY) {\nif (y > 0 || 1 / y > 0) {\nreturn 0d;\n}\n\nif (y < 0 || 1 / y < 0) {\nreturn -0d;\n}\n}\n\nif (x == Double.NEGATIVE_INFINITY)\n{\nif (y > 0.0 || 1 / y > 0.0) {\nreturn Math.PI;\n}\n\nif (y < 0 || 1 / y < 0) {\nreturn -Math.PI;\n}\n}\n\n// Neither y nor x can be infinite or NAN here\n\nif (x == 0) {\nif (y > 0 || 1 / y > 0) {\nreturn Math.PI * F_1_2;\n}\n\nif (y < 0 || 1 / y < 0) {\nreturn -Math.PI * F_1_2;\n}\n}\n\n// Compute ratio r = y/x\nfinal double r = y / x;\nif (Double.isInfinite(r)) { // bypass calculations that can create NaN\nreturn atan(r, 0, x < 0);\n}\n\ndouble ra = doubleHighPart(r);\ndouble rb = r - ra;\n\n// Split x\nfinal double xa = doubleHighPart(x);\nfinal double xb = x - xa;\n\nrb += (y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n\nfinal double temp = ra + rb;\nrb = -(temp - ra - rb);\nra = temp;\n\nif (ra == 0) { // Fix up the sign so atan works correctly\nra = copySign(0d, y);\n}\n\n// Call atan\nfinal double result = atan(ra, rb, x < 0);\n\nreturn result;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cos(D)D",
            "method_body": "public static double cos(double x) {\nint quadrant = 0;\n\n/* Take absolute value of the input */\ndouble xa = x;\nif (x < 0) {\nxa = -xa;\n}\n\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nreturn Double.NaN;\n}\n\n/* Perform any argument reduction */\ndouble xb = 0;\nif (xa > 3294198.0) {\n// PI * (2**20)\n// Argument too big for CodyWaite reduction.  Must use\n// PayneHanek.\ndouble reduceResults[] = new double[3];\nreducePayneHanek(xa, reduceResults);\nquadrant = ((int) reduceResults[0]) & 3;\nxa = reduceResults[1];\nxb = reduceResults[2];\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\n}\n\n//if (negative)\n//  quadrant = (quadrant + 2) % 4;\n\nswitch (quadrant) {\ncase 0:\nreturn cosQ(xa, xb);\ncase 1:\nreturn -sinQ(xa, xb);\ncase 2:\nreturn -cosQ(xa, xb);\ncase 3:\nreturn sinQ(xa, xb);\ndefault:\nreturn Double.NaN;\n}\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:cosQ(DD)D",
            "method_body": "private static double cosQ(double xa, double xb) {\nfinal double pi2a = 1.5707963267948966;\nfinal double pi2b = 6.123233995736766E-17;\n\nfinal double a = pi2a - xa;\ndouble b = -(a - pi2a + xa);\nb += pi2b - xb;\n\nreturn sinQ(a, b);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sinQ(DD)D",
            "method_body": "private static double sinQ(double xa, double xb) {\nint idx = (int) ((xa * 8.0) + 0.5);\nfinal double epsilon = xa - EIGHTHS[idx]; //idx*0.125;\n\n// Table lookups\nfinal double sintA = SINE_TABLE_A[idx];\nfinal double sintB = SINE_TABLE_B[idx];\nfinal double costA = COSINE_TABLE_A[idx];\nfinal double costB = COSINE_TABLE_B[idx];\n\n// Polynomial eval of sin(epsilon), cos(epsilon)\ndouble sinEpsA = epsilon;\ndouble sinEpsB = polySine(epsilon);\nfinal double cosEpsA = 1.0;\nfinal double cosEpsB = polyCosine(epsilon);\n\n// Split epsilon   xa + xb = x\nfinal double temp = sinEpsA * HEX_40000000;\ndouble temp2 = (sinEpsA + temp) - temp;\nsinEpsB +=  sinEpsA - temp2;\nsinEpsA = temp2;\n\n/* Compute sin(x) by angle addition formula */\ndouble result;\n\n/* Compute the following sum:\n*\n* result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n*          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n*\n* Ranges of elements\n*\n* xxxtA   0            PI/2\n* xxxtB   -1.5e-9      1.5e-9\n* sinEpsA -0.0625      0.0625\n* sinEpsB -6e-11       6e-11\n* cosEpsA  1.0\n* cosEpsB  0           -0.0625\n*\n*/\n\n//result = sintA + costA*sinEpsA + sintA*cosEpsB + costA*sinEpsB +\n//          sintB + costB*sinEpsA + sintB*cosEpsB + costB*sinEpsB;\n\n//result = sintA + sintA*cosEpsB + sintB + sintB * cosEpsB;\n//result += costA*sinEpsA + costA*sinEpsB + costB*sinEpsA + costB * sinEpsB;\ndouble a = 0;\ndouble b = 0;\n\ndouble t = sintA;\ndouble c = a + t;\ndouble d = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA * sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nb = b + sintA * cosEpsB + costA * sinEpsB;\n/*\nt = sintA*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costA*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nb = b + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n/*\nt = sintB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsA;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = sintB*cosEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n\nt = costB*sinEpsB;\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n*/\n\nif (xb != 0.0) {\nt = ((costA + costB) * (cosEpsA + cosEpsB) -\n(sintA + sintB) * (sinEpsA + sinEpsB)) * xb;  // approximate cosine*xb\nc = a + t;\nd = -(c - a - t);\na = c;\nb = b + d;\n}\n\nresult = a + b;\n\nreturn result;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sin(D)D",
            "method_body": "public static double sin(double x) {\nboolean negative = false;\nint quadrant = 0;\ndouble xa;\ndouble xb = 0.0;\n\n/* Take absolute value of the input */\nxa = x;\nif (x < 0) {\nnegative = true;\nxa = -xa;\n}\n\n/* Check for zero and negative zero */\nif (xa == 0.0) {\nlong bits = Double.doubleToRawLongBits(x);\nif (bits < 0) {\nreturn -0.0;\n}\nreturn 0.0;\n}\n\nif (xa != xa || xa == Double.POSITIVE_INFINITY) {\nreturn Double.NaN;\n}\n\n/* Perform any argument reduction */\nif (xa > 3294198.0) {\n// PI * (2**20)\n// Argument too big for CodyWaite reduction.  Must use\n// PayneHanek.\ndouble reduceResults[] = new double[3];\nreducePayneHanek(xa, reduceResults);\nquadrant = ((int) reduceResults[0]) & 3;\nxa = reduceResults[1];\nxb = reduceResults[2];\n} else if (xa > 1.5707963267948966) {\nfinal CodyWaite cw = new CodyWaite(xa);\nquadrant = cw.getK() & 3;\nxa = cw.getRemA();\nxb = cw.getRemB();\n}\n\nif (negative) {\nquadrant ^= 2;  // Flip bit 1\n}\n\nswitch (quadrant) {\ncase 0:\nreturn sinQ(xa, xb);\ncase 1:\nreturn cosQ(xa, xb);\ncase 2:\nreturn -sinQ(xa, xb);\ncase 3:\nreturn -cosQ(xa, xb);\ndefault:\nreturn Double.NaN;\n}\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D:<init>(D)V",
            "method_body": "public Vector1D(double x) {\nthis.x = x;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:<init>(DD)V",
            "method_body": "public IntervalsSet(final double lower, final double upper) {\nsuper(buildTree(lower, upper));\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet:buildTree(DD)Lorg/apache/commons/math3/geometry/partitioning/BSPTree;",
            "method_body": "private static BSPTree<Euclidean1D> buildTree(final double lower, final double upper) {\nif (Double.isInfinite(lower) && (lower < 0)) {\nif (Double.isInfinite(upper) && (upper > 0)) {\n// the tree must cover the whole real line\nreturn new BSPTree<Euclidean1D>(Boolean.TRUE);\n}\n// the tree must be open on the negative infinity side\nfinal SubHyperplane<Euclidean1D> upperCut =\nnew OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\nreturn new BSPTree<Euclidean1D>(upperCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(Boolean.TRUE),\nnull);\n}\nfinal SubHyperplane<Euclidean1D> lowerCut =\nnew OrientedPoint(new Vector1D(lower), false).wholeHyperplane();\nif (Double.isInfinite(upper) && (upper > 0)) {\n// the tree must be open on the positive infinity side\nreturn new BSPTree<Euclidean1D>(lowerCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(Boolean.TRUE),\nnull);\n}\n\n// the tree must be bounded on the two sides\nfinal SubHyperplane<Euclidean1D> upperCut =\nnew OrientedPoint(new Vector1D(upper), true).wholeHyperplane();\nreturn new BSPTree<Euclidean1D>(lowerCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(upperCut,\nnew BSPTree<Euclidean1D>(Boolean.FALSE),\nnew BSPTree<Euclidean1D>(Boolean.TRUE),\nnull),\nnull);\n\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:<init>(Ljava/lang/Object;)V",
            "method_body": "public BSPTree(final Object attribute) {\ncut    = null;\nplus   = null;\nminus  = null;\nparent = null;\nthis.attribute = attribute;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint:wholeHyperplane()Lorg/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint;",
            "method_body": "public SubOrientedPoint wholeHyperplane() {\nreturn new SubOrientedPoint(this, null);\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:toSubSpace(Lorg/apache/commons/math3/geometry/Vector;)Lorg/apache/commons/math3/geometry/euclidean/oned/Vector1D;",
            "method_body": "public Vector1D toSubSpace(final Vector<Euclidean2D> point) {\nVector2D p2 = (Vector2D) point;\nreturn new Vector1D(cos * p2.getX() + sin * p2.getY());\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint:<init>(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;Lorg/apache/commons/math3/geometry/partitioning/Region;)V",
            "method_body": "public SubOrientedPoint(final Hyperplane<Euclidean1D> hyperplane,\nfinal Region<Euclidean1D> remainingRegion) {\nsuper(hyperplane, remainingRegion);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:getHyperplane()Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;",
            "method_body": "public Hyperplane<S> getHyperplane() {\nreturn hyperplane;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:intersection(Lorg/apache/commons/math3/geometry/euclidean/twod/Line;)Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;",
            "method_body": "public Vector2D intersection(final Line other) {\nfinal double d = sin * other.cos - other.sin * cos;\nif (FastMath.abs(d) < 1.0e-10) {\nreturn null;\n}\nreturn new Vector2D((cos * other.originOffset - other.cos * originOffset) / d,\n(sin * other.originOffset - other.sin * originOffset) / d);\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D:getX()D",
            "method_body": "public double getX() {\nreturn x;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint:<init>(Lorg/apache/commons/math3/geometry/euclidean/oned/Vector1D;Z)V",
            "method_body": "public OrientedPoint(final Vector1D location, final boolean direct) {\nthis.location = location;\nthis.direct   = direct;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.BSPTree:<init>(Lorg/apache/commons/math3/geometry/partitioning/SubHyperplane;Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Lorg/apache/commons/math3/geometry/partitioning/BSPTree;Ljava/lang/Object;)V",
            "method_body": "public BSPTree(final SubHyperplane<S> cut, final BSPTree<S> plus, final BSPTree<S> minus,\nfinal Object attribute) {\nthis.cut       = cut;\nthis.plus      = plus;\nthis.minus     = minus;\nthis.parent    = null;\nthis.attribute = attribute;\nplus.parent    = this;\nminus.parent   = this;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:reset(Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;)V",
            "method_body": "public void reset(final Vector2D p1, final Vector2D p2) {\nfinal double dx = p2.getX() - p1.getX();\nfinal double dy = p2.getY() - p1.getY();\nfinal double d = FastMath.hypot(dx, dy);\nif (d == 0.0) {\nangle        = 0.0;\ncos          = 1.0;\nsin          = 0.0;\noriginOffset = p1.getY();\n} else {\nangle        = FastMath.PI + FastMath.atan2(-dy, -dx);\ncos          = FastMath.cos(angle);\nsin          = FastMath.sin(angle);\noriginOffset = (p2.getX() * p1.getY() - p1.getX() * p2.getY()) / d;\n}\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polySine(D)D",
            "method_body": "private static double polySine(final double x)\n{\ndouble x2 = x*x;\n\ndouble p = 2.7553817452272217E-6;\np = p * x2 + -1.9841269659586505E-4;\np = p * x2 + 0.008333333333329196;\np = p * x2 + -0.16666666666666666;\n//p *= x2;\n//p *= x;\np = p * x2 * x;\n\nreturn p;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D:getY()D",
            "method_body": "public double getY() {\nreturn y;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.Line:<init>(Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;)V",
            "method_body": "public Line(final Vector2D p1, final Vector2D p2) {\nreset(p1, p2);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion:<init>(Lorg/apache/commons/math3/geometry/partitioning/BSPTree;)V",
            "method_body": "protected AbstractRegion(final BSPTree<S> tree) {\nthis.tree = tree;\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine:<init>(Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;)V",
            "method_body": "public SubLine(final Vector2D start, final Vector2D end) {\nsuper(new Line(start, end), buildIntervalSet(start, end));\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D:getX()D",
            "method_body": "public double getX() {\nreturn x;\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:<init>(Lorg/apache/commons/math3/geometry/partitioning/Hyperplane;Lorg/apache/commons/math3/geometry/partitioning/Region;)V",
            "method_body": "protected AbstractSubHyperplane(final Hyperplane<S> hyperplane,\nfinal Region<T> remainingRegion) {\nthis.hyperplane      = hyperplane;\nthis.remainingRegion = remainingRegion;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:polyCosine(D)D",
            "method_body": "private static double polyCosine(double x) {\ndouble x2 = x*x;\n\ndouble p = 2.479773539153719E-5;\np = p * x2 + -0.0013888888689039883;\np = p * x2 + 0.041666666666621166;\np = p * x2 + -0.49999999999999994;\np *= x2;\n\nreturn p;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane:getRemainingRegion()Lorg/apache/commons/math3/geometry/partitioning/Region;",
            "method_body": "public Region<T> getRemainingRegion() {\nreturn remainingRegion;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine:buildIntervalSet(Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;Lorg/apache/commons/math3/geometry/euclidean/twod/Vector2D;)Lorg/apache/commons/math3/geometry/euclidean/oned/IntervalsSet;",
            "method_body": "private static IntervalsSet buildIntervalSet(final Vector2D start, final Vector2D end) {\nfinal Line line = new Line(start, end);\nreturn new IntervalsSet(line.toSubSpace(start).getX(),\nline.toSubSpace(end).getX());\n}",
            "method_id": 32
        }
    ]
}