{
    "bug_id": 52,
    "test_id": 0,
    "test_name": "org.apache.commons.math.geometry.euclidean.threed.RotationTest.testIssue639",
    "test_body": "public void testIssue639(){\nVector3D u1 = new Vector3D(-1321008684645961.0 /  268435456.0,\n-5774608829631843.0 /  268435456.0,\n-3822921525525679.0 / 4294967296.0);\nVector3D u2 =new Vector3D( -5712344449280879.0 /    2097152.0,\n-2275058564560979.0 /    1048576.0,\n4423475992255071.0 /      65536.0);\nRotation rot = new Rotation(u1, u2, Vector3D.PLUS_I,Vector3D.PLUS_K);\nAssert.assertEquals( 0.6228370359608200639829222, rot.getQ0(), 1.0e-15);\nAssert.assertEquals( 0.0257707621456498790029987, rot.getQ1(), 1.0e-15);\nAssert.assertEquals(-0.0000000002503012255839931, rot.getQ2(), 1.0e-15);\nAssert.assertEquals(-0.7819270390861109450724902, rot.getQ3(), 1.0e-15);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<0.6228370359608201> but was:<NaN>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math.geometry.euclidean.threed.RotationTest.testIssue639(RotationTest.java:488)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Rotation:<init>(Lorg/apache/commons/math/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math/geometry/euclidean/threed/Vector3D;Lorg/apache/commons/math/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Rotation(Vector3D u1, Vector3D u2, Vector3D v1, Vector3D v2) {\n\n// norms computation\ndouble u1u1 = u1.getNormSq();\ndouble u2u2 = u2.getNormSq();\ndouble v1v1 = v1.getNormSq();\ndouble v2v2 = v2.getNormSq();\nif ((u1u1 == 0) || (u2u2 == 0) || (v1v1 == 0) || (v2v2 == 0)) {\nthrow MathRuntimeException.createIllegalArgumentException(LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR);\n}\n\n// normalize v1 in order to have (v1'|v1') = (u1|u1)\nv1 = new Vector3D(FastMath.sqrt(u1u1 / v1v1), v1);\n\n// adjust v2 in order to have (u1|u2) = (v1'|v2') and (v2'|v2') = (u2|u2)\ndouble u1u2   = u1.dotProduct(u2);\ndouble v1v2   = v1.dotProduct(v2);\ndouble coeffU = u1u2 / u1u1;\ndouble coeffV = v1v2 / u1u1;\ndouble beta   = FastMath.sqrt((u2u2 - u1u2 * coeffU) / (v2v2 - v1v2 * coeffV));\ndouble alpha  = coeffU - beta * coeffV;\nv2 = new Vector3D(alpha, v1, beta, v2);\n\n// preliminary computation\nVector3D uRef  = u1;\nVector3D vRef  = v1;\nVector3D v1Su1 = v1.subtract(u1);\nVector3D v2Su2 = v2.subtract(u2);\nVector3D k     = v1Su1.crossProduct(v2Su2);\nVector3D u3    = u1.crossProduct(u2);\ndouble c       = k.dotProduct(u3);\nif (c == 0) {\n// the (q1, q2, q3) vector is close to the (u1, u2) plane\n// we try other vectors\nVector3D v3 = Vector3D.crossProduct(v1, v2);\nVector3D v3Su3 = v3.subtract(u3);\nk = v1Su1.crossProduct(v3Su3);\nVector3D u2Prime = u1.crossProduct(u3);\nc = k.dotProduct(u2Prime);\n\nif (c == 0) {\n// the (q1, q2, q3) vector is also close to the (u1, u3) plane,\n// it is almost aligned with u1: we try (u2, u3) and (v2, v3)\nk = v2Su2.crossProduct(v3Su3);;\nc = k.dotProduct(u2.crossProduct(u3));;\n\nif (c == 0) {\n// the (q1, q2, q3) vector is aligned with everything\n// this is really the identity rotation\nq0 = 1.0;\nq1 = 0.0;\nq2 = 0.0;\nq3 = 0.0;\nreturn;\n}\n\n// we will have to use u2 and v2 to compute the scalar part\nuRef = u2;\nvRef = v2;\n\n}\n\n}\n\n// compute the vectorial part\nc = FastMath.sqrt(c);\ndouble inv = 1.0 / (c + c);\nq1 = inv * k.getX();\nq2 = inv * k.getY();\nq3 = inv * k.getZ();\n\n// compute the scalar part\nk = new Vector3D(uRef.getY() * q3 - uRef.getZ() * q2,\nuRef.getZ() * q1 - uRef.getX() * q3,\nuRef.getX() * q2 - uRef.getY() * q1);\nq0 = vRef.dotProduct(k) / (2 * k.getNormSq());\n\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D:<init>(DDD)V",
            "method_body": "public Vector3D(double x, double y, double z) {\nthis.x = x;\nthis.y = y;\nthis.z = z;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D:getX()D",
            "method_body": "public double getX() {\nreturn x;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D:<init>(DLorg/apache/commons/math/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Vector3D(double a, Vector3D u) {\nthis.x = a * u.x;\nthis.y = a * u.y;\nthis.z = a * u.z;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Rotation:getQ0()D",
            "method_body": "public double getQ0() {\nreturn q0;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D:getZ()D",
            "method_body": "public double getZ() {\nreturn z;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D:<init>(DLorg/apache/commons/math/geometry/euclidean/threed/Vector3D;DLorg/apache/commons/math/geometry/euclidean/threed/Vector3D;)V",
            "method_body": "public Vector3D(double a1, Vector3D u1, double a2, Vector3D u2) {\nthis.x = MathUtils.linearCombination(a1, u1.x, a2, u2.x);\nthis.y = MathUtils.linearCombination(a1, u1.y, a2, u2.y);\nthis.z = MathUtils.linearCombination(a1, u1.z, a2, u2.z);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D:dotProduct(Lorg/apache/commons/math/geometry/Vector;)D",
            "method_body": "public double dotProduct(final Vector<Euclidean3D> v) {\nfinal Vector3D v3 = (Vector3D) v;\nreturn MathUtils.linearCombination(x, v3.x, y, v3.y, z, v3.z);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D:getY()D",
            "method_body": "public double getY() {\nreturn y;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math.util.MathUtils:linearCombination(DDDD)D",
            "method_body": "public static double linearCombination(final double a1, final double b1,\nfinal double a2, final double b2) {\n\n// the code below is split in many additions/subtractions that may\n// appear redundant. However, they shoud NOT be simplified, as they\n// do use IEEE753 floating point arithmetic rouding properties.\n// as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n// The variables naming conventions are that xyzHigh contains the most significant\n// bits of xyz and xyzLow contains its least significant bits. So theoretically\n// xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n// be represented in only one double precision number so we preserve two numbers\n// to hold it as long as we can, combining the high and low order bits together\n// only at the end, after cancellation may have occurred on high order bits\n\n// split a1 and b1 as two 26 bits numbers\nfinal double ca1        = SPLIT_FACTOR * a1;\nfinal double a1High     = ca1 - (ca1 - a1);\nfinal double a1Low      = a1 - a1High;\nfinal double cb1        = SPLIT_FACTOR * b1;\nfinal double b1High     = cb1 - (cb1 - b1);\nfinal double b1Low      = b1 - b1High;\n\n// accurate multiplication a1 * b1\nfinal double prod1High  = a1 * b1;\nfinal double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n// split a2 and b2 as two 26 bits numbers\nfinal double ca2        = SPLIT_FACTOR * a2;\nfinal double a2High     = ca2 - (ca2 - a2);\nfinal double a2Low      = a2 - a2High;\nfinal double cb2        = SPLIT_FACTOR * b2;\nfinal double b2High     = cb2 - (cb2 - b2);\nfinal double b2Low      = b2 - b2High;\n\n// accurate multiplication a2 * b2\nfinal double prod2High  = a2 * b2;\nfinal double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n// accurate addition a1 * b1 + a2 * b2\nfinal double s12High    = prod1High + prod2High;\nfinal double s12Prime   = s12High - prod2High;\nfinal double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n// final rounding, s12 may have suffered many cancellations, we try\n// to recover some bits from the extra words we have saved up to now\nreturn s12High + (prod1Low + prod2Low + s12Low);\n\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math.util.MathUtils:linearCombination(DDDDDD)D",
            "method_body": "public static double linearCombination(final double a1, final double b1,\nfinal double a2, final double b2,\nfinal double a3, final double b3) {\n\n// the code below is split in many additions/subtractions that may\n// appear redundant. However, they shoud NOT be simplified, as they\n// do use IEEE753 floating point arithmetic rouding properties.\n// as an example, the expression \"ca1 - (ca1 - a1)\" is NOT the same as \"a1\"\n// The variables naming conventions are that xyzHigh contains the most significant\n// bits of xyz and xyzLow contains its least significant bits. So theoretically\n// xyz is the sum xyzHigh + xyzLow, but in many cases below, this sum cannot\n// be represented in only one double precision number so we preserve two numbers\n// to hold it as long as we can, combining the high and low order bits together\n// only at the end, after cancellation may have occurred on high order bits\n\n// split a1 and b1 as two 26 bits numbers\nfinal double ca1        = SPLIT_FACTOR * a1;\nfinal double a1High     = ca1 - (ca1 - a1);\nfinal double a1Low      = a1 - a1High;\nfinal double cb1        = SPLIT_FACTOR * b1;\nfinal double b1High     = cb1 - (cb1 - b1);\nfinal double b1Low      = b1 - b1High;\n\n// accurate multiplication a1 * b1\nfinal double prod1High  = a1 * b1;\nfinal double prod1Low   = a1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n\n// split a2 and b2 as two 26 bits numbers\nfinal double ca2        = SPLIT_FACTOR * a2;\nfinal double a2High     = ca2 - (ca2 - a2);\nfinal double a2Low      = a2 - a2High;\nfinal double cb2        = SPLIT_FACTOR * b2;\nfinal double b2High     = cb2 - (cb2 - b2);\nfinal double b2Low      = b2 - b2High;\n\n// accurate multiplication a2 * b2\nfinal double prod2High  = a2 * b2;\nfinal double prod2Low   = a2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n\n// split a3 and b3 as two 26 bits numbers\nfinal double ca3        = SPLIT_FACTOR * a3;\nfinal double a3High     = ca3 - (ca3 - a3);\nfinal double a3Low      = a3 - a3High;\nfinal double cb3        = SPLIT_FACTOR * b3;\nfinal double b3High     = cb3 - (cb3 - b3);\nfinal double b3Low      = b3 - b3High;\n\n// accurate multiplication a3 * b3\nfinal double prod3High  = a3 * b3;\nfinal double prod3Low   = a3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n\n// accurate addition a1 * b1 + a2 * b2\nfinal double s12High    = prod1High + prod2High;\nfinal double s12Prime   = s12High - prod2High;\nfinal double s12Low     = (prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n\n// accurate addition a1 * b1 + a2 * b2 + a3 * b3\nfinal double s123High   = s12High + prod3High;\nfinal double s123Prime  = s123High - prod3High;\nfinal double s123Low    = (prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n\n// final rounding, s123 may have suffered many cancellations, we try\n// to recover some bits from the extra words we have saved up to now\nreturn s123High + (prod1Low + prod2Low + prod3Low + s12Low + s123Low);\n\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D:crossProduct(Lorg/apache/commons/math/geometry/Vector;)Lorg/apache/commons/math/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D crossProduct(final Vector<Euclidean3D> v) {\nfinal Vector3D v3 = (Vector3D) v;\nreturn new Vector3D(MathUtils.linearCombination(y, v3.z, -z, v3.y),\nMathUtils.linearCombination(z, v3.x, -x, v3.z),\nMathUtils.linearCombination(x, v3.y, -y, v3.x));\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D:getNormSq()D",
            "method_body": "public double getNormSq() {\n// there are no cancellation problems here, so we use the straightforward formula\nreturn x * x + y * y + z * z;\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math.geometry.euclidean.threed.Vector3D:subtract(Lorg/apache/commons/math/geometry/Vector;)Lorg/apache/commons/math/geometry/euclidean/threed/Vector3D;",
            "method_body": "public Vector3D subtract(final Vector<Euclidean3D> v) {\nfinal Vector3D v3 = (Vector3D) v;\nreturn new Vector3D(x - v3.x, y - v3.y, z - v3.z);\n}",
            "method_id": 14
        }
    ]
}