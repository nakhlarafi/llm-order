{
    "bug_id": 6,
    "test_id": 1,
    "test_name": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizerTest.testGetIterations",
    "test_body": null,
    "stack_trace": "junit.framework.AssertionFailedError\nat org.junit.Assert.fail(Assert.java:86)\nat org.junit.Assert.assertTrue(Assert.java:41)\nat org.junit.Assert.assertTrue(Assert.java:52)\nat org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizerAbstractTest.testGetIterations(AbstractLeastSquaresOptimizerAbstractTest.java:131)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseOptimizer(ConvergenceChecker<PAIR> checker) {\nthis.checker = checker;\n\nevaluations = new Incrementor(0, new MaxEvalCallback());\niterations = new Incrementor(0, new MaxIterCallback());\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:doOptimize()Lorg/apache/commons/math3/optim/PointVectorValuePair;",
            "method_body": "protected PointVectorValuePair doOptimize() {\ncheckParameters();\n\nfinal int nR = getTarget().length; // Number of observed data.\nfinal double[] currentPoint = getStartPoint();\nfinal int nC = currentPoint.length; // Number of parameters.\n\n// arrays shared with the other private methods\nsolvedCols  = FastMath.min(nR, nC);\ndiagR       = new double[nC];\njacNorm     = new double[nC];\nbeta        = new double[nC];\npermutation = new int[nC];\nlmDir       = new double[nC];\n\n// local point\ndouble   delta   = 0;\ndouble   xNorm   = 0;\ndouble[] diag    = new double[nC];\ndouble[] oldX    = new double[nC];\ndouble[] oldRes  = new double[nR];\ndouble[] oldObj  = new double[nR];\ndouble[] qtf     = new double[nR];\ndouble[] work1   = new double[nC];\ndouble[] work2   = new double[nC];\ndouble[] work3   = new double[nC];\n\nfinal RealMatrix weightMatrixSqrt = getWeightSquareRoot();\n\n// Evaluate the function at the starting point and calculate its norm.\ndouble[] currentObjective = computeObjectiveValue(currentPoint);\ndouble[] currentResiduals = computeResiduals(currentObjective);\nPointVectorValuePair current = new PointVectorValuePair(currentPoint, currentObjective);\ndouble currentCost = computeCost(currentResiduals);\n\n// Outer loop.\nlmPar = 0;\nboolean firstIteration = true;\nint iter = 0;\nfinal ConvergenceChecker<PointVectorValuePair> checker = getConvergenceChecker();\nwhile (true) {\n++iter;\nfinal PointVectorValuePair previous = current;\n\n// QR decomposition of the jacobian matrix\nqrDecomposition(computeWeightedJacobian(currentPoint));\n\nweightedResidual = weightMatrixSqrt.operate(currentResiduals);\nfor (int i = 0; i < nR; i++) {\nqtf[i] = weightedResidual[i];\n}\n\n// compute Qt.res\nqTy(qtf);\n\n// now we don't need Q anymore,\n// so let jacobian contain the R matrix with its diagonal elements\nfor (int k = 0; k < solvedCols; ++k) {\nint pk = permutation[k];\nweightedJacobian[k][pk] = diagR[pk];\n}\n\nif (firstIteration) {\n// scale the point according to the norms of the columns\n// of the initial jacobian\nxNorm = 0;\nfor (int k = 0; k < nC; ++k) {\ndouble dk = jacNorm[k];\nif (dk == 0) {\ndk = 1.0;\n}\ndouble xk = dk * currentPoint[k];\nxNorm  += xk * xk;\ndiag[k] = dk;\n}\nxNorm = FastMath.sqrt(xNorm);\n\n// initialize the step bound delta\ndelta = (xNorm == 0) ? initialStepBoundFactor : (initialStepBoundFactor * xNorm);\n}\n\n// check orthogonality between function vector and jacobian columns\ndouble maxCosine = 0;\nif (currentCost != 0) {\nfor (int j = 0; j < solvedCols; ++j) {\nint    pj = permutation[j];\ndouble s  = jacNorm[pj];\nif (s != 0) {\ndouble sum = 0;\nfor (int i = 0; i <= j; ++i) {\nsum += weightedJacobian[i][pj] * qtf[i];\n}\nmaxCosine = FastMath.max(maxCosine, FastMath.abs(sum) / (s * currentCost));\n}\n}\n}\nif (maxCosine <= orthoTolerance) {\n// Convergence has been reached.\nsetCost(currentCost);\nreturn current;\n}\n\n// rescale if necessary\nfor (int j = 0; j < nC; ++j) {\ndiag[j] = FastMath.max(diag[j], jacNorm[j]);\n}\n\n// Inner loop.\nfor (double ratio = 0; ratio < 1.0e-4;) {\n\n// save the state\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\noldX[pj] = currentPoint[pj];\n}\nfinal double previousCost = currentCost;\ndouble[] tmpVec = weightedResidual;\nweightedResidual = oldRes;\noldRes    = tmpVec;\ntmpVec    = currentObjective;\ncurrentObjective = oldObj;\noldObj    = tmpVec;\n\n// determine the Levenberg-Marquardt parameter\ndetermineLMParameter(qtf, delta, diag, work1, work2, work3);\n\n// compute the new point and the norm of the evolution direction\ndouble lmNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nlmDir[pj] = -lmDir[pj];\ncurrentPoint[pj] = oldX[pj] + lmDir[pj];\ndouble s = diag[pj] * lmDir[pj];\nlmNorm  += s * s;\n}\nlmNorm = FastMath.sqrt(lmNorm);\n// on the first iteration, adjust the initial step bound.\nif (firstIteration) {\ndelta = FastMath.min(delta, lmNorm);\n}\n\n// Evaluate the function at x + p and calculate its norm.\ncurrentObjective = computeObjectiveValue(currentPoint);\ncurrentResiduals = computeResiduals(currentObjective);\ncurrent = new PointVectorValuePair(currentPoint, currentObjective);\ncurrentCost = computeCost(currentResiduals);\n\n// compute the scaled actual reduction\ndouble actRed = -1.0;\nif (0.1 * currentCost < previousCost) {\ndouble r = currentCost / previousCost;\nactRed = 1.0 - r * r;\n}\n\n// compute the scaled predicted reduction\n// and the scaled directional derivative\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble dirJ = lmDir[pj];\nwork1[j] = 0;\nfor (int i = 0; i <= j; ++i) {\nwork1[i] += weightedJacobian[i][pj] * dirJ;\n}\n}\ndouble coeff1 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\ncoeff1 += work1[j] * work1[j];\n}\ndouble pc2 = previousCost * previousCost;\ncoeff1 = coeff1 / pc2;\ndouble coeff2 = lmPar * lmNorm * lmNorm / pc2;\ndouble preRed = coeff1 + 2 * coeff2;\ndouble dirDer = -(coeff1 + coeff2);\n\n// ratio of the actual to the predicted reduction\nratio = (preRed == 0) ? 0 : (actRed / preRed);\n\n// update the step bound\nif (ratio <= 0.25) {\ndouble tmp =\n(actRed < 0) ? (0.5 * dirDer / (dirDer + 0.5 * actRed)) : 0.5;\nif ((0.1 * currentCost >= previousCost) || (tmp < 0.1)) {\ntmp = 0.1;\n}\ndelta = tmp * FastMath.min(delta, 10.0 * lmNorm);\nlmPar /= tmp;\n} else if ((lmPar == 0) || (ratio >= 0.75)) {\ndelta = 2 * lmNorm;\nlmPar *= 0.5;\n}\n\n// test for successful iteration.\nif (ratio >= 1.0e-4) {\n// successful iteration, update the norm\nfirstIteration = false;\nxNorm = 0;\nfor (int k = 0; k < nC; ++k) {\ndouble xK = diag[k] * currentPoint[k];\nxNorm += xK * xK;\n}\nxNorm = FastMath.sqrt(xNorm);\n\n// tests for convergence.\nif (checker != null) {\n// we use the vectorial convergence checker\nif (checker.converged(iter, previous, current)) {\nsetCost(currentCost);\nreturn current;\n}\n}\n} else {\n// failed iteration, reset the previous values\ncurrentCost = previousCost;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ncurrentPoint[pj] = oldX[pj];\n}\ntmpVec    = weightedResidual;\nweightedResidual = oldRes;\noldRes    = tmpVec;\ntmpVec    = currentObjective;\ncurrentObjective = oldObj;\noldObj    = tmpVec;\n// Reset \"current\" to previous values.\ncurrent = new PointVectorValuePair(currentPoint, currentObjective);\n}\n\n// Default convergence criteria.\nif ((FastMath.abs(actRed) <= costRelativeTolerance &&\npreRed <= costRelativeTolerance &&\nratio <= 2.0) ||\ndelta <= parRelativeTolerance * xNorm) {\nsetCost(currentCost);\nreturn current;\n}\n\n// tests for termination and stringent tolerances\n// (2.2204e-16 is the machine epsilon for IEEE754)\nif ((FastMath.abs(actRed) <= 2.2204e-16) && (preRed <= 2.2204e-16) && (ratio <= 2.0)) {\nthrow new ConvergenceException(LocalizedFormats.TOO_SMALL_COST_RELATIVE_TOLERANCE,\ncostRelativeTolerance);\n} else if (delta <= 2.2204e-16 * xNorm) {\nthrow new ConvergenceException(LocalizedFormats.TOO_SMALL_PARAMETERS_RELATIVE_TOLERANCE,\nparRelativeTolerance);\n} else if (maxCosine <= 2.2204e-16)  {\nthrow new ConvergenceException(LocalizedFormats.TOO_SMALL_ORTHOGONALITY_TOLERANCE,\northoTolerance);\n}\n}\n}\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:getTarget()[D",
            "method_body": "public double[] getTarget() {\nreturn target.clone();\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:getCount()I",
            "method_body": "public int getCount() {\nreturn count;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>([[D)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d)\nthrows DimensionMismatchException, NoDataException, NullArgumentException {\ncopyIn(d);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:setCost(D)V",
            "method_body": "protected void setCost(double cost) {\nthis.cost = cost;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() throws MaxCountExceededException {\nif (++count > maximalCount) {\nmaxCountCallback.trigger(maximalCount);\n}\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:getInitialGuess()[D",
            "method_body": "public double[] getInitialGuess() {\nreturn init.clone();\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:qTy([D)V",
            "method_body": "private void qTy(double[] y) {\nfinal int nR = weightedJacobian.length;\nfinal int nC = weightedJacobian[0].length;\n\nfor (int k = 0; k < nC; ++k) {\nint pk = permutation[k];\ndouble gamma = 0;\nfor (int i = k; i < nR; ++i) {\ngamma += weightedJacobian[i][pk] * y[i];\n}\ngamma *= beta[pk];\nfor (int i = k; i < nR; ++i) {\ny[i] -= gamma * weightedJacobian[i][pk];\n}\n}\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (start != null) {\nfinal int dim = start.length;\nif (lowerBound != null) {\nif (lowerBound.length != dim) {\nthrow new DimensionMismatchException(lowerBound.length, dim);\n}\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double lo = lowerBound[i];\nif (v < lo) {\nthrow new NumberIsTooSmallException(v, lo, true);\n}\n}\n}\nif (upperBound != null) {\nif (upperBound.length != dim) {\nthrow new DimensionMismatchException(upperBound.length, dim);\n}\nfor (int i = 0; i < dim; i++) {\nfinal double v = start[i];\nfinal double hi = upperBound[i];\nif (v > hi) {\nthrow new NumberIsTooLargeException(v, hi, true);\n}\n}\n}\n}\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:<init>(II)V",
            "method_body": "protected AbstractRealMatrix(final int rowDimension,\nfinal int columnDimension)\nthrows NotStrictlyPositiveException {\nif (rowDimension < 1) {\nthrow new NotStrictlyPositiveException(rowDimension);\n}\nif (columnDimension < 1) {\nthrow new NotStrictlyPositiveException(columnDimension);\n}\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkMultiplicationCompatible(Lorg/apache/commons/math3/linear/AnyMatrix;Lorg/apache/commons/math3/linear/AnyMatrix;)V",
            "method_body": "public static void checkMultiplicationCompatible(final AnyMatrix left, final AnyMatrix right)\nthrows DimensionMismatchException {\n\nif (left.getColumnDimension() != right.getRowDimension()) {\nthrow new DimensionMismatchException(left.getColumnDimension(),\nright.getRowDimension());\n}\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:<init>(DDDDD)V",
            "method_body": "public LevenbergMarquardtOptimizer(double initialStepBoundFactor,\ndouble costRelativeTolerance,\ndouble parRelativeTolerance,\ndouble orthoTolerance,\ndouble threshold) {\nsuper(null); // No custom convergence criterion.\nthis.initialStepBoundFactor = initialStepBoundFactor;\nthis.costRelativeTolerance = costRelativeTolerance;\nthis.parRelativeTolerance = parRelativeTolerance;\nthis.orthoTolerance = orthoTolerance;\nthis.qrRankingThreshold = threshold;\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (getLowerBound() != null ||\ngetUpperBound() != null) {\nthrow new MathUnsupportedOperationException(LocalizedFormats.CONSTRAINT);\n}\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction:getModelFunction()Lorg/apache/commons/math3/analysis/MultivariateVectorFunction;",
            "method_body": "public MultivariateVectorFunction getModelFunction() {\nreturn model;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:<init>([DZ)V",
            "method_body": "public ArrayRealVector(double[] d, boolean copyArray)\nthrows NullArgumentException {\nif (d == null) {\nthrow new NullArgumentException();\n}\ndata = copyArray ? d.clone() :  d;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getData()[[D",
            "method_body": "public double[][] getData() {\nreturn copyOut();\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian:<init>(Lorg/apache/commons/math3/analysis/MultivariateMatrixFunction;)V",
            "method_body": "public ModelFunctionJacobian(MultivariateMatrixFunction j) {\njacobian = j;\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointVectorValuePair;",
            "method_body": "public PointVectorValuePair optimize(OptimizationData... optData)\nthrows TooManyEvaluationsException {\n// Set up base class and perform computation.\nreturn super.optimize(optData);\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathUtils:checkNotNull(Ljava/lang/Object;)V",
            "method_body": "public static void checkNotNull(Object o)\nthrows NullArgumentException {\nif (o == null) {\nthrow new NullArgumentException();\n}\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:<init>([DZ)V",
            "method_body": "public DiagonalMatrix(final double[] d, final boolean copyArray)\nthrows NullArgumentException {\nMathUtils.checkNotNull(d);\ndata = copyArray ? d.clone() : d;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:min(DD)D",
            "method_body": "public static double min(final double a, final double b) {\nif (a > b) {\nreturn b;\n}\nif (a < b) {\nreturn a;\n}\n/* if either arg is NaN, return NaN */\nif (a != b) {\nreturn Double.NaN;\n}\n/* min(+0.0,-0.0) == -0.0 */\n/* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn a;\n}\nreturn b;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\n// The existing values (as set by the previous call) are reused if\n// not provided in the argument list.\nfor (OptimizationData data : optData) {\nif (data instanceof MaxEval) {\nevaluations.setMaximalCount(((MaxEval) data).getMaxEval());\ncontinue;\n}\nif (data instanceof MaxIter) {\niterations.setMaximalCount(((MaxIter) data).getMaxIter());\ncontinue;\n}\n}\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected MultivariateVectorOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected JacobianMultivariateVectorOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:<init>([D)V",
            "method_body": "public ArrayRealVector(double[] d) {\ndata = d.clone();\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointVectorValuePair:<init>([D[D)V",
            "method_body": "public PointVectorValuePair(final double[] point,\nfinal double[] value) {\nthis(point, value, true);\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:pow(DI)D",
            "method_body": "public static double pow(double d, int e) {\n\nif (e == 0) {\nreturn 1.0;\n} else if (e < 0) {\ne = -e;\nd = 1.0 / d;\n}\n\n// split d as two 26 bits numbers\n// beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\nfinal int splitFactor = 0x8000001;\nfinal double cd       = splitFactor * d;\nfinal double d1High   = cd - (cd - d);\nfinal double d1Low    = d - d1High;\n\n// prepare result\ndouble resultHigh = 1;\ndouble resultLow  = 0;\n\n// d^(2p)\ndouble d2p     = d;\ndouble d2pHigh = d1High;\ndouble d2pLow  = d1Low;\n\nwhile (e != 0) {\n\nif ((e & 0x1) != 0) {\n// accurate multiplication result = result * d^(2p) using Veltkamp TwoProduct algorithm\n// beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\nfinal double tmpHigh = resultHigh * d2p;\nfinal double cRH     = splitFactor * resultHigh;\nfinal double rHH     = cRH - (cRH - resultHigh);\nfinal double rHL     = resultHigh - rHH;\nfinal double tmpLow  = rHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);\nresultHigh = tmpHigh;\nresultLow  = resultLow * d2p + tmpLow;\n}\n\n// accurate squaring d^(2(p+1)) = d^(2p) * d^(2p) using Veltkamp TwoProduct algorithm\n// beware the following expressions must NOT be simplified, they rely on floating point arithmetic properties\nfinal double tmpHigh = d2pHigh * d2p;\nfinal double cD2pH   = splitFactor * d2pHigh;\nfinal double d2pHH   = cD2pH - (cD2pH - d2pHigh);\nfinal double d2pHL   = d2pHigh - d2pHH;\nfinal double tmpLow  = d2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);\nfinal double cTmpH   = splitFactor * tmpHigh;\nd2pHigh = cTmpH - (cTmpH - tmpHigh);\nd2pLow  = d2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);\nd2p     = d2pHigh + d2pLow;\n\ne = e >> 1;\n\n}\n\nreturn resultHigh + resultLow;\n\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:getMaxEval()I",
            "method_body": "public int getMaxEval() {\nreturn maxEval;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getLowerBound()[D",
            "method_body": "public double[] getLowerBound() {\nreturn lowerBound == null ? null : lowerBound.clone();\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:computeWeightedJacobian([D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "protected RealMatrix computeWeightedJacobian(double[] params) {\nreturn weightMatrixSqrt.multiply(MatrixUtils.createRealMatrix(computeJacobian(params)));\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\n// Allow base class to register its own data.\nsuper.parseOptimizationData(optData);\n\n// The existing values (as set by the previous call) are reused if\n// not provided in the argument list.\nfor (OptimizationData data : optData) {\nif (data instanceof Weight) {\nweightMatrixSqrt = squareRoot(((Weight) data).getWeight());\n// If more data must be parsed, this statement _must_ be\n// changed to \"continue\".\nbreak;\n}\n}\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\n// Allow base class to register its own data.\nsuper.parseOptimizationData(optData);\n\n// The existing values (as set by the previous call) are reused if\n// not provided in the argument list.\nfor (OptimizationData data : optData) {\nif (data instanceof ModelFunction) {\nmodel = ((ModelFunction) data).getModelFunction();\ncontinue;\n}\nif (data instanceof Target) {\ntarget = ((Target) data).getTarget();\ncontinue;\n}\nif (data instanceof Weight) {\nweightMatrix = ((Weight) data).getWeight();\ncontinue;\n}\n}\n\n// Check input consistency.\ncheckParameters();\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column)\nthrows OutOfRangeException {\nMatrixUtils.checkMatrixIndex(this, row, column);\nreturn data[row][column];\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:copy()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix copy() {\nreturn new DiagonalMatrix(data);\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(DD)D",
            "method_body": "public static double max(final double a, final double b) {\nif (a > b) {\nreturn a;\n}\nif (a < b) {\nreturn b;\n}\n/* if either arg is NaN, return NaN */\nif (a != b) {\nreturn Double.NaN;\n}\n/* min(+0.0,-0.0) == -0.0 */\n/* 0x8000000000000000L == Double.doubleToRawLongBits(-0.0d) */\nlong bits = Double.doubleToRawLongBits(a);\nif (bits == 0x8000000000000000L) {\nreturn b;\n}\nreturn a;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:checkParameters()V",
            "method_body": "private void checkParameters() {\nif (target.length != weightMatrix.getColumnDimension()) {\nthrow new DimensionMismatchException(target.length,\nweightMatrix.getColumnDimension());\n}\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.Weight:getWeight()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getWeight() {\nreturn weightMatrix.copy();\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>([[DZ)V",
            "method_body": "public Array2DRowRealMatrix(final double[][] d, final boolean copyArray)\nthrows DimensionMismatchException, NoDataException,\nNullArgumentException {\nif (copyArray) {\ncopyIn(d);\n} else {\nif (d == null) {\nthrow new NullArgumentException();\n}\nfinal int nRows = d.length;\nif (nRows == 0) {\nthrow new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n}\nfinal int nCols = d[0].length;\nif (nCols == 0) {\nthrow new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n}\nfor (int r = 1; r < nRows; r++) {\nif (d[r].length != nCols) {\nthrow new DimensionMismatchException(d[r].length, nCols);\n}\n}\ndata = d;\n}\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.Target:<init>([D)V",
            "method_body": "public Target(double[] observations) {\ntarget = observations.clone();\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:computeCost([D)D",
            "method_body": "protected double computeCost(double[] residuals) {\nfinal ArrayRealVector r = new ArrayRealVector(residuals);\nreturn FastMath.sqrt(r.dotProduct(getWeight().operate(r)));\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:incrementEvaluationCount()V",
            "method_body": "protected abstract PAIR doOptimize();\n\n/**\n* Increment the evaluation count.\n*\n* @throws TooManyEvaluationsException if the allowed evaluations\n* have been exhausted.\n*/\nprotected void incrementEvaluationCount()\nthrows TooManyEvaluationsException {\nevaluations.incrementCount();\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:setEntry(IID)V",
            "method_body": "public void setEntry(final int row, final int column, final double value)\nthrows OutOfRangeException {\nMatrixUtils.checkMatrixIndex(this, row, column);\ndata[row][column] = value;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:setEntry(IID)V",
            "method_body": "public void setEntry(final int row, final int column, final double value)\nthrows OutOfRangeException, NumberIsTooLargeException {\nif (row == column) {\nMatrixUtils.checkRowIndex(this, row);\ndata[row] = value;\n} else {\nensureZero(value);\n}\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getStartPoint()[D",
            "method_body": "public double[] getStartPoint() {\nreturn start == null ? null : start.clone();\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max, MaxCountExceededCallback cb)\nthrows NullArgumentException {\nif (cb == null){\nthrow new NullArgumentException();\n}\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointVectorValuePair;",
            "method_body": "public PointVectorValuePair optimize(OptimizationData... optData)\nthrows TooManyEvaluationsException,\nDimensionMismatchException {\n// Set up base class and perform computation.\nreturn super.optimize(optData);\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkColumnIndex(Lorg/apache/commons/math3/linear/AnyMatrix;I)V",
            "method_body": "public static void checkColumnIndex(final AnyMatrix m, final int column)\nthrows OutOfRangeException {\nif (column < 0 || column >= m.getColumnDimension()) {\nthrow new OutOfRangeException(LocalizedFormats.COLUMN_INDEX,\ncolumn, 0, m.getColumnDimension() - 1);\n}\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:getUpperBound()[D",
            "method_body": "public double[] getUpperBound() {\nreturn upperBound == null ? null : upperBound.clone();\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn data.length;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:<init>([D)V",
            "method_body": "public DiagonalMatrix(final double[] d) {\nthis(d, true);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:qrDecomposition(Lorg/apache/commons/math3/linear/RealMatrix;)V",
            "method_body": "private void qrDecomposition(RealMatrix jacobian) throws ConvergenceException {\n// Code in this class assumes that the weighted Jacobian is -(W^(1/2) J),\n// hence the multiplication by -1.\nweightedJacobian = jacobian.scalarMultiply(-1).getData();\n\nfinal int nR = weightedJacobian.length;\nfinal int nC = weightedJacobian[0].length;\n\n// initializations\nfor (int k = 0; k < nC; ++k) {\npermutation[k] = k;\ndouble norm2 = 0;\nfor (int i = 0; i < nR; ++i) {\ndouble akk = weightedJacobian[i][k];\nnorm2 += akk * akk;\n}\njacNorm[k] = FastMath.sqrt(norm2);\n}\n\n// transform the matrix column after column\nfor (int k = 0; k < nC; ++k) {\n\n// select the column with the greatest norm on active components\nint nextColumn = -1;\ndouble ak2 = Double.NEGATIVE_INFINITY;\nfor (int i = k; i < nC; ++i) {\ndouble norm2 = 0;\nfor (int j = k; j < nR; ++j) {\ndouble aki = weightedJacobian[j][permutation[i]];\nnorm2 += aki * aki;\n}\nif (Double.isInfinite(norm2) || Double.isNaN(norm2)) {\nthrow new ConvergenceException(LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN,\nnR, nC);\n}\nif (norm2 > ak2) {\nnextColumn = i;\nak2        = norm2;\n}\n}\nif (ak2 <= qrRankingThreshold) {\nrank = k;\nreturn;\n}\nint pk                  = permutation[nextColumn];\npermutation[nextColumn] = permutation[k];\npermutation[k]          = pk;\n\n// choose alpha such that Hk.u = alpha ek\ndouble akk   = weightedJacobian[k][pk];\ndouble alpha = (akk > 0) ? -FastMath.sqrt(ak2) : FastMath.sqrt(ak2);\ndouble betak = 1.0 / (ak2 - akk * alpha);\nbeta[pk]     = betak;\n\n// transform the current column\ndiagR[pk]        = alpha;\nweightedJacobian[k][pk] -= alpha;\n\n// transform the remaining columns\nfor (int dk = nC - 1 - k; dk > 0; --dk) {\ndouble gamma = 0;\nfor (int j = k; j < nR; ++j) {\ngamma += weightedJacobian[j][pk] * weightedJacobian[j][permutation[k + dk]];\n}\ngamma *= betak;\nfor (int j = k; j < nR; ++j) {\nweightedJacobian[j][permutation[k + dk]] -= gamma * weightedJacobian[j][pk];\n}\n}\n}\nrank = solvedCols;\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunction:<init>(Lorg/apache/commons/math3/analysis/MultivariateVectorFunction;)V",
            "method_body": "public ModelFunction(MultivariateVectorFunction m) {\nmodel = m;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData) {\n// Perform optimization.\nreturn super.optimize(optData);\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected AbstractLeastSquaresOptimizer(ConvergenceChecker<PointVectorValuePair> checker) {\nsuper(checker);\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:getEntry(II)D",
            "method_body": "public double getEntry(final int row, final int column)\nthrows OutOfRangeException {\nMatrixUtils.checkMatrixIndex(this, row, column);\nreturn row == column ? data[row] : 0;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getIterations()I",
            "method_body": "public int getIterations() {\nreturn iterations.getCount();\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:getWeightSquareRoot()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getWeightSquareRoot() {\nreturn weightMatrixSqrt.copy();\n}",
            "method_id": 60
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.Weight:<init>([D)V",
            "method_body": "public Weight(double[] weight) {\nweightMatrix = new DiagonalMatrix(weight);\n}",
            "method_id": 61
        },
        {
            "method_signature": "org.apache.commons.math3.optim.MaxEval:<init>(I)V",
            "method_body": "public MaxEval(int max) {\nif (max <= 0) {\nthrow new NotStrictlyPositiveException(max);\n}\n\nmaxEval = max;\n}",
            "method_id": 62
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:checkVectorDimensions(I)V",
            "method_body": "protected void checkVectorDimensions(int n)\nthrows DimensionMismatchException {\nif (data.length != n) {\nthrow new DimensionMismatchException(data.length, n);\n}\n}",
            "method_id": 63
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:<init>(II)V",
            "method_body": "public Array2DRowRealMatrix(final int rowDimension,\nfinal int columnDimension)\nthrows NotStrictlyPositiveException {\nsuper(rowDimension, columnDimension);\ndata = new double[rowDimension][columnDimension];\n}",
            "method_id": 64
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:computeObjectiveValue([D)[D",
            "method_body": "protected double[] computeObjectiveValue(double[] params) {\nsuper.incrementEvaluationCount();\nreturn model.value(params);\n}",
            "method_id": 65
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:getDataRef()[D",
            "method_body": "public double[] getDataRef() {\nreturn data;\n}",
            "method_id": 66
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseMultivariateOptimizer:<init>(Lorg/apache/commons/math3/optim/ConvergenceChecker;)V",
            "method_body": "protected BaseMultivariateOptimizer(ConvergenceChecker<PAIR> checker) {\nsuper(checker);\n}",
            "method_id": 67
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer:parseOptimizationData([Lorg/apache/commons/math3/optim/OptimizationData;)V",
            "method_body": "protected void parseOptimizationData(OptimizationData... optData) {\n// Allow base class to register its own data.\nsuper.parseOptimizationData(optData);\n\n// The existing values (as set by the previous call) are reused if\n// not provided in the argument list.\nfor (OptimizationData data : optData) {\nif (data instanceof ModelFunctionJacobian) {\njacobian = ((ModelFunctionJacobian) data).getModelFunctionJacobian();\n// If more data must be parsed, this statement _must_ be\n// changed to \"continue\".\nbreak;\n}\n}\n}",
            "method_id": 68
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.Target:getTarget()[D",
            "method_body": "public double[] getTarget() {\nreturn target.clone();\n}",
            "method_id": 69
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyIn([[D)V",
            "method_body": "private void copyIn(final double[][] in)\nthrows DimensionMismatchException, NoDataException, NullArgumentException {\nsetSubMatrix(in, 0, 0);\n}",
            "method_id": 70
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:getDataRef()[D",
            "method_body": "public double[] getDataRef() {\nreturn data;\n}",
            "method_id": 71
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:getWeight()Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix getWeight() {\nreturn weightMatrix.copy();\n}",
            "method_id": 72
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:min(II)I",
            "method_body": "public static int min(final int a, final int b) {\nreturn (a <= b) ? a : b;\n}",
            "method_id": 73
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getRowDimension()I",
            "method_body": "public int getRowDimension() {\nreturn (data == null) ? 0 : data.length;\n}",
            "method_id": 74
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn ((data == null) || (data[0] == null)) ? 0 : data[0].length;\n}",
            "method_id": 75
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:createRealMatrix([[D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public static RealMatrix createRealMatrix(double[][] data)\nthrows NullArgumentException, DimensionMismatchException,\nNoDataException {\nif (data == null ||\ndata[0] == null) {\nthrow new NullArgumentException();\n}\nreturn (data.length * data[0].length <= 4096) ?\nnew Array2DRowRealMatrix(data) : new BlockRealMatrix(data);\n}",
            "method_id": 76
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:operate(Lorg/apache/commons/math3/linear/RealVector;)Lorg/apache/commons/math3/linear/RealVector;",
            "method_body": "public RealVector operate(final RealVector v)\nthrows DimensionMismatchException {\ntry {\nreturn new ArrayRealVector(operate(((ArrayRealVector) v).getDataRef()), false);\n} catch (ClassCastException cce) {\nfinal int nRows = getRowDimension();\nfinal int nCols = getColumnDimension();\nif (v.getDimension() != nCols) {\nthrow new DimensionMismatchException(v.getDimension(), nCols);\n}\n\nfinal double[] out = new double[nRows];\nfor (int row = 0; row < nRows; ++row) {\ndouble sum = 0;\nfor (int i = 0; i < nCols; ++i) {\nsum += getEntry(row, i) * v.getEntry(i);\n}\nout[row] = sum;\n}\n\nreturn new ArrayRealVector(out, false);\n}\n}",
            "method_id": 77
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:getColumnDimension()I",
            "method_body": "public int getColumnDimension() {\nreturn data.length;\n}",
            "method_id": 78
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:squareRoot(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "private RealMatrix squareRoot(RealMatrix m) {\nif (m instanceof DiagonalMatrix) {\nfinal int dim = m.getRowDimension();\nfinal RealMatrix sqrtM = new DiagonalMatrix(dim);\nfor (int i = 0; i < dim; i++) {\nsqrtM.setEntry(i, i, FastMath.sqrt(m.getEntry(i, i)));\n}\nreturn sqrtM;\n} else {\nfinal EigenDecomposition dec = new EigenDecomposition(m);\nreturn dec.getSquareRoot();\n}\n}",
            "method_id": 79
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.ModelFunctionJacobian:getModelFunctionJacobian()Lorg/apache/commons/math3/analysis/MultivariateMatrixFunction;",
            "method_body": "public MultivariateMatrixFunction getModelFunctionJacobian() {\nreturn jacobian;\n}",
            "method_id": 80
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkMatrixIndex(Lorg/apache/commons/math3/linear/AnyMatrix;II)V",
            "method_body": "public static void checkMatrixIndex(final AnyMatrix m,\nfinal int row, final int column)\nthrows OutOfRangeException {\ncheckRowIndex(m, row);\ncheckColumnIndex(m, column);\n}",
            "method_id": 81
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:copyOut()[[D",
            "method_body": "private double[][] copyOut() {\nfinal int nRows = this.getRowDimension();\nfinal double[][] out = new double[nRows][this.getColumnDimension()];\n// can't copy 2-d array in one shot, otherwise get row references\nfor (int i = 0; i < nRows; i++) {\nSystem.arraycopy(data[i], 0, out[i], 0, data[i].length);\n}\nreturn out;\n}",
            "method_id": 82
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.AbstractLeastSquaresOptimizer:computeResiduals([D)[D",
            "method_body": "protected double[] computeResiduals(double[] objectiveValue) {\nfinal double[] target = getTarget();\nif (objectiveValue.length != target.length) {\nthrow new DimensionMismatchException(target.length,\nobjectiveValue.length);\n}\n\nfinal double[] residuals = new double[target.length];\nfor (int i = 0; i < target.length; i++) {\nresiduals[i] = target[i] - objectiveValue[i];\n}\n\nreturn residuals;\n}",
            "method_id": 83
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Ljava/lang/Object;",
            "method_body": "public PAIR optimize(OptimizationData... optData)\nthrows TooManyEvaluationsException,\nTooManyIterationsException {\n// Parse options.\nparseOptimizationData(optData);\n\n// Reset counters.\nevaluations.resetCount();\niterations.resetCount();\n// Perform optimization.\nreturn doOptimize();\n}",
            "method_id": 84
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 85
        },
        {
            "method_signature": "org.apache.commons.math3.optim.PointVectorValuePair:<init>([D[DZ)V",
            "method_body": "public PointVectorValuePair(final double[] point,\nfinal double[] value,\nfinal boolean copyArray) {\nsuper(copyArray ?\n((point == null) ? null :\npoint.clone()) :\npoint,\ncopyArray ?\n((value == null) ? null :\nvalue.clone()) :\nvalue);\n}",
            "method_id": 86
        },
        {
            "method_signature": "org.apache.commons.math3.linear.AbstractRealMatrix:scalarMultiply(D)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix scalarMultiply(final double d) {\nfinal int rowCount    = getRowDimension();\nfinal int columnCount = getColumnDimension();\nfinal RealMatrix out = createMatrix(rowCount, columnCount);\nfor (int row = 0; row < rowCount; ++row) {\nfor (int col = 0; col < columnCount; ++col) {\nout.setEntry(row, col, getEntry(row, col) * d);\n}\n}\n\nreturn out;\n}",
            "method_id": 87
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:multiply(Lorg/apache/commons/math3/linear/RealMatrix;)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix multiply(final RealMatrix m)\nthrows DimensionMismatchException {\nif (m instanceof DiagonalMatrix) {\nreturn multiply((DiagonalMatrix) m);\n} else {\nMatrixUtils.checkMultiplicationCompatible(this, m);\nfinal int nRows = m.getRowDimension();\nfinal int nCols = m.getColumnDimension();\nfinal double[][] product = new double[nRows][nCols];\nfor (int r = 0; r < nRows; r++) {\nfor (int c = 0; c < nCols; c++) {\nproduct[r][c] = data[r] * m.getEntry(r, c);\n}\n}\nreturn new Array2DRowRealMatrix(product, false);\n}\n}",
            "method_id": 88
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:multiply(Lorg/apache/commons/math3/linear/DiagonalMatrix;)Lorg/apache/commons/math3/linear/DiagonalMatrix;",
            "method_body": "public DiagonalMatrix multiply(final DiagonalMatrix m)\nthrows DimensionMismatchException {\nMatrixUtils.checkMultiplicationCompatible(this, m);\n\nfinal int dim = getRowDimension();\nfinal double[] outData = new double[dim];\nfor (int i = 0; i < dim; i++) {\noutData[i] = data[i] * m.data[i];\n}\n\nreturn new DiagonalMatrix(outData, false);\n}",
            "method_id": 89
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:determineLMParameter([DD[D[D[D[D)V",
            "method_body": "private void determineLMParameter(double[] qy, double delta, double[] diag,\ndouble[] work1, double[] work2, double[] work3) {\nfinal int nC = weightedJacobian[0].length;\n\n// compute and store in x the gauss-newton direction, if the\n// jacobian is rank-deficient, obtain a least squares solution\nfor (int j = 0; j < rank; ++j) {\nlmDir[permutation[j]] = qy[j];\n}\nfor (int j = rank; j < nC; ++j) {\nlmDir[permutation[j]] = 0;\n}\nfor (int k = rank - 1; k >= 0; --k) {\nint pk = permutation[k];\ndouble ypk = lmDir[pk] / diagR[pk];\nfor (int i = 0; i < k; ++i) {\nlmDir[permutation[i]] -= ypk * weightedJacobian[i][pk];\n}\nlmDir[pk] = ypk;\n}\n\n// evaluate the function at the origin, and test\n// for acceptance of the Gauss-Newton direction\ndouble dxNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble s = diag[pj] * lmDir[pj];\nwork1[pj] = s;\ndxNorm += s * s;\n}\ndxNorm = FastMath.sqrt(dxNorm);\ndouble fp = dxNorm - delta;\nif (fp <= 0.1 * delta) {\nlmPar = 0;\nreturn;\n}\n\n// if the jacobian is not rank deficient, the Newton step provides\n// a lower bound, parl, for the zero of the function,\n// otherwise set this bound to zero\ndouble sum2;\ndouble parl = 0;\nif (rank == solvedCols) {\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] *= diag[pj] / dxNorm;\n}\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = 0; i < j; ++i) {\nsum += weightedJacobian[i][pj] * work1[permutation[i]];\n}\ndouble s = (work1[pj] - sum) / diagR[pj];\nwork1[pj] = s;\nsum2 += s * s;\n}\nparl = fp / (delta * sum2);\n}\n\n// calculate an upper bound, paru, for the zero of the function\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = 0; i <= j; ++i) {\nsum += weightedJacobian[i][pj] * qy[i];\n}\nsum /= diag[pj];\nsum2 += sum * sum;\n}\ndouble gNorm = FastMath.sqrt(sum2);\ndouble paru = gNorm / delta;\nif (paru == 0) {\n// 2.2251e-308 is the smallest positive real for IEE754\nparu = 2.2251e-308 / FastMath.min(delta, 0.1);\n}\n\n// if the input par lies outside of the interval (parl,paru),\n// set par to the closer endpoint\nlmPar = FastMath.min(paru, FastMath.max(lmPar, parl));\nif (lmPar == 0) {\nlmPar = gNorm / dxNorm;\n}\n\nfor (int countdown = 10; countdown >= 0; --countdown) {\n\n// evaluate the function at the current value of lmPar\nif (lmPar == 0) {\nlmPar = FastMath.max(2.2251e-308, 0.001 * paru);\n}\ndouble sPar = FastMath.sqrt(lmPar);\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] = sPar * diag[pj];\n}\ndetermineLMDirection(qy, work1, work2, work3);\n\ndxNorm = 0;\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\ndouble s = diag[pj] * lmDir[pj];\nwork3[pj] = s;\ndxNorm += s * s;\n}\ndxNorm = FastMath.sqrt(dxNorm);\ndouble previousFP = fp;\nfp = dxNorm - delta;\n\n// if the function is small enough, accept the current value\n// of lmPar, also test for the exceptional cases where parl is zero\nif ((FastMath.abs(fp) <= 0.1 * delta) ||\n((parl == 0) && (fp <= previousFP) && (previousFP < 0))) {\nreturn;\n}\n\n// compute the Newton correction\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] = work3[pj] * diag[pj] / dxNorm;\n}\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nwork1[pj] /= work2[j];\ndouble tmp = work1[pj];\nfor (int i = j + 1; i < solvedCols; ++i) {\nwork1[permutation[i]] -= weightedJacobian[i][pj] * tmp;\n}\n}\nsum2 = 0;\nfor (int j = 0; j < solvedCols; ++j) {\ndouble s = work1[permutation[j]];\nsum2 += s * s;\n}\ndouble correction = fp / (delta * sum2);\n\n// depending on the sign of the function, update parl or paru.\nif (fp > 0) {\nparl = FastMath.max(parl, lmPar);\n} else if (fp < 0) {\nparu = FastMath.min(paru, lmPar);\n}\n\n// compute an improved estimate for lmPar\nlmPar = FastMath.max(parl, lmPar + correction);\n\n}\n}",
            "method_id": 90
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:createMatrix(II)Lorg/apache/commons/math3/linear/RealMatrix;",
            "method_body": "public RealMatrix createMatrix(final int rowDimension,\nfinal int columnDimension)\nthrows NotStrictlyPositiveException {\nreturn new Array2DRowRealMatrix(rowDimension, columnDimension);\n}",
            "method_id": 91
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:determineLMDirection([D[D[D[D)V",
            "method_body": "private void determineLMDirection(double[] qy, double[] diag,\ndouble[] lmDiag, double[] work) {\n\n// copy R and Qty to preserve input and initialize s\n//  in particular, save the diagonal elements of R in lmDir\nfor (int j = 0; j < solvedCols; ++j) {\nint pj = permutation[j];\nfor (int i = j + 1; i < solvedCols; ++i) {\nweightedJacobian[i][pj] = weightedJacobian[j][permutation[i]];\n}\nlmDir[j] = diagR[pj];\nwork[j]  = qy[j];\n}\n\n// eliminate the diagonal matrix d using a Givens rotation\nfor (int j = 0; j < solvedCols; ++j) {\n\n// prepare the row of d to be eliminated, locating the\n// diagonal element using p from the Q.R. factorization\nint pj = permutation[j];\ndouble dpj = diag[pj];\nif (dpj != 0) {\nArrays.fill(lmDiag, j + 1, lmDiag.length, 0);\n}\nlmDiag[j] = dpj;\n\n//  the transformations to eliminate the row of d\n// modify only a single element of Qty\n// beyond the first n, which is initially zero.\ndouble qtbpj = 0;\nfor (int k = j; k < solvedCols; ++k) {\nint pk = permutation[k];\n\n// determine a Givens rotation which eliminates the\n// appropriate element in the current row of d\nif (lmDiag[k] != 0) {\n\nfinal double sin;\nfinal double cos;\ndouble rkk = weightedJacobian[k][pk];\nif (FastMath.abs(rkk) < FastMath.abs(lmDiag[k])) {\nfinal double cotan = rkk / lmDiag[k];\nsin   = 1.0 / FastMath.sqrt(1.0 + cotan * cotan);\ncos   = sin * cotan;\n} else {\nfinal double tan = lmDiag[k] / rkk;\ncos = 1.0 / FastMath.sqrt(1.0 + tan * tan);\nsin = cos * tan;\n}\n\n// compute the modified diagonal element of R and\n// the modified element of (Qty,0)\nweightedJacobian[k][pk] = cos * rkk + sin * lmDiag[k];\nfinal double temp = cos * work[k] + sin * qtbpj;\nqtbpj = -sin * work[k] + cos * qtbpj;\nwork[k] = temp;\n\n// accumulate the tranformation in the row of s\nfor (int i = k + 1; i < solvedCols; ++i) {\ndouble rik = weightedJacobian[i][pk];\nfinal double temp2 = cos * rik + sin * lmDiag[i];\nlmDiag[i] = -sin * rik + cos * lmDiag[i];\nweightedJacobian[i][pk] = temp2;\n}\n}\n}\n\n// store the diagonal element of s and restore\n// the corresponding diagonal element of R\nlmDiag[j] = weightedJacobian[j][permutation[j]];\nweightedJacobian[j][permutation[j]] = lmDir[j];\n}\n\n// solve the triangular system for z, if the system is\n// singular, then obtain a least squares solution\nint nSing = solvedCols;\nfor (int j = 0; j < solvedCols; ++j) {\nif ((lmDiag[j] == 0) && (nSing == solvedCols)) {\nnSing = j;\n}\nif (nSing < solvedCols) {\nwork[j] = 0;\n}\n}\nif (nSing > 0) {\nfor (int j = nSing - 1; j >= 0; --j) {\nint pj = permutation[j];\ndouble sum = 0;\nfor (int i = j + 1; i < nSing; ++i) {\nsum += weightedJacobian[i][pj] * work[i];\n}\nwork[j] = (work[j] - sum) / lmDiag[j];\n}\n}\n\n// permute the components of z back to components of lmDir\nfor (int j = 0; j < lmDir.length; ++j) {\nlmDir[permutation[j]] = work[j];\n}\n}",
            "method_id": 92
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.jacobian.LevenbergMarquardtOptimizer:<init>()V",
            "method_body": "public LevenbergMarquardtOptimizer() {\nthis(100, 1e-10, 1e-10, 1e-10, Precision.SAFE_MIN);\n}",
            "method_id": 93
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.MultivariateVectorOptimizer:optimize([Lorg/apache/commons/math3/optim/OptimizationData;)Lorg/apache/commons/math3/optim/PointVectorValuePair;",
            "method_body": "public PointVectorValuePair optimize(OptimizationData... optData)\nthrows TooManyEvaluationsException,\nDimensionMismatchException {\n// Set up base class and perform computation.\nreturn super.optimize(optData);\n}",
            "method_id": 94
        },
        {
            "method_signature": "org.apache.commons.math3.linear.ArrayRealVector:dotProduct(Lorg/apache/commons/math3/linear/RealVector;)D",
            "method_body": "public double dotProduct(RealVector v) throws DimensionMismatchException {\nif (v instanceof ArrayRealVector) {\nfinal double[] vData = ((ArrayRealVector) v).data;\ncheckVectorDimensions(vData.length);\ndouble dot = 0;\nfor (int i = 0; i < data.length; i++) {\ndot += data[i] * vData[i];\n}\nreturn dot;\n}\nreturn super.dotProduct(v);\n}",
            "method_id": 95
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:operate([D)[D",
            "method_body": "public double[] operate(final double[] v)\nthrows DimensionMismatchException {\nreturn multiply(new DiagonalMatrix(v, false)).getDataRef();\n}",
            "method_id": 96
        },
        {
            "method_signature": "org.apache.commons.math3.optim.nonlinear.vector.JacobianMultivariateVectorOptimizer:computeJacobian([D)[[D",
            "method_body": "protected double[][] computeJacobian(final double[] params) {\nreturn jacobian.value(params);\n}",
            "method_id": 97
        },
        {
            "method_signature": "org.apache.commons.math3.optim.BaseOptimizer:getConvergenceChecker()Lorg/apache/commons/math3/optim/ConvergenceChecker;",
            "method_body": "public ConvergenceChecker<PAIR> getConvergenceChecker() {\nreturn checker;\n}",
            "method_id": 98
        },
        {
            "method_signature": "org.apache.commons.math3.util.Pair:<init>(Ljava/lang/Object;Ljava/lang/Object;)V",
            "method_body": "public Pair(K k, V v) {\nkey = k;\nvalue = v;\n}",
            "method_id": 99
        },
        {
            "method_signature": "org.apache.commons.math3.linear.Array2DRowRealMatrix:setSubMatrix([[DII)V",
            "method_body": "public void setSubMatrix(final double[][] subMatrix, final int row,\nfinal int column)\nthrows NoDataException, OutOfRangeException,\nDimensionMismatchException, NullArgumentException {\nif (data == null) {\nif (row > 0) {\nthrow new MathIllegalStateException(LocalizedFormats.FIRST_ROWS_NOT_INITIALIZED_YET, row);\n}\nif (column > 0) {\nthrow new MathIllegalStateException(LocalizedFormats.FIRST_COLUMNS_NOT_INITIALIZED_YET, column);\n}\nMathUtils.checkNotNull(subMatrix);\nfinal int nRows = subMatrix.length;\nif (nRows == 0) {\nthrow new NoDataException(LocalizedFormats.AT_LEAST_ONE_ROW);\n}\n\nfinal int nCols = subMatrix[0].length;\nif (nCols == 0) {\nthrow new NoDataException(LocalizedFormats.AT_LEAST_ONE_COLUMN);\n}\ndata = new double[subMatrix.length][nCols];\nfor (int i = 0; i < data.length; ++i) {\nif (subMatrix[i].length != nCols) {\nthrow new DimensionMismatchException(subMatrix[i].length, nCols);\n}\nSystem.arraycopy(subMatrix[i], 0, data[i + row], column, nCols);\n}\n} else {\nsuper.setSubMatrix(subMatrix, row, column);\n}\n\n}",
            "method_id": 100
        },
        {
            "method_signature": "org.apache.commons.math3.optim.InitialGuess:<init>([D)V",
            "method_body": "public InitialGuess(double[] startPoint) {\ninit = startPoint.clone();\n}",
            "method_id": 101
        },
        {
            "method_signature": "org.apache.commons.math3.linear.DiagonalMatrix:<init>(I)V",
            "method_body": "public DiagonalMatrix(final int dimension)\nthrows NotStrictlyPositiveException {\nsuper(dimension, dimension);\ndata = new double[dimension];\n}",
            "method_id": 102
        },
        {
            "method_signature": "org.apache.commons.math3.linear.MatrixUtils:checkRowIndex(Lorg/apache/commons/math3/linear/AnyMatrix;I)V",
            "method_body": "public static void checkRowIndex(final AnyMatrix m, final int row)\nthrows OutOfRangeException {\nif (row < 0 ||\nrow >= m.getRowDimension()) {\nthrow new OutOfRangeException(LocalizedFormats.ROW_INDEX,\nrow, 0, m.getRowDimension() - 1);\n}\n}",
            "method_id": 103
        }
    ]
}