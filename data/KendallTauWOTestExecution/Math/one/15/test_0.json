{
    "bug_id": 15,
    "test_id": 0,
    "test_name": "org.apache.commons.math3.util.FastMathTest.testMath904",
    "test_body": "public void testMath904() {\nfinal double x = -1;\nfinal double y = (5 + 1e-15) * 1e15;\nAssert.assertEquals(Math.pow(x, y),\nFastMath.pow(x, y), 0);\nAssert.assertEquals(Math.pow(x, -y),\nFastMath.pow(x, -y), 0);\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: expected:<-1.0> but was:<1.0>\nat org.junit.Assert.fail(Assert.java:88)\nat org.junit.Assert.failNotEquals(Assert.java:743)\nat org.junit.Assert.assertEquals(Assert.java:494)\nat org.junit.Assert.assertEquals(Assert.java:592)\nat org.apache.commons.math3.util.FastMathTest.testMath904(FastMathTest.java:164)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:pow(DD)D",
            "method_body": "public static double pow(double x, double y) {\nfinal double lns[] = new double[2];\n\nif (y == 0.0) {\nreturn 1.0;\n}\n\nif (x != x) { // X is NaN\nreturn x;\n}\n\n\nif (x == 0) {\nlong bits = Double.doubleToLongBits(x);\nif ((bits & 0x8000000000000000L) != 0) {\n// -zero\nlong yi = (long) y;\n\nif (y < 0 && y == yi && (yi & 1) == 1) {\nreturn Double.NEGATIVE_INFINITY;\n}\n\nif (y > 0 && y == yi && (yi & 1) == 1) {\nreturn -0.0;\n}\n}\n\nif (y < 0) {\nreturn Double.POSITIVE_INFINITY;\n}\nif (y > 0) {\nreturn 0.0;\n}\n\nreturn Double.NaN;\n}\n\nif (x == Double.POSITIVE_INFINITY) {\nif (y != y) { // y is NaN\nreturn y;\n}\nif (y < 0.0) {\nreturn 0.0;\n} else {\nreturn Double.POSITIVE_INFINITY;\n}\n}\n\nif (y == Double.POSITIVE_INFINITY) {\nif (x * x == 1.0) {\nreturn Double.NaN;\n}\n\nif (x * x > 1.0) {\nreturn Double.POSITIVE_INFINITY;\n} else {\nreturn 0.0;\n}\n}\n\nif (x == Double.NEGATIVE_INFINITY) {\nif (y != y) { // y is NaN\nreturn y;\n}\n\nif (y < 0) {\nlong yi = (long) y;\nif (y == yi && (yi & 1) == 1) {\nreturn -0.0;\n}\n\nreturn 0.0;\n}\n\nif (y > 0)  {\nlong yi = (long) y;\nif (y == yi && (yi & 1) == 1) {\nreturn Double.NEGATIVE_INFINITY;\n}\n\nreturn Double.POSITIVE_INFINITY;\n}\n}\n\nif (y == Double.NEGATIVE_INFINITY) {\n\nif (x * x == 1.0) {\nreturn Double.NaN;\n}\n\nif (x * x < 1.0) {\nreturn Double.POSITIVE_INFINITY;\n} else {\nreturn 0.0;\n}\n}\n\n/* Handle special case x<0 */\nif (x < 0) {\n// y is an even integer in this case\nif (y >= TWO_POWER_52 || y <= -TWO_POWER_52) {\nreturn pow(-x, y);\n}\n\nif (y == (long) y) {\n// If y is an integer\nreturn ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n} else {\nreturn Double.NaN;\n}\n}\n\n/* Split y into ya and yb such that y = ya+yb */\ndouble ya;\ndouble yb;\nif (y < 8e298 && y > -8e298) {\ndouble tmp1 = y * HEX_40000000;\nya = y + tmp1 - tmp1;\nyb = y - ya;\n} else {\ndouble tmp1 = y * 9.31322574615478515625E-10;\ndouble tmp2 = tmp1 * 9.31322574615478515625E-10;\nya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\nyb = y - ya;\n}\n\n/* Compute ln(x) */\nfinal double lores = log(x, lns);\nif (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\nreturn lores;\n}\n\ndouble lna = lns[0];\ndouble lnb = lns[1];\n\n/* resplit lns */\ndouble tmp1 = lna * HEX_40000000;\ndouble tmp2 = lna + tmp1 - tmp1;\nlnb += lna - tmp2;\nlna = tmp2;\n\n// y*ln(x) = (aa+ab)\nfinal double aa = lna * ya;\nfinal double ab = lna * yb + lnb * ya + lnb * yb;\n\nlna = aa+ab;\nlnb = -(lna - aa - ab);\n\ndouble z = 1.0 / 120.0;\nz = z * lnb + (1.0 / 24.0);\nz = z * lnb + (1.0 / 6.0);\nz = z * lnb + 0.5;\nz = z * lnb + 1.0;\nz = z * lnb;\n\nfinal double result = exp(lna, z, null);\n//result = result + result * z;\nreturn result;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D[D)D",
            "method_body": "private static double log(final double x, final double[] hiPrec) {\nif (x==0) { // Handle special case of +0/-0\nreturn Double.NEGATIVE_INFINITY;\n}\nlong bits = Double.doubleToLongBits(x);\n\n/* Handle special cases of negative input, and NaN */\nif ((bits & 0x8000000000000000L) != 0 || x != x) {\nif (x != 0.0) {\nif (hiPrec != null) {\nhiPrec[0] = Double.NaN;\n}\n\nreturn Double.NaN;\n}\n}\n\n/* Handle special cases of Positive infinity. */\nif (x == Double.POSITIVE_INFINITY) {\nif (hiPrec != null) {\nhiPrec[0] = Double.POSITIVE_INFINITY;\n}\n\nreturn Double.POSITIVE_INFINITY;\n}\n\n/* Extract the exponent */\nint exp = (int)(bits >> 52)-1023;\n\nif ((bits & 0x7ff0000000000000L) == 0) {\n// Subnormal!\nif (x == 0) {\n// Zero\nif (hiPrec != null) {\nhiPrec[0] = Double.NEGATIVE_INFINITY;\n}\n\nreturn Double.NEGATIVE_INFINITY;\n}\n\n/* Normalize the subnormal number. */\nbits <<= 1;\nwhile ( (bits & 0x0010000000000000L) == 0) {\n--exp;\nbits <<= 1;\n}\n}\n\n\nif (exp == -1 || exp == 0) {\nif (x < 1.01 && x > 0.99 && hiPrec == null) {\n/* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\npolynomial expansion in higer precision. */\n\n/* Compute x - 1.0 and split it */\ndouble xa = x - 1.0;\ndouble xb = xa - x + 1.0;\ndouble tmp = xa * HEX_40000000;\ndouble aa = xa + tmp - tmp;\ndouble ab = xa - aa;\nxa = aa;\nxb = ab;\n\nfinal double[] lnCoef_last = LN_QUICK_COEF[LN_QUICK_COEF.length - 1];\ndouble ya = lnCoef_last[0];\ndouble yb = lnCoef_last[1];\n\nfor (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\n/* Add  a = y + lnQuickCoef */\nfinal double[] lnCoef_i = LN_QUICK_COEF[i];\naa = ya + lnCoef_i[0];\nab = yb + lnCoef_i[1];\n/* Split y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n}\n\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\nreturn ya + yb;\n}\n}\n\n// lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\nfinal double[] lnm = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n/*\ndouble epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\nepsilon -= 1.0;\n*/\n\n// y is the most significant 10 bits of the mantissa\n//double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n//double epsilon = (x - y) / y;\nfinal double epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\ndouble lnza = 0.0;\ndouble lnzb = 0.0;\n\nif (hiPrec != null) {\n/* split epsilon -> x */\ndouble tmp = epsilon * HEX_40000000;\ndouble aa = epsilon + tmp - tmp;\ndouble ab = epsilon - aa;\ndouble xa = aa;\ndouble xb = ab;\n\n/* Need a more accurate epsilon, so adjust the division. */\nfinal double numer = bits & 0x3ffffffffffL;\nfinal double denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\naa = numer - xa*denom - xb * denom;\nxb += aa / denom;\n\n/* Remez polynomial evaluation */\nfinal double[] lnCoef_last = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1];\ndouble ya = lnCoef_last[0];\ndouble yb = lnCoef_last[1];\n\nfor (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\n/* Add  a = y + lnHiPrecCoef */\nfinal double[] lnCoef_i = LN_HI_PREC_COEF[i];\naa = ya + lnCoef_i[0];\nab = yb + lnCoef_i[1];\n/* Split y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n}\n\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n\n/* split, so now lnz = a */\n/*\ntmp = aa * 1073741824.0;\nlnza = aa + tmp - tmp;\nlnzb = aa - lnza + ab;\n*/\nlnza = aa + ab;\nlnzb = -(lnza - aa - ab);\n} else {\n/* High precision not required.  Eval Remez polynomial\nusing standard double precision */\nlnza = -0.16624882440418567;\nlnza = lnza * epsilon + 0.19999954120254515;\nlnza = lnza * epsilon + -0.2499999997677497;\nlnza = lnza * epsilon + 0.3333333333332802;\nlnza = lnza * epsilon + -0.5;\nlnza = lnza * epsilon + 1.0;\nlnza = lnza * epsilon;\n}\n\n/* Relative sizes:\n* lnzb     [0, 2.33E-10]\n* lnm[1]   [0, 1.17E-7]\n* ln2B*exp [0, 1.12E-4]\n* lnza      [0, 9.7E-4]\n* lnm[0]   [0, 0.692]\n* ln2A*exp [0, 709]\n*/\n\n/* Compute the following sum:\n* lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n*/\n\n//return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\ndouble a = LN_2_A*exp;\ndouble b = 0.0;\ndouble c = a+lnm[0];\ndouble d = -(c-a-lnm[0]);\na = c;\nb = b + d;\n\nc = a + lnza;\nd = -(c - a - lnza);\na = c;\nb = b + d;\n\nc = a + LN_2_B*exp;\nd = -(c - a - LN_2_B*exp);\na = c;\nb = b + d;\n\nc = a + lnm[1];\nd = -(c - a - lnm[1]);\na = c;\nb = b + d;\n\nc = a + lnzb;\nd = -(c - a - lnzb);\na = c;\nb = b + d;\n\nif (hiPrec != null) {\nhiPrec[0] = a;\nhiPrec[1] = b;\n}\n\nreturn a + b;\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:exp(DD[D)D",
            "method_body": "private static double exp(double x, double extra, double[] hiPrec) {\ndouble intPartA;\ndouble intPartB;\nint intVal;\n\n/* Lookup exp(floor(x)).\n* intPartA will have the upper 22 bits, intPartB will have the lower\n* 52 bits.\n*/\nif (x < 0.0) {\nintVal = (int) -x;\n\nif (intVal > 746) {\nif (hiPrec != null) {\nhiPrec[0] = 0.0;\nhiPrec[1] = 0.0;\n}\nreturn 0.0;\n}\n\nif (intVal > 709) {\n/* This will produce a subnormal output */\nfinal double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\nif (hiPrec != null) {\nhiPrec[0] /= 285040095144011776.0;\nhiPrec[1] /= 285040095144011776.0;\n}\nreturn result;\n}\n\nif (intVal == 709) {\n/* exp(1.494140625) is nearly a machine number... */\nfinal double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\nif (hiPrec != null) {\nhiPrec[0] /= 4.455505956692756620;\nhiPrec[1] /= 4.455505956692756620;\n}\nreturn result;\n}\n\nintVal++;\n\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\nintVal = -intVal;\n} else {\nintVal = (int) x;\n\nif (intVal > 709) {\nif (hiPrec != null) {\nhiPrec[0] = Double.POSITIVE_INFINITY;\nhiPrec[1] = 0.0;\n}\nreturn Double.POSITIVE_INFINITY;\n}\n\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n}\n\n/* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n* x and look up the exp function of it.\n* fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n*/\nfinal int intFrac = (int) ((x - intVal) * 1024.0);\nfinal double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\nfinal double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n/* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n* has a value in the range 0 <= epsilon < 2^-10.\n* Do the subtraction from x as the last step to avoid possible loss of percison.\n*/\nfinal double epsilon = x - (intVal + intFrac / 1024.0);\n\n/* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\nfull double precision (52 bits).  Since z < 2^-10, we will have\n62 bits of precision when combined with the contant 1.  This will be\nused in the last addition below to get proper rounding. */\n\n/* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\nis less than 0.5 ULP */\ndouble z = 0.04168701738764507;\nz = z * epsilon + 0.1666666505023083;\nz = z * epsilon + 0.5000000000042687;\nz = z * epsilon + 1.0;\nz = z * epsilon + -3.940510424527919E-20;\n\n/* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\nexpansion.\ntempA is exact since intPartA and intPartB only have 22 bits each.\ntempB will have 52 bits of precision.\n*/\ndouble tempA = intPartA * fracPartA;\ndouble tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n/* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\nimportant.  For accuracy add by increasing size.  tempA is exact and\nmuch larger than the others.  If there are extra bits specified from the\npow() function, use them. */\nfinal double tempC = tempB + tempA;\nfinal double result;\nif (extra != 0.0) {\nresult = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n} else {\nresult = tempC*z + tempB + tempA;\n}\n\nif (hiPrec != null) {\n// If requesting high precision\nhiPrec[0] = tempA;\nhiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n}\n\nreturn result;\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.Dfp:round(I)I",
            "method_body": "protected int round(int n) {\nboolean inc = false;\nswitch (field.getRoundingMode()) {\ncase ROUND_DOWN:\ninc = false;\nbreak;\n\ncase ROUND_UP:\ninc = n != 0;       // round up if n!=0\nbreak;\n\ncase ROUND_HALF_UP:\ninc = n >= 5000;  // round half up\nbreak;\n\ncase ROUND_HALF_DOWN:\ninc = n > 5000;  // round half down\nbreak;\n\ncase ROUND_HALF_EVEN:\ninc = n > 5000 || (n == 5000 && (mant[0] & 1) == 1);  // round half-even\nbreak;\n\ncase ROUND_HALF_ODD:\ninc = n > 5000 || (n == 5000 && (mant[0] & 1) == 0);  // round half-odd\nbreak;\n\ncase ROUND_CEIL:\ninc = sign == 1 && n != 0;  // round ceil\nbreak;\n\ncase ROUND_FLOOR:\ndefault:\ninc = sign == -1 && n != 0;  // round floor\nbreak;\n}\n\nif (inc) {\n// increment if necessary\nint rh = 1;\nfor (int i = 0; i < mant.length; i++) {\nfinal int r = mant[i] + rh;\nrh = r / RADIX;\nmant[i] = r - rh * RADIX;\n}\n\nif (rh != 0) {\nshiftRight();\nmant[mant.length-1] = rh;\n}\n}\n\n// check for exceptional cases and raise signals if necessary\nif (exp < MIN_EXP) {\n// Gradual Underflow\nfield.setIEEEFlagsBits(DfpField.FLAG_UNDERFLOW);\nreturn DfpField.FLAG_UNDERFLOW;\n}\n\nif (exp > MAX_EXP) {\n// Overflow\nfield.setIEEEFlagsBits(DfpField.FLAG_OVERFLOW);\nreturn DfpField.FLAG_OVERFLOW;\n}\n\nif (n != 0) {\n// Inexact\nfield.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\nreturn DfpField.FLAG_INEXACT;\n}\n\nreturn 0;\n\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:max(II)I",
            "method_body": "public static int max(final int a, final int b) {\nreturn (a <= b) ? b : a;\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.DfpField:setIEEEFlagsBits(I)V",
            "method_body": "public void setIEEEFlagsBits(final int bits) {\nieeeFlags |= bits & (FLAG_INVALID | FLAG_DIV_ZERO | FLAG_OVERFLOW | FLAG_UNDERFLOW | FLAG_INEXACT);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.Dfp:<init>(Lorg/apache/commons/math3/dfp/DfpField;I)V",
            "method_body": "protected Dfp(final DfpField field, int x) {\nthis(field, (long) x);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.DfpField:<init>(I)V",
            "method_body": "public DfpField(final int decimalDigits) {\nthis(decimalDigits, true);\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:<init>()V",
            "method_body": "public BitsStreamGenerator() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.Dfp:<init>(Lorg/apache/commons/math3/dfp/DfpField;Ljava/lang/String;)V",
            "method_body": "protected Dfp(final DfpField field, final String s) {\n\n// initialize as if 0\nmant = new int[field.getRadixDigits()];\nsign = 1;\nexp = 0;\nnans = FINITE;\nthis.field = field;\n\nboolean decimalFound = false;\nfinal int rsize = 4;   // size of radix in decimal digits\nfinal int offset = 4;  // Starting offset into Striped\nfinal char[] striped = new char[getRadixDigits() * rsize + offset * 2];\n\n// Check some special cases\nif (s.equals(POS_INFINITY_STRING)) {\nsign = (byte) 1;\nnans = INFINITE;\nreturn;\n}\n\nif (s.equals(NEG_INFINITY_STRING)) {\nsign = (byte) -1;\nnans = INFINITE;\nreturn;\n}\n\nif (s.equals(NAN_STRING)) {\nsign = (byte) 1;\nnans = QNAN;\nreturn;\n}\n\n// Check for scientific notation\nint p = s.indexOf(\"e\");\nif (p == -1) { // try upper case?\np = s.indexOf(\"E\");\n}\n\nfinal String fpdecimal;\nint sciexp = 0;\nif (p != -1) {\n// scientific notation\nfpdecimal = s.substring(0, p);\nString fpexp = s.substring(p+1);\nboolean negative = false;\n\nfor (int i=0; i<fpexp.length(); i++)\n{\nif (fpexp.charAt(i) == '-')\n{\nnegative = true;\ncontinue;\n}\nif (fpexp.charAt(i) >= '0' && fpexp.charAt(i) <= '9') {\nsciexp = sciexp * 10 + fpexp.charAt(i) - '0';\n}\n}\n\nif (negative) {\nsciexp = -sciexp;\n}\n} else {\n// normal case\nfpdecimal = s;\n}\n\n// If there is a minus sign in the number then it is negative\nif (fpdecimal.indexOf(\"-\") !=  -1) {\nsign = -1;\n}\n\n// First off, find all of the leading zeros, trailing zeros, and significant digits\np = 0;\n\n// Move p to first significant digit\nint decimalPos = 0;\nfor (;;) {\nif (fpdecimal.charAt(p) >= '1' && fpdecimal.charAt(p) <= '9') {\nbreak;\n}\n\nif (decimalFound && fpdecimal.charAt(p) == '0') {\ndecimalPos--;\n}\n\nif (fpdecimal.charAt(p) == '.') {\ndecimalFound = true;\n}\n\np++;\n\nif (p == fpdecimal.length()) {\nbreak;\n}\n}\n\n// Copy the string onto Stripped\nint q = offset;\nstriped[0] = '0';\nstriped[1] = '0';\nstriped[2] = '0';\nstriped[3] = '0';\nint significantDigits=0;\nfor(;;) {\nif (p == (fpdecimal.length())) {\nbreak;\n}\n\n// Don't want to run pass the end of the array\nif (q == mant.length*rsize+offset+1) {\nbreak;\n}\n\nif (fpdecimal.charAt(p) == '.') {\ndecimalFound = true;\ndecimalPos = significantDigits;\np++;\ncontinue;\n}\n\nif (fpdecimal.charAt(p) < '0' || fpdecimal.charAt(p) > '9') {\np++;\ncontinue;\n}\n\nstriped[q] = fpdecimal.charAt(p);\nq++;\np++;\nsignificantDigits++;\n}\n\n\n// If the decimal point has been found then get rid of trailing zeros.\nif (decimalFound && q != offset) {\nfor (;;) {\nq--;\nif (q == offset) {\nbreak;\n}\nif (striped[q] == '0') {\nsignificantDigits--;\n} else {\nbreak;\n}\n}\n}\n\n// special case of numbers like \"0.00000\"\nif (decimalFound && significantDigits == 0) {\ndecimalPos = 0;\n}\n\n// Implicit decimal point at end of number if not present\nif (!decimalFound) {\ndecimalPos = q-offset;\n}\n\n// Find the number of significant trailing zeros\nq = offset;  // set q to point to first sig digit\np = significantDigits-1+offset;\n\nwhile (p > q) {\nif (striped[p] != '0') {\nbreak;\n}\np--;\n}\n\n// Make sure the decimal is on a mod 10000 boundary\nint i = ((rsize * 100) - decimalPos - sciexp % rsize) % rsize;\nq -= i;\ndecimalPos += i;\n\n// Make the mantissa length right by adding zeros at the end if necessary\nwhile ((p - q) < (mant.length * rsize)) {\nfor (i = 0; i < rsize; i++) {\nstriped[++p] = '0';\n}\n}\n\n// Ok, now we know how many trailing zeros there are,\n// and where the least significant digit is\nfor (i = mant.length - 1; i >= 0; i--) {\nmant[i] = (striped[q]   - '0') * 1000 +\n(striped[q+1] - '0') * 100  +\n(striped[q+2] - '0') * 10   +\n(striped[q+3] - '0');\nq += 4;\n}\n\n\nexp = (decimalPos+sciexp) / rsize;\n\nif (q < striped.length) {\n// Is there possible another digit?\nround((striped[q] - '0')*1000);\n}\n\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.random.BitsStreamGenerator:clear()V",
            "method_body": "public void clear() {\nnextGaussian = Double.NaN;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:setSeed([I)V",
            "method_body": "public void setSeed(int[] seed) {\n\nif (seed == null) {\nsetSeed(System.currentTimeMillis() + System.identityHashCode(this));\nreturn;\n}\n\nsetSeed(19650218);\nint i = 1;\nint j = 0;\n\nfor (int k = FastMath.max(N, seed.length); k != 0; k--) {\nlong l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\nlong l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\nlong l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1664525l)) + seed[j] + j; // non linear\nmt[i]   = (int) (l & 0xffffffffl);\ni++; j++;\nif (i >= N) {\nmt[0] = mt[N - 1];\ni = 1;\n}\nif (j >= seed.length) {\nj = 0;\n}\n}\n\nfor (int k = N - 1; k != 0; k--) {\nlong l0 = (mt[i] & 0x7fffffffl)   | ((mt[i]   < 0) ? 0x80000000l : 0x0l);\nlong l1 = (mt[i-1] & 0x7fffffffl) | ((mt[i-1] < 0) ? 0x80000000l : 0x0l);\nlong l  = (l0 ^ ((l1 ^ (l1 >> 30)) * 1566083941l)) - i; // non linear\nmt[i]   = (int) (l & 0xffffffffL);\ni++;\nif (i >= N) {\nmt[0] = mt[N - 1];\ni = 1;\n}\n}\n\nmt[0] = 0x80000000; // MSB is 1; assuring non-zero initial array\n\nclear(); // Clear normal deviate cache\n\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:setSeed(I)V",
            "method_body": "public void setSeed(int seed) {\n// we use a long masked by 0xffffffffL as a poor man unsigned int\nlong longMT = seed;\n// NB: unlike original C code, we are working with java longs, the cast below makes masking unnecessary\nmt[0]= (int) longMT;\nfor (mti = 1; mti < N; ++mti) {\n// See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier.\n// initializer from the 2002-01-09 C version by Makoto Matsumoto\nlongMT = (1812433253l * (longMT ^ (longMT >> 30)) + mti) & 0xffffffffL;\nmt[mti]= (int) longMT;\n}\n\nclear(); // Clear normal deviate cache\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:<init>(J)V",
            "method_body": "public MersenneTwister(long seed) {\nmt = new int[N];\nsetSeed(seed);\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.DfpField:<init>(IZ)V",
            "method_body": "private DfpField(final int decimalDigits, final boolean computeConstants) {\n\nthis.radixDigits = (decimalDigits < 13) ? 4 : (decimalDigits + 3) / 4;\nthis.rMode       = RoundingMode.ROUND_HALF_EVEN;\nthis.ieeeFlags   = 0;\nthis.zero        = new Dfp(this, 0);\nthis.one         = new Dfp(this, 1);\nthis.two         = new Dfp(this, 2);\n\nif (computeConstants) {\n// set up transcendental constants\nsynchronized (DfpField.class) {\n\n// as a heuristic to circumvent Table-Maker's Dilemma, we set the string\n// representation of the constants to be at least 3 times larger than the\n// number of decimal digits, also as an attempt to really compute these\n// constants only once, we set a minimum number of digits\ncomputeStringConstants((decimalDigits < 67) ? 200 : (3 * decimalDigits));\n\n// set up the constants at current field accuracy\nsqr2           = new Dfp(this, sqr2String);\nsqr2Split      = split(sqr2String);\nsqr2Reciprocal = new Dfp(this, sqr2ReciprocalString);\nsqr3           = new Dfp(this, sqr3String);\nsqr3Reciprocal = new Dfp(this, sqr3ReciprocalString);\npi             = new Dfp(this, piString);\npiSplit        = split(piString);\ne              = new Dfp(this, eString);\neSplit         = split(eString);\nln2            = new Dfp(this, ln2String);\nln2Split       = split(ln2String);\nln5            = new Dfp(this, ln5String);\nln5Split       = split(ln5String);\nln10           = new Dfp(this, ln10String);\n\n}\n} else {\n// dummy settings for unused constants\nsqr2           = null;\nsqr2Split      = null;\nsqr2Reciprocal = null;\nsqr3           = null;\nsqr3Reciprocal = null;\npi             = null;\npiSplit        = null;\ne              = null;\neSplit         = null;\nln2            = null;\nln2Split       = null;\nln5            = null;\nln5Split       = null;\nln10           = null;\n}\n\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.Dfp:getRadixDigits()I",
            "method_body": "public int getRadixDigits() {\nreturn field.getRadixDigits();\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.DfpField:getRoundingMode()Lorg/apache/commons/math3/dfp/DfpField$RoundingMode;",
            "method_body": "public RoundingMode getRoundingMode() {\nreturn rMode;\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.DfpField:computeStringConstants(I)V",
            "method_body": "private static void computeStringConstants(final int highPrecisionDecimalDigits) {\nif (sqr2String == null || sqr2String.length() < highPrecisionDecimalDigits - 3) {\n\n// recompute the string representation of the transcendental constants\nfinal DfpField highPrecisionField = new DfpField(highPrecisionDecimalDigits, false);\nfinal Dfp highPrecisionOne        = new Dfp(highPrecisionField, 1);\nfinal Dfp highPrecisionTwo        = new Dfp(highPrecisionField, 2);\nfinal Dfp highPrecisionThree      = new Dfp(highPrecisionField, 3);\n\nfinal Dfp highPrecisionSqr2 = highPrecisionTwo.sqrt();\nsqr2String           = highPrecisionSqr2.toString();\nsqr2ReciprocalString = highPrecisionOne.divide(highPrecisionSqr2).toString();\n\nfinal Dfp highPrecisionSqr3 = highPrecisionThree.sqrt();\nsqr3String           = highPrecisionSqr3.toString();\nsqr3ReciprocalString = highPrecisionOne.divide(highPrecisionSqr3).toString();\n\npiString   = computePi(highPrecisionOne, highPrecisionTwo, highPrecisionThree).toString();\neString    = computeExp(highPrecisionOne, highPrecisionOne).toString();\nln2String  = computeLn(highPrecisionTwo, highPrecisionOne, highPrecisionTwo).toString();\nln5String  = computeLn(new Dfp(highPrecisionField, 5),  highPrecisionOne, highPrecisionTwo).toString();\nln10String = computeLn(new Dfp(highPrecisionField, 10), highPrecisionOne, highPrecisionTwo).toString();\n\n}\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.Dfp:<init>(Lorg/apache/commons/math3/dfp/DfpField;J)V",
            "method_body": "protected Dfp(final DfpField field, long x) {\n\n// initialize as if 0\nmant = new int[field.getRadixDigits()];\nnans = FINITE;\nthis.field = field;\n\nboolean isLongMin = false;\nif (x == Long.MIN_VALUE) {\n// special case for Long.MIN_VALUE (-9223372036854775808)\n// we must shift it before taking its absolute value\nisLongMin = true;\n++x;\n}\n\n// set the sign\nif (x < 0) {\nsign = -1;\nx = -x;\n} else {\nsign = 1;\n}\n\nexp = 0;\nwhile (x != 0) {\nSystem.arraycopy(mant, mant.length - exp, mant, mant.length - 1 - exp, exp);\nmant[mant.length - 1] = (int) (x % RADIX);\nx /= RADIX;\nexp++;\n}\n\nif (isLongMin) {\n// remove the shift added for Long.MIN_VALUE\n// we know in this case that fixing the last digit is sufficient\nfor (int i = 0; i < mant.length - 1; i++) {\nif (mant[i] != 0) {\nmant[i]++;\nbreak;\n}\n}\n}\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.random.MersenneTwister:setSeed(J)V",
            "method_body": "public void setSeed(long seed) {\nsetSeed(new int[] { (int) (seed >>> 32), (int) (seed & 0xffffffffl) });\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.DfpField:getRadixDigits()I",
            "method_body": "public int getRadixDigits() {\nreturn radixDigits;\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.dfp.DfpField:split(Ljava/lang/String;)[Lorg/apache/commons/math3/dfp/Dfp;",
            "method_body": "private Dfp[] split(final String a) {\nDfp result[] = new Dfp[2];\nboolean leading = true;\nint sp = 0;\nint sig = 0;\n\nchar[] buf = new char[a.length()];\n\nfor (int i = 0; i < buf.length; i++) {\nbuf[i] = a.charAt(i);\n\nif (buf[i] >= '1' && buf[i] <= '9') {\nleading = false;\n}\n\nif (buf[i] == '.') {\nsig += (400 - sig) % 4;\nleading = false;\n}\n\nif (sig == (radixDigits / 2) * 4) {\nsp = i;\nbreak;\n}\n\nif (buf[i] >= '0' && buf[i] <= '9' && !leading) {\nsig ++;\n}\n}\n\nresult[0] = new Dfp(this, new String(buf, 0, sp));\n\nfor (int i = 0; i < buf.length; i++) {\nbuf[i] = a.charAt(i);\nif (buf[i] >= '0' && buf[i] <= '9' && i < sp) {\nbuf[i] = '0';\n}\n}\n\nresult[1] = new Dfp(this, new String(buf));\n\nreturn result;\n\n}",
            "method_id": 21
        }
    ]
}