{
    "bug_id": 31,
    "test_id": 1,
    "test_name": "org.apache.commons.math3.distribution.FDistributionTest.testMath785",
    "test_body": "public void testMath785() {\n// this test was failing due to inaccurate results from ContinuedFraction.\ntry {\ndouble prob = 0.01;\nFDistribution f = new FDistribution(200000, 200000);\ndouble result = f.inverseCumulativeProbability(prob);\nAssert.assertTrue(result < 1.0);\n} catch (Exception e) {\nAssert.fail(\"Failing to calculate inverse cumulative probability\");\n}\n}\n",
    "stack_trace": "junit.framework.AssertionFailedError: Failing to calculate inverse cumulative probability\nat org.junit.Assert.fail(Assert.java:88)\nat org.apache.commons.math3.distribution.FDistributionTest.testMath785(FDistributionTest.java:156)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:getSupportLowerBound()D",
            "method_body": "public double getSupportLowerBound() {\nreturn 0;\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.math3.exception.NoBracketingException:<init>(DDDD)V",
            "method_body": "public NoBracketingException(double lo, double hi,\nthis(LocalizedFormats.SAME_SIGN_AT_ENDPOINTS, lo, hi, fLo, fHi);\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BrentSolver:<init>(D)V",
            "method_body": "public BrentSolver(double absoluteAccuracy) {\nsuper(absoluteAccuracy);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:incrementEvaluationCount()V",
            "method_body": "protected void incrementEvaluationCount() {\ntry {\nevaluations.incrementCount();\n} catch (MaxCountExceededException e) {\nthrow new TooManyEvaluationsException(e.getMax());\n}\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.math3.exception.MathIllegalArgumentException:<init>(Lorg/apache/commons/math3/exception/util/Localizable;[Ljava/lang/Object;)V",
            "method_body": "public MathIllegalArgumentException(Localizable pattern,\nObject ... args) {\ncontext = new ExceptionContext(this);\ncontext.addMessage(pattern, args);\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.math3.special.Gamma:logGamma(D)D",
            "method_body": "public static double logGamma(double x) {\ndouble ret;\n\nif (Double.isNaN(x) || (x <= 0.0)) {\nret = Double.NaN;\n} else {\ndouble g = 607.0 / 128.0;\ndouble sum = lanczos(x);\ndouble tmp = x + g + .5;\nret = ((x + .5) * FastMath.log(tmp)) - tmp +\nHALF_LOG_2_PI + FastMath.log(sum / x);\n}\n\nreturn ret;\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:verifySequence(DDD)V",
            "method_body": "protected void verifySequence(final double lower,\nfinal double initial,\nfinal double upper) {\nUnivariateSolverUtils.verifySequence(lower, initial, upper);\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.math3.special.Beta:regularizedBeta(DDDDI)D",
            "method_body": "public static double regularizedBeta(double x,\nfinal double a, final double b,\ndouble epsilon, int maxIterations) {\ndouble ret;\n\nif (Double.isNaN(x) ||\nDouble.isNaN(a) ||\nDouble.isNaN(b) ||\nx < 0 ||\nx > 1 ||\na <= 0.0 ||\nb <= 0.0) {\nret = Double.NaN;\n} else if (x > (a + 1.0) / (a + b + 2.0)) {\nret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n} else {\nContinuedFraction fraction = new ContinuedFraction() {\n\n@Override\nprotected double getB(int n, double x) {\ndouble ret;\ndouble m;\nif (n % 2 == 0) { // even\nm = n / 2.0;\nret = (m * (b - m) * x) /\n((a + (2 * m) - 1) * (a + (2 * m)));\n} else {\nm = (n - 1.0) / 2.0;\nret = -((a + m) * (a + b + m) * x) /\n((a + (2 * m)) * (a + (2 * m) + 1.0));\n}\nreturn ret;\n}\n\n@Override\nprotected double getA(int n, double x) {\nreturn 1.0;\n}\n};\nret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -\nFastMath.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n1.0 / fraction.evaluate(x, epsilon, maxIterations);\n}\n\nreturn ret;\n}",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.math3.exception.util.ArgUtils:flatten([Ljava/lang/Object;)[Ljava/lang/Object;",
            "method_body": "public static Object[] flatten(Object[] array) {\nfinal List<Object> list = new ArrayList<Object>();\nif (array != null) {\nfor (Object o : array) {\nif (o instanceof Object[]) {\nfor (Object oR : flatten((Object[]) o)) {\nlist.add(oR);\n}\n} else {\nlist.add(o);\n}\n}\n}\nreturn list.toArray();\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:getNumericalMean()D",
            "method_body": "public double getNumericalMean() {\nfinal double denominatorDF = getDenominatorDegreesOfFreedom();\n\nif (denominatorDF > 2) {\nreturn denominatorDF / (denominatorDF - 2);\n}\n\nreturn Double.NaN;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.AbstractUnivariateSolver:<init>(D)V",
            "method_body": "protected AbstractUnivariateSolver(final double absoluteAccuracy) {\nsuper(absoluteAccuracy);\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:exp(D)D",
            "method_body": "public static double exp(double x) {\nreturn exp(x, 0.0, null);\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.math3.special.Beta$1:<init>(DD)V",
            "method_body": "public static double regularizedBeta(double x,\nif (Double.isNaN(x) ||\n} else if (x > (a + 1.0) / (a + b + 2.0)) {\nret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\nContinuedFraction fraction = new ContinuedFraction() {\nif (n % 2 == 0) { // even\nm = n / 2.0;\nret = (m * (b - m) * x) /\nm = (n - 1.0) / 2.0;\nret = -((a + m) * (a + b + m) * x) /\nreturn ret;\nreturn 1.0;\nret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -\nreturn ret;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractRealDistribution$1:<init>(Lorg/apache/commons/math3/distribution/AbstractRealDistribution;D)V",
            "method_body": "public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\nif (p < 0.0 || p > 1.0) {\ndouble lowerBound = getSupportLowerBound();\nif (p == 0.0) {\ndouble upperBound = getSupportUpperBound();\nif (p == 1.0) {\nfinal double mu = getNumericalMean();\nfinal double sig = FastMath.sqrt(getNumericalVariance());\nchebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\nif (lowerBound == Double.NEGATIVE_INFINITY) {\nif (upperBound == Double.POSITIVE_INFINITY) {\nif (chebyshevApplies) {\nupperBound = mu + sig * FastMath.sqrt(p / (1. - p));\nfinal UnivariateFunction toSolve = new UnivariateFunction() {\nreturn cumulativeProbability(x) - p;\ndouble x = UnivariateSolverUtils.solve(toSolve,\nif (!isSupportConnected()) {\n}",
            "method_id": 13
        },
        {
            "method_signature": "org.apache.commons.math3.special.Gamma:lanczos(D)D",
            "method_body": "public static double lanczos(final double x) {\ndouble sum = 0.0;\nfor (int i = LANCZOS.length - 1; i > 0; --i) {\nsum = sum + (LANCZOS[i] / (x + i));\n}\nreturn sum + LANCZOS[0];\n}",
            "method_id": 14
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>()V",
            "method_body": "public Incrementor() {\nthis(0);\n}",
            "method_id": 15
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BrentSolver:doSolve()D",
            "method_body": "protected double doSolve() {\ndouble min = getMin();\ndouble max = getMax();\nfinal double initial = getStartValue();\nfinal double functionValueAccuracy = getFunctionValueAccuracy();\n\nverifySequence(min, initial, max);\n\n// Return the initial guess if it is good enough.\ndouble yInitial = computeObjectiveValue(initial);\nif (FastMath.abs(yInitial) <= functionValueAccuracy) {\nreturn initial;\n}\n\n// Return the first endpoint if it is good enough.\ndouble yMin = computeObjectiveValue(min);\nif (FastMath.abs(yMin) <= functionValueAccuracy) {\nreturn min;\n}\n\n// Reduce interval if min and initial bracket the root.\nif (yInitial * yMin < 0) {\nreturn brent(min, initial, yMin, yInitial);\n}\n\n// Return the second endpoint if it is good enough.\ndouble yMax = computeObjectiveValue(max);\nif (FastMath.abs(yMax) <= functionValueAccuracy) {\nreturn max;\n}\n\n// Reduce interval if initial and max bracket the root.\nif (yInitial * yMax < 0) {\nreturn brent(initial, max, yInitial, yMax);\n}\n\nthrow new NoBracketingException(min, max, yMin, yMax);\n}",
            "method_id": 16
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getMin()D",
            "method_body": "public double getMin() {\nreturn searchMin;\n}",
            "method_id": 17
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils:verifyInterval(DD)V",
            "method_body": "public static void verifyInterval(final double lower,\nfinal double upper) {\nif (lower >= upper) {\nthrow new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\nlower, upper, false);\n}\n}",
            "method_id": 18
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:incrementCount()V",
            "method_body": "public void incrementCount() {\nif (++count > maximalCount) {\nmaxCountCallback.trigger(maximalCount);\n}\n}",
            "method_id": 19
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:solve(ILorg/apache/commons/math3/analysis/UnivariateFunction;DDD)D",
            "method_body": "public double solve(int maxEval, FUNC f, double min, double max, double startValue) {\n// Initialization.\nsetup(maxEval, f, min, max, startValue);\n\n// Perform computation.\nreturn doSolve();\n}",
            "method_id": 20
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getFunctionValueAccuracy()D",
            "method_body": "public double getFunctionValueAccuracy() {\nreturn functionValueAccuracy;\n}",
            "method_id": 21
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:setMaximalCount(I)V",
            "method_body": "public void setMaximalCount(int max) {\nmaximalCount = max;\n}",
            "method_id": 22
        },
        {
            "method_signature": "org.apache.commons.math3.special.Beta:logBeta(DDDI)D",
            "method_body": "public static double logBeta(double a, double b,\ndouble epsilon,\nint maxIterations) {\ndouble ret;\n\nif (Double.isNaN(a) ||\nDouble.isNaN(b) ||\na <= 0.0 ||\nb <= 0.0) {\nret = Double.NaN;\n} else {\nret = Gamma.logGamma(a) + Gamma.logGamma(b) -\nGamma.logGamma(a + b);\n}\n\nreturn ret;\n}",
            "method_id": 23
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractRealDistribution$1:value(D)D",
            "method_body": "public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n/*\n* IMPLEMENTATION NOTES\n* --------------------\n* Where applicable, use is made of the one-sided Chebyshev inequality\n* to bracket the root. This inequality states that\n* P(X - mu >= k * sig) <= 1 / (1 + k^2),\n* mu: mean, sig: standard deviation. Equivalently\n* 1 - P(X < mu + k * sig) <= 1 / (1 + k^2),\n* F(mu + k * sig) >= k^2 / (1 + k^2).\n*\n* For k = sqrt(p / (1 - p)), we find\n* F(mu + k * sig) >= p,\n* and (mu + k * sig) is an upper-bound for the root.\n*\n* Then, introducing Y = -X, mean(Y) = -mu, sd(Y) = sig, and\n* P(Y >= -mu + k * sig) <= 1 / (1 + k^2),\n* P(-X >= -mu + k * sig) <= 1 / (1 + k^2),\n* P(X <= mu - k * sig) <= 1 / (1 + k^2),\n* F(mu - k * sig) <= 1 / (1 + k^2).\n*\n* For k = sqrt((1 - p) / p), we find\n* F(mu - k * sig) <= p,\n* and (mu - k * sig) is a lower-bound for the root.\n*\n* In cases where the Chebyshev inequality does not apply, geometric\n* progressions 1, 2, 4, ... and -1, -2, -4, ... are used to bracket\n* the root.\n*/\nif (p < 0.0 || p > 1.0) {\nthrow new OutOfRangeException(p, 0, 1);\n}\n\ndouble lowerBound = getSupportLowerBound();\nif (p == 0.0) {\nreturn lowerBound;\n}\n\ndouble upperBound = getSupportUpperBound();\nif (p == 1.0) {\nreturn upperBound;\n}\n\nfinal double mu = getNumericalMean();\nfinal double sig = FastMath.sqrt(getNumericalVariance());\nfinal boolean chebyshevApplies;\nchebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\nDouble.isInfinite(sig) || Double.isNaN(sig));\n\nif (lowerBound == Double.NEGATIVE_INFINITY) {\nif (chebyshevApplies) {\nlowerBound = mu - sig * FastMath.sqrt((1. - p) / p);\n} else {\nlowerBound = -1.0;\nwhile (cumulativeProbability(lowerBound) >= p) {\nlowerBound *= 2.0;\n}\n}\n}\n\nif (upperBound == Double.POSITIVE_INFINITY) {\nif (chebyshevApplies) {\nupperBound = mu + sig * FastMath.sqrt(p / (1. - p));\n} else {\nupperBound = 1.0;\nwhile (cumulativeProbability(upperBound) < p) {\nupperBound *= 2.0;\n}\n}\n}\n\nfinal UnivariateFunction toSolve = new UnivariateFunction() {\n\npublic double value(final double x) {\nreturn cumulativeProbability(x) - p;\n}\n};\n\ndouble x = UnivariateSolverUtils.solve(toSolve,\nlowerBound,\nupperBound,\ngetSolverAbsoluteAccuracy());\n\nif (!isSupportConnected()) {\n/* Test for plateau. */\nfinal double dx = getSolverAbsoluteAccuracy();\nif (x - dx >= getSupportLowerBound()) {\ndouble px = cumulativeProbability(x);\nif (cumulativeProbability(x - dx) == px) {\nupperBound = x;\nwhile (upperBound - lowerBound > dx) {\nfinal double midPoint = 0.5 * (lowerBound + upperBound);\nif (cumulativeProbability(midPoint) < px) {\nlowerBound = midPoint;\n} else {\nupperBound = midPoint;\n}\n}\nreturn upperBound;\n}\n}\n}\nreturn x;\n}",
            "method_id": 24
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:resetCount()V",
            "method_body": "public void resetCount() {\ncount = 0;\n}",
            "method_id": 25
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:computeObjectiveValue(D)D",
            "method_body": "protected double computeObjectiveValue(double point)\nthrows TooManyEvaluationsException {\nincrementEvaluationCount();\nreturn function.value(point);\n}",
            "method_id": 26
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils:solve(Lorg/apache/commons/math3/analysis/UnivariateFunction;DDD)D",
            "method_body": "public static double solve(UnivariateFunction function,\ndouble x0, double x1,\ndouble absoluteAccuracy) {\nif (function == null) {\nthrow new NullArgumentException(LocalizedFormats.FUNCTION);\n}\nfinal UnivariateSolver solver = new BrentSolver(absoluteAccuracy);\nreturn solver.solve(Integer.MAX_VALUE, function, x0, x1);\n}",
            "method_id": 27
        },
        {
            "method_signature": "org.apache.commons.math3.util.ContinuedFraction:<init>()V",
            "method_body": "protected ContinuedFraction() {\nsuper();\n}",
            "method_id": 28
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:getNumeratorDegreesOfFreedom()D",
            "method_body": "public double getNumeratorDegreesOfFreedom() {\nreturn numeratorDegreesOfFreedom;\n}",
            "method_id": 29
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:setup(ILorg/apache/commons/math3/analysis/UnivariateFunction;DDD)V",
            "method_body": "protected void setup(int maxEval,\nFUNC f,\ndouble min, double max,\ndouble startValue) {\n// Checks.\nMathUtils.checkNotNull(f);\n\n// Reset.\nsearchMin = min;\nsearchMax = max;\nsearchStart = startValue;\nfunction = f;\nevaluations.setMaximalCount(maxEval);\nevaluations.resetCount();\n}",
            "method_id": 30
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(ILorg/apache/commons/math3/util/Incrementor$MaxCountExceededCallback;)V",
            "method_body": "public Incrementor(int max,\nMaxCountExceededCallback cb) {\nmaximalCount = max;\nmaxCountCallback = cb;\n}",
            "method_id": 31
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:sqrt(D)D",
            "method_body": "public static double sqrt(final double a) {\nreturn Math.sqrt(a);\n}",
            "method_id": 32
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:cumulativeProbability(D)D",
            "method_body": "public double cumulativeProbability(double x)  {\ndouble ret;\nif (x <= 0) {\nret = 0;\n} else {\ndouble n = numeratorDegreesOfFreedom;\ndouble m = denominatorDegreesOfFreedom;\n\nret = Beta.regularizedBeta((n * x) / (m + n * x),\n0.5 * n,\n0.5 * m);\n}\nreturn ret;\n}",
            "method_id": 33
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:exp(DD[D)D",
            "method_body": "private static double exp(double x, double extra, double[] hiPrec) {\ndouble intPartA;\ndouble intPartB;\nint intVal;\n\n/* Lookup exp(floor(x)).\n* intPartA will have the upper 22 bits, intPartB will have the lower\n* 52 bits.\n*/\nif (x < 0.0) {\nintVal = (int) -x;\n\nif (intVal > 746) {\nif (hiPrec != null) {\nhiPrec[0] = 0.0;\nhiPrec[1] = 0.0;\n}\nreturn 0.0;\n}\n\nif (intVal > 709) {\n/* This will produce a subnormal output */\nfinal double result = exp(x+40.19140625, extra, hiPrec) / 285040095144011776.0;\nif (hiPrec != null) {\nhiPrec[0] /= 285040095144011776.0;\nhiPrec[1] /= 285040095144011776.0;\n}\nreturn result;\n}\n\nif (intVal == 709) {\n/* exp(1.494140625) is nearly a machine number... */\nfinal double result = exp(x+1.494140625, extra, hiPrec) / 4.455505956692756620;\nif (hiPrec != null) {\nhiPrec[0] /= 4.455505956692756620;\nhiPrec[1] /= 4.455505956692756620;\n}\nreturn result;\n}\n\nintVal++;\n\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX-intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX-intVal];\n\nintVal = -intVal;\n} else {\nintVal = (int) x;\n\nif (intVal > 709) {\nif (hiPrec != null) {\nhiPrec[0] = Double.POSITIVE_INFINITY;\nhiPrec[1] = 0.0;\n}\nreturn Double.POSITIVE_INFINITY;\n}\n\nintPartA = ExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX+intVal];\nintPartB = ExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX+intVal];\n}\n\n/* Get the fractional part of x, find the greatest multiple of 2^-10 less than\n* x and look up the exp function of it.\n* fracPartA will have the upper 22 bits, fracPartB the lower 52 bits.\n*/\nfinal int intFrac = (int) ((x - intVal) * 1024.0);\nfinal double fracPartA = ExpFracTable.EXP_FRAC_TABLE_A[intFrac];\nfinal double fracPartB = ExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n\n/* epsilon is the difference in x from the nearest multiple of 2^-10.  It\n* has a value in the range 0 <= epsilon < 2^-10.\n* Do the subtraction from x as the last step to avoid possible loss of percison.\n*/\nfinal double epsilon = x - (intVal + intFrac / 1024.0);\n\n/* Compute z = exp(epsilon) - 1.0 via a minimax polynomial.  z has\nfull double precision (52 bits).  Since z < 2^-10, we will have\n62 bits of precision when combined with the contant 1.  This will be\nused in the last addition below to get proper rounding. */\n\n/* Remez generated polynomial.  Converges on the interval [0, 2^-10], error\nis less than 0.5 ULP */\ndouble z = 0.04168701738764507;\nz = z * epsilon + 0.1666666505023083;\nz = z * epsilon + 0.5000000000042687;\nz = z * epsilon + 1.0;\nz = z * epsilon + -3.940510424527919E-20;\n\n/* Compute (intPartA+intPartB) * (fracPartA+fracPartB) by binomial\nexpansion.\ntempA is exact since intPartA and intPartB only have 22 bits each.\ntempB will have 52 bits of precision.\n*/\ndouble tempA = intPartA * fracPartA;\ndouble tempB = intPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n\n/* Compute the result.  (1+z)(tempA+tempB).  Order of operations is\nimportant.  For accuracy add by increasing size.  tempA is exact and\nmuch larger than the others.  If there are extra bits specified from the\npow() function, use them. */\nfinal double tempC = tempB + tempA;\nfinal double result;\nif (extra != 0.0) {\nresult = tempC*extra*z + tempC*extra + tempC*z + tempB + tempA;\n} else {\nresult = tempC*z + tempB + tempA;\n}\n\nif (hiPrec != null) {\n// If requesting high precision\nhiPrec[0] = tempA;\nhiPrec[1] = tempC*extra*z + tempC*extra + tempC*z + tempB;\n}\n\nreturn result;\n}",
            "method_id": 34
        },
        {
            "method_signature": "org.apache.commons.math3.special.Beta$1:getB(ID)D",
            "method_body": "public static double regularizedBeta(double x,\nfinal double a, final double b,\ndouble epsilon, int maxIterations) {\ndouble ret;\n\nif (Double.isNaN(x) ||\nDouble.isNaN(a) ||\nDouble.isNaN(b) ||\nx < 0 ||\nx > 1 ||\na <= 0.0 ||\nb <= 0.0) {\nret = Double.NaN;\n} else if (x > (a + 1.0) / (a + b + 2.0)) {\nret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n} else {\nContinuedFraction fraction = new ContinuedFraction() {\n\n@Override\nprotected double getB(int n, double x) {\ndouble ret;\ndouble m;\nif (n % 2 == 0) { // even\nm = n / 2.0;\nret = (m * (b - m) * x) /\n((a + (2 * m) - 1) * (a + (2 * m)));\n} else {\nm = (n - 1.0) / 2.0;\nret = -((a + m) * (a + b + m) * x) /\n((a + (2 * m)) * (a + (2 * m) + 1.0));\n}\nreturn ret;\n}\n\n@Override\nprotected double getA(int n, double x) {\nreturn 1.0;\n}\n};\nret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -\nFastMath.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n1.0 / fraction.evaluate(x, epsilon, maxIterations);\n}\n\nreturn ret;\n}",
            "method_id": 35
        },
        {
            "method_signature": "org.apache.commons.math3.special.Beta:regularizedBeta(DDD)D",
            "method_body": "public static double regularizedBeta(double x, double a, double b) {\nreturn regularizedBeta(x, a, b, DEFAULT_EPSILON, Integer.MAX_VALUE);\n}",
            "method_id": 36
        },
        {
            "method_signature": "org.apache.commons.math3.util.MathUtils:checkNotNull(Ljava/lang/Object;)V",
            "method_body": "public static void checkNotNull(Object o)\nthrows NullArgumentException {\nif (o == null) {\nthrow new NullArgumentException();\n}\n}",
            "method_id": 37
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:getDenominatorDegreesOfFreedom()D",
            "method_body": "public double getDenominatorDegreesOfFreedom() {\nreturn denominatorDegreesOfFreedom;\n}",
            "method_id": 38
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D)D",
            "method_body": "public static double log(final double x) {\nreturn log(x, null);\n}",
            "method_id": 39
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.AbstractRealDistribution:inverseCumulativeProbability(D)D",
            "method_body": "public double inverseCumulativeProbability(final double p) throws OutOfRangeException {\n/*\n* IMPLEMENTATION NOTES\n* --------------------\n* Where applicable, use is made of the one-sided Chebyshev inequality\n* to bracket the root. This inequality states that\n* P(X - mu >= k * sig) <= 1 / (1 + k^2),\n* mu: mean, sig: standard deviation. Equivalently\n* 1 - P(X < mu + k * sig) <= 1 / (1 + k^2),\n* F(mu + k * sig) >= k^2 / (1 + k^2).\n*\n* For k = sqrt(p / (1 - p)), we find\n* F(mu + k * sig) >= p,\n* and (mu + k * sig) is an upper-bound for the root.\n*\n* Then, introducing Y = -X, mean(Y) = -mu, sd(Y) = sig, and\n* P(Y >= -mu + k * sig) <= 1 / (1 + k^2),\n* P(-X >= -mu + k * sig) <= 1 / (1 + k^2),\n* P(X <= mu - k * sig) <= 1 / (1 + k^2),\n* F(mu - k * sig) <= 1 / (1 + k^2).\n*\n* For k = sqrt((1 - p) / p), we find\n* F(mu - k * sig) <= p,\n* and (mu - k * sig) is a lower-bound for the root.\n*\n* In cases where the Chebyshev inequality does not apply, geometric\n* progressions 1, 2, 4, ... and -1, -2, -4, ... are used to bracket\n* the root.\n*/\nif (p < 0.0 || p > 1.0) {\nthrow new OutOfRangeException(p, 0, 1);\n}\n\ndouble lowerBound = getSupportLowerBound();\nif (p == 0.0) {\nreturn lowerBound;\n}\n\ndouble upperBound = getSupportUpperBound();\nif (p == 1.0) {\nreturn upperBound;\n}\n\nfinal double mu = getNumericalMean();\nfinal double sig = FastMath.sqrt(getNumericalVariance());\nfinal boolean chebyshevApplies;\nchebyshevApplies = !(Double.isInfinite(mu) || Double.isNaN(mu) ||\nDouble.isInfinite(sig) || Double.isNaN(sig));\n\nif (lowerBound == Double.NEGATIVE_INFINITY) {\nif (chebyshevApplies) {\nlowerBound = mu - sig * FastMath.sqrt((1. - p) / p);\n} else {\nlowerBound = -1.0;\nwhile (cumulativeProbability(lowerBound) >= p) {\nlowerBound *= 2.0;\n}\n}\n}\n\nif (upperBound == Double.POSITIVE_INFINITY) {\nif (chebyshevApplies) {\nupperBound = mu + sig * FastMath.sqrt(p / (1. - p));\n} else {\nupperBound = 1.0;\nwhile (cumulativeProbability(upperBound) < p) {\nupperBound *= 2.0;\n}\n}\n}\n\nfinal UnivariateFunction toSolve = new UnivariateFunction() {\n\npublic double value(final double x) {\nreturn cumulativeProbability(x) - p;\n}\n};\n\ndouble x = UnivariateSolverUtils.solve(toSolve,\nlowerBound,\nupperBound,\ngetSolverAbsoluteAccuracy());\n\nif (!isSupportConnected()) {\n/* Test for plateau. */\nfinal double dx = getSolverAbsoluteAccuracy();\nif (x - dx >= getSupportLowerBound()) {\ndouble px = cumulativeProbability(x);\nif (cumulativeProbability(x - dx) == px) {\nupperBound = x;\nwhile (upperBound - lowerBound > dx) {\nfinal double midPoint = 0.5 * (lowerBound + upperBound);\nif (cumulativeProbability(midPoint) < px) {\nlowerBound = midPoint;\n} else {\nupperBound = midPoint;\n}\n}\nreturn upperBound;\n}\n}\n}\nreturn x;\n}",
            "method_id": 40
        },
        {
            "method_signature": "org.apache.commons.math3.util.Incrementor:<init>(I)V",
            "method_body": "public Incrementor(int max) {\nthis(max,\nnew MaxCountExceededCallback() {\n/** {@inheritDoc} */\npublic void trigger(int max) {\nthrow new MaxCountExceededException(max);\n}\n});\n}",
            "method_id": 41
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:calculateNumericalVariance()D",
            "method_body": "protected double calculateNumericalVariance() {\nfinal double denominatorDF = getDenominatorDegreesOfFreedom();\n\nif (denominatorDF > 4) {\nfinal double numeratorDF = getNumeratorDegreesOfFreedom();\nfinal double denomDFMinusTwo = denominatorDF - 2;\n\nreturn ( 2 * (denominatorDF * denominatorDF) * (numeratorDF + denominatorDF - 2) ) /\n( (numeratorDF * (denomDFMinusTwo * denomDFMinusTwo) * (denominatorDF - 4)) );\n}\n\nreturn Double.NaN;\n}",
            "method_id": 42
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getMax()D",
            "method_body": "public double getMax() {\nreturn searchMax;\n}",
            "method_id": 43
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:getSolverAbsoluteAccuracy()D",
            "method_body": "protected double getSolverAbsoluteAccuracy() {\nreturn solverAbsoluteAccuracy;\n}",
            "method_id": 44
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:<init>(DDD)V",
            "method_body": "protected BaseAbstractUnivariateSolver(final double relativeAccuracy,\nfinal double absoluteAccuracy,\nfinal double functionValueAccuracy) {\nthis.absoluteAccuracy = absoluteAccuracy;\nthis.relativeAccuracy = relativeAccuracy;\nthis.functionValueAccuracy = functionValueAccuracy;\n}",
            "method_id": 45
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:solve(ILorg/apache/commons/math3/analysis/UnivariateFunction;DD)D",
            "method_body": "public double solve(int maxEval, FUNC f, double min, double max) {\nreturn solve(maxEval, f, min, max, min + 0.5 * (max - min));\n}",
            "method_id": 46
        },
        {
            "method_signature": "org.apache.commons.math3.exception.util.ExceptionContext:<init>(Ljava/lang/Throwable;)V",
            "method_body": "public ExceptionContext(final Throwable throwable) {\nthis.throwable = throwable;\nmsgPatterns    = new ArrayList<Localizable>();\nmsgArguments   = new ArrayList<Object[]>();\ncontext        = new HashMap<String, Object>();\n}",
            "method_id": 47
        },
        {
            "method_signature": "org.apache.commons.math3.special.Beta$1:getA(ID)D",
            "method_body": "public static double regularizedBeta(double x,\nfinal double a, final double b,\ndouble epsilon, int maxIterations) {\ndouble ret;\n\nif (Double.isNaN(x) ||\nDouble.isNaN(a) ||\nDouble.isNaN(b) ||\nx < 0 ||\nx > 1 ||\na <= 0.0 ||\nb <= 0.0) {\nret = Double.NaN;\n} else if (x > (a + 1.0) / (a + b + 2.0)) {\nret = 1.0 - regularizedBeta(1.0 - x, b, a, epsilon, maxIterations);\n} else {\nContinuedFraction fraction = new ContinuedFraction() {\n\n@Override\nprotected double getB(int n, double x) {\ndouble ret;\ndouble m;\nif (n % 2 == 0) { // even\nm = n / 2.0;\nret = (m * (b - m) * x) /\n((a + (2 * m) - 1) * (a + (2 * m)));\n} else {\nm = (n - 1.0) / 2.0;\nret = -((a + m) * (a + b + m) * x) /\n((a + (2 * m)) * (a + (2 * m) + 1.0));\n}\nreturn ret;\n}\n\n@Override\nprotected double getA(int n, double x) {\nreturn 1.0;\n}\n};\nret = FastMath.exp((a * FastMath.log(x)) + (b * FastMath.log(1.0 - x)) -\nFastMath.log(a) - logBeta(a, b, epsilon, maxIterations)) *\n1.0 / fraction.evaluate(x, epsilon, maxIterations);\n}\n\nreturn ret;\n}",
            "method_id": 48
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:<init>(D)V",
            "method_body": "protected BaseAbstractUnivariateSolver(final double absoluteAccuracy) {\nthis(DEFAULT_RELATIVE_ACCURACY,\nabsoluteAccuracy,\nDEFAULT_FUNCTION_VALUE_ACCURACY);\n}",
            "method_id": 49
        },
        {
            "method_signature": "org.apache.commons.math3.exception.util.ExceptionContext:addMessage(Lorg/apache/commons/math3/exception/util/Localizable;[Ljava/lang/Object;)V",
            "method_body": "public void addMessage(Localizable pattern,\nObject ... arguments) {\nmsgPatterns.add(pattern);\nmsgArguments.add(ArgUtils.flatten(arguments));\n}",
            "method_id": 50
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver:getStartValue()D",
            "method_body": "public double getStartValue() {\nreturn searchStart;\n}",
            "method_id": 51
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:getNumericalVariance()D",
            "method_body": "public double getNumericalVariance() {\nif (!numericalVarianceIsCalculated) {\nnumericalVariance = calculateNumericalVariance();\nnumericalVarianceIsCalculated = true;\n}\nreturn numericalVariance;\n}",
            "method_id": 52
        },
        {
            "method_signature": "org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils:verifySequence(DDD)V",
            "method_body": "public static void verifySequence(final double lower,\nfinal double initial,\nfinal double upper) {\nverifyInterval(lower, initial);\nverifyInterval(initial, upper);\n}",
            "method_id": 53
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:abs(D)D",
            "method_body": "public static double abs(double x) {\nreturn (x < 0.0) ? -x : (x == 0.0) ? 0.0 : x; // -0.0 => +0.0\n}",
            "method_id": 54
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:getSupportUpperBound()D",
            "method_body": "public double getSupportUpperBound() {\nreturn Double.POSITIVE_INFINITY;\n}",
            "method_id": 55
        },
        {
            "method_signature": "org.apache.commons.math3.exception.NoBracketingException:<init>(Lorg/apache/commons/math3/exception/util/Localizable;DDDD[Ljava/lang/Object;)V",
            "method_body": "public NoBracketingException(Localizable specific,\nsuper(specific, lo, hi, fLo, fHi, args);\nthis.lo = lo;\nthis.hi = hi;\nthis.fLo = fLo;\nthis.fHi = fHi;\n}",
            "method_id": 56
        },
        {
            "method_signature": "org.apache.commons.math3.util.FastMath:log(D[D)D",
            "method_body": "private static double log(final double x, final double[] hiPrec) {\nif (x==0) { // Handle special case of +0/-0\nreturn Double.NEGATIVE_INFINITY;\n}\nlong bits = Double.doubleToLongBits(x);\n\n/* Handle special cases of negative input, and NaN */\nif ((bits & 0x8000000000000000L) != 0 || x != x) {\nif (x != 0.0) {\nif (hiPrec != null) {\nhiPrec[0] = Double.NaN;\n}\n\nreturn Double.NaN;\n}\n}\n\n/* Handle special cases of Positive infinity. */\nif (x == Double.POSITIVE_INFINITY) {\nif (hiPrec != null) {\nhiPrec[0] = Double.POSITIVE_INFINITY;\n}\n\nreturn Double.POSITIVE_INFINITY;\n}\n\n/* Extract the exponent */\nint exp = (int)(bits >> 52)-1023;\n\nif ((bits & 0x7ff0000000000000L) == 0) {\n// Subnormal!\nif (x == 0) {\n// Zero\nif (hiPrec != null) {\nhiPrec[0] = Double.NEGATIVE_INFINITY;\n}\n\nreturn Double.NEGATIVE_INFINITY;\n}\n\n/* Normalize the subnormal number. */\nbits <<= 1;\nwhile ( (bits & 0x0010000000000000L) == 0) {\nexp--;\nbits <<= 1;\n}\n}\n\n\nif (exp == -1 || exp == 0) {\nif (x < 1.01 && x > 0.99 && hiPrec == null) {\n/* The normal method doesn't work well in the range [0.99, 1.01], so call do a straight\npolynomial expansion in higer precision. */\n\n/* Compute x - 1.0 and split it */\ndouble xa = x - 1.0;\ndouble xb = xa - x + 1.0;\ndouble tmp = xa * HEX_40000000;\ndouble aa = xa + tmp - tmp;\ndouble ab = xa - aa;\nxa = aa;\nxb = ab;\n\ndouble ya = LN_QUICK_COEF[LN_QUICK_COEF.length-1][0];\ndouble yb = LN_QUICK_COEF[LN_QUICK_COEF.length-1][1];\n\nfor (int i = LN_QUICK_COEF.length - 2; i >= 0; i--) {\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\n/* Add  a = y + lnQuickCoef */\naa = ya + LN_QUICK_COEF[i][0];\nab = yb + LN_QUICK_COEF[i][1];\n/* Split y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n}\n\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\nreturn ya + yb;\n}\n}\n\n// lnm is a log of a number in the range of 1.0 - 2.0, so 0 <= lnm < ln(2)\ndouble lnm[] = lnMant.LN_MANT[(int)((bits & 0x000ffc0000000000L) >> 42)];\n\n/*\ndouble epsilon = x / Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n\nepsilon -= 1.0;\n*/\n\n// y is the most significant 10 bits of the mantissa\n//double y = Double.longBitsToDouble(bits & 0xfffffc0000000000L);\n//double epsilon = (x - y) / y;\ndouble epsilon = (bits & 0x3ffffffffffL) / (TWO_POWER_52 + (bits & 0x000ffc0000000000L));\n\ndouble lnza = 0.0;\ndouble lnzb = 0.0;\n\nif (hiPrec != null) {\n/* split epsilon -> x */\ndouble tmp = epsilon * HEX_40000000;\ndouble aa = epsilon + tmp - tmp;\ndouble ab = epsilon - aa;\ndouble xa = aa;\ndouble xb = ab;\n\n/* Need a more accurate epsilon, so adjust the division. */\ndouble numer = bits & 0x3ffffffffffL;\ndouble denom = TWO_POWER_52 + (bits & 0x000ffc0000000000L);\naa = numer - xa*denom - xb * denom;\nxb += aa / denom;\n\n/* Remez polynomial evaluation */\ndouble ya = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][0];\ndouble yb = LN_HI_PREC_COEF[LN_HI_PREC_COEF.length-1][1];\n\nfor (int i = LN_HI_PREC_COEF.length - 2; i >= 0; i--) {\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n/* split, so now y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n\n/* Add  a = y + lnHiPrecCoef */\naa = ya + LN_HI_PREC_COEF[i][0];\nab = yb + LN_HI_PREC_COEF[i][1];\n/* Split y = a */\ntmp = aa * HEX_40000000;\nya = aa + tmp - tmp;\nyb = aa - ya + ab;\n}\n\n/* Multiply a = y * x */\naa = ya * xa;\nab = ya * xb + yb * xa + yb * xb;\n\n/* split, so now lnz = a */\n/*\ntmp = aa * 1073741824.0;\nlnza = aa + tmp - tmp;\nlnzb = aa - lnza + ab;\n*/\nlnza = aa + ab;\nlnzb = -(lnza - aa - ab);\n} else {\n/* High precision not required.  Eval Remez polynomial\nusing standard double precision */\nlnza = -0.16624882440418567;\nlnza = lnza * epsilon + 0.19999954120254515;\nlnza = lnza * epsilon + -0.2499999997677497;\nlnza = lnza * epsilon + 0.3333333333332802;\nlnza = lnza * epsilon + -0.5;\nlnza = lnza * epsilon + 1.0;\nlnza = lnza * epsilon;\n}\n\n/* Relative sizes:\n* lnzb     [0, 2.33E-10]\n* lnm[1]   [0, 1.17E-7]\n* ln2B*exp [0, 1.12E-4]\n* lnza      [0, 9.7E-4]\n* lnm[0]   [0, 0.692]\n* ln2A*exp [0, 709]\n*/\n\n/* Compute the following sum:\n* lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\n*/\n\n//return lnzb + lnm[1] + ln2B*exp + lnza + lnm[0] + ln2A*exp;\ndouble a = LN_2_A*exp;\ndouble b = 0.0;\ndouble c = a+lnm[0];\ndouble d = -(c-a-lnm[0]);\na = c;\nb = b + d;\n\nc = a + lnza;\nd = -(c - a - lnza);\na = c;\nb = b + d;\n\nc = a + LN_2_B*exp;\nd = -(c - a - LN_2_B*exp);\na = c;\nb = b + d;\n\nc = a + lnm[1];\nd = -(c - a - lnm[1]);\na = c;\nb = b + d;\n\nc = a + lnzb;\nd = -(c - a - lnzb);\na = c;\nb = b + d;\n\nif (hiPrec != null) {\nhiPrec[0] = a;\nhiPrec[1] = b;\n}\n\nreturn a + b;\n}",
            "method_id": 57
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:<init>(DDD)V",
            "method_body": "public FDistribution(double numeratorDegreesOfFreedom,\ndouble denominatorDegreesOfFreedom,\ndouble inverseCumAccuracy)\nthrows NotStrictlyPositiveException {\nif (numeratorDegreesOfFreedom <= 0) {\nthrow new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\nnumeratorDegreesOfFreedom);\n}\nif (denominatorDegreesOfFreedom <= 0) {\nthrow new NotStrictlyPositiveException(LocalizedFormats.DEGREES_OF_FREEDOM,\ndenominatorDegreesOfFreedom);\n}\nthis.numeratorDegreesOfFreedom = numeratorDegreesOfFreedom;\nthis.denominatorDegreesOfFreedom = denominatorDegreesOfFreedom;\nsolverAbsoluteAccuracy = inverseCumAccuracy;\n}",
            "method_id": 58
        },
        {
            "method_signature": "org.apache.commons.math3.distribution.FDistribution:<init>(DD)V",
            "method_body": "public FDistribution(double numeratorDegreesOfFreedom,\ndouble denominatorDegreesOfFreedom)\nthrows NotStrictlyPositiveException {\nthis(numeratorDegreesOfFreedom, denominatorDegreesOfFreedom,\nDEFAULT_INVERSE_ABSOLUTE_ACCURACY);\n}",
            "method_id": 59
        },
        {
            "method_signature": "org.apache.commons.math3.util.ContinuedFraction:evaluate(DDI)D",
            "method_body": "public double evaluate(double x, double epsilon, int maxIterations) {\nfinal double small = 1e-50;\ndouble hPrev = getA(0, x);\n\n// use the value of small as epsilon criteria for zero checks\nif (Precision.equals(hPrev, 0.0, small)) {\nhPrev = small;\n}\n\nint n = 1;\ndouble dPrev = 0.0;\ndouble p0 = 1.0;\ndouble q1 = 1.0;\ndouble cPrev = hPrev;\ndouble hN = hPrev;\n\nwhile (n < maxIterations) {\nfinal double a = getA(n, x);\nfinal double b = getB(n, x);\n\ndouble cN = a * hPrev + b * p0;\ndouble q2 = a * q1 + b * dPrev;\nif (Double.isInfinite(cN) || Double.isInfinite(q2)) {\ndouble scaleFactor = 1d;\ndouble lastScaleFactor = 1d;\nfinal int maxPower = 5;\nfinal double scale = FastMath.max(a,b);\nif (scale <= 0) {  // Can't scale\nthrow new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE, x);\n}\nfor (int i = 0; i < maxPower; i++) {\nlastScaleFactor = scaleFactor;\nscaleFactor *= scale;\nif (a != 0.0 && a > b) {\ncN = hPrev / lastScaleFactor + (b / scaleFactor * p0);\nq2 = q1 / lastScaleFactor + (b / scaleFactor * dPrev);\n} else if (b != 0) {\ncN = (a / scaleFactor * hPrev) + p0 / lastScaleFactor;\nq2 = (a / scaleFactor * q1) + dPrev / lastScaleFactor;\n}\nif (!(Double.isInfinite(cN) || Double.isInfinite(q2))) {\nbreak;\n}\n}\n}\n\nfinal double deltaN = cN / q2 / cPrev;\nhN = cPrev * deltaN;\n\nif (Double.isInfinite(hN)) {\nthrow new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_INFINITY_DIVERGENCE,\nx);\n}\nif (Double.isNaN(hN)) {\nthrow new ConvergenceException(LocalizedFormats.CONTINUED_FRACTION_NAN_DIVERGENCE,\nx);\n}\n\nif (FastMath.abs(deltaN - 1.0) < epsilon) {\nbreak;\n}\n\ndPrev = q1;\ncPrev = cN / q2;\np0 = hPrev;\nhPrev = cN;\nq1 = q2;\nn++;\n}\n\nif (n >= maxIterations) {\nthrow new MaxCountExceededException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION,\nmaxIterations, x);\n}\n\nreturn hN;\n}",
            "method_id": 60
        }
    ]
}