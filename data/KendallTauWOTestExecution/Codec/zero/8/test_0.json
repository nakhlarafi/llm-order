{
    "bug_id": 8,
    "test_id": 0,
    "test_name": "org.apache.commons.codec.binary.Base64InputStreamTest.testCodec105",
    "test_body": "public void testCodec105() throws IOException {\nBase64InputStream in = new Base64InputStream(new Codec105ErrorInputStream(), true, 0, null);\nfor (int i = 0; i < 5; i++) {\nin.read();\n}\n}\n",
    "stack_trace": "java.lang.ArrayIndexOutOfBoundsException: 2\nat org.apache.commons.codec.binary.Base64.encode(Base64.java:497)\nat org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:173)\nat org.apache.commons.codec.binary.Base64InputStream.read(Base64InputStream.java:109)\nat org.apache.commons.codec.binary.Base64InputStreamTest.testCodec105(Base64InputStreamTest.java:58)",
    "covered_methods": [
        {
            "method_signature": "org.apache.commons.codec.binary.Base64:resizeBuffer()V",
            "method_body": "private void resizeBuffer() {\nif (buffer == null) {\nbuffer = new byte[DEFAULT_BUFFER_SIZE];\npos = 0;\nreadPos = 0;\n} else {\nbyte[] b = new byte[buffer.length * DEFAULT_BUFFER_RESIZE_FACTOR];\nSystem.arraycopy(buffer, 0, b, 0, buffer.length);\nbuffer = b;\n}\n}",
            "method_id": 0
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64:encode([BII)V",
            "method_body": "void encode(byte[] in, int inPos, int inAvail) {\nif (eof) {\nreturn;\n}\n// inAvail < 0 is how we're informed of EOF in the underlying data we're\n// encoding.\nif (inAvail < 0) {\neof = true;\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nswitch (modulus) {\ncase 1 :\nbuffer[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\nbuffer[pos++] = PAD;\n}\nbreak;\n\ncase 2 :\nbuffer[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n// URL-SAFE skips the padding to further reduce size.\nif (encodeTable == STANDARD_ENCODE_TABLE) {\nbuffer[pos++] = PAD;\n}\nbreak;\n}\n// Don't want to append the CRLF two times in a row, so make sure previous\n// character is not from CRLF!\nbyte b = lineSeparator[lineSeparator.length - 1];\nif (lineLength > 0 && pos > 0 && buffer[pos-1] != b) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\n}\n} else {\nfor (int i = 0; i < inAvail; i++) {\nif (buffer == null || buffer.length - pos < encodeSize) {\nresizeBuffer();\n}\nmodulus = (++modulus) % 3;\nint b = in[inPos++];\nif (b < 0) {\nb += 256;\n}\nx = (x << 8) + b;\nif (0 == modulus) {\nbuffer[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 12) & MASK_6BITS];\nbuffer[pos++] = encodeTable[(x >> 6) & MASK_6BITS];\nbuffer[pos++] = encodeTable[x & MASK_6BITS];\ncurrentLinePos += 4;\nif (lineLength > 0 && lineLength <= currentLinePos) {\nSystem.arraycopy(lineSeparator, 0, buffer, pos, lineSeparator.length);\npos += lineSeparator.length;\ncurrentLinePos = 0;\n}\n}\n}\n}\n}",
            "method_id": 1
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[B)V",
            "method_body": "public Base64(int lineLength, byte[] lineSeparator) {\nthis(lineLength, lineSeparator, false);\n}",
            "method_id": 2
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64:hasData()Z",
            "method_body": "boolean hasData() {\nreturn this.buffer != null;\n}",
            "method_id": 3
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read([BII)I",
            "method_body": "public int read(byte b[], int offset, int len) throws IOException {\nif (b == null) {\nthrow new NullPointerException();\n} else if (offset < 0 || len < 0) {\nthrow new IndexOutOfBoundsException();\n} else if (offset > b.length || offset + len > b.length) {\nthrow new IndexOutOfBoundsException();\n} else if (len == 0) {\nreturn 0;\n} else {\nint readLen = 0;\n/*\nRationale for while-loop on (readLen == 0):\n-----\nBase64.readResults() usually returns > 0 or EOF (-1).  In the\nrare case where it returns 0, we just keep trying.\n\nThis is essentially an undocumented contract for InputStream\nimplementors that want their code to work properly with\njava.io.InputStreamReader, since the latter hates it when\nInputStream.read(byte[]) returns a zero.  Unfortunately our\nreadResults() call must return 0 if a large amount of the data\nbeing decoded was non-base64, so this while-loop enables proper\ninterop with InputStreamReader for that scenario.\n-----\nThis is a fix for CODEC-101\n*/\nwhile (readLen == 0) {\nif (!base64.hasData()) {\nbyte[] buf = new byte[doEncode ? 4096 : 8192];\nint c = in.read(buf);\nif (c > 0 && b.length == len) {\nbase64.setInitialBuffer(b, offset, len);\n}\nif (doEncode) {\nbase64.encode(buf, 0, c);\n} else {\nbase64.decode(buf, 0, c);\n}\n}\nreadLen = base64.readResults(b, offset, len);\n}\nreturn readLen;\n}\n}",
            "method_id": 4
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64InputStream:<init>(Ljava/io/InputStream;ZI[B)V",
            "method_body": "public Base64InputStream(InputStream in, boolean doEncode, int lineLength, byte[] lineSeparator) {\nsuper(in);\nthis.doEncode = doEncode;\nthis.base64 = new Base64(lineLength, lineSeparator);\n}",
            "method_id": 5
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64:readResults([BII)I",
            "method_body": "int readResults(byte[] b, int bPos, int bAvail) {\nif (buffer != null) {\nint len = Math.min(avail(), bAvail);\nSystem.arraycopy(buffer, readPos, b, bPos, len);\nreadPos += len;\nif (readPos >= pos) {\nbuffer = null;\n}\nreturn len;\n}\nreturn eof ? -1 : 0;\n}",
            "method_id": 6
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64:<clinit>()V",
            "method_body": "public static final int PEM_CHUNK_SIZE = 64;\n\n/**\n* Chunk separator per RFC 2045 section 2.1.\n*\n* <p>\n* N.B. The next major release may break compatibility and make this field private.\n* </p>\n*\n* @see <a href=\"http://www.ietf.org/rfc/rfc2045.txt\">RFC 2045 section 2.1</a>\n*/\nstatic final byte[] CHUNK_SEPARATOR = {'\\r', '\\n'};",
            "method_id": 7
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64:isBase64(B)Z",
            "method_body": "public static boolean isBase64(byte octet) {\nreturn octet == PAD || (octet >= 0 && octet < DECODE_TABLE.length && DECODE_TABLE[octet] != -1);\n}",
            "method_id": 8
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64:avail()I",
            "method_body": "int avail() {\nreturn buffer != null ? pos - readPos : 0;\n}",
            "method_id": 9
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64:<init>(I[BZ)V",
            "method_body": "public Base64(int lineLength, byte[] lineSeparator, boolean urlSafe) {\nif (lineSeparator == null) {\nlineLength = 0;  // disable chunk-separating\nlineSeparator = CHUNK_SEPARATOR;  // this just gets ignored\n}\nthis.lineLength = lineLength > 0 ? (lineLength / 4) * 4 : 0;\nthis.lineSeparator = new byte[lineSeparator.length];\nSystem.arraycopy(lineSeparator, 0, this.lineSeparator, 0, lineSeparator.length);\nif (lineLength > 0) {\nthis.encodeSize = 4 + lineSeparator.length;\n} else {\nthis.encodeSize = 4;\n}\nthis.decodeSize = this.encodeSize - 1;\nif (containsBase64Byte(lineSeparator)) {\nString sep = StringUtils.newStringUtf8(lineSeparator);\nthrow new IllegalArgumentException(\"lineSeperator must not contain base64 characters: [\" + sep + \"]\");\n}\nthis.encodeTable = urlSafe ? URL_SAFE_ENCODE_TABLE : STANDARD_ENCODE_TABLE;\n}",
            "method_id": 10
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64InputStream:read()I",
            "method_body": "public int read() throws IOException {\nint r = read(singleByte, 0, 1);\nwhile (r == 0) {\nr = read(singleByte, 0, 1);\n}\nif (r > 0) {\nreturn singleByte[0] < 0 ? 256 + singleByte[0] : singleByte[0];\n}\nreturn -1;\n}",
            "method_id": 11
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64:containsBase64Byte([B)Z",
            "method_body": "private static boolean containsBase64Byte(byte[] arrayOctet) {\nfor (int i = 0; i < arrayOctet.length; i++) {\nif (isBase64(arrayOctet[i])) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 12
        },
        {
            "method_signature": "org.apache.commons.codec.binary.Base64:setInitialBuffer([BII)V",
            "method_body": "void setInitialBuffer(byte[] out, int outPos, int outAvail) {\nif (out != null && out.length == outAvail) {\nbuffer = out;\npos = outPos;\nreadPos = outPos;\n}\n}",
            "method_id": 13
        }
    ]
}