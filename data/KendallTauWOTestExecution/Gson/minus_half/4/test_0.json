{
    "bug_id": 4,
    "test_id": 0,
    "test_name": "com.google.gson.stream.JsonReaderTest.testTopLevelValueTypes",
    "test_body": "public void testTopLevelValueTypes() throws IOException {\nJsonReader reader1 = new JsonReader(reader(\"true\"));\nassertTrue(reader1.nextBoolean());\nassertEquals(JsonToken.END_DOCUMENT, reader1.peek());\nJsonReader reader2 = new JsonReader(reader(\"false\"));\nassertFalse(reader2.nextBoolean());\nassertEquals(JsonToken.END_DOCUMENT, reader2.peek());\nJsonReader reader3 = new JsonReader(reader(\"null\"));\nassertEquals(JsonToken.NULL, reader3.peek());\nreader3.nextNull();\nassertEquals(JsonToken.END_DOCUMENT, reader3.peek());\nJsonReader reader4 = new JsonReader(reader(\"123\"));\nassertEquals(123, reader4.nextInt());\nassertEquals(JsonToken.END_DOCUMENT, reader4.peek());\nJsonReader reader5 = new JsonReader(reader(\"123.4\"));\nassertEquals(123.4, reader5.nextDouble());\nassertEquals(JsonToken.END_DOCUMENT, reader5.peek());\nJsonReader reader6 = new JsonReader(reader(\"\\\"a\\\"\"));\nassertEquals(\"a\", reader6.nextString());\nassertEquals(JsonToken.END_DOCUMENT, reader6.peek());\n}\n",
    "stack_trace": "com.google.gson.stream.MalformedJsonException: Use JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $\nat com.google.gson.stream.JsonReader.syntaxError(JsonReader.java:1572)\nat com.google.gson.stream.JsonReader.checkLenient(JsonReader.java:1422)\nat com.google.gson.stream.JsonReader.doPeek(JsonReader.java:586)\nat com.google.gson.stream.JsonReader.nextBoolean(JsonReader.java:854)\nat com.google.gson.stream.JsonReaderTest.testTopLevelValueTypes(JsonReaderTest.java:1224)",
    "covered_methods": [
        {
            "method_signature": "com.google.gson.stream.JsonReader:checkLenient()V",
            "method_body": "private void checkLenient() throws IOException {\nif (!lenient) {\nthrow syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n}\n}",
            "method_id": 0
        },
        {
            "method_signature": "com.google.gson.stream.MalformedJsonException:<init>(Ljava/lang/String;)V",
            "method_body": "public MalformedJsonException(String msg) {\nsuper(msg);\n}",
            "method_id": 1
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:syntaxError(Ljava/lang/String;)Ljava/io/IOException;",
            "method_body": "private IOException syntaxError(String message) throws IOException {\nthrow new MalformedJsonException(message\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}",
            "method_id": 2
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:getLineNumber()I",
            "method_body": "int getLineNumber() {\nreturn lineNumber + 1;\n}",
            "method_id": 3
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
            "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}",
            "method_id": 4
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
            "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 5
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:nextBoolean()Z",
            "method_body": "public boolean nextBoolean() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_TRUE) {\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn true;\n} else if (p == PEEKED_FALSE) {\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn false;\n}\nthrow new IllegalStateException(\"Expected a boolean but was \" + peek()\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber() + \" path \" + getPath());\n}",
            "method_id": 6
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:getPath()Ljava/lang/String;",
            "method_body": "public String getPath() {\nStringBuilder result = new StringBuilder().append('$');\nfor (int i = 0, size = stackSize; i < size; i++) {\nswitch (stack[i]) {\ncase JsonScope.EMPTY_ARRAY:\ncase JsonScope.NONEMPTY_ARRAY:\nresult.append('[').append(pathIndices[i]).append(']');\nbreak;\n\ncase JsonScope.EMPTY_OBJECT:\ncase JsonScope.DANGLING_NAME:\ncase JsonScope.NONEMPTY_OBJECT:\nresult.append('.');\nif (pathNames[i] != null) {\nresult.append(pathNames[i]);\n}\nbreak;\n\ncase JsonScope.NONEMPTY_DOCUMENT:\ncase JsonScope.EMPTY_DOCUMENT:\ncase JsonScope.CLOSED:\nbreak;\n}\n}\nreturn result.toString();\n}",
            "method_id": 7
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
            "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\"\n+ \" at line \" + getLineNumber() + \" column \" + getColumnNumber());\n} else {\nreturn -1;\n}\n}",
            "method_id": 8
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:getColumnNumber()I",
            "method_body": "int getColumnNumber() {\nreturn pos - lineStart + 1;\n}",
            "method_id": 9
        }
    ]
}