{
    "bug_id": 13,
    "test_id": 0,
    "test_name": "com.google.gson.stream.JsonReaderTest.testNegativeZero",
    "test_body": "public void testNegativeZero() throws Exception {\nJsonReader reader = new JsonReader(reader(\"[-0]\"));\nreader.setLenient(false);\nreader.beginArray();\nassertEquals(NUMBER, reader.peek());\nassertEquals(\"-0\", reader.nextString());\n}\n",
    "stack_trace": "junit.framework.ComparisonFailure: expected:<[-]0> but was:<[]0>\nat junit.framework.Assert.assertEquals(Assert.java:100)\nat junit.framework.Assert.assertEquals(Assert.java:107)\nat junit.framework.TestCase.assertEquals(TestCase.java:269)\nat com.google.gson.stream.JsonReaderTest.testNegativeZero(JsonReaderTest.java:573)",
    "covered_methods": [
        {
            "method_signature": "com.google.gson.stream.JsonReader:isLiteral(C)Z",
            "method_body": "private boolean isLiteral(char c) throws IOException {\nswitch (c) {\ncase '/':\ncase '\\\\':\ncase ';':\ncase '#':\ncase '=':\ncheckLenient(); // fall-through\ncase '{':\ncase '}':\ncase '[':\ncase ']':\ncase ':':\ncase ',':\ncase ' ':\ncase '\\t':\ncase '\\f':\ncase '\\r':\ncase '\\n':\nreturn false;\ndefault:\nreturn true;\n}\n}",
            "method_id": 0
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
            "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 1
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
            "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\" + locationString());\n} else {\nreturn -1;\n}\n}",
            "method_id": 2
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
            "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}",
            "method_id": 3
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:peekNumber()I",
            "method_body": "private int peekNumber() throws IOException {\n// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\n\nlong value = 0; // Negative to accommodate Long.MIN_VALUE more easily.\nboolean negative = false;\nboolean fitsInLong = true;\nint last = NUMBER_CHAR_NONE;\n\nint i = 0;\n\ncharactersOfNumber:\nfor (; true; i++) {\nif (p + i == l) {\nif (i == buffer.length) {\n// Though this looks like a well-formed number, it's too long to continue reading. Give up\n// and let the application handle this as an unquoted literal.\nreturn PEEKED_NONE;\n}\nif (!fillBuffer(i + 1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nchar c = buffer[p + i];\nswitch (c) {\ncase '-':\nif (last == NUMBER_CHAR_NONE) {\nnegative = true;\nlast = NUMBER_CHAR_SIGN;\ncontinue;\n} else if (last == NUMBER_CHAR_EXP_E) {\nlast = NUMBER_CHAR_EXP_SIGN;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ncase '+':\nif (last == NUMBER_CHAR_EXP_E) {\nlast = NUMBER_CHAR_EXP_SIGN;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ncase 'e':\ncase 'E':\nif (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) {\nlast = NUMBER_CHAR_EXP_E;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ncase '.':\nif (last == NUMBER_CHAR_DIGIT) {\nlast = NUMBER_CHAR_DECIMAL;\ncontinue;\n}\nreturn PEEKED_NONE;\n\ndefault:\nif (c < '0' || c > '9') {\nif (!isLiteral(c)) {\nbreak charactersOfNumber;\n}\nreturn PEEKED_NONE;\n}\nif (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) {\nvalue = -(c - '0');\nlast = NUMBER_CHAR_DIGIT;\n} else if (last == NUMBER_CHAR_DIGIT) {\nif (value == 0) {\nreturn PEEKED_NONE; // Leading '0' prefix is not allowed (since it could be octal).\n}\nlong newValue = value * 10 - (c - '0');\nfitsInLong &= value > MIN_INCOMPLETE_INTEGER\n|| (value == MIN_INCOMPLETE_INTEGER && newValue < value);\nvalue = newValue;\n} else if (last == NUMBER_CHAR_DECIMAL) {\nlast = NUMBER_CHAR_FRACTION_DIGIT;\n} else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) {\nlast = NUMBER_CHAR_EXP_DIGIT;\n}\n}\n}\n\n// We've read a complete number. Decide if it's a PEEKED_LONG or a PEEKED_NUMBER.\nif (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) {\npeekedLong = negative ? value : -value;\npos += i;\nreturn peeked = PEEKED_LONG;\n} else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT\n|| last == NUMBER_CHAR_EXP_DIGIT) {\npeekedNumberLength = i;\nreturn peeked = PEEKED_NUMBER;\n} else {\nreturn PEEKED_NONE;\n}\n}",
            "method_id": 4
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
            "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}",
            "method_id": 5
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:peekKeyword()I",
            "method_body": "private int peekKeyword() throws IOException {\n// Figure out which keyword we're matching against by its first character.\nchar c = buffer[pos];\nString keyword;\nString keywordUpper;\nint peeking;\nif (c == 't' || c == 'T') {\nkeyword = \"true\";\nkeywordUpper = \"TRUE\";\npeeking = PEEKED_TRUE;\n} else if (c == 'f' || c == 'F') {\nkeyword = \"false\";\nkeywordUpper = \"FALSE\";\npeeking = PEEKED_FALSE;\n} else if (c == 'n' || c == 'N') {\nkeyword = \"null\";\nkeywordUpper = \"NULL\";\npeeking = PEEKED_NULL;\n} else {\nreturn PEEKED_NONE;\n}\n\n// Confirm that chars [1..length) match the keyword.\nint length = keyword.length();\nfor (int i = 1; i < length; i++) {\nif (pos + i >= limit && !fillBuffer(i + 1)) {\nreturn PEEKED_NONE;\n}\nc = buffer[pos + i];\nif (c != keyword.charAt(i) && c != keywordUpper.charAt(i)) {\nreturn PEEKED_NONE;\n}\n}\n\nif ((pos + length < limit || fillBuffer(length + 1))\n&& isLiteral(buffer[pos + length])) {\nreturn PEEKED_NONE; // Don't match trues, falsey or nullsoft!\n}\n\n// We've found the keyword followed either by EOF or by a non-literal character.\npos += length;\nreturn peeked = peeking;\n}",
            "method_id": 6
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
            "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nString result;\nif (p == PEEKED_UNQUOTED) {\nresult = nextUnquotedValue();\n} else if (p == PEEKED_SINGLE_QUOTED) {\nresult = nextQuotedValue('\\'');\n} else if (p == PEEKED_DOUBLE_QUOTED) {\nresult = nextQuotedValue('\"');\n} else if (p == PEEKED_BUFFERED) {\nresult = peekedString;\npeekedString = null;\n} else if (p == PEEKED_LONG) {\nresult = Long.toString(peekedLong);\n} else if (p == PEEKED_NUMBER) {\nresult = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else {\nthrow new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}",
            "method_id": 7
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:beginArray()V",
            "method_body": "public void beginArray() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_BEGIN_ARRAY) {\npush(JsonScope.EMPTY_ARRAY);\npathIndices[stackSize - 1] = 0;\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n}\n}",
            "method_id": 8
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
            "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nint[] newPathIndices = new int[stackSize * 2];\nString[] newPathNames = new String[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nSystem.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\nSystem.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\nstack = newStack;\npathIndices = newPathIndices;\npathNames = newPathNames;\n}\nstack[stackSize++] = newTop;\n}",
            "method_id": 9
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
            "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}",
            "method_id": 10
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
            "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}",
            "method_id": 11
        }
    ]
}