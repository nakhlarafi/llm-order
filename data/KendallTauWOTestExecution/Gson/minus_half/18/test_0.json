{
    "bug_id": 18,
    "test_id": 0,
    "test_name": "com.google.gson.functional.CollectionTest.testIssue1107",
    "test_body": "public void testIssue1107() {\nString json = \"{\\n\" +\n\"  \\\"inBig\\\": {\\n\" +\n\"    \\\"key\\\": [\\n\" +\n\"      { \\\"inSmall\\\": \\\"hello\\\" }\\n\" +\n\"    ]\\n\" +\n\"  }\\n\" +\n\"}\";\nBigClass bigClass = new Gson().fromJson(json, BigClass.class);\nSmallClass small = bigClass.inBig.get(\"key\").get(0);\nassertNotNull(small);\nassertEquals(\"hello\", small.inSmall);\n}\n",
    "stack_trace": "java.lang.ClassCastException: com.google.gson.internal.LinkedTreeMap cannot be cast to com.google.gson.functional.CollectionTest$SmallClass\nat com.google.gson.functional.CollectionTest.testIssue1107(CollectionTest.java:410)",
    "covered_methods": [
        {
            "method_signature": "com.google.gson.internal.Primitives:isPrimitive(Ljava/lang/reflect/Type;)Z",
            "method_body": "public static boolean isPrimitive(Type type) {\nreturn PRIMITIVE_TO_WRAPPER_TYPE.containsKey(type);\n}",
            "method_id": 0
        },
        {
            "method_signature": "com.google.gson.Gson:floatAdapter(Z)Lcom/google/gson/TypeAdapter;",
            "method_body": "private TypeAdapter<Number> floatAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.FLOAT;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Float read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn (float) in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nfloat floatValue = value.floatValue();\ncheckValidFloatingPoint(floatValue);\nout.value(value);\n}\n};\n}",
            "method_id": 1
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$BoundField:<init>(Ljava/lang/String;ZZ)V",
            "method_body": "protected BoundField(String name, boolean serialized, boolean deserialized) {\nthis.name = name;\nthis.serialized = serialized;\nthis.deserialized = deserialized;\n}",
            "method_id": 2
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getFieldNames(Ljava/lang/reflect/Field;)Ljava/util/List;",
            "method_body": "private List<String> getFieldNames(Field f) {\nSerializedName annotation = f.getAnnotation(SerializedName.class);\nif (annotation == null) {\nString name = fieldNamingPolicy.translateName(f);\nreturn Collections.singletonList(name);\n}\n\nString serializedName = annotation.value();\nString[] alternates = annotation.alternate();\nif (alternates.length == 0) {\nreturn Collections.singletonList(serializedName);\n}\n\nList<String> fieldNames = new ArrayList<String>(alternates.length + 1);\nfieldNames.add(serializedName);\nfor (String alternate : alternates) {\nfieldNames.add(alternate);\n}\nreturn fieldNames;\n}",
            "method_id": 3
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$32:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 4
        },
        {
            "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>(Ljava/util/Comparator;)V",
            "method_body": "public LinkedTreeMap(Comparator<? super K> comparator) {\nthis.comparator = comparator != null\n? comparator\n: (Comparator) NATURAL_ORDER;\n}",
            "method_id": 5
        },
        {
            "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultImplementationConstructor(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
            "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayDeque<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}",
            "method_id": 6
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;Ljava/util/Collection;)Ljava/lang/reflect/Type;",
            "method_body": "private static Type resolve(Type context, Class<?> contextRawType, Type toResolve,\nCollection<TypeVariable> visitedTypeVariables) {\n// this implementation is made a little more complicated in an attempt to avoid object-creation\nwhile (true) {\nif (toResolve instanceof TypeVariable) {\nTypeVariable<?> typeVariable = (TypeVariable<?>) toResolve;\nif (visitedTypeVariables.contains(typeVariable)) {\n// cannot reduce due to infinite recursion\nreturn toResolve;\n} else {\nvisitedTypeVariables.add(typeVariable);\n}\ntoResolve = resolveTypeVariable(context, contextRawType, typeVariable);\nif (toResolve == typeVariable) {\nreturn toResolve;\n}\n\n} else if (toResolve instanceof Class && ((Class<?>) toResolve).isArray()) {\nClass<?> original = (Class<?>) toResolve;\nType componentType = original.getComponentType();\nType newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof GenericArrayType) {\nGenericArrayType original = (GenericArrayType) toResolve;\nType componentType = original.getGenericComponentType();\nType newComponentType = resolve(context, contextRawType, componentType, visitedTypeVariables);\nreturn componentType == newComponentType\n? original\n: arrayOf(newComponentType);\n\n} else if (toResolve instanceof ParameterizedType) {\nParameterizedType original = (ParameterizedType) toResolve;\nType ownerType = original.getOwnerType();\nType newOwnerType = resolve(context, contextRawType, ownerType, visitedTypeVariables);\nboolean changed = newOwnerType != ownerType;\n\nType[] args = original.getActualTypeArguments();\nfor (int t = 0, length = args.length; t < length; t++) {\nType resolvedTypeArgument = resolve(context, contextRawType, args[t], visitedTypeVariables);\nif (resolvedTypeArgument != args[t]) {\nif (!changed) {\nargs = args.clone();\nchanged = true;\n}\nargs[t] = resolvedTypeArgument;\n}\n}\n\nreturn changed\n? newParameterizedTypeWithOwner(newOwnerType, original.getRawType(), args)\n: original;\n\n} else if (toResolve instanceof WildcardType) {\nWildcardType original = (WildcardType) toResolve;\nType[] originalLowerBound = original.getLowerBounds();\nType[] originalUpperBound = original.getUpperBounds();\n\nif (originalLowerBound.length == 1) {\nType lowerBound = resolve(context, contextRawType, originalLowerBound[0], visitedTypeVariables);\nif (lowerBound != originalLowerBound[0]) {\nreturn supertypeOf(lowerBound);\n}\n} else if (originalUpperBound.length == 1) {\nType upperBound = resolve(context, contextRawType, originalUpperBound[0], visitedTypeVariables);\nif (upperBound != originalUpperBound[0]) {\nreturn subtypeOf(upperBound);\n}\n}\nreturn original;\n\n} else {\nreturn toResolve;\n}\n}\n}",
            "method_id": 7
        },
        {
            "method_signature": "com.google.gson.Gson:longAdapter(Lcom/google/gson/LongSerializationPolicy;)Lcom/google/gson/TypeAdapter;",
            "method_body": "private static TypeAdapter<Number> longAdapter(LongSerializationPolicy longSerializationPolicy) {\nif (longSerializationPolicy == LongSerializationPolicy.DEFAULT) {\nreturn TypeAdapters.LONG;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Number read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextLong();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\nout.value(value.toString());\n}\n};\n}",
            "method_id": 8
        },
        {
            "method_signature": "com.google.gson.internal.ConstructorConstructor:<init>(Ljava/util/Map;)V",
            "method_body": "public ConstructorConstructor(Map<Type, InstanceCreator<?>> instanceCreators) {\nthis.instanceCreators = instanceCreators;\n}",
            "method_id": 9
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:setLenient(Z)V",
            "method_body": "public final void setLenient(boolean lenient) {\nthis.lenient = lenient;\n}",
            "method_id": 10
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:getSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
            "method_body": "static Type getSupertype(Type context, Class<?> contextRawType, Class<?> supertype) {\n// wildcards are useless for resolving supertypes. As the upper bound has the same raw type, use it instead\ncheckArgument(supertype.isAssignableFrom(contextRawType));\nreturn resolve(context, contextRawType,\n$Gson$Types.getGenericSupertype(context, contextRawType, supertype));\n}",
            "method_id": 11
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:getRawType(Ljava/lang/reflect/Type;)Ljava/lang/Class;",
            "method_body": "public static Class<?> getRawType(Type type) {\nif (type instanceof Class<?>) {\n// type is a normal class.\nreturn (Class<?>) type;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType parameterizedType = (ParameterizedType) type;\n\n// I'm not exactly sure why getRawType() returns Type instead of Class.\n// Neal isn't either but suspects some pathological case related\n// to nested classes exists.\nType rawType = parameterizedType.getRawType();\ncheckArgument(rawType instanceof Class);\nreturn (Class<?>) rawType;\n\n} else if (type instanceof GenericArrayType) {\nType componentType = ((GenericArrayType)type).getGenericComponentType();\nreturn Array.newInstance(getRawType(componentType), 0).getClass();\n\n} else if (type instanceof TypeVariable) {\n// we could use the variable's bounds, but that won't work if there are multiple.\n// having a raw type that's more general than necessary is okay\nreturn Object.class;\n\n} else if (type instanceof WildcardType) {\nreturn getRawType(((WildcardType) type).getUpperBounds()[0]);\n\n} else {\nString className = type == null ? \"null\" : type.getClass().getName();\nthrow new IllegalArgumentException(\"Expected a Class, ParameterizedType, or \"\n+ \"GenericArrayType, but <\" + type + \"> is of type \" + className);\n}\n}",
            "method_id": 12
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:doPeek()I",
            "method_body": "int doPeek() throws IOException {\nint peekStack = stack[stackSize - 1];\nif (peekStack == JsonScope.EMPTY_ARRAY) {\nstack[stackSize - 1] = JsonScope.NONEMPTY_ARRAY;\n} else if (peekStack == JsonScope.NONEMPTY_ARRAY) {\n// Look for a comma before the next element.\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase ']':\nreturn peeked = PEEKED_END_ARRAY;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated array\");\n}\n} else if (peekStack == JsonScope.EMPTY_OBJECT || peekStack == JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1] = JsonScope.DANGLING_NAME;\n// Look for a comma before the next element.\nif (peekStack == JsonScope.NONEMPTY_OBJECT) {\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '}':\nreturn peeked = PEEKED_END_OBJECT;\ncase ';':\ncheckLenient(); // fall-through\ncase ',':\nbreak;\ndefault:\nthrow syntaxError(\"Unterminated object\");\n}\n}\nint c = nextNonWhitespace(true);\nswitch (c) {\ncase '\"':\nreturn peeked = PEEKED_DOUBLE_QUOTED_NAME;\ncase '\\'':\ncheckLenient();\nreturn peeked = PEEKED_SINGLE_QUOTED_NAME;\ncase '}':\nif (peekStack != JsonScope.NONEMPTY_OBJECT) {\nreturn peeked = PEEKED_END_OBJECT;\n} else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:\ncheckLenient();\npos--; // Don't consume the first character in an unquoted string.\nif (isLiteral((char) c)) {\nreturn peeked = PEEKED_UNQUOTED_NAME;\n} else {\nthrow syntaxError(\"Expected name\");\n}\n}",
            "method_id": 13
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;Z)Z",
            "method_body": "public boolean excludeField(Field f, boolean serialize) {\nreturn excludeField(f, serialize, excluder);\n}",
            "method_id": 14
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:endObject()V",
            "method_body": "public void endObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_END_OBJECT) {\nstackSize--;\npathNames[stackSize] = null; // Free the last path name so that it can be garbage collected!\npathIndices[stackSize - 1]++;\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + locationString());\n}\n}",
            "method_id": 15
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
            "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}",
            "method_id": 16
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:getCollectionElementType(Ljava/lang/reflect/Type;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
            "method_body": "public static Type getCollectionElementType(Type context, Class<?> contextRawType) {\nType collectionType = getSupertype(context, contextRawType, Collection.class);\n\nif (collectionType instanceof WildcardType) {\ncollectionType = ((WildcardType)collectionType).getUpperBounds()[0];\n}\nif (collectionType instanceof ParameterizedType) {\nreturn ((ParameterizedType) collectionType).getActualTypeArguments()[0];\n}\nreturn Object.class;\n}",
            "method_id": 17
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:nextName()Ljava/lang/String;",
            "method_body": "public String nextName() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nString result;\nif (p == PEEKED_UNQUOTED_NAME) {\nresult = nextUnquotedValue();\n} else if (p == PEEKED_SINGLE_QUOTED_NAME) {\nresult = nextQuotedValue('\\'');\n} else if (p == PEEKED_DOUBLE_QUOTED_NAME) {\nresult = nextQuotedValue('\"');\n} else {\nthrow new IllegalStateException(\"Expected a name but was \" + peek() + locationString());\n}\npeeked = PEEKED_NONE;\npathNames[stackSize - 1] = result;\nreturn result;\n}",
            "method_id": 18
        },
        {
            "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}\n};",
            "method_id": 19
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
            "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nabstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\nabstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n}\n\npublic static final class Adapter<T> extends TypeAdapter<T> {\nprivate final ObjectConstructor<T> constructor;\nprivate final Map<String, BoundField> boundFields;\n\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\n\n@Override public T read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nT instance = constructor.construct();\n\ntry {\nin.beginObject();\nwhile (in.hasNext()) {\nString name = in.nextName();\nBoundField field = boundFields.get(name);\nif (field == null || !field.deserialized) {\nin.skipValue();\n} else {\nfield.read(in, instance);\n}\n}\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nin.endObject();\nreturn instance;\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\n\nout.beginObject();\ntry {\nfor (BoundField boundField : boundFields.values()) {\nif (boundField.writeField(value)) {\nout.name(boundField.name);\nboundField.write(out, value);\n}\n}\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nout.endObject();\n}\n}",
            "method_id": 20
        },
        {
            "method_signature": "com.google.gson.Gson:fromJson(Ljava/io/Reader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
            "method_body": "public <T> T fromJson(Reader json, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nJsonReader jsonReader = newJsonReader(json);\nT object = (T) fromJson(jsonReader, typeOfT);\nassertFullConsumption(object, jsonReader);\nreturn object;\n}",
            "method_id": 21
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:checkNotPrimitive(Ljava/lang/reflect/Type;)V",
            "method_body": "static void checkNotPrimitive(Type type) {\ncheckArgument(!(type instanceof Class<?>) || !((Class<?>) type).isPrimitive());\n}",
            "method_id": 22
        },
        {
            "method_signature": "com.google.gson.Gson:newJsonReader(Ljava/io/Reader;)Lcom/google/gson/stream/JsonReader;",
            "method_body": "public JsonReader newJsonReader(Reader reader) {\nJsonReader jsonReader = new JsonReader(reader);\njsonReader.setLenient(lenient);\nreturn jsonReader;\n}",
            "method_id": 23
        },
        {
            "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}\n};",
            "method_id": 24
        },
        {
            "method_signature": "com.google.gson.Gson:fromJson(Lcom/google/gson/stream/JsonReader;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
            "method_body": "public <T> T fromJson(JsonReader reader, Type typeOfT) throws JsonIOException, JsonSyntaxException {\nboolean isEmpty = true;\nboolean oldLenient = reader.isLenient();\nreader.setLenient(true);\ntry {\nreader.peek();\nisEmpty = false;\nTypeToken<T> typeToken = (TypeToken<T>) TypeToken.get(typeOfT);\nTypeAdapter<T> typeAdapter = getAdapter(typeToken);\nT object = typeAdapter.read(reader);\nreturn object;\n} catch (EOFException e) {\n/*\n* For compatibility with JSON 1.5 and earlier, we return null for empty\n* documents instead of throwing.\n*/\nif (isEmpty) {\nreturn null;\n}\nthrow new JsonSyntaxException(e);\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\n// TODO(inder): Figure out whether it is indeed right to rethrow this as JsonSyntaxException\nthrow new JsonSyntaxException(e);\n} finally {\nreader.setLenient(oldLenient);\n}\n}",
            "method_id": 25
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$33:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 26
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:<clinit>()V",
            "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\n\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate boolean requireExpose;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n\n@Override protected Excluder clone() {\ntry {\nreturn (Excluder) super.clone();\n} catch (CloneNotSupportedException e) {\nthrow new AssertionError(e);\n}\n}",
            "method_id": 27
        },
        {
            "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
            "method_body": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}",
            "method_id": 28
        },
        {
            "method_signature": "com.google.gson.Gson$FutureTypeAdapter:setDelegate(Lcom/google/gson/TypeAdapter;)V",
            "method_body": "public void setDelegate(TypeAdapter<T> typeAdapter) {\nif (delegate != null) {\nthrow new AssertionError();\n}\ndelegate = typeAdapter;\n}",
            "method_id": 29
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:beginObject()V",
            "method_body": "public void beginObject() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_BEGIN_OBJECT) {\npush(JsonScope.EMPTY_OBJECT);\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + locationString());\n}\n}",
            "method_id": 30
        },
        {
            "method_signature": "com.google.gson.internal.ConstructorConstructor$14:construct()Ljava/lang/Object;",
            "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nfinal Type type, final Class<? super T> rawType) {\nreturn new ObjectConstructor<T>() {\nprivate final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n@SuppressWarnings(\"unchecked\")\n@Override public T construct() {\ntry {\nObject newInstance = unsafeAllocator.newInstance(rawType);\nreturn (T) newInstance;\n} catch (Exception e) {\nthrow new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n+ \"Registering an InstanceCreator with Gson for this type may fix this problem.\"), e);\n}\n}\n};\n}",
            "method_id": 31
        },
        {
            "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:getKeyAdapter(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;)Lcom/google/gson/TypeAdapter;",
            "method_body": "private TypeAdapter<?> getKeyAdapter(Gson context, Type keyType) {\nreturn (keyType == boolean.class || keyType == Boolean.class)\n? TypeAdapters.BOOLEAN_AS_STRING\n: context.getAdapter(TypeToken.get(keyType));\n}",
            "method_id": 32
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, final TypeToken<T> type) {\nClass<? super T> raw = type.getRawType();\n\nif (!Object.class.isAssignableFrom(raw)) {\nreturn null; // it's a primitive!\n}\n\nObjectConstructor<T> constructor = constructorConstructor.get(type);\nreturn new Adapter<T>(constructor, getBoundFields(gson, type, raw));\n}",
            "method_id": 33
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters:<clinit>()V",
            "method_body": "public static final TypeAdapter<Class> CLASS = new TypeAdapter<Class>() {\n@Override\npublic void write(JsonWriter out, Class value) throws IOException {\nthrow new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \"\n+ value.getName() + \". Forgot to register a type adapter?\");\n}\n@Override\npublic Class read(JsonReader in) throws IOException {\nthrow new UnsupportedOperationException(\n\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n}\n}.nullSafe();",
            "method_id": 34
        },
        {
            "method_signature": "com.google.gson.internal.UnsafeAllocator$1:newInstance(Ljava/lang/Class;)Ljava/lang/Object;",
            "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\n\npublic static UnsafeAllocator create() {\n// try JVM\n// public class Unsafe {\n//   public Object allocateInstance(Class<?> type);\n// }\ntry {\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) allocateInstance.invoke(unsafe, c);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, post-gingerbread\n// public class ObjectStreamClass {\n//   private static native int getConstructorId(Class<?> c);\n//   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n// }\ntry {\nMethod getConstructorId = ObjectStreamClass.class\n.getDeclaredMethod(\"getConstructorId\", Class.class);\ngetConstructorId.setAccessible(true);\nfinal int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\nfinal Method newInstance = ObjectStreamClass.class\n.getDeclaredMethod(\"newInstance\", Class.class, int.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, constructorId);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, pre-gingerbread\n// public class ObjectInputStream {\n//   private static native Object newInstance(\n//     Class<?> instantiationClass, Class<?> constructorClass);\n// }\ntry {\nfinal Method newInstance = ObjectInputStream.class\n.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, Object.class);\n}\n};\n} catch (Exception ignored) {\n}\n\n// give up\nreturn new UnsafeAllocator() {\n@Override\npublic <T> T newInstance(Class<T> c) {\nthrow new UnsupportedOperationException(\"Cannot allocate \" + c);\n}\n};\n}",
            "method_id": 35
        },
        {
            "method_signature": "com.google.gson.Gson:<clinit>()V",
            "method_body": "static final boolean DEFAULT_JSON_NON_EXECUTABLE = false;\nstatic final boolean DEFAULT_LENIENT = false;\nstatic final boolean DEFAULT_PRETTY_PRINT = false;\nstatic final boolean DEFAULT_ESCAPE_HTML = true;\nstatic final boolean DEFAULT_SERIALIZE_NULLS = false;\nstatic final boolean DEFAULT_COMPLEX_MAP_KEYS = false;\nstatic final boolean DEFAULT_SPECIALIZE_FLOAT_VALUES = false;\n\nprivate static final TypeToken<?> NULL_KEY_SURROGATE = TypeToken.get(Object.class);\nprivate static final String JSON_NON_EXECUTABLE_PREFIX = \")]}'\\n\";\n\n/**\n* This thread local guards against reentrant calls to getAdapter(). In\n* certain object graphs, creating an adapter for a type may recursively\n* require an adapter for the same type! Without intervention, the recursive\n* lookup would stack overflow. We cheat by returning a proxy type adapter.\n* The proxy is wired up once the initial adapter has been created.\n*/\nprivate final ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>> calls\n= new ThreadLocal<Map<TypeToken<?>, FutureTypeAdapter<?>>>();\n\nprivate final Map<TypeToken<?>, TypeAdapter<?>> typeTokenCache = new ConcurrentHashMap<TypeToken<?>, TypeAdapter<?>>();\n\nprivate final ConstructorConstructor constructorConstructor;\nprivate final JsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory;\n\nfinal List<TypeAdapterFactory> factories;\n\nfinal Excluder excluder;\nfinal FieldNamingStrategy fieldNamingStrategy;\nfinal Map<Type, InstanceCreator<?>> instanceCreators;\nfinal boolean serializeNulls;\nfinal boolean complexMapKeySerialization;\nfinal boolean generateNonExecutableJson;\nfinal boolean htmlSafe;\nfinal boolean prettyPrinting;\nfinal boolean lenient;\nfinal boolean serializeSpecialFloatingPointValues;\nfinal String datePattern;\nfinal int dateStyle;\nfinal int timeStyle;\nfinal LongSerializationPolicy longSerializationPolicy;\nfinal List<TypeAdapterFactory> builderFactories;\nfinal List<TypeAdapterFactory> builderHierarchyFactories;\n\n/**\n* Constructs a Gson object with default configuration. The default configuration has the\n* following settings:\n* <ul>\n*   <li>The JSON generated by <code>toJson</code> methods is in compact representation. This\n*   means that all the unneeded white-space is removed. You can change this behavior with\n*   {@link GsonBuilder#setPrettyPrinting()}. </li>",
            "method_id": 36
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:hashCode()I",
            "method_body": "@Override public final int hashCode() {\nreturn this.hashCode;\n}",
            "method_id": 37
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:getRawType()Ljava/lang/Class;",
            "method_body": "public final Class<? super T> getRawType() {\nreturn rawType;\n}",
            "method_id": 38
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public <T> TypeAdapter<T> create(final Gson gson, final TypeToken<T> type) {\nClass<?> rawType = type.getRawType();\nfinal boolean skipSerialize = excludeClass(rawType, true);\nfinal boolean skipDeserialize = excludeClass(rawType, false);\n\nif (!skipSerialize && !skipDeserialize) {\nreturn null;\n}\n\nreturn new TypeAdapter<T>() {\n/** The delegate is lazily created because it may not be needed, and creating it may fail. */\nprivate TypeAdapter<T> delegate;\n\n@Override public T read(JsonReader in) throws IOException {\nif (skipDeserialize) {\nin.skipValue();\nreturn null;\n}\nreturn delegate().read(in);\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (skipSerialize) {\nout.nullValue();\nreturn;\n}\ndelegate().write(out, value);\n}\n\nprivate TypeAdapter<T> delegate() {\nTypeAdapter<T> d = delegate;\nreturn d != null\n? d\n: (delegate = gson.getDelegateAdapter(Excluder.this, type));\n}\n};\n}",
            "method_id": 39
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters:newTypeHierarchyFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
            "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 40
        },
        {
            "method_signature": "com.google.gson.internal.bind.TimeTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Time.class ? (TypeAdapter<T>) new TimeTypeAdapter() : null;\n}",
            "method_id": 41
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:getMapKeyAndValueTypes(Ljava/lang/reflect/Type;Ljava/lang/Class;)[Ljava/lang/reflect/Type;",
            "method_body": "public static Type[] getMapKeyAndValueTypes(Type context, Class<?> contextRawType) {\n/*\n* Work around a problem with the declaration of java.util.Properties. That\n* class should extend Hashtable<String, String>, but it's declared to\n* extend Hashtable<Object, Object>.\n*/\nif (context == Properties.class) {\nreturn new Type[] { String.class, String.class }; // TODO: test subclasses of Properties!\n}\n\nType mapType = getSupertype(context, contextRawType, Map.class);\n// TODO: strip wildcards?\nif (mapType instanceof ParameterizedType) {\nParameterizedType mapParameterizedType = (ParameterizedType) mapType;\nreturn mapParameterizedType.getActualTypeArguments();\n}\nreturn new Type[] { Object.class, Object.class };\n}",
            "method_id": 42
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/reflect/Type;)Lcom/google/gson/reflect/TypeToken;",
            "method_body": "public static TypeToken<?> get(Type type) {\nreturn new TypeToken<Object>(type);\n}",
            "method_id": 43
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:getType()Ljava/lang/reflect/Type;",
            "method_body": "public final Type getType() {\nreturn type;\n}",
            "method_id": 44
        },
        {
            "method_signature": "com.google.gson.internal.ConstructorConstructor$8:construct()Ljava/lang/Object;",
            "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayDeque<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}",
            "method_id": 45
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types$WildcardTypeImpl:<init>([Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
            "method_body": "public WildcardTypeImpl(Type[] upperBounds, Type[] lowerBounds) {\ncheckArgument(lowerBounds.length <= 1);\ncheckArgument(upperBounds.length == 1);\n\nif (lowerBounds.length == 1) {\ncheckNotNull(lowerBounds[0]);\ncheckNotPrimitive(lowerBounds[0]);\ncheckArgument(upperBounds[0] == Object.class);\nthis.lowerBound = canonicalize(lowerBounds[0]);\nthis.upperBound = Object.class;\n\n} else {\ncheckNotNull(upperBounds[0]);\ncheckNotPrimitive(upperBounds[0]);\nthis.lowerBound = null;\nthis.upperBound = canonicalize(upperBounds[0]);\n}\n}",
            "method_id": 46
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:excludeClass(Ljava/lang/Class;Z)Z",
            "method_body": "public boolean excludeClass(Class<?> clazz, boolean serialize) {\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(clazz.getAnnotation(Since.class), clazz.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (!serializeInnerClasses && isInnerClass(clazz)) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(clazz)) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipClass(clazz)) {\nreturn true;\n}\n}\n\nreturn false;\n}",
            "method_id": 47
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:<clinit>()V",
            "method_body": "static final Type[] EMPTY_TYPE_ARRAY = new Type[] {};\nstatic final Type[] EMPTY_TYPE_ARRAY = new Type[] {};",
            "method_id": 48
        },
        {
            "method_signature": "com.google.gson.internal.LinkedTreeMap:findByObject(Ljava/lang/Object;)Lcom/google/gson/internal/LinkedTreeMap$Node;",
            "method_body": "Node<K, V> findByObject(Object key) {\ntry {\nreturn key != null ? find((K) key, false) : null;\n} catch (ClassCastException e) {\nreturn null;\n}\n}",
            "method_id": 49
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:resolve(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
            "method_body": "public static Type resolve(Type context, Class<?> contextRawType, Type toResolve) {\nreturn resolve(context, contextRawType, toResolve, new HashSet<TypeVariable>());\n}",
            "method_id": 50
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:<init>(Lcom/google/gson/Gson;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;)V",
            "method_body": "TypeAdapterRuntimeTypeWrapper(Gson context, TypeAdapter<T> delegate, Type type) {\nthis.context = context;\nthis.delegate = delegate;\nthis.type = type;\n}",
            "method_id": 51
        },
        {
            "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;)V",
            "method_body": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor) {\nthis.constructorConstructor = constructorConstructor;\n}",
            "method_id": 52
        },
        {
            "method_signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> targetType) {\nClass<? super T> rawType = targetType.getRawType();\nJsonAdapter annotation = rawType.getAnnotation(JsonAdapter.class);\nif (annotation == null) {\nreturn null;\n}\nreturn (TypeAdapter<T>) getTypeAdapter(constructorConstructor, gson, targetType, annotation);\n}",
            "method_id": 53
        },
        {
            "method_signature": "com.google.gson.internal.ConstructorConstructor$13:construct()Ljava/lang/Object;",
            "method_body": "private <T> ObjectConstructor<T> newDefaultImplementationConstructor(\nfinal Type type, Class<? super T> rawType) {\nif (Collection.class.isAssignableFrom(rawType)) {\nif (SortedSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeSet<Object>();\n}\n};\n} else if (EnumSet.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"rawtypes\")\n@Override public T construct() {\nif (type instanceof ParameterizedType) {\nType elementType = ((ParameterizedType) type).getActualTypeArguments()[0];\nif (elementType instanceof Class) {\nreturn (T) EnumSet.noneOf((Class)elementType);\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n} else {\nthrow new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n}\n}\n};\n} else if (Set.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashSet<Object>();\n}\n};\n} else if (Queue.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayDeque<Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ArrayList<Object>();\n}\n};\n}\n}\n\nif (Map.class.isAssignableFrom(rawType)) {\nif (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentSkipListMap<Object, Object>();\n}\n};\n} else if (ConcurrentMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new ConcurrentHashMap<Object, Object>();\n}\n};\n} else if (SortedMap.class.isAssignableFrom(rawType)) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new TreeMap<Object, Object>();\n}\n};\n} else if (type instanceof ParameterizedType && !(String.class.isAssignableFrom(\nTypeToken.get(((ParameterizedType) type).getActualTypeArguments()[0]).getRawType()))) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedHashMap<Object, Object>();\n}\n};\n} else {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn (T) new LinkedTreeMap<String, Object>();\n}\n};\n}\n}\n\nreturn null;\n}",
            "method_id": 54
        },
        {
            "method_signature": "com.google.gson.internal.UnsafeAllocator:create()Lcom/google/gson/internal/UnsafeAllocator;",
            "method_body": "public abstract <T> T newInstance(Class<T> c) throws Exception;\n\npublic static UnsafeAllocator create() {\n// try JVM\n// public class Unsafe {\n//   public Object allocateInstance(Class<?> type);\n// }\ntry {\nClass<?> unsafeClass = Class.forName(\"sun.misc.Unsafe\");\nField f = unsafeClass.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nfinal Object unsafe = f.get(null);\nfinal Method allocateInstance = unsafeClass.getMethod(\"allocateInstance\", Class.class);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) allocateInstance.invoke(unsafe, c);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, post-gingerbread\n// public class ObjectStreamClass {\n//   private static native int getConstructorId(Class<?> c);\n//   private static native Object newInstance(Class<?> instantiationClass, int methodId);\n// }\ntry {\nMethod getConstructorId = ObjectStreamClass.class\n.getDeclaredMethod(\"getConstructorId\", Class.class);\ngetConstructorId.setAccessible(true);\nfinal int constructorId = (Integer) getConstructorId.invoke(null, Object.class);\nfinal Method newInstance = ObjectStreamClass.class\n.getDeclaredMethod(\"newInstance\", Class.class, int.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, constructorId);\n}\n};\n} catch (Exception ignored) {\n}\n\n// try dalvikvm, pre-gingerbread\n// public class ObjectInputStream {\n//   private static native Object newInstance(\n//     Class<?> instantiationClass, Class<?> constructorClass);\n// }\ntry {\nfinal Method newInstance = ObjectInputStream.class\n.getDeclaredMethod(\"newInstance\", Class.class, Class.class);\nnewInstance.setAccessible(true);\nreturn new UnsafeAllocator() {\n@Override\n@SuppressWarnings(\"unchecked\")\npublic <T> T newInstance(Class<T> c) throws Exception {\nassertInstantiable(c);\nreturn (T) newInstance.invoke(null, c, Object.class);\n}\n};\n} catch (Exception ignored) {\n}\n\n// give up\nreturn new UnsafeAllocator() {\n@Override\npublic <T> T newInstance(Class<T> c) {\nthrow new UnsupportedOperationException(\"Cannot allocate \" + c);\n}\n};\n}",
            "method_id": 55
        },
        {
            "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;",
            "method_body": "public <T> T fromJson(String json, Class<T> classOfT) throws JsonSyntaxException {\nObject object = fromJson(json, (Type) classOfT);\nreturn Primitives.wrap(classOfT).cast(object);\n}",
            "method_id": 56
        },
        {
            "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Z)V",
            "method_body": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nboolean complexMapKeySerialization) {\nthis.constructorConstructor = constructorConstructor;\nthis.complexMapKeySerialization = complexMapKeySerialization;\n}",
            "method_id": 57
        },
        {
            "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Collection.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nType elementType = $Gson$Types.getCollectionElementType(type, rawType);\nTypeAdapter<?> elementTypeAdapter = gson.getAdapter(TypeToken.get(elementType));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // create() doesn't define a type parameter\nTypeAdapter<T> result = new Adapter(gson, elementType, elementTypeAdapter, constructor);\nreturn result;\n}",
            "method_id": 58
        },
        {
            "method_signature": "com.google.gson.internal.bind.ArrayTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\nif (!(type instanceof GenericArrayType || type instanceof Class && ((Class<?>) type).isArray())) {\nreturn null;\n}\n\nType componentType = $Gson$Types.getArrayComponentType(type);\nTypeAdapter<?> componentTypeAdapter = gson.getAdapter(TypeToken.get(componentType));\nreturn new ArrayTypeAdapter(\ngson, componentTypeAdapter, $Gson$Types.getRawType(componentType));\n}",
            "method_id": 59
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
            "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> type, final TypeAdapter<TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == type ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + type.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 60
        },
        {
            "method_signature": "com.google.gson.Gson:atomicLongAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
            "method_body": "private static TypeAdapter<AtomicLong> atomicLongAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLong>() {\n@Override public void write(JsonWriter out, AtomicLong value) throws IOException {\nlongAdapter.write(out, value.get());\n}\n@Override public AtomicLong read(JsonReader in) throws IOException {\nNumber value = longAdapter.read(in);\nreturn new AtomicLong(value.longValue());\n}\n}.nullSafe();\n}",
            "method_id": 61
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:getGenericSupertype(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/Class;)Ljava/lang/reflect/Type;",
            "method_body": "static Type getGenericSupertype(Type context, Class<?> rawType, Class<?> toResolve) {\nif (toResolve == rawType) {\nreturn context;\n}\n\n// we skip searching through interfaces if unknown is an interface\nif (toResolve.isInterface()) {\nClass<?>[] interfaces = rawType.getInterfaces();\nfor (int i = 0, length = interfaces.length; i < length; i++) {\nif (interfaces[i] == toResolve) {\nreturn rawType.getGenericInterfaces()[i];\n} else if (toResolve.isAssignableFrom(interfaces[i])) {\nreturn getGenericSupertype(rawType.getGenericInterfaces()[i], interfaces[i], toResolve);\n}\n}\n}\n\n// check our supertypes\nif (!rawType.isInterface()) {\nwhile (rawType != Object.class) {\nClass<?> rawSupertype = rawType.getSuperclass();\nif (rawSupertype == toResolve) {\nreturn rawType.getGenericSuperclass();\n} else if (toResolve.isAssignableFrom(rawSupertype)) {\nreturn getGenericSupertype(rawType.getGenericSuperclass(), rawSupertype, toResolve);\n}\nrawType = rawSupertype;\n}\n}\n\n// we can't resolve this further\nreturn toResolve;\n}",
            "method_id": 62
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:nextNonWhitespace(Z)I",
            "method_body": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n/*\n* This code uses ugly local variables 'p' and 'l' representing the 'pos'\n* and 'limit' fields respectively. Using locals rather than fields saves\n* a few field reads for each whitespace character in a pretty-printed\n* document, resulting in a 5% speedup. We need to flush 'p' to its field\n* before any (potentially indirect) call to fillBuffer() and reread both\n* 'p' and 'l' after any (potentially indirect) call to the same method.\n*/\nchar[] buffer = this.buffer;\nint p = pos;\nint l = limit;\nwhile (true) {\nif (p == l) {\npos = p;\nif (!fillBuffer(1)) {\nbreak;\n}\np = pos;\nl = limit;\n}\n\nint c = buffer[p++];\nif (c == '\\n') {\nlineNumber++;\nlineStart = p;\ncontinue;\n} else if (c == ' ' || c == '\\r' || c == '\\t') {\ncontinue;\n}\n\nif (c == '/') {\npos = p;\nif (p == l) {\npos--; // push back '/' so it's still in the buffer when this method returns\nboolean charsLoaded = fillBuffer(2);\npos++; // consume the '/' again\nif (!charsLoaded) {\nreturn c;\n}\n}\n\ncheckLenient();\nchar peek = buffer[pos];\nswitch (peek) {\ncase '*':\n// skip a /* c-style comment */\npos++;\nif (!skipTo(\"*/\")) {\nthrow syntaxError(\"Unterminated comment\");\n}\np = pos + 2;\nl = limit;\ncontinue;\n\ncase '/':\n// skip a // end-of-line comment\npos++;\nskipToEndOfLine();\np = pos;\nl = limit;\ncontinue;\n\ndefault:\nreturn c;\n}\n} else if (c == '#') {\npos = p;\n/*\n* Skip a # hash end-of-line comment. The JSON RFC doesn't\n* specify this behaviour, but it's required to parse\n* existing documents. See http://b/2571423.\n*/\ncheckLenient();\nskipToEndOfLine();\np = pos;\nl = limit;\n} else {\npos = p;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\" + locationString());\n} else {\nreturn -1;\n}\n}",
            "method_id": 63
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactoryForMultipleTypes(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
            "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 64
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$26:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nif (typeToken.getRawType() != Timestamp.class) {\nreturn null;\n}\n\nfinal TypeAdapter<Date> dateTypeAdapter = gson.getAdapter(Date.class);\nreturn (TypeAdapter<T>) new TypeAdapter<Timestamp>() {\n@Override public Timestamp read(JsonReader in) throws IOException {\nDate date = dateTypeAdapter.read(in);\nreturn date != null ? new Timestamp(date.getTime()) : null;\n}\n\n@Override public void write(JsonWriter out, Timestamp value) throws IOException {\ndateTypeAdapter.write(out, value);\n}\n};\n}",
            "method_id": 65
        },
        {
            "method_signature": "com.google.gson.internal.LinkedTreeMap:put(Ljava/lang/Object;Ljava/lang/Object;)Ljava/lang/Object;",
            "method_body": "@Override public V put(K key, V value) {\nif (key == null) {\nthrow new NullPointerException(\"key == null\");\n}\nNode<K, V> created = find(key, true);\nV result = created.value;\ncreated.value = value;\nreturn result;\n}",
            "method_id": 66
        },
        {
            "method_signature": "com.google.gson.Gson:getAdapter(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public <T> TypeAdapter<T> getAdapter(TypeToken<T> type) {\nTypeAdapter<?> cached = typeTokenCache.get(type == null ? NULL_KEY_SURROGATE : type);\nif (cached != null) {\nreturn (TypeAdapter<T>) cached;\n}\n\nMap<TypeToken<?>, FutureTypeAdapter<?>> threadCalls = calls.get();\nboolean requiresThreadLocalCleanup = false;\nif (threadCalls == null) {\nthreadCalls = new HashMap<TypeToken<?>, FutureTypeAdapter<?>>();\ncalls.set(threadCalls);\nrequiresThreadLocalCleanup = true;\n}\n\n// the key and value type parameters always agree\nFutureTypeAdapter<T> ongoingCall = (FutureTypeAdapter<T>) threadCalls.get(type);\nif (ongoingCall != null) {\nreturn ongoingCall;\n}\n\ntry {\nFutureTypeAdapter<T> call = new FutureTypeAdapter<T>();\nthreadCalls.put(type, call);\n\nfor (TypeAdapterFactory factory : factories) {\nTypeAdapter<T> candidate = factory.create(this, type);\nif (candidate != null) {\ncall.setDelegate(candidate);\ntypeTokenCache.put(type, candidate);\nreturn candidate;\n}\n}\nthrow new IllegalArgumentException(\"GSON cannot handle \" + type);\n} finally {\nthreadCalls.remove(type);\n\nif (requiresThreadLocalCleanup) {\ncalls.remove();\n}\n}\n}",
            "method_id": 67
        },
        {
            "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
            "method_body": "public Adapter(Gson context, Type elementType,\nTypeAdapter<E> elementTypeAdapter,\nObjectConstructor<? extends Collection<E>> constructor) {\nthis.elementTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<E>(context, elementTypeAdapter, elementType);\nthis.constructor = constructor;\n}",
            "method_id": 68
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:<init>(Ljava/io/Reader;)V",
            "method_body": "public JsonReader(Reader in) {\nif (in == null) {\nthrow new NullPointerException(\"in == null\");\n}\nthis.in = in;\n}",
            "method_id": 69
        },
        {
            "method_signature": "com.google.gson.TypeAdapter:nullSafe()Lcom/google/gson/TypeAdapter;",
            "method_body": "public final TypeAdapter<T> nullSafe() {\nreturn new TypeAdapter<T>() {\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\n} else {\nTypeAdapter.this.write(out, value);\n}\n}\n@Override public T read(JsonReader reader) throws IOException {\nif (reader.peek() == JsonToken.NULL) {\nreader.nextNull();\nreturn null;\n}\nreturn TypeAdapter.this.read(reader);\n}\n};\n}",
            "method_id": 70
        },
        {
            "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>()V",
            "method_body": "Node() {\nkey = null;\nnext = prev = this;\n}",
            "method_id": 71
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:getBoundFields(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;Ljava/lang/Class;)Ljava/util/Map;",
            "method_body": "private Map<String, BoundField> getBoundFields(Gson context, TypeToken<?> type, Class<?> raw) {\nMap<String, BoundField> result = new LinkedHashMap<String, BoundField>();\nif (raw.isInterface()) {\nreturn result;\n}\n\nType declaredType = type.getType();\nwhile (raw != Object.class) {\nField[] fields = raw.getDeclaredFields();\nfor (Field field : fields) {\nboolean serialize = excludeField(field, true);\nboolean deserialize = excludeField(field, false);\nif (!serialize && !deserialize) {\ncontinue;\n}\nfield.setAccessible(true);\nType fieldType = $Gson$Types.resolve(type.getType(), raw, field.getGenericType());\nList<String> fieldNames = getFieldNames(field);\nBoundField previous = null;\nfor (int i = 0, size = fieldNames.size(); i < size; ++i) {\nString name = fieldNames.get(i);\nif (i != 0) serialize = false; // only serialize the default name\nBoundField boundField = createBoundField(context, field, name,\nTypeToken.get(fieldType), serialize, deserialize);\nBoundField replaced = result.put(name, boundField);\nif (previous == null) previous = replaced;\n}\nif (previous != null) {\nthrow new IllegalArgumentException(declaredType\n+ \" declares multiple JSON fields named \" + previous.name);\n}\n}\ntype = TypeToken.get($Gson$Types.resolve(type.getType(), raw, raw.getGenericSuperclass()));\nraw = type.getRawType();\n}\nreturn result;\n}",
            "method_id": 72
        },
        {
            "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<init>(Lcom/google/gson/Gson;)V",
            "method_body": "ObjectTypeAdapter(Gson gson) {\nthis.gson = gson;\n}",
            "method_id": 73
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types$ParameterizedTypeImpl:<init>(Ljava/lang/reflect/Type;Ljava/lang/reflect/Type;[Ljava/lang/reflect/Type;)V",
            "method_body": "public ParameterizedTypeImpl(Type ownerType, Type rawType, Type... typeArguments) {\n// require an owner type if the raw type needs it\nif (rawType instanceof Class<?>) {\nClass<?> rawTypeAsClass = (Class<?>) rawType;\nboolean isStaticOrTopLevelClass = Modifier.isStatic(rawTypeAsClass.getModifiers())\n|| rawTypeAsClass.getEnclosingClass() == null;\ncheckArgument(ownerType != null || isStaticOrTopLevelClass);\n}\n\nthis.ownerType = ownerType == null ? null : canonicalize(ownerType);\nthis.rawType = canonicalize(rawType);\nthis.typeArguments = typeArguments.clone();\nfor (int t = 0, length = this.typeArguments.length; t < length; t++) {\ncheckNotNull(this.typeArguments[t]);\ncheckNotPrimitive(this.typeArguments[t]);\nthis.typeArguments[t] = canonicalize(this.typeArguments[t]);\n}\n}",
            "method_id": 74
        },
        {
            "method_signature": "com.google.gson.internal.LinkedTreeMap:<init>()V",
            "method_body": "public LinkedTreeMap() {\nthis((Comparator<? super K>) NATURAL_ORDER);\n}",
            "method_id": 75
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:nextQuotedValue(C)Ljava/lang/String;",
            "method_body": "private String nextQuotedValue(char quote) throws IOException {\n// Like nextNonWhitespace, this uses locals 'p' and 'l' to save inner-loop field access.\nchar[] buffer = this.buffer;\nStringBuilder builder = null;\nwhile (true) {\nint p = pos;\nint l = limit;\n/* the index of the first character not yet appended to the builder. */\nint start = p;\nwhile (p < l) {\nint c = buffer[p++];\n\nif (c == quote) {\npos = p;\nint len = p - start - 1;\nif (builder == null) {\nreturn new String(buffer, start, len);\n} else {\nbuilder.append(buffer, start, len);\nreturn builder.toString();\n}\n} else if (c == '\\\\') {\npos = p;\nint len = p - start - 1;\nif (builder == null) {\nint estimatedLength = (len + 1) * 2;\nbuilder = new StringBuilder(Math.max(estimatedLength, 16));\n}\nbuilder.append(buffer, start, len);\nbuilder.append(readEscapeCharacter());\np = pos;\nl = limit;\nstart = p;\n} else if (c == '\\n') {\nlineNumber++;\nlineStart = p;\n}\n}\n\nif (builder == null) {\nint estimatedLength = (p - start) * 2;\nbuilder = new StringBuilder(Math.max(estimatedLength, 16));\n}\nbuilder.append(buffer, start, p - start);\npos = p;\nif (!fillBuffer(1)) {\nthrow syntaxError(\"Unterminated string\");\n}\n}\n}",
            "method_id": 76
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1:read(Lcom/google/gson/stream/JsonReader;Ljava/lang/Object;)V",
            "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = jsonAdapterFactory.getTypeAdapter(\nconstructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t = jsonAdapterPresent ? typeAdapter\n: new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}",
            "method_id": 77
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$30:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nif (!Enum.class.isAssignableFrom(rawType) || rawType == Enum.class) {\nreturn null;\n}\nif (!rawType.isEnum()) {\nrawType = rawType.getSuperclass(); // handle anonymous subclasses\n}\nreturn (TypeAdapter<T>) new EnumTypeAdapter(rawType);\n}",
            "method_id": 78
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:peek()Lcom/google/gson/stream/JsonToken;",
            "method_body": "public JsonToken peek() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\n\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:\nreturn JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:\nreturn JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:\nreturn JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:\nreturn JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:\ncase PEEKED_DOUBLE_QUOTED_NAME:\ncase PEEKED_UNQUOTED_NAME:\nreturn JsonToken.NAME;\ncase PEEKED_TRUE:\ncase PEEKED_FALSE:\nreturn JsonToken.BOOLEAN;\ncase PEEKED_NULL:\nreturn JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:\ncase PEEKED_DOUBLE_QUOTED:\ncase PEEKED_UNQUOTED:\ncase PEEKED_BUFFERED:\nreturn JsonToken.STRING;\ncase PEEKED_LONG:\ncase PEEKED_NUMBER:\nreturn JsonToken.NUMBER;\ncase PEEKED_EOF:\nreturn JsonToken.END_DOCUMENT;\ndefault:\nthrow new AssertionError();\n}\n}",
            "method_id": 79
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:push(I)V",
            "method_body": "private void push(int newTop) {\nif (stackSize == stack.length) {\nint[] newStack = new int[stackSize * 2];\nint[] newPathIndices = new int[stackSize * 2];\nString[] newPathNames = new String[stackSize * 2];\nSystem.arraycopy(stack, 0, newStack, 0, stackSize);\nSystem.arraycopy(pathIndices, 0, newPathIndices, 0, stackSize);\nSystem.arraycopy(pathNames, 0, newPathNames, 0, stackSize);\nstack = newStack;\npathIndices = newPathIndices;\npathNames = newPathNames;\n}\nstack[stackSize++] = newTop;\n}",
            "method_id": 80
        },
        {
            "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nType type = typeToken.getType();\n\nClass<? super T> rawType = typeToken.getRawType();\nif (!Map.class.isAssignableFrom(rawType)) {\nreturn null;\n}\n\nClass<?> rawTypeOfSrc = $Gson$Types.getRawType(type);\nType[] keyAndValueTypes = $Gson$Types.getMapKeyAndValueTypes(type, rawTypeOfSrc);\nTypeAdapter<?> keyAdapter = getKeyAdapter(gson, keyAndValueTypes[0]);\nTypeAdapter<?> valueAdapter = gson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\nObjectConstructor<T> constructor = constructorConstructor.get(typeToken);\n\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\n// we don't define a type parameter for the key or value types\nTypeAdapter<T> result = new Adapter(gson, keyAndValueTypes[0], keyAdapter,\nkeyAndValueTypes[1], valueAdapter, constructor);\nreturn result;\n}",
            "method_id": 81
        },
        {
            "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}",
            "method_id": 82
        },
        {
            "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/bind/MapTypeAdapterFactory;Lcom/google/gson/Gson;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Ljava/lang/reflect/Type;Lcom/google/gson/TypeAdapter;Lcom/google/gson/internal/ObjectConstructor;)V",
            "method_body": "public Adapter(Gson context, Type keyType, TypeAdapter<K> keyTypeAdapter,\nType valueType, TypeAdapter<V> valueTypeAdapter,\nObjectConstructor<? extends Map<K, V>> constructor) {\nthis.keyTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<K>(context, keyTypeAdapter, keyType);\nthis.valueTypeAdapter =\nnew TypeAdapterRuntimeTypeWrapper<V>(context, valueTypeAdapter, valueType);\nthis.constructor = constructor;\n}",
            "method_id": 83
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:<init>(Lcom/google/gson/internal/ConstructorConstructor;Lcom/google/gson/FieldNamingStrategy;Lcom/google/gson/internal/Excluder;Lcom/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory;)V",
            "method_body": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,\nFieldNamingStrategy fieldNamingPolicy, Excluder excluder,\nJsonAdapterAnnotationTypeAdapterFactory jsonAdapterFactory) {\nthis.constructorConstructor = constructorConstructor;\nthis.fieldNamingPolicy = fieldNamingPolicy;\nthis.excluder = excluder;\nthis.jsonAdapterFactory = jsonAdapterFactory;\n}",
            "method_id": 84
        },
        {
            "method_signature": "com.google.gson.internal.bind.DateTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}",
            "method_id": 85
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters:newFactory(Ljava/lang/Class;Ljava/lang/Class;Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapterFactory;",
            "method_body": "public static <TT> TypeAdapterFactory newFactory(\nfinal Class<TT> unboxed, final Class<TT> boxed, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == unboxed || rawType == boxed) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + boxed.getName()\n+ \"+\" + unboxed.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 86
        },
        {
            "method_signature": "com.google.gson.Gson:assertFullConsumption(Ljava/lang/Object;Lcom/google/gson/stream/JsonReader;)V",
            "method_body": "private static void assertFullConsumption(Object obj, JsonReader reader) {\ntry {\nif (obj != null && reader.peek() != JsonToken.END_DOCUMENT) {\nthrow new JsonIOException(\"JSON document was not fully consumed.\");\n}\n} catch (MalformedJsonException e) {\nthrow new JsonSyntaxException(e);\n} catch (IOException e) {\nthrow new JsonIOException(e);\n}\n}",
            "method_id": 87
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkNotNull(Ljava/lang/Object;)Ljava/lang/Object;",
            "method_body": "public static <T> T checkNotNull(T obj) {\nif (obj == null) {\nthrow new NullPointerException();\n}\nreturn obj;\n}",
            "method_id": 88
        },
        {
            "method_signature": "com.google.gson.internal.bind.MapTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Map;",
            "method_body": "@Override public Map<K, V> read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nMap<K, V> map = constructor.construct();\n\nif (peek == JsonToken.BEGIN_ARRAY) {\nin.beginArray();\nwhile (in.hasNext()) {\nin.beginArray(); // entry array\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\nin.endArray();\n}\nin.endArray();\n} else {\nin.beginObject();\nwhile (in.hasNext()) {\nJsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\nK key = keyTypeAdapter.read(in);\nV value = valueTypeAdapter.read(in);\nV replaced = map.put(key, value);\nif (replaced != null) {\nthrow new JsonSyntaxException(\"duplicate key: \" + key);\n}\n}\nin.endObject();\n}\nreturn map;\n}",
            "method_id": 89
        },
        {
            "method_signature": "com.google.gson.Gson:<init>()V",
            "method_body": "public Gson() {\nthis(Excluder.DEFAULT, FieldNamingPolicy.IDENTITY,\nCollections.<Type, InstanceCreator<?>>emptyMap(), DEFAULT_SERIALIZE_NULLS,\nDEFAULT_COMPLEX_MAP_KEYS, DEFAULT_JSON_NON_EXECUTABLE, DEFAULT_ESCAPE_HTML,\nDEFAULT_PRETTY_PRINT, DEFAULT_LENIENT, DEFAULT_SPECIALIZE_FLOAT_VALUES,\nLongSerializationPolicy.DEFAULT, null, DateFormat.DEFAULT, DateFormat.DEFAULT,\nCollections.<TypeAdapterFactory>emptyList(), Collections.<TypeAdapterFactory>emptyList(),\nCollections.<TypeAdapterFactory>emptyList());\n}",
            "method_id": 90
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:endArray()V",
            "method_body": "public void endArray() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_END_ARRAY) {\nstackSize--;\npathIndices[stackSize - 1]++;\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + locationString());\n}\n}",
            "method_id": 91
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:hashCodeOrZero(Ljava/lang/Object;)I",
            "method_body": "static int hashCodeOrZero(Object o) {\nreturn o != null ? o.hashCode() : 0;\n}",
            "method_id": 92
        },
        {
            "method_signature": "com.google.gson.Gson:atomicLongArrayAdapter(Lcom/google/gson/TypeAdapter;)Lcom/google/gson/TypeAdapter;",
            "method_body": "private static TypeAdapter<AtomicLongArray> atomicLongArrayAdapter(final TypeAdapter<Number> longAdapter) {\nreturn new TypeAdapter<AtomicLongArray>() {\n@Override public void write(JsonWriter out, AtomicLongArray value) throws IOException {\nout.beginArray();\nfor (int i = 0, length = value.length(); i < length; i++) {\nlongAdapter.write(out, value.get(i));\n}\nout.endArray();\n}\n@Override public AtomicLongArray read(JsonReader in) throws IOException {\nList<Long> list = new ArrayList<Long>();\nin.beginArray();\nwhile (in.hasNext()) {\nlong value = longAdapter.read(in).longValue();\nlist.add(value);\n}\nin.endArray();\nint length = list.size();\nAtomicLongArray array = new AtomicLongArray(length);\nfor (int i = 0; i < length; ++i) {\narray.set(i, list.get(i));\n}\nreturn array;\n}\n}.nullSafe();\n}",
            "method_id": 93
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:hasNext()Z",
            "method_body": "public boolean hasNext() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nreturn p != PEEKED_END_OBJECT && p != PEEKED_END_ARRAY;\n}",
            "method_id": 94
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:createBoundField(Lcom/google/gson/Gson;Ljava/lang/reflect/Field;Ljava/lang/String;Lcom/google/gson/reflect/TypeToken;ZZ)Lcom/google/gson/internal/bind/ReflectiveTypeAdapterFactory$BoundField;",
            "method_body": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(\nfinal Gson context, final Field field, final String name,\nfinal TypeToken<?> fieldType, boolean serialize, boolean deserialize) {\nfinal boolean isPrimitive = Primitives.isPrimitive(fieldType.getRawType());\n// special casing primitives here saves ~5% on Android...\nJsonAdapter annotation = field.getAnnotation(JsonAdapter.class);\nTypeAdapter<?> mapped = null;\nif (annotation != null) {\nmapped = jsonAdapterFactory.getTypeAdapter(\nconstructorConstructor, context, fieldType, annotation);\n}\nfinal boolean jsonAdapterPresent = mapped != null;\nif (mapped == null) mapped = context.getAdapter(fieldType);\n\nfinal TypeAdapter<?> typeAdapter = mapped;\nreturn new ReflectiveTypeAdapterFactory.BoundField(name, serialize, deserialize) {\n@SuppressWarnings({\"unchecked\", \"rawtypes\"}) // the type adapter and field type always agree\n@Override void write(JsonWriter writer, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = field.get(value);\nTypeAdapter t = jsonAdapterPresent ? typeAdapter\n: new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\nt.write(writer, fieldValue);\n}\n@Override void read(JsonReader reader, Object value)\nthrows IOException, IllegalAccessException {\nObject fieldValue = typeAdapter.read(reader);\nif (fieldValue != null || !isPrimitive) {\nfield.set(value, fieldValue);\n}\n}\n@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\nif (!serialized) return false;\nObject fieldValue = field.get(value);\nreturn fieldValue != value; // avoid recursion for example for Throwable.cause\n}\n};\n}",
            "method_id": 95
        },
        {
            "method_signature": "com.google.gson.internal.Primitives:<clinit>()V",
            "method_body": "private static final Map<Class<?>, Class<?>> PRIMITIVE_TO_WRAPPER_TYPE;\n\n/** A map from wrapper types to their corresponding primitive types. */\nprivate static final Map<Class<?>, Class<?>> WRAPPER_TO_PRIMITIVE_TYPE;\n\n// Sad that we can't use a BiMap. :(\n\nstatic {\nMap<Class<?>, Class<?>> primToWrap = new HashMap<Class<?>, Class<?>>(16);\nMap<Class<?>, Class<?>> wrapToPrim = new HashMap<Class<?>, Class<?>>(16);\n\nadd(primToWrap, wrapToPrim, boolean.class, Boolean.class);\nadd(primToWrap, wrapToPrim, byte.class, Byte.class);\nadd(primToWrap, wrapToPrim, char.class, Character.class);\nadd(primToWrap, wrapToPrim, double.class, Double.class);\nadd(primToWrap, wrapToPrim, float.class, Float.class);\nadd(primToWrap, wrapToPrim, int.class, Integer.class);\nadd(primToWrap, wrapToPrim, long.class, Long.class);\nadd(primToWrap, wrapToPrim, short.class, Short.class);\nadd(primToWrap, wrapToPrim, void.class, Void.class);\n\nPRIMITIVE_TO_WRAPPER_TYPE = Collections.unmodifiableMap(primToWrap);\nWRAPPER_TO_PRIMITIVE_TYPE = Collections.unmodifiableMap(wrapToPrim);\n}",
            "method_id": 96
        },
        {
            "method_signature": "com.google.gson.internal.LinkedTreeMap$Node:<init>(Lcom/google/gson/internal/LinkedTreeMap$Node;Ljava/lang/Object;Lcom/google/gson/internal/LinkedTreeMap$Node;Lcom/google/gson/internal/LinkedTreeMap$Node;)V",
            "method_body": "Node(Node<K, V> parent, K key, Node<K, V> next, Node<K, V> prev) {\nthis.parent = parent;\nthis.key = key;\nthis.height = 1;\nthis.next = next;\nthis.prev = prev;\nprev.next = this;\nnext.prev = this;\n}",
            "method_id": 97
        },
        {
            "method_signature": "com.google.gson.internal.LinkedTreeMap:get(Ljava/lang/Object;)Ljava/lang/Object;",
            "method_body": "@Override public V get(Object key) {\nNode<K, V> node = findByObject(key);\nreturn node != null ? node.value : null;\n}",
            "method_id": 98
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:<init>(Ljava/lang/reflect/Type;)V",
            "method_body": "TypeToken(Type type) {\nthis.type = $Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\nthis.rawType = (Class<? super T>) $Gson$Types.getRawType(this.type);\nthis.hashCode = this.type.hashCode();\n}",
            "method_id": 99
        },
        {
            "method_signature": "com.google.gson.FieldNamingPolicy$1:translateName(Ljava/lang/reflect/Field;)Ljava/lang/String;",
            "method_body": "@Override public String translateName(Field f) {\nreturn f.getName();\n}",
            "method_id": 100
        },
        {
            "method_signature": "com.google.gson.internal.bind.SqlDateTypeAdapter:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == java.sql.Date.class\n? (TypeAdapter<T>) new SqlDateTypeAdapter() : null;\n}\n};",
            "method_id": 101
        },
        {
            "method_signature": "com.google.gson.Gson:<init>(Lcom/google/gson/internal/Excluder;Lcom/google/gson/FieldNamingStrategy;Ljava/util/Map;ZZZZZZZLcom/google/gson/LongSerializationPolicy;Ljava/lang/String;IILjava/util/List;Ljava/util/List;Ljava/util/List;)V",
            "method_body": "Gson(final Excluder excluder, final FieldNamingStrategy fieldNamingStrategy,\nfinal Map<Type, InstanceCreator<?>> instanceCreators, boolean serializeNulls,\nboolean complexMapKeySerialization, boolean generateNonExecutableGson, boolean htmlSafe,\nboolean prettyPrinting, boolean lenient, boolean serializeSpecialFloatingPointValues,\nLongSerializationPolicy longSerializationPolicy, String datePattern, int dateStyle,\nint timeStyle, List<TypeAdapterFactory> builderFactories,\nList<TypeAdapterFactory> builderHierarchyFactories,\nList<TypeAdapterFactory> factoriesToBeAdded) {\nthis.excluder = excluder;\nthis.fieldNamingStrategy = fieldNamingStrategy;\nthis.instanceCreators = instanceCreators;\nthis.constructorConstructor = new ConstructorConstructor(instanceCreators);\nthis.serializeNulls = serializeNulls;\nthis.complexMapKeySerialization = complexMapKeySerialization;\nthis.generateNonExecutableJson = generateNonExecutableGson;\nthis.htmlSafe = htmlSafe;\nthis.prettyPrinting = prettyPrinting;\nthis.lenient = lenient;\nthis.serializeSpecialFloatingPointValues = serializeSpecialFloatingPointValues;\nthis.longSerializationPolicy = longSerializationPolicy;\nthis.datePattern = datePattern;\nthis.dateStyle = dateStyle;\nthis.timeStyle = timeStyle;\nthis.builderFactories = builderFactories;\nthis.builderHierarchyFactories = builderHierarchyFactories;\n\nList<TypeAdapterFactory> factories = new ArrayList<TypeAdapterFactory>();\n\n// built-in type adapters that cannot be overridden\nfactories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\nfactories.add(ObjectTypeAdapter.FACTORY);\n\n// the excluder must precede all adapters that handle user-defined types\nfactories.add(excluder);\n\n// users' type adapters\nfactories.addAll(factoriesToBeAdded);\n\n// type adapters for basic platform types\nfactories.add(TypeAdapters.STRING_FACTORY);\nfactories.add(TypeAdapters.INTEGER_FACTORY);\nfactories.add(TypeAdapters.BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.BYTE_FACTORY);\nfactories.add(TypeAdapters.SHORT_FACTORY);\nTypeAdapter<Number> longAdapter = longAdapter(longSerializationPolicy);\nfactories.add(TypeAdapters.newFactory(long.class, Long.class, longAdapter));\nfactories.add(TypeAdapters.newFactory(double.class, Double.class,\ndoubleAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.newFactory(float.class, Float.class,\nfloatAdapter(serializeSpecialFloatingPointValues)));\nfactories.add(TypeAdapters.NUMBER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\nfactories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\nfactories.add(TypeAdapters.newFactory(AtomicLong.class, atomicLongAdapter(longAdapter)));\nfactories.add(TypeAdapters.newFactory(AtomicLongArray.class, atomicLongArrayAdapter(longAdapter)));\nfactories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\nfactories.add(TypeAdapters.CHARACTER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUILDER_FACTORY);\nfactories.add(TypeAdapters.STRING_BUFFER_FACTORY);\nfactories.add(TypeAdapters.newFactory(BigDecimal.class, TypeAdapters.BIG_DECIMAL));\nfactories.add(TypeAdapters.newFactory(BigInteger.class, TypeAdapters.BIG_INTEGER));\nfactories.add(TypeAdapters.URL_FACTORY);\nfactories.add(TypeAdapters.URI_FACTORY);\nfactories.add(TypeAdapters.UUID_FACTORY);\nfactories.add(TypeAdapters.CURRENCY_FACTORY);\nfactories.add(TypeAdapters.LOCALE_FACTORY);\nfactories.add(TypeAdapters.INET_ADDRESS_FACTORY);\nfactories.add(TypeAdapters.BIT_SET_FACTORY);\nfactories.add(DateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CALENDAR_FACTORY);\nfactories.add(TimeTypeAdapter.FACTORY);\nfactories.add(SqlDateTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.TIMESTAMP_FACTORY);\nfactories.add(ArrayTypeAdapter.FACTORY);\nfactories.add(TypeAdapters.CLASS_FACTORY);\n\n// type adapters for composite and user-defined types\nfactories.add(new CollectionTypeAdapterFactory(constructorConstructor));\nfactories.add(new MapTypeAdapterFactory(constructorConstructor, complexMapKeySerialization));\nthis.jsonAdapterFactory = new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor);\nfactories.add(jsonAdapterFactory);\nfactories.add(TypeAdapters.ENUM_FACTORY);\nfactories.add(new ReflectiveTypeAdapterFactory(\nconstructorConstructor, fieldNamingStrategy, excluder, jsonAdapterFactory));\n\nthis.factories = Collections.unmodifiableList(factories);\n}",
            "method_id": 102
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:excludeField(Ljava/lang/reflect/Field;Z)Z",
            "method_body": "public boolean excludeField(Field field, boolean serialize) {\nif ((modifiers & field.getModifiers()) != 0) {\nreturn true;\n}\n\nif (version != Excluder.IGNORE_VERSIONS\n&& !isValidVersion(field.getAnnotation(Since.class), field.getAnnotation(Until.class))) {\nreturn true;\n}\n\nif (field.isSynthetic()) {\nreturn true;\n}\n\nif (requireExpose) {\nExpose annotation = field.getAnnotation(Expose.class);\nif (annotation == null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\nreturn true;\n}\n}\n\nif (!serializeInnerClasses && isInnerClass(field.getType())) {\nreturn true;\n}\n\nif (isAnonymousOrLocal(field.getType())) {\nreturn true;\n}\n\nList<ExclusionStrategy> list = serialize ? serializationStrategies : deserializationStrategies;\nif (!list.isEmpty()) {\nFieldAttributes fieldAttributes = new FieldAttributes(field);\nfor (ExclusionStrategy exclusionStrategy : list) {\nif (exclusionStrategy.shouldSkipField(fieldAttributes)) {\nreturn true;\n}\n}\n}\n\nreturn false;\n}",
            "method_id": 103
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter:<init>(Lcom/google/gson/internal/ObjectConstructor;Ljava/util/Map;)V",
            "method_body": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException;\nabstract void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException;\nabstract void read(JsonReader reader, Object value) throws IOException, IllegalAccessException;\n}\n\npublic static final class Adapter<T> extends TypeAdapter<T> {\nprivate final ObjectConstructor<T> constructor;\nprivate final Map<String, BoundField> boundFields;\n\nAdapter(ObjectConstructor<T> constructor, Map<String, BoundField> boundFields) {\nthis.constructor = constructor;\nthis.boundFields = boundFields;\n}\n\n@Override public T read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nT instance = constructor.construct();\n\ntry {\nin.beginObject();\nwhile (in.hasNext()) {\nString name = in.nextName();\nBoundField field = boundFields.get(name);\nif (field == null || !field.deserialized) {\nin.skipValue();\n} else {\nfield.read(in, instance);\n}\n}\n} catch (IllegalStateException e) {\nthrow new JsonSyntaxException(e);\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nin.endObject();\nreturn instance;\n}\n\n@Override public void write(JsonWriter out, T value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\n\nout.beginObject();\ntry {\nfor (BoundField boundField : boundFields.values()) {\nif (boundField.writeField(value)) {\nout.name(boundField.name);\nboundField.write(out, value);\n}\n}\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\nout.endObject();\n}\n}",
            "method_id": 104
        },
        {
            "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$2:<clinit>()V",
            "method_body": "@Override public Object read(JsonReader in) throws IOException {\nJsonToken token = in.peek();\nswitch (token) {\ncase BEGIN_ARRAY:\nList<Object> list = new ArrayList<Object>();\nin.beginArray();\nwhile (in.hasNext()) {\nlist.add(read(in));\n}\nin.endArray();\nreturn list;\n\ncase BEGIN_OBJECT:\nMap<String, Object> map = new LinkedTreeMap<String, Object>();\nin.beginObject();\nwhile (in.hasNext()) {\nmap.put(in.nextName(), read(in));\n}\nin.endObject();\nreturn map;\n\ncase STRING:\nreturn in.nextString();\n\ncase NUMBER:\nreturn in.nextDouble();\n\ncase BOOLEAN:\nreturn in.nextBoolean();\n\ncase NULL:\nin.nextNull();\nreturn null;\n\ndefault:\nthrow new IllegalStateException();\n}\n}",
            "method_id": 105
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:isLenient()Z",
            "method_body": "public final boolean isLenient() {\nreturn lenient;\n}",
            "method_id": 106
        },
        {
            "method_signature": "com.google.gson.Gson:fromJson(Ljava/lang/String;Ljava/lang/reflect/Type;)Ljava/lang/Object;",
            "method_body": "public <T> T fromJson(String json, Type typeOfT) throws JsonSyntaxException {\nif (json == null) {\nreturn null;\n}\nStringReader reader = new StringReader(json);\nT target = (T) fromJson(reader, typeOfT);\nreturn target;\n}",
            "method_id": 107
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$35:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public static <T1> TypeAdapterFactory newTypeHierarchyFactory(\nfinal Class<T1> clazz, final TypeAdapter<T1> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T2> TypeAdapter<T2> create(Gson gson, TypeToken<T2> typeToken) {\nfinal Class<? super T2> requestedType = typeToken.getRawType();\nif (!clazz.isAssignableFrom(requestedType)) {\nreturn null;\n}\nreturn (TypeAdapter<T2>) new TypeAdapter<T1>() {\n@Override public void write(JsonWriter out, T1 value) throws IOException {\ntypeAdapter.write(out, value);\n}\n\n@Override public T1 read(JsonReader in) throws IOException {\nT1 result = typeAdapter.read(in);\nif (result != null && !requestedType.isInstance(result)) {\nthrow new JsonSyntaxException(\"Expected a \" + requestedType.getName()\n+ \" but was \" + result.getClass().getName());\n}\nreturn result;\n}\n};\n}\n@Override public String toString() {\nreturn \"Factory[typeHierarchy=\" + clazz.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 108
        },
        {
            "method_signature": "com.google.gson.internal.UnsafeAllocator:assertInstantiable(Ljava/lang/Class;)V",
            "method_body": "static void assertInstantiable(Class<?> c) {\nint modifiers = c.getModifiers();\nif (Modifier.isInterface(modifiers)) {\nthrow new UnsupportedOperationException(\"Interface can't be instantiated! Interface name: \" + c.getName());\n}\nif (Modifier.isAbstract(modifiers)) {\nthrow new UnsupportedOperationException(\"Abstract class can't be instantiated! Class name: \" + c.getName());\n}\n}",
            "method_id": 109
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$34:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "public static <TT> TypeAdapterFactory newFactoryForMultipleTypes(final Class<TT> base,\nfinal Class<? extends TT> sub, final TypeAdapter<? super TT> typeAdapter) {\nreturn new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nClass<? super T> rawType = typeToken.getRawType();\nreturn (rawType == base || rawType == sub) ? (TypeAdapter<T>) typeAdapter : null;\n}\n@Override public String toString() {\nreturn \"Factory[type=\" + base.getName()\n+ \"+\" + sub.getName() + \",adapter=\" + typeAdapter + \"]\";\n}\n};\n}",
            "method_id": 110
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:beginArray()V",
            "method_body": "public void beginArray() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nif (p == PEEKED_BEGIN_ARRAY) {\npush(JsonScope.EMPTY_ARRAY);\npathIndices[stackSize - 1] = 0;\npeeked = PEEKED_NONE;\n} else {\nthrow new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + locationString());\n}\n}",
            "method_id": 111
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader$1:promoteNameToValue(Lcom/google/gson/stream/JsonReader;)V",
            "method_body": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\nif (reader instanceof JsonTreeReader) {\n((JsonTreeReader)reader).promoteNameToValue();\nreturn;\n}\nint p = reader.peeked;\nif (p == PEEKED_NONE) {\np = reader.doPeek();\n}\nif (p == PEEKED_DOUBLE_QUOTED_NAME) {\nreader.peeked = PEEKED_DOUBLE_QUOTED;\n} else if (p == PEEKED_SINGLE_QUOTED_NAME) {\nreader.peeked = PEEKED_SINGLE_QUOTED;\n} else if (p == PEEKED_UNQUOTED_NAME) {\nreader.peeked = PEEKED_UNQUOTED;\n} else {\nthrow new IllegalStateException(\n\"Expected a name but was \" + reader.peek() + reader.locationString());\n}\n}",
            "method_id": 112
        },
        {
            "method_signature": "com.google.gson.internal.ConstructorConstructor:newDefaultConstructor(Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
            "method_body": "private <T> ObjectConstructor<T> newDefaultConstructor(Class<? super T> rawType) {\ntry {\nfinal Constructor<? super T> constructor = rawType.getDeclaredConstructor();\nif (!constructor.isAccessible()) {\nconstructor.setAccessible(true);\n}\nreturn new ObjectConstructor<T>() {\n@SuppressWarnings(\"unchecked\") // T is the same raw type as is requested\n@Override public T construct() {\ntry {\nObject[] args = null;\nreturn (T) constructor.newInstance(args);\n} catch (InstantiationException e) {\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\", e);\n} catch (InvocationTargetException e) {\n// TODO: don't wrap if cause is unchecked!\n// TODO: JsonParseException ?\nthrow new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",\ne.getTargetException());\n} catch (IllegalAccessException e) {\nthrow new AssertionError(e);\n}\n}\n};\n} catch (NoSuchMethodException e) {\nreturn null;\n}\n}",
            "method_id": 113
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:declaringClassOf(Ljava/lang/reflect/TypeVariable;)Ljava/lang/Class;",
            "method_body": "private static Class<?> declaringClassOf(TypeVariable<?> typeVariable) {\nGenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();\nreturn genericDeclaration instanceof Class\n? (Class<?>) genericDeclaration\n: null;\n}",
            "method_id": 114
        },
        {
            "method_signature": "com.google.gson.internal.LinkedTreeMap:find(Ljava/lang/Object;Z)Lcom/google/gson/internal/LinkedTreeMap$Node;",
            "method_body": "Node<K, V> find(K key, boolean create) {\nComparator<? super K> comparator = this.comparator;\nNode<K, V> nearest = root;\nint comparison = 0;\n\nif (nearest != null) {\n// Micro-optimization: avoid polymorphic calls to Comparator.compare().\n@SuppressWarnings(\"unchecked\") // Throws a ClassCastException below if there's trouble.\nComparable<Object> comparableKey = (comparator == NATURAL_ORDER)\n? (Comparable<Object>) key\n: null;\n\nwhile (true) {\ncomparison = (comparableKey != null)\n? comparableKey.compareTo(nearest.key)\n: comparator.compare(key, nearest.key);\n\n// We found the requested key.\nif (comparison == 0) {\nreturn nearest;\n}\n\n// If it exists, the key is in a subtree. Go deeper.\nNode<K, V> child = (comparison < 0) ? nearest.left : nearest.right;\nif (child == null) {\nbreak;\n}\n\nnearest = child;\n}\n}\n\n// The key doesn't exist in this tree.\nif (!create) {\nreturn null;\n}\n\n// Create the node and add it to the tree or the table.\nNode<K, V> header = this.header;\nNode<K, V> created;\nif (nearest == null) {\n// Check that the value is comparable if we didn't do any comparisons.\nif (comparator == NATURAL_ORDER && !(key instanceof Comparable)) {\nthrow new ClassCastException(key.getClass().getName() + \" is not Comparable\");\n}\ncreated = new Node<K, V>(nearest, key, header, header.prev);\nroot = created;\n} else {\ncreated = new Node<K, V>(nearest, key, header, header.prev);\nif (comparison < 0) { // nearest.key is higher\nnearest.left = created;\n} else { // comparison > 0, nearest.key is lower\nnearest.right = created;\n}\nrebalance(nearest, true);\n}\nsize++;\nmodCount++;\n\nreturn created;\n}",
            "method_id": 115
        },
        {
            "method_signature": "com.google.gson.internal.ConstructorConstructor:newUnsafeAllocator(Ljava/lang/reflect/Type;Ljava/lang/Class;)Lcom/google/gson/internal/ObjectConstructor;",
            "method_body": "private <T> ObjectConstructor<T> newUnsafeAllocator(\nfinal Type type, final Class<? super T> rawType) {\nreturn new ObjectConstructor<T>() {\nprivate final UnsafeAllocator unsafeAllocator = UnsafeAllocator.create();\n@SuppressWarnings(\"unchecked\")\n@Override public T construct() {\ntry {\nObject newInstance = unsafeAllocator.newInstance(rawType);\nreturn (T) newInstance;\n} catch (Exception e) {\nthrow new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"\n+ \"Registering an InstanceCreator with Gson for this type may fix this problem.\"), e);\n}\n}\n};\n}",
            "method_id": 116
        },
        {
            "method_signature": "com.google.gson.Gson:doubleAdapter(Z)Lcom/google/gson/TypeAdapter;",
            "method_body": "private TypeAdapter<Number> doubleAdapter(boolean serializeSpecialFloatingPointValues) {\nif (serializeSpecialFloatingPointValues) {\nreturn TypeAdapters.DOUBLE;\n}\nreturn new TypeAdapter<Number>() {\n@Override public Double read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\nreturn in.nextDouble();\n}\n@Override public void write(JsonWriter out, Number value) throws IOException {\nif (value == null) {\nout.nullValue();\nreturn;\n}\ndouble doubleValue = value.doubleValue();\ncheckValidFloatingPoint(doubleValue);\nout.value(value);\n}\n};\n}",
            "method_id": 117
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:nextString()Ljava/lang/String;",
            "method_body": "public String nextString() throws IOException {\nint p = peeked;\nif (p == PEEKED_NONE) {\np = doPeek();\n}\nString result;\nif (p == PEEKED_UNQUOTED) {\nresult = nextUnquotedValue();\n} else if (p == PEEKED_SINGLE_QUOTED) {\nresult = nextQuotedValue('\\'');\n} else if (p == PEEKED_DOUBLE_QUOTED) {\nresult = nextQuotedValue('\"');\n} else if (p == PEEKED_BUFFERED) {\nresult = peekedString;\npeekedString = null;\n} else if (p == PEEKED_LONG) {\nresult = Long.toString(peekedLong);\n} else if (p == PEEKED_NUMBER) {\nresult = new String(buffer, pos, peekedNumberLength);\npos += peekedNumberLength;\n} else {\nthrow new IllegalStateException(\"Expected a string but was \" + peek() + locationString());\n}\npeeked = PEEKED_NONE;\npathIndices[stackSize - 1]++;\nreturn result;\n}",
            "method_id": 118
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:<init>()V",
            "method_body": "private static final double IGNORE_VERSIONS = -1.0d;\npublic static final Excluder DEFAULT = new Excluder();\nprivate double version = IGNORE_VERSIONS;\nprivate int modifiers = Modifier.TRANSIENT | Modifier.STATIC;\nprivate boolean serializeInnerClasses = true;\nprivate List<ExclusionStrategy> serializationStrategies = Collections.emptyList();\nprivate List<ExclusionStrategy> deserializationStrategies = Collections.emptyList();\n}",
            "method_id": 119
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:canonicalize(Ljava/lang/reflect/Type;)Ljava/lang/reflect/Type;",
            "method_body": "public static Type canonicalize(Type type) {\nif (type instanceof Class) {\nClass<?> c = (Class<?>) type;\nreturn c.isArray() ? new GenericArrayTypeImpl(canonicalize(c.getComponentType())) : c;\n\n} else if (type instanceof ParameterizedType) {\nParameterizedType p = (ParameterizedType) type;\nreturn new ParameterizedTypeImpl(p.getOwnerType(),\np.getRawType(), p.getActualTypeArguments());\n\n} else if (type instanceof GenericArrayType) {\nGenericArrayType g = (GenericArrayType) type;\nreturn new GenericArrayTypeImpl(g.getGenericComponentType());\n\n} else if (type instanceof WildcardType) {\nWildcardType w = (WildcardType) type;\nreturn new WildcardTypeImpl(w.getUpperBounds(), w.getLowerBounds());\n\n} else {\n// type is either serializable as-is or unsupported\nreturn type;\n}\n}",
            "method_id": 120
        },
        {
            "method_signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory$Adapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/util/Collection;",
            "method_body": "@Override public Collection<E> read(JsonReader in) throws IOException {\nif (in.peek() == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n\nCollection<E> collection = constructor.construct();\nin.beginArray();\nwhile (in.hasNext()) {\nE instance = elementTypeAdapter.read(in);\ncollection.add(instance);\n}\nin.endArray();\nreturn collection;\n}",
            "method_id": 121
        },
        {
            "method_signature": "com.google.gson.internal.bind.DateTypeAdapter:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\") // we use a runtime check to make sure the 'T's equal\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> typeToken) {\nreturn typeToken.getRawType() == Date.class ? (TypeAdapter<T>) new DateTypeAdapter() : null;\n}\n};",
            "method_id": 122
        },
        {
            "method_signature": "com.google.gson.internal.ConstructorConstructor:get(Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/internal/ObjectConstructor;",
            "method_body": "public <T> ObjectConstructor<T> get(TypeToken<T> typeToken) {\nfinal Type type = typeToken.getType();\nfinal Class<? super T> rawType = typeToken.getRawType();\n\n// first try an instance creator\n\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> typeCreator = (InstanceCreator<T>) instanceCreators.get(type);\nif (typeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn typeCreator.createInstance(type);\n}\n};\n}\n\n// Next try raw type match for instance creators\n@SuppressWarnings(\"unchecked\") // types must agree\nfinal InstanceCreator<T> rawTypeCreator =\n(InstanceCreator<T>) instanceCreators.get(rawType);\nif (rawTypeCreator != null) {\nreturn new ObjectConstructor<T>() {\n@Override public T construct() {\nreturn rawTypeCreator.createInstance(type);\n}\n};\n}\n\nObjectConstructor<T> defaultConstructor = newDefaultConstructor(rawType);\nif (defaultConstructor != null) {\nreturn defaultConstructor;\n}\n\nObjectConstructor<T> defaultImplementation = newDefaultImplementationConstructor(type, rawType);\nif (defaultImplementation != null) {\nreturn defaultImplementation;\n}\n\n// finally try unsafe\nreturn newUnsafeAllocator(type, rawType);\n}",
            "method_id": 123
        },
        {
            "method_signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory:excludeField(Ljava/lang/reflect/Field;ZLcom/google/gson/internal/Excluder;)Z",
            "method_body": "static boolean excludeField(Field f, boolean serialize, Excluder excluder) {\nreturn !excluder.excludeClass(f.getType(), serialize) && !excluder.excludeField(f, serialize);\n}",
            "method_id": 124
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:fillBuffer(I)Z",
            "method_body": "private boolean fillBuffer(int minimum) throws IOException {\nchar[] buffer = this.buffer;\nlineStart -= pos;\nif (limit != pos) {\nlimit -= pos;\nSystem.arraycopy(buffer, pos, buffer, 0, limit);\n} else {\nlimit = 0;\n}\n\npos = 0;\nint total;\nwhile ((total = in.read(buffer, limit, buffer.length - limit)) != -1) {\nlimit += total;\n\n// if this is the first read, consume an optional byte order mark (BOM) if it exists\nif (lineNumber == 0 && lineStart == 0 && limit > 0 && buffer[0] == '\\ufeff') {\npos++;\nlineStart++;\nminimum++;\n}\n\nif (limit >= minimum) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 125
        },
        {
            "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:<clinit>()V",
            "method_body": "public static final TypeAdapterFactory FACTORY = new TypeAdapterFactory() {\n@SuppressWarnings(\"unchecked\")\n@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}\n};",
            "method_id": 126
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapters$17:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/String;",
            "method_body": "public String read(JsonReader in) throws IOException {\nJsonToken peek = in.peek();\nif (peek == JsonToken.NULL) {\nin.nextNull();\nreturn null;\n}\n/* coerce booleans to strings for backwards compatibility */\nif (peek == JsonToken.BOOLEAN) {\nreturn Boolean.toString(in.nextBoolean());\n}\nreturn in.nextString();\n}",
            "method_id": 127
        },
        {
            "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter$1:create(Lcom/google/gson/Gson;Lcom/google/gson/reflect/TypeToken;)Lcom/google/gson/TypeAdapter;",
            "method_body": "@Override public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {\nif (type.getRawType() == Object.class) {\nreturn (TypeAdapter<T>) new ObjectTypeAdapter(gson);\n}\nreturn null;\n}",
            "method_id": 128
        },
        {
            "method_signature": "com.google.gson.stream.JsonReader:consumeNonExecutePrefix()V",
            "method_body": "private void consumeNonExecutePrefix() throws IOException {\n// fast forward through the leading whitespace\nnextNonWhitespace(true);\npos--;\n\nif (pos + NON_EXECUTE_PREFIX.length > limit && !fillBuffer(NON_EXECUTE_PREFIX.length)) {\nreturn;\n}\n\nfor (int i = 0; i < NON_EXECUTE_PREFIX.length; i++) {\nif (buffer[pos + i] != NON_EXECUTE_PREFIX[i]) {\nreturn; // not a security token!\n}\n}\n\n// we consumed a security token!\npos += NON_EXECUTE_PREFIX.length;\n}",
            "method_id": 129
        },
        {
            "method_signature": "com.google.gson.internal.Primitives:add(Ljava/util/Map;Ljava/util/Map;Ljava/lang/Class;Ljava/lang/Class;)V",
            "method_body": "private static void add(Map<Class<?>, Class<?>> forward,\nMap<Class<?>, Class<?>> backward, Class<?> key, Class<?> value) {\nforward.put(key, value);\nbackward.put(value, key);\n}",
            "method_id": 130
        },
        {
            "method_signature": "com.google.gson.internal.bind.ObjectTypeAdapter:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
            "method_body": "@Override public Object read(JsonReader in) throws IOException {\nJsonToken token = in.peek();\nswitch (token) {\ncase BEGIN_ARRAY:\nList<Object> list = new ArrayList<Object>();\nin.beginArray();\nwhile (in.hasNext()) {\nlist.add(read(in));\n}\nin.endArray();\nreturn list;\n\ncase BEGIN_OBJECT:\nMap<String, Object> map = new LinkedTreeMap<String, Object>();\nin.beginObject();\nwhile (in.hasNext()) {\nmap.put(in.nextName(), read(in));\n}\nin.endObject();\nreturn map;\n\ncase STRING:\nreturn in.nextString();\n\ncase NUMBER:\nreturn in.nextDouble();\n\ncase BOOLEAN:\nreturn in.nextBoolean();\n\ncase NULL:\nin.nextNull();\nreturn null;\n\ndefault:\nthrow new IllegalStateException();\n}\n}",
            "method_id": 131
        },
        {
            "method_signature": "com.google.gson.internal.Primitives:wrap(Ljava/lang/Class;)Ljava/lang/Class;",
            "method_body": "public static <T> Class<T> wrap(Class<T> type) {\n// cast is safe: long.class and Long.class are both of type Class<Long>\n@SuppressWarnings(\"unchecked\")\nClass<T> wrapped = (Class<T>) PRIMITIVE_TO_WRAPPER_TYPE.get(\n$Gson$Preconditions.checkNotNull(type));\nreturn (wrapped == null) ? type : wrapped;\n}",
            "method_id": 132
        },
        {
            "method_signature": "com.google.gson.reflect.TypeToken:get(Ljava/lang/Class;)Lcom/google/gson/reflect/TypeToken;",
            "method_body": "public static <T> TypeToken<T> get(Class<T> type) {\nreturn new TypeToken<T>(type);\n}",
            "method_id": 133
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Types:resolveTypeVariable(Ljava/lang/reflect/Type;Ljava/lang/Class;Ljava/lang/reflect/TypeVariable;)Ljava/lang/reflect/Type;",
            "method_body": "static Type resolveTypeVariable(Type context, Class<?> contextRawType, TypeVariable<?> unknown) {\nClass<?> declaredByRaw = declaringClassOf(unknown);\n\n// we can't reduce this further\nif (declaredByRaw == null) {\nreturn unknown;\n}\n\nType declaredBy = getGenericSupertype(context, contextRawType, declaredByRaw);\nif (declaredBy instanceof ParameterizedType) {\nint index = indexOf(declaredByRaw.getTypeParameters(), unknown);\nreturn ((ParameterizedType) declaredBy).getActualTypeArguments()[index];\n}\n\nreturn unknown;\n}",
            "method_id": 134
        },
        {
            "method_signature": "com.google.gson.internal.bind.TypeAdapterRuntimeTypeWrapper:read(Lcom/google/gson/stream/JsonReader;)Ljava/lang/Object;",
            "method_body": "public T read(JsonReader in) throws IOException {\nreturn delegate.read(in);\n}",
            "method_id": 135
        },
        {
            "method_signature": "com.google.gson.internal.Excluder:isAnonymousOrLocal(Ljava/lang/Class;)Z",
            "method_body": "private boolean isAnonymousOrLocal(Class<?> clazz) {\nreturn !Enum.class.isAssignableFrom(clazz)\n&& (clazz.isAnonymousClass() || clazz.isLocalClass());\n}",
            "method_id": 136
        },
        {
            "method_signature": "com.google.gson.internal.LinkedTreeMap:<clinit>()V",
            "method_body": "private static final Comparator<Comparable> NATURAL_ORDER = new Comparator<Comparable>() {\n};",
            "method_id": 137
        }
    ]
}