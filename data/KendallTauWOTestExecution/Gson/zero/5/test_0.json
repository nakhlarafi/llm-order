{
    "bug_id": 5,
    "test_id": 0,
    "test_name": "com.google.gson.DefaultDateTypeAdapterTest.testDateDeserializationISO8601",
    "test_body": "public void testDateDeserializationISO8601() throws Exception {\nDefaultDateTypeAdapter adapter = new DefaultDateTypeAdapter();\nassertParsed(\"1970-01-01T00:00:00.000Z\", adapter);\nassertParsed(\"1970-01-01T00:00Z\", adapter);\nassertParsed(\"1970-01-01T00:00:00+00:00\", adapter);\nassertParsed(\"1970-01-01T01:00:00+01:00\", adapter);\nassertParsed(\"1970-01-01T01:00:00+01\", adapter);\n}\n",
    "stack_trace": "com.google.gson.JsonSyntaxException: 1970-01-01T01:00:00+01\nat com.google.gson.DefaultDateTypeAdapter.deserializeToDate(DefaultDateTypeAdapter.java:107)\nat com.google.gson.DefaultDateTypeAdapter.deserialize(DefaultDateTypeAdapter.java:84)\nat com.google.gson.DefaultDateTypeAdapterTest.assertParsed(DefaultDateTypeAdapterTest.java:168)\nat com.google.gson.DefaultDateTypeAdapterTest.testDateDeserializationISO8601(DefaultDateTypeAdapterTest.java:133)",
    "covered_methods": [
        {
            "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>(Ljava/text/DateFormat;Ljava/text/DateFormat;)V",
            "method_body": "DefaultDateTypeAdapter(DateFormat enUsFormat, DateFormat localFormat) {\nthis.enUsFormat = enUsFormat;\nthis.localFormat = localFormat;\n}",
            "method_id": 0
        },
        {
            "method_signature": "com.google.gson.JsonSyntaxException:<init>(Ljava/lang/String;Ljava/lang/Throwable;)V",
            "method_body": "public JsonSyntaxException(String msg, Throwable cause) {\nsuper(msg, cause);\n}",
            "method_id": 1
        },
        {
            "method_signature": "com.google.gson.JsonPrimitive:isNumber()Z",
            "method_body": "public boolean isNumber() {\nreturn value instanceof Number;\n}",
            "method_id": 2
        },
        {
            "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:parseInt(Ljava/lang/String;II)I",
            "method_body": "private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException {\nif (beginIndex < 0 || endIndex > value.length() || beginIndex > endIndex) {\nthrow new NumberFormatException(value);\n}\n// use same logic as in Integer.parseInt() but less generic we're not supporting negative values\nint i = beginIndex;\nint result = 0;\nint digit;\nif (i < endIndex) {\ndigit = Character.digit(value.charAt(i++), 10);\nif (digit < 0) {\nthrow new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n}\nresult = -digit;\n}\nwhile (i < endIndex) {\ndigit = Character.digit(value.charAt(i++), 10);\nif (digit < 0) {\nthrow new NumberFormatException(\"Invalid number: \" + value.substring(beginIndex, endIndex));\n}\nresult *= 10;\nresult -= digit;\n}\nreturn -result;\n}",
            "method_id": 3
        },
        {
            "method_signature": "com.google.gson.DefaultDateTypeAdapter:<init>()V",
            "method_body": "DefaultDateTypeAdapter() {\nthis(DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.US),\nDateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT));\n}",
            "method_id": 4
        },
        {
            "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:indexOfNonDigit(Ljava/lang/String;I)I",
            "method_body": "private static int indexOfNonDigit(String string, int offset) {\nfor (int i = offset; i < string.length(); i++) {\nchar c = string.charAt(i);\nif (c < '0' || c > '9') return i;\n}\nreturn string.length();\n}",
            "method_id": 5
        },
        {
            "method_signature": "com.google.gson.JsonParseException:<init>(Ljava/lang/String;Ljava/lang/Throwable;)V",
            "method_body": "public JsonParseException(String msg, Throwable cause) {\nsuper(msg, cause);\n}",
            "method_id": 6
        },
        {
            "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:<clinit>()V",
            "method_body": "private static final String UTC_ID = \"UTC\";\n/**\n* The UTC timezone, prefetched to avoid more lookups.\n*\n* @since 2.7\n*/\nprivate static final TimeZone TIMEZONE_UTC = TimeZone.getTimeZone(UTC_ID);\n\n/*\n/**********************************************************\n/* Formatting\n/**********************************************************\n*/\n\n/**\n* Format a date into 'yyyy-MM-ddThh:mm:ssZ' (default timezone, no milliseconds precision)\n*\n* @param date the date to format\n* @return the date formatted as 'yyyy-MM-ddThh:mm:ssZ'\n*/\npublic static String format(Date date) {\nreturn format(date, false, TIMEZONE_UTC);\n}",
            "method_id": 7
        },
        {
            "method_signature": "com.google.gson.JsonPrimitive:<clinit>()V",
            "method_body": "private static final Class<?>[] PRIMITIVE_TYPES = { int.class, long.class, short.class,\nfloat.class, double.class, byte.class, boolean.class, char.class, Integer.class, Long.class,\nShort.class, Float.class, Double.class, Byte.class, Boolean.class, Character.class };",
            "method_id": 8
        },
        {
            "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:parse(Ljava/lang/String;Ljava/text/ParsePosition;)Ljava/util/Date;",
            "method_body": "public static Date parse(String date, ParsePosition pos) throws ParseException {\nException fail = null;\ntry {\nint offset = pos.getIndex();\n\n// extract year\nint year = parseInt(date, offset, offset += 4);\nif (checkOffset(date, offset, '-')) {\noffset += 1;\n}\n\n// extract month\nint month = parseInt(date, offset, offset += 2);\nif (checkOffset(date, offset, '-')) {\noffset += 1;\n}\n\n// extract day\nint day = parseInt(date, offset, offset += 2);\n// default time value\nint hour = 0;\nint minutes = 0;\nint seconds = 0;\nint milliseconds = 0; // always use 0 otherwise returned date will include millis of current time\n\n// if the value has no time component (and no time zone), we are done\nboolean hasT = checkOffset(date, offset, 'T');\n\nif (!hasT && (date.length() <= offset)) {\nCalendar calendar = new GregorianCalendar(year, month - 1, day);\n\npos.setIndex(offset);\nreturn calendar.getTime();\n}\n\nif (hasT) {\n\n// extract hours, minutes, seconds and milliseconds\nhour = parseInt(date, offset += 1, offset += 2);\nif (checkOffset(date, offset, ':')) {\noffset += 1;\n}\n\nminutes = parseInt(date, offset, offset += 2);\nif (checkOffset(date, offset, ':')) {\noffset += 1;\n}\n// second and milliseconds can be optional\nif (date.length() > offset) {\nchar c = date.charAt(offset);\nif (c != 'Z' && c != '+' && c != '-') {\nseconds = parseInt(date, offset, offset += 2);\nif (seconds > 59 && seconds < 63) seconds = 59; // truncate up to 3 leap seconds\n// milliseconds can be optional in the format\nif (checkOffset(date, offset, '.')) {\noffset += 1;\nint endOffset = indexOfNonDigit(date, offset + 1); // assume at least one digit\nint parseEndOffset = Math.min(endOffset, offset + 3); // parse up to 3 digits\nint fraction = parseInt(date, offset, parseEndOffset);\n// compensate for \"missing\" digits\nswitch (parseEndOffset - offset) { // number of digits parsed\ncase 2:\nmilliseconds = fraction * 10;\nbreak;\ncase 1:\nmilliseconds = fraction * 100;\nbreak;\ndefault:\nmilliseconds = fraction;\n}\noffset = endOffset;\n}\n}\n}\n}\n\n// extract timezone\nif (date.length() <= offset) {\nthrow new IllegalArgumentException(\"No time zone indicator\");\n}\n\nTimeZone timezone = null;\nchar timezoneIndicator = date.charAt(offset);\n\nif (timezoneIndicator == 'Z') {\ntimezone = TIMEZONE_UTC;\noffset += 1;\n} else if (timezoneIndicator == '+' || timezoneIndicator == '-') {\nString timezoneOffset = date.substring(offset);\n\n// When timezone has no minutes, we should append it, valid timezones are, for example: +00:00, +0000 and +00\n\noffset += timezoneOffset.length();\n// 18-Jun-2015, tatu: Minor simplification, skip offset of \"+0000\"/\"+00:00\"\nif (\"+0000\".equals(timezoneOffset) || \"+00:00\".equals(timezoneOffset)) {\ntimezone = TIMEZONE_UTC;\n} else {\n// 18-Jun-2015, tatu: Looks like offsets only work from GMT, not UTC...\n//    not sure why, but that's the way it looks. Further, Javadocs for\n//    `java.util.TimeZone` specifically instruct use of GMT as base for\n//    custom timezones... odd.\nString timezoneId = \"GMT\" + timezoneOffset;\n//                    String timezoneId = \"UTC\" + timezoneOffset;\n\ntimezone = TimeZone.getTimeZone(timezoneId);\n\nString act = timezone.getID();\nif (!act.equals(timezoneId)) {\n/* 22-Jan-2015, tatu: Looks like canonical version has colons, but we may be given\n*    one without. If so, don't sweat.\n*   Yes, very inefficient. Hopefully not hit often.\n*   If it becomes a perf problem, add 'loose' comparison instead.\n*/\nString cleaned = act.replace(\":\", \"\");\nif (!cleaned.equals(timezoneId)) {\nthrow new IndexOutOfBoundsException(\"Mismatching time zone indicator: \"+timezoneId+\" given, resolves to \"\n+timezone.getID());\n}\n}\n}\n} else {\nthrow new IndexOutOfBoundsException(\"Invalid time zone indicator '\" + timezoneIndicator+\"'\");\n}\n\nCalendar calendar = new GregorianCalendar(timezone);\ncalendar.setLenient(false);\ncalendar.set(Calendar.YEAR, year);\ncalendar.set(Calendar.MONTH, month - 1);\ncalendar.set(Calendar.DAY_OF_MONTH, day);\ncalendar.set(Calendar.HOUR_OF_DAY, hour);\ncalendar.set(Calendar.MINUTE, minutes);\ncalendar.set(Calendar.SECOND, seconds);\ncalendar.set(Calendar.MILLISECOND, milliseconds);\n\npos.setIndex(offset);\nreturn calendar.getTime();\n// If we get a ParseException it'll already have the right message/offset.\n// Other exception types can convert here.\n} catch (IndexOutOfBoundsException e) {\nfail = e;\n} catch (NumberFormatException e) {\nfail = e;\n} catch (IllegalArgumentException e) {\nfail = e;\n}\nString input = (date == null) ? null : ('\"' + date + \"'\");\nString msg = fail.getMessage();\nif (msg == null || msg.isEmpty()) {\nmsg = \"(\"+fail.getClass().getName()+\")\";\n}\nParseException ex = new ParseException(\"Failed to parse date [\" + input + \"]: \" + msg, pos.getIndex());\nex.initCause(fail);\nthrow ex;\n}",
            "method_id": 9
        },
        {
            "method_signature": "com.google.gson.JsonPrimitive:isBoolean()Z",
            "method_body": "public boolean isBoolean() {\nreturn value instanceof Boolean;\n}",
            "method_id": 10
        },
        {
            "method_signature": "com.google.gson.internal.bind.util.ISO8601Utils:checkOffset(Ljava/lang/String;IC)Z",
            "method_body": "private static boolean checkOffset(String value, int offset, char expected) {\nreturn (offset < value.length()) && (value.charAt(offset) == expected);\n}",
            "method_id": 11
        },
        {
            "method_signature": "com.google.gson.internal.$Gson$Preconditions:checkArgument(Z)V",
            "method_body": "public static void checkArgument(boolean condition) {\nif (!condition) {\nthrow new IllegalArgumentException();\n}\n}",
            "method_id": 12
        },
        {
            "method_signature": "com.google.gson.JsonPrimitive:isPrimitiveOrString(Ljava/lang/Object;)Z",
            "method_body": "private static boolean isPrimitiveOrString(Object target) {\nif (target instanceof String) {\nreturn true;\n}\n\nClass<?> classOfPrimitive = target.getClass();\nfor (Class<?> standardPrimitive : PRIMITIVE_TYPES) {\nif (standardPrimitive.isAssignableFrom(classOfPrimitive)) {\nreturn true;\n}\n}\nreturn false;\n}",
            "method_id": 13
        },
        {
            "method_signature": "com.google.gson.DefaultDateTypeAdapter:deserializeToDate(Lcom/google/gson/JsonElement;)Ljava/util/Date;",
            "method_body": "private Date deserializeToDate(JsonElement json) {\nsynchronized (localFormat) {\ntry {\nreturn localFormat.parse(json.getAsString());\n} catch (ParseException ignored) {}\ntry {\nreturn enUsFormat.parse(json.getAsString());\n} catch (ParseException ignored) {}\ntry {\nreturn ISO8601Utils.parse(json.getAsString(), new ParsePosition(0));\n} catch (ParseException e) {\nthrow new JsonSyntaxException(json.getAsString(), e);\n}\n}\n}",
            "method_id": 14
        },
        {
            "method_signature": "com.google.gson.JsonPrimitive:getAsString()Ljava/lang/String;",
            "method_body": "public String getAsString() {\nif (isNumber()) {\nreturn getAsNumber().toString();\n} else if (isBoolean()) {\nreturn getAsBooleanWrapper().toString();\n} else {\nreturn (String) value;\n}\n}",
            "method_id": 15
        },
        {
            "method_signature": "com.google.gson.DefaultDateTypeAdapter:deserialize(Lcom/google/gson/JsonElement;Ljava/lang/reflect/Type;Lcom/google/gson/JsonDeserializationContext;)Ljava/util/Date;",
            "method_body": "public Date deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\nthrows JsonParseException {\nif (!(json instanceof JsonPrimitive)) {\nthrow new JsonParseException(\"The date should be a string value\");\n}\nDate date = deserializeToDate(json);\nif (typeOfT == Date.class) {\nreturn date;\n} else if (typeOfT == Timestamp.class) {\nreturn new Timestamp(date.getTime());\n} else if (typeOfT == java.sql.Date.class) {\nreturn new java.sql.Date(date.getTime());\n} else {\nthrow new IllegalArgumentException(getClass() + \" cannot deserialize to \" + typeOfT);\n}\n}",
            "method_id": 16
        },
        {
            "method_signature": "com.google.gson.JsonPrimitive:setValue(Ljava/lang/Object;)V",
            "method_body": "void setValue(Object primitive) {\nif (primitive instanceof Character) {\n// convert characters to strings since in JSON, characters are represented as a single\n// character string\nchar c = ((Character) primitive).charValue();\nthis.value = String.valueOf(c);\n} else {\n$Gson$Preconditions.checkArgument(primitive instanceof Number\n|| isPrimitiveOrString(primitive));\nthis.value = primitive;\n}\n}",
            "method_id": 17
        },
        {
            "method_signature": "com.google.gson.JsonPrimitive:<init>(Ljava/lang/String;)V",
            "method_body": "public JsonPrimitive(String string) {\nsetValue(string);\n}",
            "method_id": 18
        }
    ]
}