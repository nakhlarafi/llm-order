{
    "bug_id": 10,
    "test_id": 0,
    "test_name": "com.fasterxml.jackson.core.sym.TestByteBasedSymbols.testIssue207",
    "test_body": "public void testIssue207() throws Exception\n{\nByteQuadsCanonicalizer nc = ByteQuadsCanonicalizer.createRoot(-523743345);\nField byteSymbolCanonicalizerField = JsonFactory.class.getDeclaredField(\"_byteSymbolCanonicalizer\");\nbyteSymbolCanonicalizerField.setAccessible(true);\nJsonFactory jsonF = new JsonFactory();\nbyteSymbolCanonicalizerField.set(jsonF, nc);\nStringBuilder stringBuilder = new StringBuilder();\nstringBuilder.append(\"{\\n\");\nstringBuilder.append(\"    \\\"expectedGCperPosition\\\": null\");\nfor (int i = 0; i < 60; ++i) {\nstringBuilder.append(\",\\n    \\\"\").append(i + 1).append(\"\\\": null\");\n}\nstringBuilder.append(\"\\n}\");\nJsonParser p = jsonF.createParser(stringBuilder.toString().getBytes(\"UTF-8\"));\nwhile (p.nextToken() != null) { }\np.close();\n}\n",
    "stack_trace": "java.lang.ArrayIndexOutOfBoundsException: 256\nat com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer.addName(ByteQuadsCanonicalizer.java:853)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.addName(UTF8StreamJsonParser.java:2340)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.parseEscapedName(UTF8StreamJsonParser.java:1980)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.slowParseName(UTF8StreamJsonParser.java:1867)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser._parseName(UTF8StreamJsonParser.java:1651)\nat com.fasterxml.jackson.core.json.UTF8StreamJsonParser.nextToken(UTF8StreamJsonParser.java:740)\nat com.fasterxml.jackson.core.sym.TestByteBasedSymbols.testIssue207(TestByteBasedSymbols.java:119)",
    "covered_methods": [
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}",
            "method_id": 0
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}",
            "method_id": 1
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper:detectEncoding()Lcom/fasterxml/jackson/core/JsonEncoding;",
            "method_body": "public JsonEncoding detectEncoding() throws IOException\n{\nboolean foundEncoding = false;\n\n// First things first: BOM handling\n/* Note: we can require 4 bytes to be read, since no\n* combination of BOM + valid JSON content can have\n* shorter length (shortest valid JSON content is single\n* digit char, but BOMs are chosen such that combination\n* is always at least 4 chars long)\n*/\nif (ensureLoaded(4)) {\nint quad =  (_inputBuffer[_inputPtr] << 24)\n| ((_inputBuffer[_inputPtr+1] & 0xFF) << 16)\n| ((_inputBuffer[_inputPtr+2] & 0xFF) << 8)\n| (_inputBuffer[_inputPtr+3] & 0xFF);\n\nif (handleBOM(quad)) {\nfoundEncoding = true;\n} else {\n/* If no BOM, need to auto-detect based on first char;\n* this works since it must be 7-bit ascii (wrt. unicode\n* compatible encodings, only ones JSON can be transferred\n* over)\n*/\n// UTF-32?\nif (checkUTF32(quad)) {\nfoundEncoding = true;\n} else if (checkUTF16(quad >>> 16)) {\nfoundEncoding = true;\n}\n}\n} else if (ensureLoaded(2)) {\nint i16 = ((_inputBuffer[_inputPtr] & 0xFF) << 8)\n| (_inputBuffer[_inputPtr+1] & 0xFF);\nif (checkUTF16(i16)) {\nfoundEncoding = true;\n}\n}\n\nJsonEncoding enc;\n\n/* Not found yet? As per specs, this means it must be UTF-8. */\nif (!foundEncoding) {\nenc = JsonEncoding.UTF8;\n} else {\nswitch (_bytesPerChar) {\ncase 1: enc = JsonEncoding.UTF8;\nbreak;\ncase 2: enc = _bigEndian ? JsonEncoding.UTF16_BE : JsonEncoding.UTF16_LE;\nbreak;\ncase 4: enc = _bigEndian ? JsonEncoding.UTF32_BE : JsonEncoding.UTF32_LE;\nbreak;\ndefault: throw new RuntimeException(\"Internal error\"); // should never get here\n}\n}\n_context.setEncoding(enc);\nreturn enc;\n}",
            "method_id": 2
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:slowParseName()Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleUnexpectedValue(i);\n}\n\n\nprivate final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n{\n// // // and this is back to standard nextToken()\n\nString n = _parseName(i);\n_parsingContext.setCurrentName(n);\nfinal boolean match = n.equals(str.getValue());\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n\n// Ok: we must have a value... what is it? Strings are very common, check first:\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn match;\n}\nJsonToken t;\n\nswitch (i) {\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ncase 't':\n_matchToken(\"true\", 1);\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase 'f':\n_matchToken(\"false\", 1);\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchToken(\"null\", 1);\nt = JsonToken.VALUE_NULL;\nbreak;\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ndefault:\nt = _handleUnexpectedValue(i);\n}\n_nextToken = t;\nreturn match;\n}\n\n@Override\npublic String nextTextValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\nreturn _finishAndReturnString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n@Override\npublic int nextIntValue(int defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n@Override\npublic long nextLongValue(long defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n@Override\npublic Boolean nextBooleanValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n\nJsonToken t = nextToken();\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected JsonToken _parsePosNumber(int c) throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n// Ok: we can first just add digit we saw first:\noutBuf[0] = (char) c;\nint intLen = 1;\nint outPtr = 1;\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - 1; // 1 == outPtr\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) { // split across boundary, offline\nreturn _parseNumber2(outBuf, outPtr, false, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, false, intLen);\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n// And there we have it!\nreturn resetInt(false, intLen);\n}\n\nprotected JsonToken _parseNegNumber() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\noutBuf[outPtr++] = '-';\n// Must have something after sign too\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Note: must be followed by a digit\nif (c < INT_0 || c > INT_9) {\nreturn _handleInvalidNumberStart(c, true);\n}\n\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n\n// Ok: we can first just add digit we saw first:\noutBuf[outPtr++] = (char) c;\nint intLen = 1;\n\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - outPtr;\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) {\n// Long enough to be split across boundary, so:\nreturn _parseNumber2(outBuf, outPtr, true, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, true, intLen);\n}\n\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n\n// And there we have it!\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to handle parsing when input is split across buffer boundary\n* (or output is longer than segment used to store it)\n*/\nprivate final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\nint intPartLength) throws IOException\n{\n// Ok, parse the rest\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_textBuffer.setCurrentLength(outPtr);\nreturn resetInt(negative, intPartLength);\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c > INT_9 || c < INT_0) {\nif (c == INT_PERIOD || c == INT_e || c == INT_E) {\nreturn _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n}\nbreak;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n++intPartLength;\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n}\n\n// And there we have it!\nreturn resetInt(negative, intPartLength);\n\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final int _verifyNoLeadingZeroes() throws IOException\n{\n// Ok to have plain \"0\"\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn INT_0;\n}\nint ch = _inputBuffer[_inputPtr] & 0xFF;\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < INT_0 || ch > INT_9) {\nreturn INT_0;\n}\n// [JACKSON-358]: we may want to allow them, after all...\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\nreturn INT_0;\n}\n++_inputPtr; // skip previous zeroes\nif (ch != INT_0) { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\nboolean negative, int integerPartLength) throws IOException\n{\nint fractLen = 0;\nboolean eof = false;\n\n// And then see if we get other parts\nif (c == INT_PERIOD) { // yes, fraction\noutBuf[outPtr++] = (char) c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == INT_e || c == INT_E) { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Not optional, can require that we get one more char\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Likewise, non optional:\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n\n// And there we have it!\nreturn resetFloat(negative, integerPartLength, fractLen, expLen);\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\n// TODO? Handle UTF-8 char decoding for error reporting\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName(int i) throws IOException\n{\nif (i != INT_QUOTE) {\nreturn _handleOddName(i);\n}\n// First: can we optimize out bounds checks?\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\n}\n\n// If so, can also unroll loops nicely\n/* 25-Nov-2008, tatu: This may seem weird, but here we do\n*   NOT want to worry about UTF-8 decoding. Rather, we'll\n*   assume that part is ok (if not it will get caught\n*   later on), and just handle quotes and backslashes here.\n*/\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\nint q = input[_inputPtr++] & 0xFF;\n\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\n}\nif (i == INT_QUOTE) { // 4 byte/char case or broken\nreturn findName(q, 4);\n}\nreturn parseName(q, i, 4);\n}\nif (i == INT_QUOTE) { // 3 byte/char case or broken\nreturn findName(q, 3);\n}\nreturn parseName(q, i, 3);\n}\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\n}\nreturn parseName(q, i, 2);\n}\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\n}\nreturn parseName(q, i, 1);\n}\nif (q == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseName(0, q, 0); // quoting or invalid char\n}\n\nprotected final String parseMediumName(int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Ok, got 5 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 5 bytes\nreturn findName(_quad1, q2, 1);\n}\nreturn parseName(_quad1, q2, i, 1); // quoting or invalid char\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 6 bytes\nreturn findName(_quad1, q2, 2);\n}\nreturn parseName(_quad1, q2, i, 2);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 7 bytes\nreturn findName(_quad1, q2, 3);\n}\nreturn parseName(_quad1, q2, i, 3);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 8 bytes\nreturn findName(_quad1, q2, 4);\n}\nreturn parseName(_quad1, q2, i, 4);\n}\nreturn parseMediumName2(i, q2);\n}\n\n/**\n* @since 2.6\n*/\nprotected final String parseMediumName2(int q3, final int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Got 9 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 9 bytes\nreturn findName(_quad1, q2, q3, 1);\n}\nreturn parseName(_quad1, q2, q3, i, 1);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 10 bytes\nreturn findName(_quad1, q2, q3, 2);\n}\nreturn parseName(_quad1, q2, q3, i, 2);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 11 bytes\nreturn findName(_quad1, q2, q3, 3);\n}\nreturn parseName(_quad1, q2, q3, i, 3);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 12 bytes\nreturn findName(_quad1, q2, q3, 4);\n}\nreturn parseName(_quad1, q2, q3, i, 4);\n}\nreturn parseLongName(i, q2, q3);\n}\n\nprotected final String parseLongName(int q, final int q2, int q3) throws IOException\n{\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\n\n// As explained above, will ignore UTF-8 encoding at this point\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\n\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 1);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 2);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 2);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 3);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 3);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 4);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 4);\n}\n\n// Nope, no end in sight. Need to grow quad array etc\nif (qlen >= _quadBuffer.length) {\n_quadBuffer = growArrayBy(_quadBuffer, qlen);\n}\n_quadBuffer[qlen++] = q;\nq = i;\n}\n\n/* Let's offline if we hit buffer boundary (otherwise would\n* need to [try to] align input, which is bit complicated\n* and may not always be possible)\n*/\nreturn parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n}\n\n/**\n* Method called when not even first 8 bytes are guaranteed\n* to come consequtively. Happens rarely, so this is offlined;\n* plus we'll also do full checks for escaping etc.\n*/\nprotected String slowParseName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n}\n}\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\n}\n\nprivate final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\nreturn parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\nreturn parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n}\n\n/**\n* Slower parsing method which is generally branched to when\n* an escape sequence is detected (or alternatively for long\n* names, one crossing input buffer boundary).\n* Needs to be able to handle more exceptional cases, gets slower,\n* and hance is offlined to a separate method.\n*/\nprotected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\nint currQuadBytes) throws IOException\n{\n/* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n*   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n*   caught later on), and just handle quotes and backslashes here.\n*/\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\n}\n// Unquoted white space?\nif (ch != INT_BACKSLASH) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int ch) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\nchar c = (char) _decodeCharForError(ch);\n_reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n}\n/* Also: note that although we use a different table here,\n* it does NOT handle UTF-8 decoding. It'll just pass those\n* high-bit codes as acceptable for later decoding.\n*/\nfinal int[] codes = CharTypes.getInputCodeUtf8JsNames();\n// Also: must start with a valid character...\nif (codes[ch] != 0) {\n_reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\n\n/* Ok, now; instead of ultra-optimizing parsing here (as with\n* regular JSON names), let's just use the generic \"slow\"\n* variant. Can measure its impact later on if need be\n*/\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\nwhile (true) {\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (codes[ch] != 0) {\nbreak;\n}\n++_inputPtr;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n* main reason being to try to avoid slowing down fast path\n* for valid JSON -- more alternatives, more code, generally\n* bit slower execution.\n*/\nprotected String _parseAposName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\'' for name\");\n}\n}\nint ch = _inputBuffer[_inputPtr++] & 0xFF;\nif (ch == '\\'') { // special case, ''\nreturn \"\";\n}\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\n// Copied from parseEscapedFieldName, with minor mods:\n\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (ch == '\\'') {\nbreak;\n}\n// additional check to skip handling of double-quotes\nif (ch != '\"' && codes[ch] != 0) {\nif (ch != '\\\\') {\n// Unquoted white space?\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/*\n/**********************************************************\n/* Internal methods, symbol (name) handling\n/**********************************************************\n*/\n\nprivate final String findName(int q1, int lastQuadBytes) throws JsonParseException\n{\nq1 = pad(q1, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n{\nq2 = pad(q2, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1, q2);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn addName(_quadBuffer, 2, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n{\nq3 = pad(q3, lastQuadBytes);\nString name = _symbols.findName(q1, q2, q3);\nif (name != null) {\nreturn name;\n}\nint[] quads = _quadBuffer;\nquads[0] = q1;\nquads[1] = q2;\nquads[2] = pad(q3, lastQuadBytes);\nreturn addName(quads, 3, lastQuadBytes);\n}\n\nprivate final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n{\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\n}\nreturn name;\n}\n\n/**\n* This is the main workhorse method used when we take a symbol\n* table miss. It needs to demultiplex individual bytes, decode\n* multi-byte chars (if any), and then construct Name instance\n* and add it to the symbol table.\n*/\nprivate final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n{\n/* Ok: must decode UTF-8 chars. No other validation is\n* needed, since unescaping has been done earlier as necessary\n* (as well as error reporting for unescaped control chars)\n*/\n// 4 bytes per quad, except last one maybe less\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n/* And last one is not correctly aligned (leading zero bytes instead\n* need to shift a bit, instead of trailing). Only need to shift it\n* for UTF-8 decoding; need revert for storage (since key will not\n* be aligned, to optimize lookup speed)\n*/\nint lastQuad;\n\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\n// 8/16/24 bit left shift\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n} else {\nlastQuad = 0;\n}\n\n// Need some working space, TextBuffer works well:\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\n\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\n\nif (ch > 127) { // multi-byte\nint needed;\nif ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\nch &= 0x1F;\nneeded = 1;\n} else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\nch &= 0x0F;\nneeded = 2;\n} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\nch &= 0x07;\nneeded = 3;\n} else { // 5- and 6-byte chars not valid xml chars\n_reportInvalidInitial(ch);\nneeded = ch = 1; // never really gets this far\n}\nif ((ix + needed) > byteLen) {\n_reportInvalidEOF(\" in field name\");\n}\n\n// Ok, always need at least one more:\nint ch2 = quads[ix >> 2]; // current quad, need to shift+mask\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 1) {\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 2) { // 4 bytes? (need surrogates on output)\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2 & 0xFF);\n}\nch = (ch << 6) | (ch2 & 0x3F);\n}\n}\nif (needed > 2) { // surrogate pair? once again, let's output one here, one later on\nch -= 0x10000; // to normalize it starting with 0x0\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) (0xD800 + (ch >> 10));\nch = 0xDC00 | (ch & 0x03FF);\n}\n}\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) ch;\n}\n\n// Ok. Now we have the character array, and can construct the String\nString baseName = new String(cbuf, 0, cix);\n// And finally, un-align if necessary\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\n}\nreturn _symbols.addName(baseName, quads, qlen);\n}\n\n/*\n/**********************************************************\n/* Internal methods, String value parsing\n/**********************************************************\n*/\n\n@Override\nprotected void _finishString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\n_textBuffer.setCurrentLength(outPtr);\nreturn;\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\n}\n\n/**\n* @since 2.6\n*/\nprotected String _finishAndReturnString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\nreturn _textBuffer.setCurrentAndReturn(outPtr);\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\nreturn _textBuffer.contentsAsString();\n}\n\nprivate final void _finishString2(char[] outBuf, int outPtr)\nthrows IOException\n{\nint c;\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ASCII non-funny-char loop:\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nfinal int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nc = _decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\n// Need to be fully UTF-8 aware here:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\nint c;\n\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nint max = _inputEnd;\nif (ptr >= max) {\nloadMoreGuaranteed();\nptr = _inputPtr;\nmax = _inputEnd;\n}\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\n_decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\n_skipUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\n_skipUtf8_3(c);\nbreak;\ncase 4: // 4-byte UTF\n_skipUtf8_4(c);\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n}\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleUnexpectedValue(int c)\nthrows IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (c) {\ncase ']':\ncase '}':\n// Error: neither is valid at this point; valid closers have\n// been handled earlier\n_reportUnexpectedChar(c, \"expected a value\");\ncase '\\'':\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(c)) {\n_reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos()\nthrows IOException\n{\nint c = 0;\n// Otherwise almost verbatim copy of _finishString()\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ascii non-funny-char loop:\nascii_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nint max = _inputEnd;\n{\nint max2 = _inputPtr + (outBuf.length - outPtr);\nif (max2 < max) {\nmax = max2;\n}\n}\nwhile (_inputPtr < max) {\nc = (int) inputBuffer[_inputPtr++] & 0xFF;\nif (c == '\\'' || codes[c] != 0) {\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n}\n\n// Ok: end marker, escape or multi-byte?\nif (c == '\\'') {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nif (c != '\\'') { // marked as special, isn't here\nc = _decodeEscaped();\n}\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n_throwUnquotedSpace(c, \"string value\");\n}\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n\nreturn JsonToken.VALUE_STRING;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\nthrows IOException\n{\nwhile (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nch = _inputBuffer[_inputPtr++];\nString match;\nif (ch == 'N') {\nmatch = neg ? \"-INF\" :\"+INF\";\n} else if (ch == 'n') {\nmatch = neg ? \"-Infinity\" :\"+Infinity\";\n} else {\nbreak;\n}\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\nprotected final void _matchToken(String matchStr, int i) throws IOException\n{\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\n_matchToken2(matchStr, i);\nreturn;\n}\ndo {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n_reportInvalidToken(matchStr.substring(0, i));\n}\n++_inputPtr;\n} while (++i < len);\n\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n_checkMatchEnd(matchStr, i, ch);\n}\n}",
            "method_id": 3
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper:handleBOM(I)Z",
            "method_body": "public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException\n{\n// Ideally we should see \"[\" or \"{\"; but if not, we'll accept double-quote (String)\n// in future could also consider accepting non-standard matches?\n\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nbyte b = acc.nextByte();\n// Very first thing, a UTF-8 BOM?\nif (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != UTF8_BOM_2) {\nreturn MatchStrength.NO_MATCH;\n}\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != UTF8_BOM_3) {\nreturn MatchStrength.NO_MATCH;\n}\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nb = acc.nextByte();\n}\n// Then possible leading space\nint ch = skipSpace(acc, b);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\n// First, let's see if it looks like a structured type:\nif (ch == '{') { // JSON object?\n// Ideally we need to find either double-quote or closing bracket\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (ch == '\"' || ch == '}') {\nreturn MatchStrength.SOLID_MATCH;\n}\n// ... should we allow non-standard? Let's not yet... can add if need be\nreturn MatchStrength.NO_MATCH;\n}\nMatchStrength strength;\n\nif (ch == '[') {\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\n// closing brackets is easy; but for now, let's also accept opening...\nif (ch == ']' || ch == '[') {\nreturn MatchStrength.SOLID_MATCH;\n}\nreturn MatchStrength.SOLID_MATCH;\n} else {\n// plain old value is not very convincing...\nstrength = MatchStrength.WEAK_MATCH;\n}\n\nif (ch == '\"') { // string value\nreturn strength;\n}\nif (ch <= '9' && ch >= '0') { // number\nreturn strength;\n}\nif (ch == '-') { // negative number\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nreturn (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH;\n}\n// or one of literals\nif (ch == 'n') { // null\nreturn tryMatch(acc, \"ull\", strength);\n}\nif (ch == 't') { // true\nreturn tryMatch(acc, \"rue\", strength);\n}\nif (ch == 'f') { // false\nreturn tryMatch(acc, \"alse\", strength);\n}\nreturn MatchStrength.NO_MATCH;\n}\n\nprivate static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\nthrows IOException\n{\nfor (int i = 0, len = matchStr.length(); i < len; ++i) {\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != matchStr.charAt(i)) {\nreturn MatchStrength.NO_MATCH;\n}\n}\nreturn fullMatchStrength;\n}\n\nprivate static int skipSpace(InputAccessor acc) throws IOException\n{\nif (!acc.hasMoreBytes()) {\nreturn -1;\n}\nreturn skipSpace(acc, acc.nextByte());\n}\n\nprivate static int skipSpace(InputAccessor acc, byte b) throws IOException\n{\nwhile (true) {\nint ch = (int) b & 0xFF;\nif (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\nreturn ch;\n}\nif (!acc.hasMoreBytes()) {\nreturn -1;\n}\nb = acc.nextByte();\nch = (int) b & 0xFF;\n}\n}\n\n/*\n/**********************************************************\n/* Internal methods, parsing\n/**********************************************************\n*/\n\n/**\n* @return True if a BOM was succesfully found, and encoding\n*   thereby recognized.\n*/\nprivate boolean handleBOM(int quad) throws IOException\n{\n/* Handling of (usually) optional BOM (required for\n* multi-byte formats); first 32-bit charsets:\n*/\nswitch (quad) {\ncase 0x0000FEFF:\n_bigEndian = true;\n_inputPtr += 4;\n_bytesPerChar = 4;\nreturn true;\ncase 0xFFFE0000: // UCS-4, LE?\n_inputPtr += 4;\n_bytesPerChar = 4;\n_bigEndian = false;\nreturn true;\ncase 0x0000FFFE: // UCS-4, in-order...\nreportWeirdUCS4(\"2143\"); // throws exception\ncase 0xFEFF0000: // UCS-4, in-order...\nreportWeirdUCS4(\"3412\"); // throws exception\n}\n// Ok, if not, how about 16-bit encoding BOMs?\nint msw = quad >>> 16;\nif (msw == 0xFEFF) { // UTF-16, BE\n_inputPtr += 2;\n_bytesPerChar = 2;\n_bigEndian = true;\nreturn true;\n}\nif (msw == 0xFFFE) { // UTF-16, LE\n_inputPtr += 2;\n_bytesPerChar = 2;\n_bigEndian = false;\nreturn true;\n}\n// And if not, then UTF-8 BOM?\nif ((quad >>> 8) == 0xEFBBBF) { // UTF-8\n_inputPtr += 3;\n_bytesPerChar = 1;\n_bigEndian = true; // doesn't really matter\nreturn true;\n}\nreturn false;\n}\n\nprivate boolean checkUTF32(int quad) throws IOException\n{\n/* Handling of (usually) optional BOM (required for\n* multi-byte formats); first 32-bit charsets:\n*/\nif ((quad >> 8) == 0) { // 0x000000?? -> UTF32-BE\n_bigEndian = true;\n} else if ((quad & 0x00FFFFFF) == 0) { // 0x??000000 -> UTF32-LE\n_bigEndian = false;\n} else if ((quad & ~0x00FF0000) == 0) { // 0x00??0000 -> UTF32-in-order\nreportWeirdUCS4(\"3412\");\n} else if ((quad & ~0x0000FF00) == 0) { // 0x0000??00 -> UTF32-in-order\nreportWeirdUCS4(\"2143\");\n} else {\n// Can not be valid UTF-32 encoded JSON...\nreturn false;\n}\n// Not BOM (just regular content), nothing to skip past:\n//_inputPtr += 4;\n_bytesPerChar = 4;\nreturn true;\n}\n\nprivate boolean checkUTF16(int i16)\n{\nif ((i16 & 0xFF00) == 0) { // UTF-16BE\n_bigEndian = true;\n} else if ((i16 & 0x00FF) == 0) { // UTF-16LE\n_bigEndian = false;\n} else { // nope, not  UTF-16\nreturn false;\n}\n// Not BOM (just regular content), nothing to skip past:\n//_inputPtr += 2;\n_bytesPerChar = 2;\nreturn true;\n}\n\n/*\n/**********************************************************\n/* Internal methods, problem reporting\n/**********************************************************\n*/\n\nprivate void reportWeirdUCS4(String type) throws IOException {\nthrow new CharConversionException(\"Unsupported UCS-4 endianness (\"+type+\") detected\");\n}\n\n/*\n/**********************************************************\n/* Internal methods, raw input access\n/**********************************************************\n*/\n\nprotected boolean ensureLoaded(int minimum) throws IOException {\n/* Let's assume here buffer has enough room -- this will always\n* be true for the limited used this method gets\n*/\nint gotten = (_inputEnd - _inputPtr);\nwhile (gotten < minimum) {\nint count;\n\nif (_in == null) { // block source\ncount = -1;\n} else {\ncount = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n}\nif (count < 1) {\nreturn false;\n}\n_inputEnd += count;\ngotten += count;\n}\nreturn true;\n}\n}",
            "method_id": 4
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:addName(Ljava/lang/String;[II)Ljava/lang/String;",
            "method_body": "public String addName(String name, int[] q, int qlen)\n{\n_verifySharing();\nif (_intern) {\nname = InternCache.instance.intern(name);\n}\nint offset;\n\nswitch (qlen) {\ncase 1:\n{\noffset = _findOffsetForAdd(calcHash(q[0]));\n_hashArea[offset] = q[0];\n_hashArea[offset+3] = 1;\n}\nbreak;\ncase 2:\n{\noffset = _findOffsetForAdd(calcHash(q[0], q[1]));\n_hashArea[offset] = q[0];\n_hashArea[offset+1] = q[1];\n_hashArea[offset+3] = 2;\n}\nbreak;\ncase 3:\n{\noffset = _findOffsetForAdd(calcHash(q[0], q[1], q[2]));\n_hashArea[offset] = q[0];\n_hashArea[offset+1] = q[1];\n_hashArea[offset+2] = q[2];\n_hashArea[offset+3] = 3;\n}\nbreak;\ndefault:\nfinal int hash = calcHash(q, qlen);\noffset = _findOffsetForAdd(hash);\n\n_hashArea[offset] = hash;\nint longStart = _appendLongName(q, qlen);\n_hashArea[offset+1] = longStart;\n_hashArea[offset+3] = qlen;\n}\n// plus add the actual String\n_names[offset >> 2] = name;\n\n// and finally; see if we really should rehash.\n++_count;\n_verifyNeedForRehash();\nreturn name;\n}",
            "method_id": 5
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.SerializedString:<init>(Ljava/lang/String;)V",
            "method_body": "public SerializedString(String v) {\nif (v == null) {\nthrow new IllegalStateException(\"Null String illegal for SerializedString\");\n}\n_value = v;\n}",
            "method_id": 6
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper:checkUTF16(I)Z",
            "method_body": "public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException\n{\n// Ideally we should see \"[\" or \"{\"; but if not, we'll accept double-quote (String)\n// in future could also consider accepting non-standard matches?\n\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nbyte b = acc.nextByte();\n// Very first thing, a UTF-8 BOM?\nif (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != UTF8_BOM_2) {\nreturn MatchStrength.NO_MATCH;\n}\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != UTF8_BOM_3) {\nreturn MatchStrength.NO_MATCH;\n}\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nb = acc.nextByte();\n}\n// Then possible leading space\nint ch = skipSpace(acc, b);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\n// First, let's see if it looks like a structured type:\nif (ch == '{') { // JSON object?\n// Ideally we need to find either double-quote or closing bracket\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (ch == '\"' || ch == '}') {\nreturn MatchStrength.SOLID_MATCH;\n}\n// ... should we allow non-standard? Let's not yet... can add if need be\nreturn MatchStrength.NO_MATCH;\n}\nMatchStrength strength;\n\nif (ch == '[') {\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\n// closing brackets is easy; but for now, let's also accept opening...\nif (ch == ']' || ch == '[') {\nreturn MatchStrength.SOLID_MATCH;\n}\nreturn MatchStrength.SOLID_MATCH;\n} else {\n// plain old value is not very convincing...\nstrength = MatchStrength.WEAK_MATCH;\n}\n\nif (ch == '\"') { // string value\nreturn strength;\n}\nif (ch <= '9' && ch >= '0') { // number\nreturn strength;\n}\nif (ch == '-') { // negative number\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nreturn (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH;\n}\n// or one of literals\nif (ch == 'n') { // null\nreturn tryMatch(acc, \"ull\", strength);\n}\nif (ch == 't') { // true\nreturn tryMatch(acc, \"rue\", strength);\n}\nif (ch == 'f') { // false\nreturn tryMatch(acc, \"alse\", strength);\n}\nreturn MatchStrength.NO_MATCH;\n}\n\nprivate static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\nthrows IOException\n{\nfor (int i = 0, len = matchStr.length(); i < len; ++i) {\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != matchStr.charAt(i)) {\nreturn MatchStrength.NO_MATCH;\n}\n}\nreturn fullMatchStrength;\n}\n\nprivate static int skipSpace(InputAccessor acc) throws IOException\n{\nif (!acc.hasMoreBytes()) {\nreturn -1;\n}\nreturn skipSpace(acc, acc.nextByte());\n}\n\nprivate static int skipSpace(InputAccessor acc, byte b) throws IOException\n{\nwhile (true) {\nint ch = (int) b & 0xFF;\nif (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\nreturn ch;\n}\nif (!acc.hasMoreBytes()) {\nreturn -1;\n}\nb = acc.nextByte();\nch = (int) b & 0xFF;\n}\n}\n\n/*\n/**********************************************************\n/* Internal methods, parsing\n/**********************************************************\n*/\n\n/**\n* @return True if a BOM was succesfully found, and encoding\n*   thereby recognized.\n*/\nprivate boolean handleBOM(int quad) throws IOException\n{\n/* Handling of (usually) optional BOM (required for\n* multi-byte formats); first 32-bit charsets:\n*/\nswitch (quad) {\ncase 0x0000FEFF:\n_bigEndian = true;\n_inputPtr += 4;\n_bytesPerChar = 4;\nreturn true;\ncase 0xFFFE0000: // UCS-4, LE?\n_inputPtr += 4;\n_bytesPerChar = 4;\n_bigEndian = false;\nreturn true;\ncase 0x0000FFFE: // UCS-4, in-order...\nreportWeirdUCS4(\"2143\"); // throws exception\ncase 0xFEFF0000: // UCS-4, in-order...\nreportWeirdUCS4(\"3412\"); // throws exception\n}\n// Ok, if not, how about 16-bit encoding BOMs?\nint msw = quad >>> 16;\nif (msw == 0xFEFF) { // UTF-16, BE\n_inputPtr += 2;\n_bytesPerChar = 2;\n_bigEndian = true;\nreturn true;\n}\nif (msw == 0xFFFE) { // UTF-16, LE\n_inputPtr += 2;\n_bytesPerChar = 2;\n_bigEndian = false;\nreturn true;\n}\n// And if not, then UTF-8 BOM?\nif ((quad >>> 8) == 0xEFBBBF) { // UTF-8\n_inputPtr += 3;\n_bytesPerChar = 1;\n_bigEndian = true; // doesn't really matter\nreturn true;\n}\nreturn false;\n}\n\nprivate boolean checkUTF32(int quad) throws IOException\n{\n/* Handling of (usually) optional BOM (required for\n* multi-byte formats); first 32-bit charsets:\n*/\nif ((quad >> 8) == 0) { // 0x000000?? -> UTF32-BE\n_bigEndian = true;\n} else if ((quad & 0x00FFFFFF) == 0) { // 0x??000000 -> UTF32-LE\n_bigEndian = false;\n} else if ((quad & ~0x00FF0000) == 0) { // 0x00??0000 -> UTF32-in-order\nreportWeirdUCS4(\"3412\");\n} else if ((quad & ~0x0000FF00) == 0) { // 0x0000??00 -> UTF32-in-order\nreportWeirdUCS4(\"2143\");\n} else {\n// Can not be valid UTF-32 encoded JSON...\nreturn false;\n}\n// Not BOM (just regular content), nothing to skip past:\n//_inputPtr += 4;\n_bytesPerChar = 4;\nreturn true;\n}\n\nprivate boolean checkUTF16(int i16)\n{\nif ((i16 & 0xFF00) == 0) { // UTF-16BE\n_bigEndian = true;\n} else if ((i16 & 0x00FF) == 0) { // UTF-16LE\n_bigEndian = false;\n} else { // nope, not  UTF-16\nreturn false;\n}\n// Not BOM (just regular content), nothing to skip past:\n//_inputPtr += 2;\n_bytesPerChar = 2;\nreturn true;\n}\n\n/*\n/**********************************************************\n/* Internal methods, problem reporting\n/**********************************************************\n*/\n\nprivate void reportWeirdUCS4(String type) throws IOException {\nthrow new CharConversionException(\"Unsupported UCS-4 endianness (\"+type+\") detected\");\n}\n\n/*\n/**********************************************************\n/* Internal methods, raw input access\n/**********************************************************\n*/\n\nprotected boolean ensureLoaded(int minimum) throws IOException {\n/* Let's assume here buffer has enough room -- this will always\n* be true for the limited used this method gets\n*/\nint gotten = (_inputEnd - _inputPtr);\nwhile (gotten < minimum) {\nint count;\n\nif (_in == null) { // block source\ncount = -1;\n} else {\ncount = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n}\nif (count < 1) {\nreturn false;\n}\n_inputEnd += count;\ngotten += count;\n}\nreturn true;\n}\n}",
            "method_id": 7
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:createRoot()Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;",
            "method_body": "public static CharsToNameCanonicalizer createRoot() {\n/* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n* based attacks.\n*/\nlong now = System.currentTimeMillis();\n// ensure it's not 0; and might as well require to be odd so:\nint seed = (((int) now) + ((int) (now >>> 32))) | 1;\nreturn createRoot(seed);\n}",
            "method_id": 8
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:constructTextBuffer()Lcom/fasterxml/jackson/core/util/TextBuffer;",
            "method_body": "public TextBuffer constructTextBuffer() {\nreturn new TextBuffer(_bufferRecycler);\n}",
            "method_id": 9
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:createChildObjectContext(II)Lcom/fasterxml/jackson/core/json/JsonReadContext;",
            "method_body": "public JsonReadContext createChildObjectContext(int lineNr, int colNr) {\nJsonReadContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new JsonReadContext(this,\n(_dups == null) ? null : _dups.child(), TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}\nctxt.reset(TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}",
            "method_id": 10
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonStreamContext:<init>()V",
            "method_body": "protected JsonStreamContext() { }\nprotected JsonStreamContext() { }",
            "method_id": 11
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:findName([II)Ljava/lang/String;",
            "method_body": "public String findName(int[] q, int qlen)\n{\n/* This version differs significantly, because longer names do not fit within cell.\n* Rather, they contain hash in main slot, and offset+length to extension area\n* that contains actual quads.\n*/\nif (qlen < 4) { // another sanity check\nif (qlen == 3) {\nreturn findName(q[0], q[1], q[2]);\n}\nif (qlen == 2) {\nreturn findName(q[0], q[1]);\n}\nreturn findName(q[0]);\n}\nfinal int hash = calcHash(q, qlen);\nint offset = _calcOffset(hash);\n\nfinal int[] hashArea = _hashArea;\n\nfinal int len = hashArea[offset+3];\n\nif ((hash == hashArea[offset]) && (len == qlen)) {\n// probable but not guaranteed: verify\nif (_verifyLongName(q, qlen, hashArea[offset+1])) {\nreturn _names[offset >> 2];\n}\n}\nif (len == 0) { // empty slot; unlikely but avoid further lookups if so\nreturn null;\n}\n// secondary?\nint offset2 = _secondaryStart + ((offset >> 3) << 2);\n\nfinal int len2 = hashArea[offset2+3];\nif ((hash == hashArea[offset2]) && (len2 == qlen)) {\nif (_verifyLongName(q, qlen, hashArea[offset2+1])) {\nreturn _names[offset2 >> 2];\n}\n}\nif (len == 0) { // empty slot? Short-circuit if no more spillovers\nreturn null;\n}\nreturn _findSecondary(offset, hash, q, qlen);\n}",
            "method_id": 12
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:<init>(Ljava/lang/String;IZ)V",
            "method_body": "private Feature(boolean defaultState) {\n_mask = (1 << ordinal());\n_defaultState = defaultState;\n}",
            "method_id": 13
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:setCurrentName(Ljava/lang/String;)V",
            "method_body": "public void setCurrentName(String name) throws JsonProcessingException {\n_currentName = name;\nif (_dups != null) { _checkDup(_dups, name); }\n}",
            "method_id": 14
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:parseEscapedName([IIIII)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleUnexpectedValue(i);\n}\n\n\nprivate final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n{\n// // // and this is back to standard nextToken()\n\nString n = _parseName(i);\n_parsingContext.setCurrentName(n);\nfinal boolean match = n.equals(str.getValue());\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n\n// Ok: we must have a value... what is it? Strings are very common, check first:\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn match;\n}\nJsonToken t;\n\nswitch (i) {\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ncase 't':\n_matchToken(\"true\", 1);\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase 'f':\n_matchToken(\"false\", 1);\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchToken(\"null\", 1);\nt = JsonToken.VALUE_NULL;\nbreak;\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ndefault:\nt = _handleUnexpectedValue(i);\n}\n_nextToken = t;\nreturn match;\n}\n\n@Override\npublic String nextTextValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\nreturn _finishAndReturnString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n@Override\npublic int nextIntValue(int defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n@Override\npublic long nextLongValue(long defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n@Override\npublic Boolean nextBooleanValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n\nJsonToken t = nextToken();\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected JsonToken _parsePosNumber(int c) throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n// Ok: we can first just add digit we saw first:\noutBuf[0] = (char) c;\nint intLen = 1;\nint outPtr = 1;\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - 1; // 1 == outPtr\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) { // split across boundary, offline\nreturn _parseNumber2(outBuf, outPtr, false, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, false, intLen);\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n// And there we have it!\nreturn resetInt(false, intLen);\n}\n\nprotected JsonToken _parseNegNumber() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\noutBuf[outPtr++] = '-';\n// Must have something after sign too\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Note: must be followed by a digit\nif (c < INT_0 || c > INT_9) {\nreturn _handleInvalidNumberStart(c, true);\n}\n\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n\n// Ok: we can first just add digit we saw first:\noutBuf[outPtr++] = (char) c;\nint intLen = 1;\n\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - outPtr;\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) {\n// Long enough to be split across boundary, so:\nreturn _parseNumber2(outBuf, outPtr, true, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, true, intLen);\n}\n\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n\n// And there we have it!\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to handle parsing when input is split across buffer boundary\n* (or output is longer than segment used to store it)\n*/\nprivate final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\nint intPartLength) throws IOException\n{\n// Ok, parse the rest\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_textBuffer.setCurrentLength(outPtr);\nreturn resetInt(negative, intPartLength);\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c > INT_9 || c < INT_0) {\nif (c == INT_PERIOD || c == INT_e || c == INT_E) {\nreturn _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n}\nbreak;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n++intPartLength;\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n}\n\n// And there we have it!\nreturn resetInt(negative, intPartLength);\n\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final int _verifyNoLeadingZeroes() throws IOException\n{\n// Ok to have plain \"0\"\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn INT_0;\n}\nint ch = _inputBuffer[_inputPtr] & 0xFF;\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < INT_0 || ch > INT_9) {\nreturn INT_0;\n}\n// [JACKSON-358]: we may want to allow them, after all...\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\nreturn INT_0;\n}\n++_inputPtr; // skip previous zeroes\nif (ch != INT_0) { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\nboolean negative, int integerPartLength) throws IOException\n{\nint fractLen = 0;\nboolean eof = false;\n\n// And then see if we get other parts\nif (c == INT_PERIOD) { // yes, fraction\noutBuf[outPtr++] = (char) c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == INT_e || c == INT_E) { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Not optional, can require that we get one more char\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Likewise, non optional:\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n\n// And there we have it!\nreturn resetFloat(negative, integerPartLength, fractLen, expLen);\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\n// TODO? Handle UTF-8 char decoding for error reporting\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName(int i) throws IOException\n{\nif (i != INT_QUOTE) {\nreturn _handleOddName(i);\n}\n// First: can we optimize out bounds checks?\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\n}\n\n// If so, can also unroll loops nicely\n/* 25-Nov-2008, tatu: This may seem weird, but here we do\n*   NOT want to worry about UTF-8 decoding. Rather, we'll\n*   assume that part is ok (if not it will get caught\n*   later on), and just handle quotes and backslashes here.\n*/\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\nint q = input[_inputPtr++] & 0xFF;\n\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\n}\nif (i == INT_QUOTE) { // 4 byte/char case or broken\nreturn findName(q, 4);\n}\nreturn parseName(q, i, 4);\n}\nif (i == INT_QUOTE) { // 3 byte/char case or broken\nreturn findName(q, 3);\n}\nreturn parseName(q, i, 3);\n}\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\n}\nreturn parseName(q, i, 2);\n}\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\n}\nreturn parseName(q, i, 1);\n}\nif (q == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseName(0, q, 0); // quoting or invalid char\n}\n\nprotected final String parseMediumName(int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Ok, got 5 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 5 bytes\nreturn findName(_quad1, q2, 1);\n}\nreturn parseName(_quad1, q2, i, 1); // quoting or invalid char\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 6 bytes\nreturn findName(_quad1, q2, 2);\n}\nreturn parseName(_quad1, q2, i, 2);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 7 bytes\nreturn findName(_quad1, q2, 3);\n}\nreturn parseName(_quad1, q2, i, 3);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 8 bytes\nreturn findName(_quad1, q2, 4);\n}\nreturn parseName(_quad1, q2, i, 4);\n}\nreturn parseMediumName2(i, q2);\n}\n\n/**\n* @since 2.6\n*/\nprotected final String parseMediumName2(int q3, final int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Got 9 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 9 bytes\nreturn findName(_quad1, q2, q3, 1);\n}\nreturn parseName(_quad1, q2, q3, i, 1);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 10 bytes\nreturn findName(_quad1, q2, q3, 2);\n}\nreturn parseName(_quad1, q2, q3, i, 2);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 11 bytes\nreturn findName(_quad1, q2, q3, 3);\n}\nreturn parseName(_quad1, q2, q3, i, 3);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 12 bytes\nreturn findName(_quad1, q2, q3, 4);\n}\nreturn parseName(_quad1, q2, q3, i, 4);\n}\nreturn parseLongName(i, q2, q3);\n}\n\nprotected final String parseLongName(int q, final int q2, int q3) throws IOException\n{\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\n\n// As explained above, will ignore UTF-8 encoding at this point\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\n\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 1);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 2);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 2);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 3);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 3);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 4);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 4);\n}\n\n// Nope, no end in sight. Need to grow quad array etc\nif (qlen >= _quadBuffer.length) {\n_quadBuffer = growArrayBy(_quadBuffer, qlen);\n}\n_quadBuffer[qlen++] = q;\nq = i;\n}\n\n/* Let's offline if we hit buffer boundary (otherwise would\n* need to [try to] align input, which is bit complicated\n* and may not always be possible)\n*/\nreturn parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n}\n\n/**\n* Method called when not even first 8 bytes are guaranteed\n* to come consequtively. Happens rarely, so this is offlined;\n* plus we'll also do full checks for escaping etc.\n*/\nprotected String slowParseName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n}\n}\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\n}\n\nprivate final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\nreturn parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\nreturn parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n}\n\n/**\n* Slower parsing method which is generally branched to when\n* an escape sequence is detected (or alternatively for long\n* names, one crossing input buffer boundary).\n* Needs to be able to handle more exceptional cases, gets slower,\n* and hance is offlined to a separate method.\n*/\nprotected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\nint currQuadBytes) throws IOException\n{\n/* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n*   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n*   caught later on), and just handle quotes and backslashes here.\n*/\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\n}\n// Unquoted white space?\nif (ch != INT_BACKSLASH) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int ch) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\nchar c = (char) _decodeCharForError(ch);\n_reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n}\n/* Also: note that although we use a different table here,\n* it does NOT handle UTF-8 decoding. It'll just pass those\n* high-bit codes as acceptable for later decoding.\n*/\nfinal int[] codes = CharTypes.getInputCodeUtf8JsNames();\n// Also: must start with a valid character...\nif (codes[ch] != 0) {\n_reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\n\n/* Ok, now; instead of ultra-optimizing parsing here (as with\n* regular JSON names), let's just use the generic \"slow\"\n* variant. Can measure its impact later on if need be\n*/\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\nwhile (true) {\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (codes[ch] != 0) {\nbreak;\n}\n++_inputPtr;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n* main reason being to try to avoid slowing down fast path\n* for valid JSON -- more alternatives, more code, generally\n* bit slower execution.\n*/\nprotected String _parseAposName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\'' for name\");\n}\n}\nint ch = _inputBuffer[_inputPtr++] & 0xFF;\nif (ch == '\\'') { // special case, ''\nreturn \"\";\n}\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\n// Copied from parseEscapedFieldName, with minor mods:\n\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (ch == '\\'') {\nbreak;\n}\n// additional check to skip handling of double-quotes\nif (ch != '\"' && codes[ch] != 0) {\nif (ch != '\\\\') {\n// Unquoted white space?\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/*\n/**********************************************************\n/* Internal methods, symbol (name) handling\n/**********************************************************\n*/\n\nprivate final String findName(int q1, int lastQuadBytes) throws JsonParseException\n{\nq1 = pad(q1, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n{\nq2 = pad(q2, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1, q2);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn addName(_quadBuffer, 2, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n{\nq3 = pad(q3, lastQuadBytes);\nString name = _symbols.findName(q1, q2, q3);\nif (name != null) {\nreturn name;\n}\nint[] quads = _quadBuffer;\nquads[0] = q1;\nquads[1] = q2;\nquads[2] = pad(q3, lastQuadBytes);\nreturn addName(quads, 3, lastQuadBytes);\n}\n\nprivate final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n{\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\n}\nreturn name;\n}\n\n/**\n* This is the main workhorse method used when we take a symbol\n* table miss. It needs to demultiplex individual bytes, decode\n* multi-byte chars (if any), and then construct Name instance\n* and add it to the symbol table.\n*/\nprivate final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n{\n/* Ok: must decode UTF-8 chars. No other validation is\n* needed, since unescaping has been done earlier as necessary\n* (as well as error reporting for unescaped control chars)\n*/\n// 4 bytes per quad, except last one maybe less\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n/* And last one is not correctly aligned (leading zero bytes instead\n* need to shift a bit, instead of trailing). Only need to shift it\n* for UTF-8 decoding; need revert for storage (since key will not\n* be aligned, to optimize lookup speed)\n*/\nint lastQuad;\n\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\n// 8/16/24 bit left shift\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n} else {\nlastQuad = 0;\n}\n\n// Need some working space, TextBuffer works well:\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\n\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\n\nif (ch > 127) { // multi-byte\nint needed;\nif ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\nch &= 0x1F;\nneeded = 1;\n} else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\nch &= 0x0F;\nneeded = 2;\n} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\nch &= 0x07;\nneeded = 3;\n} else { // 5- and 6-byte chars not valid xml chars\n_reportInvalidInitial(ch);\nneeded = ch = 1; // never really gets this far\n}\nif ((ix + needed) > byteLen) {\n_reportInvalidEOF(\" in field name\");\n}\n\n// Ok, always need at least one more:\nint ch2 = quads[ix >> 2]; // current quad, need to shift+mask\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 1) {\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 2) { // 4 bytes? (need surrogates on output)\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2 & 0xFF);\n}\nch = (ch << 6) | (ch2 & 0x3F);\n}\n}\nif (needed > 2) { // surrogate pair? once again, let's output one here, one later on\nch -= 0x10000; // to normalize it starting with 0x0\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) (0xD800 + (ch >> 10));\nch = 0xDC00 | (ch & 0x03FF);\n}\n}\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) ch;\n}\n\n// Ok. Now we have the character array, and can construct the String\nString baseName = new String(cbuf, 0, cix);\n// And finally, un-align if necessary\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\n}\nreturn _symbols.addName(baseName, quads, qlen);\n}\n\n/*\n/**********************************************************\n/* Internal methods, String value parsing\n/**********************************************************\n*/\n\n@Override\nprotected void _finishString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\n_textBuffer.setCurrentLength(outPtr);\nreturn;\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\n}\n\n/**\n* @since 2.6\n*/\nprotected String _finishAndReturnString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\nreturn _textBuffer.setCurrentAndReturn(outPtr);\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\nreturn _textBuffer.contentsAsString();\n}\n\nprivate final void _finishString2(char[] outBuf, int outPtr)\nthrows IOException\n{\nint c;\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ASCII non-funny-char loop:\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nfinal int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nc = _decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\n// Need to be fully UTF-8 aware here:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\nint c;\n\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nint max = _inputEnd;\nif (ptr >= max) {\nloadMoreGuaranteed();\nptr = _inputPtr;\nmax = _inputEnd;\n}\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\n_decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\n_skipUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\n_skipUtf8_3(c);\nbreak;\ncase 4: // 4-byte UTF\n_skipUtf8_4(c);\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n}\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleUnexpectedValue(int c)\nthrows IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (c) {\ncase ']':\ncase '}':\n// Error: neither is valid at this point; valid closers have\n// been handled earlier\n_reportUnexpectedChar(c, \"expected a value\");\ncase '\\'':\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(c)) {\n_reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos()\nthrows IOException\n{\nint c = 0;\n// Otherwise almost verbatim copy of _finishString()\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ascii non-funny-char loop:\nascii_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nint max = _inputEnd;\n{\nint max2 = _inputPtr + (outBuf.length - outPtr);\nif (max2 < max) {\nmax = max2;\n}\n}\nwhile (_inputPtr < max) {\nc = (int) inputBuffer[_inputPtr++] & 0xFF;\nif (c == '\\'' || codes[c] != 0) {\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n}\n\n// Ok: end marker, escape or multi-byte?\nif (c == '\\'') {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nif (c != '\\'') { // marked as special, isn't here\nc = _decodeEscaped();\n}\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n_throwUnquotedSpace(c, \"string value\");\n}\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n\nreturn JsonToken.VALUE_STRING;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\nthrows IOException\n{\nwhile (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nch = _inputBuffer[_inputPtr++];\nString match;\nif (ch == 'N') {\nmatch = neg ? \"-INF\" :\"+INF\";\n} else if (ch == 'n') {\nmatch = neg ? \"-Infinity\" :\"+Infinity\";\n} else {\nbreak;\n}\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\nprotected final void _matchToken(String matchStr, int i) throws IOException\n{\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\n_matchToken2(matchStr, i);\nreturn;\n}\ndo {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n_reportInvalidToken(matchStr.substring(0, i));\n}\n++_inputPtr;\n} while (++i < len);\n\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n_checkMatchEnd(matchStr, i, ch);\n}\n}",
            "method_id": 15
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:<init>(Lcom/fasterxml/jackson/core/util/BufferRecycler;)V",
            "method_body": "public TextBuffer(BufferRecycler allocator) {\n_allocator = allocator;\n}",
            "method_id": 16
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.InternCache:<init>()V",
            "method_body": "private InternCache() { super(MAX_ENTRIES, 0.8f, 4); }\nprivate InternCache() { super(MAX_ENTRIES, 0.8f, 4); }",
            "method_id": 17
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:getMask()I",
            "method_body": "public int getMask() { return (1 << ordinal()); }\npublic int getMask() { return (1 << ordinal()); }",
            "method_id": 18
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserMinimalBase:<init>(I)V",
            "method_body": "protected ParserMinimalBase(int features) { super(features); }\nprotected ParserMinimalBase(int features) { super(features); }",
            "method_id": 19
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:charBufferLength(I)I",
            "method_body": "protected int charBufferLength(int ix) {\nreturn CHAR_BUFFER_LENGTHS[ix];\n}",
            "method_id": 20
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:<init>()V",
            "method_body": "public JsonFactory() { this(null); }\npublic JsonFactory() { this(null); }",
            "method_id": 21
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:addName([III)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleUnexpectedValue(i);\n}\n\n\nprivate final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n{\n// // // and this is back to standard nextToken()\n\nString n = _parseName(i);\n_parsingContext.setCurrentName(n);\nfinal boolean match = n.equals(str.getValue());\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n\n// Ok: we must have a value... what is it? Strings are very common, check first:\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn match;\n}\nJsonToken t;\n\nswitch (i) {\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ncase 't':\n_matchToken(\"true\", 1);\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase 'f':\n_matchToken(\"false\", 1);\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchToken(\"null\", 1);\nt = JsonToken.VALUE_NULL;\nbreak;\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ndefault:\nt = _handleUnexpectedValue(i);\n}\n_nextToken = t;\nreturn match;\n}\n\n@Override\npublic String nextTextValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\nreturn _finishAndReturnString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n@Override\npublic int nextIntValue(int defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n@Override\npublic long nextLongValue(long defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n@Override\npublic Boolean nextBooleanValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n\nJsonToken t = nextToken();\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected JsonToken _parsePosNumber(int c) throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n// Ok: we can first just add digit we saw first:\noutBuf[0] = (char) c;\nint intLen = 1;\nint outPtr = 1;\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - 1; // 1 == outPtr\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) { // split across boundary, offline\nreturn _parseNumber2(outBuf, outPtr, false, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, false, intLen);\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n// And there we have it!\nreturn resetInt(false, intLen);\n}\n\nprotected JsonToken _parseNegNumber() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\noutBuf[outPtr++] = '-';\n// Must have something after sign too\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Note: must be followed by a digit\nif (c < INT_0 || c > INT_9) {\nreturn _handleInvalidNumberStart(c, true);\n}\n\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n\n// Ok: we can first just add digit we saw first:\noutBuf[outPtr++] = (char) c;\nint intLen = 1;\n\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - outPtr;\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) {\n// Long enough to be split across boundary, so:\nreturn _parseNumber2(outBuf, outPtr, true, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, true, intLen);\n}\n\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n\n// And there we have it!\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to handle parsing when input is split across buffer boundary\n* (or output is longer than segment used to store it)\n*/\nprivate final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\nint intPartLength) throws IOException\n{\n// Ok, parse the rest\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_textBuffer.setCurrentLength(outPtr);\nreturn resetInt(negative, intPartLength);\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c > INT_9 || c < INT_0) {\nif (c == INT_PERIOD || c == INT_e || c == INT_E) {\nreturn _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n}\nbreak;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n++intPartLength;\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n}\n\n// And there we have it!\nreturn resetInt(negative, intPartLength);\n\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final int _verifyNoLeadingZeroes() throws IOException\n{\n// Ok to have plain \"0\"\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn INT_0;\n}\nint ch = _inputBuffer[_inputPtr] & 0xFF;\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < INT_0 || ch > INT_9) {\nreturn INT_0;\n}\n// [JACKSON-358]: we may want to allow them, after all...\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\nreturn INT_0;\n}\n++_inputPtr; // skip previous zeroes\nif (ch != INT_0) { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\nboolean negative, int integerPartLength) throws IOException\n{\nint fractLen = 0;\nboolean eof = false;\n\n// And then see if we get other parts\nif (c == INT_PERIOD) { // yes, fraction\noutBuf[outPtr++] = (char) c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == INT_e || c == INT_E) { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Not optional, can require that we get one more char\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Likewise, non optional:\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n\n// And there we have it!\nreturn resetFloat(negative, integerPartLength, fractLen, expLen);\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\n// TODO? Handle UTF-8 char decoding for error reporting\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName(int i) throws IOException\n{\nif (i != INT_QUOTE) {\nreturn _handleOddName(i);\n}\n// First: can we optimize out bounds checks?\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\n}\n\n// If so, can also unroll loops nicely\n/* 25-Nov-2008, tatu: This may seem weird, but here we do\n*   NOT want to worry about UTF-8 decoding. Rather, we'll\n*   assume that part is ok (if not it will get caught\n*   later on), and just handle quotes and backslashes here.\n*/\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\nint q = input[_inputPtr++] & 0xFF;\n\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\n}\nif (i == INT_QUOTE) { // 4 byte/char case or broken\nreturn findName(q, 4);\n}\nreturn parseName(q, i, 4);\n}\nif (i == INT_QUOTE) { // 3 byte/char case or broken\nreturn findName(q, 3);\n}\nreturn parseName(q, i, 3);\n}\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\n}\nreturn parseName(q, i, 2);\n}\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\n}\nreturn parseName(q, i, 1);\n}\nif (q == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseName(0, q, 0); // quoting or invalid char\n}\n\nprotected final String parseMediumName(int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Ok, got 5 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 5 bytes\nreturn findName(_quad1, q2, 1);\n}\nreturn parseName(_quad1, q2, i, 1); // quoting or invalid char\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 6 bytes\nreturn findName(_quad1, q2, 2);\n}\nreturn parseName(_quad1, q2, i, 2);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 7 bytes\nreturn findName(_quad1, q2, 3);\n}\nreturn parseName(_quad1, q2, i, 3);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 8 bytes\nreturn findName(_quad1, q2, 4);\n}\nreturn parseName(_quad1, q2, i, 4);\n}\nreturn parseMediumName2(i, q2);\n}\n\n/**\n* @since 2.6\n*/\nprotected final String parseMediumName2(int q3, final int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Got 9 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 9 bytes\nreturn findName(_quad1, q2, q3, 1);\n}\nreturn parseName(_quad1, q2, q3, i, 1);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 10 bytes\nreturn findName(_quad1, q2, q3, 2);\n}\nreturn parseName(_quad1, q2, q3, i, 2);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 11 bytes\nreturn findName(_quad1, q2, q3, 3);\n}\nreturn parseName(_quad1, q2, q3, i, 3);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 12 bytes\nreturn findName(_quad1, q2, q3, 4);\n}\nreturn parseName(_quad1, q2, q3, i, 4);\n}\nreturn parseLongName(i, q2, q3);\n}\n\nprotected final String parseLongName(int q, final int q2, int q3) throws IOException\n{\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\n\n// As explained above, will ignore UTF-8 encoding at this point\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\n\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 1);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 2);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 2);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 3);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 3);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 4);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 4);\n}\n\n// Nope, no end in sight. Need to grow quad array etc\nif (qlen >= _quadBuffer.length) {\n_quadBuffer = growArrayBy(_quadBuffer, qlen);\n}\n_quadBuffer[qlen++] = q;\nq = i;\n}\n\n/* Let's offline if we hit buffer boundary (otherwise would\n* need to [try to] align input, which is bit complicated\n* and may not always be possible)\n*/\nreturn parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n}\n\n/**\n* Method called when not even first 8 bytes are guaranteed\n* to come consequtively. Happens rarely, so this is offlined;\n* plus we'll also do full checks for escaping etc.\n*/\nprotected String slowParseName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n}\n}\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\n}\n\nprivate final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\nreturn parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\nreturn parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n}\n\n/**\n* Slower parsing method which is generally branched to when\n* an escape sequence is detected (or alternatively for long\n* names, one crossing input buffer boundary).\n* Needs to be able to handle more exceptional cases, gets slower,\n* and hance is offlined to a separate method.\n*/\nprotected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\nint currQuadBytes) throws IOException\n{\n/* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n*   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n*   caught later on), and just handle quotes and backslashes here.\n*/\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\n}\n// Unquoted white space?\nif (ch != INT_BACKSLASH) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int ch) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\nchar c = (char) _decodeCharForError(ch);\n_reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n}\n/* Also: note that although we use a different table here,\n* it does NOT handle UTF-8 decoding. It'll just pass those\n* high-bit codes as acceptable for later decoding.\n*/\nfinal int[] codes = CharTypes.getInputCodeUtf8JsNames();\n// Also: must start with a valid character...\nif (codes[ch] != 0) {\n_reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\n\n/* Ok, now; instead of ultra-optimizing parsing here (as with\n* regular JSON names), let's just use the generic \"slow\"\n* variant. Can measure its impact later on if need be\n*/\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\nwhile (true) {\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (codes[ch] != 0) {\nbreak;\n}\n++_inputPtr;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n* main reason being to try to avoid slowing down fast path\n* for valid JSON -- more alternatives, more code, generally\n* bit slower execution.\n*/\nprotected String _parseAposName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\'' for name\");\n}\n}\nint ch = _inputBuffer[_inputPtr++] & 0xFF;\nif (ch == '\\'') { // special case, ''\nreturn \"\";\n}\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\n// Copied from parseEscapedFieldName, with minor mods:\n\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (ch == '\\'') {\nbreak;\n}\n// additional check to skip handling of double-quotes\nif (ch != '\"' && codes[ch] != 0) {\nif (ch != '\\\\') {\n// Unquoted white space?\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/*\n/**********************************************************\n/* Internal methods, symbol (name) handling\n/**********************************************************\n*/\n\nprivate final String findName(int q1, int lastQuadBytes) throws JsonParseException\n{\nq1 = pad(q1, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n{\nq2 = pad(q2, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1, q2);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn addName(_quadBuffer, 2, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n{\nq3 = pad(q3, lastQuadBytes);\nString name = _symbols.findName(q1, q2, q3);\nif (name != null) {\nreturn name;\n}\nint[] quads = _quadBuffer;\nquads[0] = q1;\nquads[1] = q2;\nquads[2] = pad(q3, lastQuadBytes);\nreturn addName(quads, 3, lastQuadBytes);\n}\n\nprivate final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n{\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\n}\nreturn name;\n}\n\n/**\n* This is the main workhorse method used when we take a symbol\n* table miss. It needs to demultiplex individual bytes, decode\n* multi-byte chars (if any), and then construct Name instance\n* and add it to the symbol table.\n*/\nprivate final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n{\n/* Ok: must decode UTF-8 chars. No other validation is\n* needed, since unescaping has been done earlier as necessary\n* (as well as error reporting for unescaped control chars)\n*/\n// 4 bytes per quad, except last one maybe less\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n/* And last one is not correctly aligned (leading zero bytes instead\n* need to shift a bit, instead of trailing). Only need to shift it\n* for UTF-8 decoding; need revert for storage (since key will not\n* be aligned, to optimize lookup speed)\n*/\nint lastQuad;\n\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\n// 8/16/24 bit left shift\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n} else {\nlastQuad = 0;\n}\n\n// Need some working space, TextBuffer works well:\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\n\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\n\nif (ch > 127) { // multi-byte\nint needed;\nif ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\nch &= 0x1F;\nneeded = 1;\n} else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\nch &= 0x0F;\nneeded = 2;\n} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\nch &= 0x07;\nneeded = 3;\n} else { // 5- and 6-byte chars not valid xml chars\n_reportInvalidInitial(ch);\nneeded = ch = 1; // never really gets this far\n}\nif ((ix + needed) > byteLen) {\n_reportInvalidEOF(\" in field name\");\n}\n\n// Ok, always need at least one more:\nint ch2 = quads[ix >> 2]; // current quad, need to shift+mask\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 1) {\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 2) { // 4 bytes? (need surrogates on output)\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2 & 0xFF);\n}\nch = (ch << 6) | (ch2 & 0x3F);\n}\n}\nif (needed > 2) { // surrogate pair? once again, let's output one here, one later on\nch -= 0x10000; // to normalize it starting with 0x0\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) (0xD800 + (ch >> 10));\nch = 0xDC00 | (ch & 0x03FF);\n}\n}\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) ch;\n}\n\n// Ok. Now we have the character array, and can construct the String\nString baseName = new String(cbuf, 0, cix);\n// And finally, un-align if necessary\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\n}\nreturn _symbols.addName(baseName, quads, qlen);\n}\n\n/*\n/**********************************************************\n/* Internal methods, String value parsing\n/**********************************************************\n*/\n\n@Override\nprotected void _finishString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\n_textBuffer.setCurrentLength(outPtr);\nreturn;\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\n}\n\n/**\n* @since 2.6\n*/\nprotected String _finishAndReturnString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\nreturn _textBuffer.setCurrentAndReturn(outPtr);\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\nreturn _textBuffer.contentsAsString();\n}\n\nprivate final void _finishString2(char[] outBuf, int outPtr)\nthrows IOException\n{\nint c;\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ASCII non-funny-char loop:\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nfinal int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nc = _decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\n// Need to be fully UTF-8 aware here:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\nint c;\n\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nint max = _inputEnd;\nif (ptr >= max) {\nloadMoreGuaranteed();\nptr = _inputPtr;\nmax = _inputEnd;\n}\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\n_decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\n_skipUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\n_skipUtf8_3(c);\nbreak;\ncase 4: // 4-byte UTF\n_skipUtf8_4(c);\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n}\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleUnexpectedValue(int c)\nthrows IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (c) {\ncase ']':\ncase '}':\n// Error: neither is valid at this point; valid closers have\n// been handled earlier\n_reportUnexpectedChar(c, \"expected a value\");\ncase '\\'':\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(c)) {\n_reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos()\nthrows IOException\n{\nint c = 0;\n// Otherwise almost verbatim copy of _finishString()\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ascii non-funny-char loop:\nascii_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nint max = _inputEnd;\n{\nint max2 = _inputPtr + (outBuf.length - outPtr);\nif (max2 < max) {\nmax = max2;\n}\n}\nwhile (_inputPtr < max) {\nc = (int) inputBuffer[_inputPtr++] & 0xFF;\nif (c == '\\'' || codes[c] != 0) {\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n}\n\n// Ok: end marker, escape or multi-byte?\nif (c == '\\'') {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nif (c != '\\'') { // marked as special, isn't here\nc = _decodeEscaped();\n}\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n_throwUnquotedSpace(c, \"string value\");\n}\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n\nreturn JsonToken.VALUE_STRING;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\nthrows IOException\n{\nwhile (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nch = _inputBuffer[_inputPtr++];\nString match;\nif (ch == 'N') {\nmatch = neg ? \"-INF\" :\"+INF\";\n} else if (ch == 'n') {\nmatch = neg ? \"-Infinity\" :\"+Infinity\";\n} else {\nbreak;\n}\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\nprotected final void _matchToken(String matchStr, int i) throws IOException\n{\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\n_matchToken2(matchStr, i);\nreturn;\n}\ndo {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n_reportInvalidToken(matchStr.substring(0, i));\n}\n++_inputPtr;\n} while (++i < len);\n\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n_checkMatchEnd(matchStr, i, ch);\n}\n}",
            "method_id": 22
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator$Feature:enabledByDefault()Z",
            "method_body": "public boolean enabledByDefault() { return _defaultState; }\npublic boolean enabledByDefault() { return _defaultState; }",
            "method_id": 23
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.CharTypes:<clinit>()V",
            "method_body": "private final static char[] HC = \"0123456789ABCDEF\".toCharArray();\nprivate final static byte[] HB;\nstatic {\nint len = HC.length;\nHB = new byte[len];\nfor (int i = 0; i < len; ++i) {\nHB[i] = (byte) HC[i];\n}\n}",
            "method_id": 24
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:_thresholdSize(I)I",
            "method_body": "private static int _thresholdSize(int hashAreaSize) { return hashAreaSize - (hashAreaSize >> 2); }\nprivate static int _thresholdSize(int hashAreaSize) { return hashAreaSize - (hashAreaSize >> 2); }",
            "method_id": 25
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:findName(II)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleUnexpectedValue(i);\n}\n\n\nprivate final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n{\n// // // and this is back to standard nextToken()\n\nString n = _parseName(i);\n_parsingContext.setCurrentName(n);\nfinal boolean match = n.equals(str.getValue());\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n\n// Ok: we must have a value... what is it? Strings are very common, check first:\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn match;\n}\nJsonToken t;\n\nswitch (i) {\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ncase 't':\n_matchToken(\"true\", 1);\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase 'f':\n_matchToken(\"false\", 1);\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchToken(\"null\", 1);\nt = JsonToken.VALUE_NULL;\nbreak;\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ndefault:\nt = _handleUnexpectedValue(i);\n}\n_nextToken = t;\nreturn match;\n}\n\n@Override\npublic String nextTextValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\nreturn _finishAndReturnString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n@Override\npublic int nextIntValue(int defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n@Override\npublic long nextLongValue(long defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n@Override\npublic Boolean nextBooleanValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n\nJsonToken t = nextToken();\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected JsonToken _parsePosNumber(int c) throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n// Ok: we can first just add digit we saw first:\noutBuf[0] = (char) c;\nint intLen = 1;\nint outPtr = 1;\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - 1; // 1 == outPtr\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) { // split across boundary, offline\nreturn _parseNumber2(outBuf, outPtr, false, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, false, intLen);\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n// And there we have it!\nreturn resetInt(false, intLen);\n}\n\nprotected JsonToken _parseNegNumber() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\noutBuf[outPtr++] = '-';\n// Must have something after sign too\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Note: must be followed by a digit\nif (c < INT_0 || c > INT_9) {\nreturn _handleInvalidNumberStart(c, true);\n}\n\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n\n// Ok: we can first just add digit we saw first:\noutBuf[outPtr++] = (char) c;\nint intLen = 1;\n\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - outPtr;\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) {\n// Long enough to be split across boundary, so:\nreturn _parseNumber2(outBuf, outPtr, true, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, true, intLen);\n}\n\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n\n// And there we have it!\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to handle parsing when input is split across buffer boundary\n* (or output is longer than segment used to store it)\n*/\nprivate final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\nint intPartLength) throws IOException\n{\n// Ok, parse the rest\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_textBuffer.setCurrentLength(outPtr);\nreturn resetInt(negative, intPartLength);\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c > INT_9 || c < INT_0) {\nif (c == INT_PERIOD || c == INT_e || c == INT_E) {\nreturn _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n}\nbreak;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n++intPartLength;\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n}\n\n// And there we have it!\nreturn resetInt(negative, intPartLength);\n\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final int _verifyNoLeadingZeroes() throws IOException\n{\n// Ok to have plain \"0\"\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn INT_0;\n}\nint ch = _inputBuffer[_inputPtr] & 0xFF;\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < INT_0 || ch > INT_9) {\nreturn INT_0;\n}\n// [JACKSON-358]: we may want to allow them, after all...\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\nreturn INT_0;\n}\n++_inputPtr; // skip previous zeroes\nif (ch != INT_0) { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\nboolean negative, int integerPartLength) throws IOException\n{\nint fractLen = 0;\nboolean eof = false;\n\n// And then see if we get other parts\nif (c == INT_PERIOD) { // yes, fraction\noutBuf[outPtr++] = (char) c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == INT_e || c == INT_E) { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Not optional, can require that we get one more char\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Likewise, non optional:\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n\n// And there we have it!\nreturn resetFloat(negative, integerPartLength, fractLen, expLen);\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\n// TODO? Handle UTF-8 char decoding for error reporting\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName(int i) throws IOException\n{\nif (i != INT_QUOTE) {\nreturn _handleOddName(i);\n}\n// First: can we optimize out bounds checks?\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\n}\n\n// If so, can also unroll loops nicely\n/* 25-Nov-2008, tatu: This may seem weird, but here we do\n*   NOT want to worry about UTF-8 decoding. Rather, we'll\n*   assume that part is ok (if not it will get caught\n*   later on), and just handle quotes and backslashes here.\n*/\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\nint q = input[_inputPtr++] & 0xFF;\n\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\n}\nif (i == INT_QUOTE) { // 4 byte/char case or broken\nreturn findName(q, 4);\n}\nreturn parseName(q, i, 4);\n}\nif (i == INT_QUOTE) { // 3 byte/char case or broken\nreturn findName(q, 3);\n}\nreturn parseName(q, i, 3);\n}\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\n}\nreturn parseName(q, i, 2);\n}\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\n}\nreturn parseName(q, i, 1);\n}\nif (q == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseName(0, q, 0); // quoting or invalid char\n}\n\nprotected final String parseMediumName(int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Ok, got 5 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 5 bytes\nreturn findName(_quad1, q2, 1);\n}\nreturn parseName(_quad1, q2, i, 1); // quoting or invalid char\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 6 bytes\nreturn findName(_quad1, q2, 2);\n}\nreturn parseName(_quad1, q2, i, 2);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 7 bytes\nreturn findName(_quad1, q2, 3);\n}\nreturn parseName(_quad1, q2, i, 3);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 8 bytes\nreturn findName(_quad1, q2, 4);\n}\nreturn parseName(_quad1, q2, i, 4);\n}\nreturn parseMediumName2(i, q2);\n}\n\n/**\n* @since 2.6\n*/\nprotected final String parseMediumName2(int q3, final int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Got 9 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 9 bytes\nreturn findName(_quad1, q2, q3, 1);\n}\nreturn parseName(_quad1, q2, q3, i, 1);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 10 bytes\nreturn findName(_quad1, q2, q3, 2);\n}\nreturn parseName(_quad1, q2, q3, i, 2);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 11 bytes\nreturn findName(_quad1, q2, q3, 3);\n}\nreturn parseName(_quad1, q2, q3, i, 3);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 12 bytes\nreturn findName(_quad1, q2, q3, 4);\n}\nreturn parseName(_quad1, q2, q3, i, 4);\n}\nreturn parseLongName(i, q2, q3);\n}\n\nprotected final String parseLongName(int q, final int q2, int q3) throws IOException\n{\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\n\n// As explained above, will ignore UTF-8 encoding at this point\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\n\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 1);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 2);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 2);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 3);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 3);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 4);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 4);\n}\n\n// Nope, no end in sight. Need to grow quad array etc\nif (qlen >= _quadBuffer.length) {\n_quadBuffer = growArrayBy(_quadBuffer, qlen);\n}\n_quadBuffer[qlen++] = q;\nq = i;\n}\n\n/* Let's offline if we hit buffer boundary (otherwise would\n* need to [try to] align input, which is bit complicated\n* and may not always be possible)\n*/\nreturn parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n}\n\n/**\n* Method called when not even first 8 bytes are guaranteed\n* to come consequtively. Happens rarely, so this is offlined;\n* plus we'll also do full checks for escaping etc.\n*/\nprotected String slowParseName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n}\n}\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\n}\n\nprivate final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\nreturn parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\nreturn parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n}\n\n/**\n* Slower parsing method which is generally branched to when\n* an escape sequence is detected (or alternatively for long\n* names, one crossing input buffer boundary).\n* Needs to be able to handle more exceptional cases, gets slower,\n* and hance is offlined to a separate method.\n*/\nprotected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\nint currQuadBytes) throws IOException\n{\n/* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n*   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n*   caught later on), and just handle quotes and backslashes here.\n*/\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\n}\n// Unquoted white space?\nif (ch != INT_BACKSLASH) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int ch) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\nchar c = (char) _decodeCharForError(ch);\n_reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n}\n/* Also: note that although we use a different table here,\n* it does NOT handle UTF-8 decoding. It'll just pass those\n* high-bit codes as acceptable for later decoding.\n*/\nfinal int[] codes = CharTypes.getInputCodeUtf8JsNames();\n// Also: must start with a valid character...\nif (codes[ch] != 0) {\n_reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\n\n/* Ok, now; instead of ultra-optimizing parsing here (as with\n* regular JSON names), let's just use the generic \"slow\"\n* variant. Can measure its impact later on if need be\n*/\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\nwhile (true) {\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (codes[ch] != 0) {\nbreak;\n}\n++_inputPtr;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n* main reason being to try to avoid slowing down fast path\n* for valid JSON -- more alternatives, more code, generally\n* bit slower execution.\n*/\nprotected String _parseAposName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\'' for name\");\n}\n}\nint ch = _inputBuffer[_inputPtr++] & 0xFF;\nif (ch == '\\'') { // special case, ''\nreturn \"\";\n}\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\n// Copied from parseEscapedFieldName, with minor mods:\n\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (ch == '\\'') {\nbreak;\n}\n// additional check to skip handling of double-quotes\nif (ch != '\"' && codes[ch] != 0) {\nif (ch != '\\\\') {\n// Unquoted white space?\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/*\n/**********************************************************\n/* Internal methods, symbol (name) handling\n/**********************************************************\n*/\n\nprivate final String findName(int q1, int lastQuadBytes) throws JsonParseException\n{\nq1 = pad(q1, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n{\nq2 = pad(q2, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1, q2);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn addName(_quadBuffer, 2, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n{\nq3 = pad(q3, lastQuadBytes);\nString name = _symbols.findName(q1, q2, q3);\nif (name != null) {\nreturn name;\n}\nint[] quads = _quadBuffer;\nquads[0] = q1;\nquads[1] = q2;\nquads[2] = pad(q3, lastQuadBytes);\nreturn addName(quads, 3, lastQuadBytes);\n}\n\nprivate final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n{\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\n}\nreturn name;\n}\n\n/**\n* This is the main workhorse method used when we take a symbol\n* table miss. It needs to demultiplex individual bytes, decode\n* multi-byte chars (if any), and then construct Name instance\n* and add it to the symbol table.\n*/\nprivate final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n{\n/* Ok: must decode UTF-8 chars. No other validation is\n* needed, since unescaping has been done earlier as necessary\n* (as well as error reporting for unescaped control chars)\n*/\n// 4 bytes per quad, except last one maybe less\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n/* And last one is not correctly aligned (leading zero bytes instead\n* need to shift a bit, instead of trailing). Only need to shift it\n* for UTF-8 decoding; need revert for storage (since key will not\n* be aligned, to optimize lookup speed)\n*/\nint lastQuad;\n\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\n// 8/16/24 bit left shift\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n} else {\nlastQuad = 0;\n}\n\n// Need some working space, TextBuffer works well:\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\n\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\n\nif (ch > 127) { // multi-byte\nint needed;\nif ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\nch &= 0x1F;\nneeded = 1;\n} else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\nch &= 0x0F;\nneeded = 2;\n} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\nch &= 0x07;\nneeded = 3;\n} else { // 5- and 6-byte chars not valid xml chars\n_reportInvalidInitial(ch);\nneeded = ch = 1; // never really gets this far\n}\nif ((ix + needed) > byteLen) {\n_reportInvalidEOF(\" in field name\");\n}\n\n// Ok, always need at least one more:\nint ch2 = quads[ix >> 2]; // current quad, need to shift+mask\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 1) {\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 2) { // 4 bytes? (need surrogates on output)\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2 & 0xFF);\n}\nch = (ch << 6) | (ch2 & 0x3F);\n}\n}\nif (needed > 2) { // surrogate pair? once again, let's output one here, one later on\nch -= 0x10000; // to normalize it starting with 0x0\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) (0xD800 + (ch >> 10));\nch = 0xDC00 | (ch & 0x03FF);\n}\n}\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) ch;\n}\n\n// Ok. Now we have the character array, and can construct the String\nString baseName = new String(cbuf, 0, cix);\n// And finally, un-align if necessary\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\n}\nreturn _symbols.addName(baseName, quads, qlen);\n}\n\n/*\n/**********************************************************\n/* Internal methods, String value parsing\n/**********************************************************\n*/\n\n@Override\nprotected void _finishString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\n_textBuffer.setCurrentLength(outPtr);\nreturn;\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\n}\n\n/**\n* @since 2.6\n*/\nprotected String _finishAndReturnString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\nreturn _textBuffer.setCurrentAndReturn(outPtr);\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\nreturn _textBuffer.contentsAsString();\n}\n\nprivate final void _finishString2(char[] outBuf, int outPtr)\nthrows IOException\n{\nint c;\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ASCII non-funny-char loop:\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nfinal int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nc = _decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\n// Need to be fully UTF-8 aware here:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\nint c;\n\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nint max = _inputEnd;\nif (ptr >= max) {\nloadMoreGuaranteed();\nptr = _inputPtr;\nmax = _inputEnd;\n}\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\n_decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\n_skipUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\n_skipUtf8_3(c);\nbreak;\ncase 4: // 4-byte UTF\n_skipUtf8_4(c);\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n}\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleUnexpectedValue(int c)\nthrows IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (c) {\ncase ']':\ncase '}':\n// Error: neither is valid at this point; valid closers have\n// been handled earlier\n_reportUnexpectedChar(c, \"expected a value\");\ncase '\\'':\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(c)) {\n_reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos()\nthrows IOException\n{\nint c = 0;\n// Otherwise almost verbatim copy of _finishString()\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ascii non-funny-char loop:\nascii_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nint max = _inputEnd;\n{\nint max2 = _inputPtr + (outBuf.length - outPtr);\nif (max2 < max) {\nmax = max2;\n}\n}\nwhile (_inputPtr < max) {\nc = (int) inputBuffer[_inputPtr++] & 0xFF;\nif (c == '\\'' || codes[c] != 0) {\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n}\n\n// Ok: end marker, escape or multi-byte?\nif (c == '\\'') {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nif (c != '\\'') { // marked as special, isn't here\nc = _decodeEscaped();\n}\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n_throwUnquotedSpace(c, \"string value\");\n}\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n\nreturn JsonToken.VALUE_STRING;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\nthrows IOException\n{\nwhile (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nch = _inputBuffer[_inputPtr++];\nString match;\nif (ch == 'N') {\nmatch = neg ? \"-INF\" :\"+INF\";\n} else if (ch == 'n') {\nmatch = neg ? \"-Infinity\" :\"+Infinity\";\n} else {\nbreak;\n}\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\nprotected final void _matchToken(String matchStr, int i) throws IOException\n{\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\n_matchToken2(matchStr, i);\nreturn;\n}\ndo {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n_reportInvalidToken(matchStr.substring(0, i));\n}\n++_inputPtr;\n} while (++i < len);\n\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n_checkMatchEnd(matchStr, i, ch);\n}\n}",
            "method_id": 26
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:<init>(Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer;ZIZLcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer$TableInfo;)V",
            "method_body": "private ByteQuadsCanonicalizer(ByteQuadsCanonicalizer parent, boolean intern,\nint seed, boolean failOnDoS, TableInfo state)\n{\n_parent = parent;\n_seed = seed;\n_intern = intern;\n_failOnDoS = failOnDoS;\n_tableInfo = null; // not used by child tables\n\n// Then copy shared state\n_count = state.count;\n_hashSize = state.size;\n_secondaryStart = _hashSize << 2; // right after primary area\n_tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n_tertiaryShift = state.tertiaryShift;\n\n_hashArea = state.mainHash;\n_names = state.names;\n\n_spilloverEnd = state.spilloverEnd;\n_longNameOffset = state.longNameOffset;\n\n// and then set other state to reflect sharing status\n_needRehash = false;\n_hashShared = true;\n}",
            "method_id": 27
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:makeOrphan(I)Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;",
            "method_body": "private CharsToNameCanonicalizer makeOrphan(int seed) {\nreturn new CharsToNameCanonicalizer(null, -1, _symbols, _buckets, _size, seed, _longestCollisionList);\n}",
            "method_id": 28
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:makeChild(I)Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer;",
            "method_body": "public ByteQuadsCanonicalizer makeChild(int flags) {\nreturn new ByteQuadsCanonicalizer(this,\nJsonFactory.Feature.INTERN_FIELD_NAMES.enabledIn(flags),\n_seed,\nJsonFactory.Feature.FAIL_ON_SYMBOL_HASH_OVERFLOW.enabledIn(flags),\n_tableInfo.get());\n}",
            "method_id": 29
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:pad(II)I",
            "method_body": "private final static int pad(int q, int bytes) {\nreturn (bytes == 4) ? q : (q | (-1 << (bytes << 3)));\n}",
            "method_id": 30
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:<init>(Lcom/fasterxml/jackson/core/util/BufferRecycler;Ljava/lang/Object;Z)V",
            "method_body": "public IOContext(BufferRecycler br, Object sourceRef, boolean managedResource)\n{\n_bufferRecycler = br;\n_sourceRef = sourceRef;\n_managedResource = managedResource;\n}",
            "method_id": 31
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:<clinit>()V",
            "method_body": "protected byte[] _binaryValue;\n\n/*\n/**********************************************************\n/* Constants and fields of former 'JsonNumericParserBase'\n/**********************************************************\n*/\n\nfinal protected static int NR_UNKNOWN = 0;\n\n// First, integer types\n\nfinal protected static int NR_INT = 0x0001;\nfinal protected static int NR_LONG = 0x0002;\nfinal protected static int NR_BIGINT = 0x0004;\n\n// And then floating point types\n\nfinal protected static int NR_DOUBLE = 0x008;\nfinal protected static int NR_BIGDECIMAL = 0x0010;\n\n// Also, we need some numeric constants\n\nfinal static BigInteger BI_MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE);\nfinal static BigInteger BI_MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE);\n\nfinal static BigInteger BI_MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);\nfinal static BigInteger BI_MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);\n\nfinal static BigDecimal BD_MIN_LONG = new BigDecimal(BI_MIN_LONG);\nfinal static BigDecimal BD_MAX_LONG = new BigDecimal(BI_MAX_LONG);\n\nfinal static BigDecimal BD_MIN_INT = new BigDecimal(BI_MIN_INT);\nfinal static BigDecimal BD_MAX_INT = new BigDecimal(BI_MAX_INT);\n\nfinal static long MIN_INT_L = (long) Integer.MIN_VALUE;\nfinal static long MAX_INT_L = (long) Integer.MAX_VALUE;\n\n// These are not very accurate, but have to do... (for bounds checks)\n\nfinal static double MIN_LONG_D = (double) Long.MIN_VALUE;\nfinal static double MAX_LONG_D = (double) Long.MAX_VALUE;\n\nfinal static double MIN_INT_D = (double) Integer.MIN_VALUE;\nfinal static double MAX_INT_D = (double) Integer.MAX_VALUE;\n\n// Digits, numeric\nfinal protected static int INT_0 = '0';\nfinal protected static int INT_9 = '9';\n\nfinal protected static int INT_MINUS = '-';\nfinal protected static int INT_PLUS = '+';\n\nfinal protected static char CHAR_NULL = '\\0';\n\n// Numeric value holders: multiple fields used for\n// for efficiency\n\n/**\n* Bitfield that indicates which numeric representations\n* have been calculated for the current type\n*/\nprotected int _numTypesValid = NR_UNKNOWN;\n\n// First primitives\n\nprotected int _numberInt;\n\nprotected long _numberLong;\n\nprotected double _numberDouble;\n\n// And then object types\n\nprotected BigInteger _numberBigInt;\n\nprotected BigDecimal _numberBigDecimal;\n\n// And then other information about value itself\n\n/**\n* Flag that indicates whether numeric value has a negative\n* value. That is, whether its textual representation starts\n* with minus character.\n*/\nprotected boolean _numberNegative;\n\n/**\n* Length of integer part of the number, in characters\n*/\nprotected int _intLength;\n\n/**\n* Length of the fractional part (not including decimal\n* point or exponent), in characters.\n* Not used for  pure integer values.\n*/\nprotected int _fractLength;\n\n/**\n* Length of the exponent part of the number, if any, not\n* including 'e' marker or sign, just digits.\n* Not used for  pure integer values.\n*/\nprotected int _expLength;\n\n/*\n/**********************************************************\n/* Life-cycle\n/**********************************************************\n*/\n\nprotected ParserBase(IOContext ctxt, int features) {\nsuper(features);\n_ioContext = ctxt;\n_textBuffer = ctxt.constructTextBuffer();\nDupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n? DupDetector.rootDetector(this) : null;\n_parsingContext = JsonReadContext.createRootContext(dups);\n}",
            "method_id": 32
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:expectComma()Z",
            "method_body": "public boolean expectComma() {\n/* Assumption here is that we will be getting a value (at least\n* before calling this method again), and\n* so will auto-increment index to avoid having to do another call\n*/\nint ix = ++_index; // starts from -1\nreturn (_type != TYPE_ROOT && ix > 0);\n}",
            "method_id": 33
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:createRoot()Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer;",
            "method_body": "public static ByteQuadsCanonicalizer createRoot() {\n/* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n* based attacks.\n*/\nlong now = System.currentTimeMillis();\n// ensure it's not 0; and might as well require to be odd so:\nint seed = (((int) now) + ((int) (now >>> 32))) | 1;\nreturn createRoot(seed);\n}",
            "method_id": 34
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:calcHash([II)I",
            "method_body": "public int calcHash(int[] q, int qlen)\n{\nif (qlen < 4) {\nthrow new IllegalArgumentException();\n}\n/* And then change handling again for \"multi-quad\" case; mostly\n* to make calculation of collisions less fun. For example,\n* add seed bit later in the game, and switch plus/xor around,\n* use different shift lengths.\n*/\nint hash = q[0] ^ _seed;\nhash += (hash >>> 9);\nhash += q[1];\nhash += (hash >>> 15);\nhash *= MULT;\nhash ^= q[2];\nhash += (hash >>> 4);\n\nfor (int i = 3; i < qlen; ++i) {\nint next = q[i];\nnext = next ^ (next >> 21);\nhash += next;\n}\nhash *= MULT2;\n\n// and finally shuffle some more once done\nhash += (hash >>> 19);\nhash ^= (hash << 5);\nreturn hash;\n}",
            "method_id": 35
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:parseLongName(III)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleUnexpectedValue(i);\n}\n\n\nprivate final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n{\n// // // and this is back to standard nextToken()\n\nString n = _parseName(i);\n_parsingContext.setCurrentName(n);\nfinal boolean match = n.equals(str.getValue());\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n\n// Ok: we must have a value... what is it? Strings are very common, check first:\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn match;\n}\nJsonToken t;\n\nswitch (i) {\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ncase 't':\n_matchToken(\"true\", 1);\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase 'f':\n_matchToken(\"false\", 1);\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchToken(\"null\", 1);\nt = JsonToken.VALUE_NULL;\nbreak;\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ndefault:\nt = _handleUnexpectedValue(i);\n}\n_nextToken = t;\nreturn match;\n}\n\n@Override\npublic String nextTextValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\nreturn _finishAndReturnString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n@Override\npublic int nextIntValue(int defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n@Override\npublic long nextLongValue(long defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n@Override\npublic Boolean nextBooleanValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n\nJsonToken t = nextToken();\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected JsonToken _parsePosNumber(int c) throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n// Ok: we can first just add digit we saw first:\noutBuf[0] = (char) c;\nint intLen = 1;\nint outPtr = 1;\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - 1; // 1 == outPtr\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) { // split across boundary, offline\nreturn _parseNumber2(outBuf, outPtr, false, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, false, intLen);\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n// And there we have it!\nreturn resetInt(false, intLen);\n}\n\nprotected JsonToken _parseNegNumber() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\noutBuf[outPtr++] = '-';\n// Must have something after sign too\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Note: must be followed by a digit\nif (c < INT_0 || c > INT_9) {\nreturn _handleInvalidNumberStart(c, true);\n}\n\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n\n// Ok: we can first just add digit we saw first:\noutBuf[outPtr++] = (char) c;\nint intLen = 1;\n\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - outPtr;\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) {\n// Long enough to be split across boundary, so:\nreturn _parseNumber2(outBuf, outPtr, true, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, true, intLen);\n}\n\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n\n// And there we have it!\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to handle parsing when input is split across buffer boundary\n* (or output is longer than segment used to store it)\n*/\nprivate final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\nint intPartLength) throws IOException\n{\n// Ok, parse the rest\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_textBuffer.setCurrentLength(outPtr);\nreturn resetInt(negative, intPartLength);\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c > INT_9 || c < INT_0) {\nif (c == INT_PERIOD || c == INT_e || c == INT_E) {\nreturn _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n}\nbreak;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n++intPartLength;\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n}\n\n// And there we have it!\nreturn resetInt(negative, intPartLength);\n\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final int _verifyNoLeadingZeroes() throws IOException\n{\n// Ok to have plain \"0\"\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn INT_0;\n}\nint ch = _inputBuffer[_inputPtr] & 0xFF;\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < INT_0 || ch > INT_9) {\nreturn INT_0;\n}\n// [JACKSON-358]: we may want to allow them, after all...\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\nreturn INT_0;\n}\n++_inputPtr; // skip previous zeroes\nif (ch != INT_0) { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\nboolean negative, int integerPartLength) throws IOException\n{\nint fractLen = 0;\nboolean eof = false;\n\n// And then see if we get other parts\nif (c == INT_PERIOD) { // yes, fraction\noutBuf[outPtr++] = (char) c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == INT_e || c == INT_E) { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Not optional, can require that we get one more char\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Likewise, non optional:\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n\n// And there we have it!\nreturn resetFloat(negative, integerPartLength, fractLen, expLen);\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\n// TODO? Handle UTF-8 char decoding for error reporting\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName(int i) throws IOException\n{\nif (i != INT_QUOTE) {\nreturn _handleOddName(i);\n}\n// First: can we optimize out bounds checks?\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\n}\n\n// If so, can also unroll loops nicely\n/* 25-Nov-2008, tatu: This may seem weird, but here we do\n*   NOT want to worry about UTF-8 decoding. Rather, we'll\n*   assume that part is ok (if not it will get caught\n*   later on), and just handle quotes and backslashes here.\n*/\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\nint q = input[_inputPtr++] & 0xFF;\n\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\n}\nif (i == INT_QUOTE) { // 4 byte/char case or broken\nreturn findName(q, 4);\n}\nreturn parseName(q, i, 4);\n}\nif (i == INT_QUOTE) { // 3 byte/char case or broken\nreturn findName(q, 3);\n}\nreturn parseName(q, i, 3);\n}\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\n}\nreturn parseName(q, i, 2);\n}\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\n}\nreturn parseName(q, i, 1);\n}\nif (q == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseName(0, q, 0); // quoting or invalid char\n}\n\nprotected final String parseMediumName(int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Ok, got 5 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 5 bytes\nreturn findName(_quad1, q2, 1);\n}\nreturn parseName(_quad1, q2, i, 1); // quoting or invalid char\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 6 bytes\nreturn findName(_quad1, q2, 2);\n}\nreturn parseName(_quad1, q2, i, 2);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 7 bytes\nreturn findName(_quad1, q2, 3);\n}\nreturn parseName(_quad1, q2, i, 3);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 8 bytes\nreturn findName(_quad1, q2, 4);\n}\nreturn parseName(_quad1, q2, i, 4);\n}\nreturn parseMediumName2(i, q2);\n}\n\n/**\n* @since 2.6\n*/\nprotected final String parseMediumName2(int q3, final int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Got 9 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 9 bytes\nreturn findName(_quad1, q2, q3, 1);\n}\nreturn parseName(_quad1, q2, q3, i, 1);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 10 bytes\nreturn findName(_quad1, q2, q3, 2);\n}\nreturn parseName(_quad1, q2, q3, i, 2);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 11 bytes\nreturn findName(_quad1, q2, q3, 3);\n}\nreturn parseName(_quad1, q2, q3, i, 3);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 12 bytes\nreturn findName(_quad1, q2, q3, 4);\n}\nreturn parseName(_quad1, q2, q3, i, 4);\n}\nreturn parseLongName(i, q2, q3);\n}\n\nprotected final String parseLongName(int q, final int q2, int q3) throws IOException\n{\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\n\n// As explained above, will ignore UTF-8 encoding at this point\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\n\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 1);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 2);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 2);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 3);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 3);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 4);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 4);\n}\n\n// Nope, no end in sight. Need to grow quad array etc\nif (qlen >= _quadBuffer.length) {\n_quadBuffer = growArrayBy(_quadBuffer, qlen);\n}\n_quadBuffer[qlen++] = q;\nq = i;\n}\n\n/* Let's offline if we hit buffer boundary (otherwise would\n* need to [try to] align input, which is bit complicated\n* and may not always be possible)\n*/\nreturn parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n}\n\n/**\n* Method called when not even first 8 bytes are guaranteed\n* to come consequtively. Happens rarely, so this is offlined;\n* plus we'll also do full checks for escaping etc.\n*/\nprotected String slowParseName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n}\n}\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\n}\n\nprivate final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\nreturn parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\nreturn parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n}\n\n/**\n* Slower parsing method which is generally branched to when\n* an escape sequence is detected (or alternatively for long\n* names, one crossing input buffer boundary).\n* Needs to be able to handle more exceptional cases, gets slower,\n* and hance is offlined to a separate method.\n*/\nprotected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\nint currQuadBytes) throws IOException\n{\n/* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n*   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n*   caught later on), and just handle quotes and backslashes here.\n*/\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\n}\n// Unquoted white space?\nif (ch != INT_BACKSLASH) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int ch) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\nchar c = (char) _decodeCharForError(ch);\n_reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n}\n/* Also: note that although we use a different table here,\n* it does NOT handle UTF-8 decoding. It'll just pass those\n* high-bit codes as acceptable for later decoding.\n*/\nfinal int[] codes = CharTypes.getInputCodeUtf8JsNames();\n// Also: must start with a valid character...\nif (codes[ch] != 0) {\n_reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\n\n/* Ok, now; instead of ultra-optimizing parsing here (as with\n* regular JSON names), let's just use the generic \"slow\"\n* variant. Can measure its impact later on if need be\n*/\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\nwhile (true) {\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (codes[ch] != 0) {\nbreak;\n}\n++_inputPtr;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n* main reason being to try to avoid slowing down fast path\n* for valid JSON -- more alternatives, more code, generally\n* bit slower execution.\n*/\nprotected String _parseAposName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\'' for name\");\n}\n}\nint ch = _inputBuffer[_inputPtr++] & 0xFF;\nif (ch == '\\'') { // special case, ''\nreturn \"\";\n}\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\n// Copied from parseEscapedFieldName, with minor mods:\n\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (ch == '\\'') {\nbreak;\n}\n// additional check to skip handling of double-quotes\nif (ch != '\"' && codes[ch] != 0) {\nif (ch != '\\\\') {\n// Unquoted white space?\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/*\n/**********************************************************\n/* Internal methods, symbol (name) handling\n/**********************************************************\n*/\n\nprivate final String findName(int q1, int lastQuadBytes) throws JsonParseException\n{\nq1 = pad(q1, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n{\nq2 = pad(q2, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1, q2);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn addName(_quadBuffer, 2, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n{\nq3 = pad(q3, lastQuadBytes);\nString name = _symbols.findName(q1, q2, q3);\nif (name != null) {\nreturn name;\n}\nint[] quads = _quadBuffer;\nquads[0] = q1;\nquads[1] = q2;\nquads[2] = pad(q3, lastQuadBytes);\nreturn addName(quads, 3, lastQuadBytes);\n}\n\nprivate final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n{\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\n}\nreturn name;\n}\n\n/**\n* This is the main workhorse method used when we take a symbol\n* table miss. It needs to demultiplex individual bytes, decode\n* multi-byte chars (if any), and then construct Name instance\n* and add it to the symbol table.\n*/\nprivate final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n{\n/* Ok: must decode UTF-8 chars. No other validation is\n* needed, since unescaping has been done earlier as necessary\n* (as well as error reporting for unescaped control chars)\n*/\n// 4 bytes per quad, except last one maybe less\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n/* And last one is not correctly aligned (leading zero bytes instead\n* need to shift a bit, instead of trailing). Only need to shift it\n* for UTF-8 decoding; need revert for storage (since key will not\n* be aligned, to optimize lookup speed)\n*/\nint lastQuad;\n\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\n// 8/16/24 bit left shift\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n} else {\nlastQuad = 0;\n}\n\n// Need some working space, TextBuffer works well:\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\n\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\n\nif (ch > 127) { // multi-byte\nint needed;\nif ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\nch &= 0x1F;\nneeded = 1;\n} else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\nch &= 0x0F;\nneeded = 2;\n} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\nch &= 0x07;\nneeded = 3;\n} else { // 5- and 6-byte chars not valid xml chars\n_reportInvalidInitial(ch);\nneeded = ch = 1; // never really gets this far\n}\nif ((ix + needed) > byteLen) {\n_reportInvalidEOF(\" in field name\");\n}\n\n// Ok, always need at least one more:\nint ch2 = quads[ix >> 2]; // current quad, need to shift+mask\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 1) {\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 2) { // 4 bytes? (need surrogates on output)\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2 & 0xFF);\n}\nch = (ch << 6) | (ch2 & 0x3F);\n}\n}\nif (needed > 2) { // surrogate pair? once again, let's output one here, one later on\nch -= 0x10000; // to normalize it starting with 0x0\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) (0xD800 + (ch >> 10));\nch = 0xDC00 | (ch & 0x03FF);\n}\n}\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) ch;\n}\n\n// Ok. Now we have the character array, and can construct the String\nString baseName = new String(cbuf, 0, cix);\n// And finally, un-align if necessary\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\n}\nreturn _symbols.addName(baseName, quads, qlen);\n}\n\n/*\n/**********************************************************\n/* Internal methods, String value parsing\n/**********************************************************\n*/\n\n@Override\nprotected void _finishString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\n_textBuffer.setCurrentLength(outPtr);\nreturn;\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\n}\n\n/**\n* @since 2.6\n*/\nprotected String _finishAndReturnString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\nreturn _textBuffer.setCurrentAndReturn(outPtr);\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\nreturn _textBuffer.contentsAsString();\n}\n\nprivate final void _finishString2(char[] outBuf, int outPtr)\nthrows IOException\n{\nint c;\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ASCII non-funny-char loop:\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nfinal int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nc = _decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\n// Need to be fully UTF-8 aware here:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\nint c;\n\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nint max = _inputEnd;\nif (ptr >= max) {\nloadMoreGuaranteed();\nptr = _inputPtr;\nmax = _inputEnd;\n}\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\n_decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\n_skipUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\n_skipUtf8_3(c);\nbreak;\ncase 4: // 4-byte UTF\n_skipUtf8_4(c);\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n}\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleUnexpectedValue(int c)\nthrows IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (c) {\ncase ']':\ncase '}':\n// Error: neither is valid at this point; valid closers have\n// been handled earlier\n_reportUnexpectedChar(c, \"expected a value\");\ncase '\\'':\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(c)) {\n_reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos()\nthrows IOException\n{\nint c = 0;\n// Otherwise almost verbatim copy of _finishString()\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ascii non-funny-char loop:\nascii_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nint max = _inputEnd;\n{\nint max2 = _inputPtr + (outBuf.length - outPtr);\nif (max2 < max) {\nmax = max2;\n}\n}\nwhile (_inputPtr < max) {\nc = (int) inputBuffer[_inputPtr++] & 0xFF;\nif (c == '\\'' || codes[c] != 0) {\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n}\n\n// Ok: end marker, escape or multi-byte?\nif (c == '\\'') {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nif (c != '\\'') { // marked as special, isn't here\nc = _decodeEscaped();\n}\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n_throwUnquotedSpace(c, \"string value\");\n}\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n\nreturn JsonToken.VALUE_STRING;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\nthrows IOException\n{\nwhile (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nch = _inputBuffer[_inputPtr++];\nString match;\nif (ch == 'N') {\nmatch = neg ? \"-INF\" :\"+INF\";\n} else if (ch == 'n') {\nmatch = neg ? \"-Infinity\" :\"+Infinity\";\n} else {\nbreak;\n}\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\nprotected final void _matchToken(String matchStr, int i) throws IOException\n{\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\n_matchToken2(matchStr, i);\nreturn;\n}\ndo {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n_reportInvalidToken(matchStr.substring(0, i));\n}\n++_inputPtr;\n} while (++i < len);\n\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n_checkMatchEnd(matchStr, i, ch);\n}\n}",
            "method_id": 36
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_parseName(I)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleUnexpectedValue(i);\n}\n\n\nprivate final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n{\n// // // and this is back to standard nextToken()\n\nString n = _parseName(i);\n_parsingContext.setCurrentName(n);\nfinal boolean match = n.equals(str.getValue());\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n\n// Ok: we must have a value... what is it? Strings are very common, check first:\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn match;\n}\nJsonToken t;\n\nswitch (i) {\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ncase 't':\n_matchToken(\"true\", 1);\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase 'f':\n_matchToken(\"false\", 1);\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchToken(\"null\", 1);\nt = JsonToken.VALUE_NULL;\nbreak;\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ndefault:\nt = _handleUnexpectedValue(i);\n}\n_nextToken = t;\nreturn match;\n}\n\n@Override\npublic String nextTextValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\nreturn _finishAndReturnString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n@Override\npublic int nextIntValue(int defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n@Override\npublic long nextLongValue(long defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n@Override\npublic Boolean nextBooleanValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n\nJsonToken t = nextToken();\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected JsonToken _parsePosNumber(int c) throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n// Ok: we can first just add digit we saw first:\noutBuf[0] = (char) c;\nint intLen = 1;\nint outPtr = 1;\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - 1; // 1 == outPtr\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) { // split across boundary, offline\nreturn _parseNumber2(outBuf, outPtr, false, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, false, intLen);\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n// And there we have it!\nreturn resetInt(false, intLen);\n}\n\nprotected JsonToken _parseNegNumber() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\noutBuf[outPtr++] = '-';\n// Must have something after sign too\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Note: must be followed by a digit\nif (c < INT_0 || c > INT_9) {\nreturn _handleInvalidNumberStart(c, true);\n}\n\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n\n// Ok: we can first just add digit we saw first:\noutBuf[outPtr++] = (char) c;\nint intLen = 1;\n\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - outPtr;\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) {\n// Long enough to be split across boundary, so:\nreturn _parseNumber2(outBuf, outPtr, true, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, true, intLen);\n}\n\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n\n// And there we have it!\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to handle parsing when input is split across buffer boundary\n* (or output is longer than segment used to store it)\n*/\nprivate final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\nint intPartLength) throws IOException\n{\n// Ok, parse the rest\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_textBuffer.setCurrentLength(outPtr);\nreturn resetInt(negative, intPartLength);\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c > INT_9 || c < INT_0) {\nif (c == INT_PERIOD || c == INT_e || c == INT_E) {\nreturn _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n}\nbreak;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n++intPartLength;\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n}\n\n// And there we have it!\nreturn resetInt(negative, intPartLength);\n\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final int _verifyNoLeadingZeroes() throws IOException\n{\n// Ok to have plain \"0\"\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn INT_0;\n}\nint ch = _inputBuffer[_inputPtr] & 0xFF;\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < INT_0 || ch > INT_9) {\nreturn INT_0;\n}\n// [JACKSON-358]: we may want to allow them, after all...\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\nreturn INT_0;\n}\n++_inputPtr; // skip previous zeroes\nif (ch != INT_0) { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\nboolean negative, int integerPartLength) throws IOException\n{\nint fractLen = 0;\nboolean eof = false;\n\n// And then see if we get other parts\nif (c == INT_PERIOD) { // yes, fraction\noutBuf[outPtr++] = (char) c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == INT_e || c == INT_E) { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Not optional, can require that we get one more char\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Likewise, non optional:\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n\n// And there we have it!\nreturn resetFloat(negative, integerPartLength, fractLen, expLen);\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\n// TODO? Handle UTF-8 char decoding for error reporting\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName(int i) throws IOException\n{\nif (i != INT_QUOTE) {\nreturn _handleOddName(i);\n}\n// First: can we optimize out bounds checks?\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\n}\n\n// If so, can also unroll loops nicely\n/* 25-Nov-2008, tatu: This may seem weird, but here we do\n*   NOT want to worry about UTF-8 decoding. Rather, we'll\n*   assume that part is ok (if not it will get caught\n*   later on), and just handle quotes and backslashes here.\n*/\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\nint q = input[_inputPtr++] & 0xFF;\n\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\n}\nif (i == INT_QUOTE) { // 4 byte/char case or broken\nreturn findName(q, 4);\n}\nreturn parseName(q, i, 4);\n}\nif (i == INT_QUOTE) { // 3 byte/char case or broken\nreturn findName(q, 3);\n}\nreturn parseName(q, i, 3);\n}\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\n}\nreturn parseName(q, i, 2);\n}\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\n}\nreturn parseName(q, i, 1);\n}\nif (q == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseName(0, q, 0); // quoting or invalid char\n}\n\nprotected final String parseMediumName(int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Ok, got 5 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 5 bytes\nreturn findName(_quad1, q2, 1);\n}\nreturn parseName(_quad1, q2, i, 1); // quoting or invalid char\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 6 bytes\nreturn findName(_quad1, q2, 2);\n}\nreturn parseName(_quad1, q2, i, 2);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 7 bytes\nreturn findName(_quad1, q2, 3);\n}\nreturn parseName(_quad1, q2, i, 3);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 8 bytes\nreturn findName(_quad1, q2, 4);\n}\nreturn parseName(_quad1, q2, i, 4);\n}\nreturn parseMediumName2(i, q2);\n}\n\n/**\n* @since 2.6\n*/\nprotected final String parseMediumName2(int q3, final int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Got 9 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 9 bytes\nreturn findName(_quad1, q2, q3, 1);\n}\nreturn parseName(_quad1, q2, q3, i, 1);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 10 bytes\nreturn findName(_quad1, q2, q3, 2);\n}\nreturn parseName(_quad1, q2, q3, i, 2);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 11 bytes\nreturn findName(_quad1, q2, q3, 3);\n}\nreturn parseName(_quad1, q2, q3, i, 3);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 12 bytes\nreturn findName(_quad1, q2, q3, 4);\n}\nreturn parseName(_quad1, q2, q3, i, 4);\n}\nreturn parseLongName(i, q2, q3);\n}\n\nprotected final String parseLongName(int q, final int q2, int q3) throws IOException\n{\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\n\n// As explained above, will ignore UTF-8 encoding at this point\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\n\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 1);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 2);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 2);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 3);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 3);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 4);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 4);\n}\n\n// Nope, no end in sight. Need to grow quad array etc\nif (qlen >= _quadBuffer.length) {\n_quadBuffer = growArrayBy(_quadBuffer, qlen);\n}\n_quadBuffer[qlen++] = q;\nq = i;\n}\n\n/* Let's offline if we hit buffer boundary (otherwise would\n* need to [try to] align input, which is bit complicated\n* and may not always be possible)\n*/\nreturn parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n}\n\n/**\n* Method called when not even first 8 bytes are guaranteed\n* to come consequtively. Happens rarely, so this is offlined;\n* plus we'll also do full checks for escaping etc.\n*/\nprotected String slowParseName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n}\n}\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\n}\n\nprivate final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\nreturn parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\nreturn parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n}\n\n/**\n* Slower parsing method which is generally branched to when\n* an escape sequence is detected (or alternatively for long\n* names, one crossing input buffer boundary).\n* Needs to be able to handle more exceptional cases, gets slower,\n* and hance is offlined to a separate method.\n*/\nprotected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\nint currQuadBytes) throws IOException\n{\n/* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n*   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n*   caught later on), and just handle quotes and backslashes here.\n*/\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\n}\n// Unquoted white space?\nif (ch != INT_BACKSLASH) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int ch) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\nchar c = (char) _decodeCharForError(ch);\n_reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n}\n/* Also: note that although we use a different table here,\n* it does NOT handle UTF-8 decoding. It'll just pass those\n* high-bit codes as acceptable for later decoding.\n*/\nfinal int[] codes = CharTypes.getInputCodeUtf8JsNames();\n// Also: must start with a valid character...\nif (codes[ch] != 0) {\n_reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\n\n/* Ok, now; instead of ultra-optimizing parsing here (as with\n* regular JSON names), let's just use the generic \"slow\"\n* variant. Can measure its impact later on if need be\n*/\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\nwhile (true) {\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (codes[ch] != 0) {\nbreak;\n}\n++_inputPtr;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n* main reason being to try to avoid slowing down fast path\n* for valid JSON -- more alternatives, more code, generally\n* bit slower execution.\n*/\nprotected String _parseAposName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\'' for name\");\n}\n}\nint ch = _inputBuffer[_inputPtr++] & 0xFF;\nif (ch == '\\'') { // special case, ''\nreturn \"\";\n}\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\n// Copied from parseEscapedFieldName, with minor mods:\n\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (ch == '\\'') {\nbreak;\n}\n// additional check to skip handling of double-quotes\nif (ch != '\"' && codes[ch] != 0) {\nif (ch != '\\\\') {\n// Unquoted white space?\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/*\n/**********************************************************\n/* Internal methods, symbol (name) handling\n/**********************************************************\n*/\n\nprivate final String findName(int q1, int lastQuadBytes) throws JsonParseException\n{\nq1 = pad(q1, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n{\nq2 = pad(q2, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1, q2);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn addName(_quadBuffer, 2, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n{\nq3 = pad(q3, lastQuadBytes);\nString name = _symbols.findName(q1, q2, q3);\nif (name != null) {\nreturn name;\n}\nint[] quads = _quadBuffer;\nquads[0] = q1;\nquads[1] = q2;\nquads[2] = pad(q3, lastQuadBytes);\nreturn addName(quads, 3, lastQuadBytes);\n}\n\nprivate final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n{\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\n}\nreturn name;\n}\n\n/**\n* This is the main workhorse method used when we take a symbol\n* table miss. It needs to demultiplex individual bytes, decode\n* multi-byte chars (if any), and then construct Name instance\n* and add it to the symbol table.\n*/\nprivate final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n{\n/* Ok: must decode UTF-8 chars. No other validation is\n* needed, since unescaping has been done earlier as necessary\n* (as well as error reporting for unescaped control chars)\n*/\n// 4 bytes per quad, except last one maybe less\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n/* And last one is not correctly aligned (leading zero bytes instead\n* need to shift a bit, instead of trailing). Only need to shift it\n* for UTF-8 decoding; need revert for storage (since key will not\n* be aligned, to optimize lookup speed)\n*/\nint lastQuad;\n\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\n// 8/16/24 bit left shift\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n} else {\nlastQuad = 0;\n}\n\n// Need some working space, TextBuffer works well:\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\n\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\n\nif (ch > 127) { // multi-byte\nint needed;\nif ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\nch &= 0x1F;\nneeded = 1;\n} else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\nch &= 0x0F;\nneeded = 2;\n} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\nch &= 0x07;\nneeded = 3;\n} else { // 5- and 6-byte chars not valid xml chars\n_reportInvalidInitial(ch);\nneeded = ch = 1; // never really gets this far\n}\nif ((ix + needed) > byteLen) {\n_reportInvalidEOF(\" in field name\");\n}\n\n// Ok, always need at least one more:\nint ch2 = quads[ix >> 2]; // current quad, need to shift+mask\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 1) {\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 2) { // 4 bytes? (need surrogates on output)\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2 & 0xFF);\n}\nch = (ch << 6) | (ch2 & 0x3F);\n}\n}\nif (needed > 2) { // surrogate pair? once again, let's output one here, one later on\nch -= 0x10000; // to normalize it starting with 0x0\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) (0xD800 + (ch >> 10));\nch = 0xDC00 | (ch & 0x03FF);\n}\n}\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) ch;\n}\n\n// Ok. Now we have the character array, and can construct the String\nString baseName = new String(cbuf, 0, cix);\n// And finally, un-align if necessary\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\n}\nreturn _symbols.addName(baseName, quads, qlen);\n}\n\n/*\n/**********************************************************\n/* Internal methods, String value parsing\n/**********************************************************\n*/\n\n@Override\nprotected void _finishString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\n_textBuffer.setCurrentLength(outPtr);\nreturn;\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\n}\n\n/**\n* @since 2.6\n*/\nprotected String _finishAndReturnString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\nreturn _textBuffer.setCurrentAndReturn(outPtr);\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\nreturn _textBuffer.contentsAsString();\n}\n\nprivate final void _finishString2(char[] outBuf, int outPtr)\nthrows IOException\n{\nint c;\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ASCII non-funny-char loop:\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nfinal int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nc = _decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\n// Need to be fully UTF-8 aware here:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\nint c;\n\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nint max = _inputEnd;\nif (ptr >= max) {\nloadMoreGuaranteed();\nptr = _inputPtr;\nmax = _inputEnd;\n}\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\n_decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\n_skipUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\n_skipUtf8_3(c);\nbreak;\ncase 4: // 4-byte UTF\n_skipUtf8_4(c);\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n}\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleUnexpectedValue(int c)\nthrows IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (c) {\ncase ']':\ncase '}':\n// Error: neither is valid at this point; valid closers have\n// been handled earlier\n_reportUnexpectedChar(c, \"expected a value\");\ncase '\\'':\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(c)) {\n_reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos()\nthrows IOException\n{\nint c = 0;\n// Otherwise almost verbatim copy of _finishString()\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ascii non-funny-char loop:\nascii_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nint max = _inputEnd;\n{\nint max2 = _inputPtr + (outBuf.length - outPtr);\nif (max2 < max) {\nmax = max2;\n}\n}\nwhile (_inputPtr < max) {\nc = (int) inputBuffer[_inputPtr++] & 0xFF;\nif (c == '\\'' || codes[c] != 0) {\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n}\n\n// Ok: end marker, escape or multi-byte?\nif (c == '\\'') {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nif (c != '\\'') { // marked as special, isn't here\nc = _decodeEscaped();\n}\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n_throwUnquotedSpace(c, \"string value\");\n}\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n\nreturn JsonToken.VALUE_STRING;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\nthrows IOException\n{\nwhile (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nch = _inputBuffer[_inputPtr++];\nString match;\nif (ch == 'N') {\nmatch = neg ? \"-INF\" :\"+INF\";\n} else if (ch == 'n') {\nmatch = neg ? \"-Infinity\" :\"+Infinity\";\n} else {\nbreak;\n}\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\nprotected final void _matchToken(String matchStr, int i) throws IOException\n{\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\n_matchToken2(matchStr, i);\nreturn;\n}\ndo {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n_reportInvalidToken(matchStr.substring(0, i));\n}\n++_inputPtr;\n} while (++i < len);\n\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n_checkMatchEnd(matchStr, i, ch);\n}\n}",
            "method_id": 37
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonEncoding:<init>(Ljava/lang/String;ILjava/lang/String;ZI)V",
            "method_body": "JsonEncoding(String javaName, boolean bigEndian, int bits)\n{\n_javaName = javaName;\n_bigEndian = bigEndian;\n_bits = bits;\n}",
            "method_id": 38
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:<clinit>()V",
            "method_body": "public final static int BYTE_READ_IO_BUFFER = 0;\n\n/**\n* Buffer used for temporarily storing encoded content; used\n* for example by UTF-8 encoding writer\n*/\npublic final static int BYTE_WRITE_ENCODING_BUFFER = 1;\n\n/**\n* Buffer used for temporarily concatenating output; used for\n* example when requesting output as byte array.\n*/\npublic final static int BYTE_WRITE_CONCAT_BUFFER = 2;\n\n/**\n* Buffer used for concatenating binary data that is either being\n* encoded as base64 output, or decoded from base64 input.\n*\n* @since 2.1\n*/\npublic final static int BYTE_BASE64_CODEC_BUFFER = 3;\n\npublic final static int CHAR_TOKEN_BUFFER = 0;  // Tokenizable input\npublic final static int CHAR_CONCAT_BUFFER = 1; // concatenated output\npublic final static int CHAR_TEXT_BUFFER = 2; // Text content from input\npublic final static int CHAR_NAME_COPY_BUFFER = 3; // Temporary buffer for getting name characters\n\n// Buffer lengths, defined in 2.4 (smaller before that)\n\nprivate final static int[] BYTE_BUFFER_LENGTHS = new int[] { 8000, 8000, 2000, 2000 };",
            "method_id": 39
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_skipColon()I",
            "method_body": "private final int _skipColon() throws IOException\n{\nif ((_inputPtr + 4) >= _inputEnd) {\nreturn _skipColon2(false);\n}\n// Fast path: colon with optional single-space/tab before and/or after:\nint i = _inputBuffer[_inputPtr];\nif (i == INT_COLON) { // common case, no leading space\ni = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) { // nor trailing\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true); // true -> skipped colon\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = _inputBuffer[++_inputPtr];\n}\nif (i == INT_COLON) {\ni = _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\nif (i == INT_SPACE || i == INT_TAB) {\ni = (int) _inputBuffer[++_inputPtr];\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\nreturn _skipColon2(true);\n}\n++_inputPtr;\nreturn i;\n}\n}\nreturn _skipColon2(true);\n}\nreturn _skipColon2(false);\n}",
            "method_id": 40
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper:checkUTF32(I)Z",
            "method_body": "public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException\n{\n// Ideally we should see \"[\" or \"{\"; but if not, we'll accept double-quote (String)\n// in future could also consider accepting non-standard matches?\n\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nbyte b = acc.nextByte();\n// Very first thing, a UTF-8 BOM?\nif (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != UTF8_BOM_2) {\nreturn MatchStrength.NO_MATCH;\n}\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != UTF8_BOM_3) {\nreturn MatchStrength.NO_MATCH;\n}\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nb = acc.nextByte();\n}\n// Then possible leading space\nint ch = skipSpace(acc, b);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\n// First, let's see if it looks like a structured type:\nif (ch == '{') { // JSON object?\n// Ideally we need to find either double-quote or closing bracket\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (ch == '\"' || ch == '}') {\nreturn MatchStrength.SOLID_MATCH;\n}\n// ... should we allow non-standard? Let's not yet... can add if need be\nreturn MatchStrength.NO_MATCH;\n}\nMatchStrength strength;\n\nif (ch == '[') {\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\n// closing brackets is easy; but for now, let's also accept opening...\nif (ch == ']' || ch == '[') {\nreturn MatchStrength.SOLID_MATCH;\n}\nreturn MatchStrength.SOLID_MATCH;\n} else {\n// plain old value is not very convincing...\nstrength = MatchStrength.WEAK_MATCH;\n}\n\nif (ch == '\"') { // string value\nreturn strength;\n}\nif (ch <= '9' && ch >= '0') { // number\nreturn strength;\n}\nif (ch == '-') { // negative number\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nreturn (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH;\n}\n// or one of literals\nif (ch == 'n') { // null\nreturn tryMatch(acc, \"ull\", strength);\n}\nif (ch == 't') { // true\nreturn tryMatch(acc, \"rue\", strength);\n}\nif (ch == 'f') { // false\nreturn tryMatch(acc, \"alse\", strength);\n}\nreturn MatchStrength.NO_MATCH;\n}\n\nprivate static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\nthrows IOException\n{\nfor (int i = 0, len = matchStr.length(); i < len; ++i) {\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != matchStr.charAt(i)) {\nreturn MatchStrength.NO_MATCH;\n}\n}\nreturn fullMatchStrength;\n}\n\nprivate static int skipSpace(InputAccessor acc) throws IOException\n{\nif (!acc.hasMoreBytes()) {\nreturn -1;\n}\nreturn skipSpace(acc, acc.nextByte());\n}\n\nprivate static int skipSpace(InputAccessor acc, byte b) throws IOException\n{\nwhile (true) {\nint ch = (int) b & 0xFF;\nif (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\nreturn ch;\n}\nif (!acc.hasMoreBytes()) {\nreturn -1;\n}\nb = acc.nextByte();\nch = (int) b & 0xFF;\n}\n}\n\n/*\n/**********************************************************\n/* Internal methods, parsing\n/**********************************************************\n*/\n\n/**\n* @return True if a BOM was succesfully found, and encoding\n*   thereby recognized.\n*/\nprivate boolean handleBOM(int quad) throws IOException\n{\n/* Handling of (usually) optional BOM (required for\n* multi-byte formats); first 32-bit charsets:\n*/\nswitch (quad) {\ncase 0x0000FEFF:\n_bigEndian = true;\n_inputPtr += 4;\n_bytesPerChar = 4;\nreturn true;\ncase 0xFFFE0000: // UCS-4, LE?\n_inputPtr += 4;\n_bytesPerChar = 4;\n_bigEndian = false;\nreturn true;\ncase 0x0000FFFE: // UCS-4, in-order...\nreportWeirdUCS4(\"2143\"); // throws exception\ncase 0xFEFF0000: // UCS-4, in-order...\nreportWeirdUCS4(\"3412\"); // throws exception\n}\n// Ok, if not, how about 16-bit encoding BOMs?\nint msw = quad >>> 16;\nif (msw == 0xFEFF) { // UTF-16, BE\n_inputPtr += 2;\n_bytesPerChar = 2;\n_bigEndian = true;\nreturn true;\n}\nif (msw == 0xFFFE) { // UTF-16, LE\n_inputPtr += 2;\n_bytesPerChar = 2;\n_bigEndian = false;\nreturn true;\n}\n// And if not, then UTF-8 BOM?\nif ((quad >>> 8) == 0xEFBBBF) { // UTF-8\n_inputPtr += 3;\n_bytesPerChar = 1;\n_bigEndian = true; // doesn't really matter\nreturn true;\n}\nreturn false;\n}\n\nprivate boolean checkUTF32(int quad) throws IOException\n{\n/* Handling of (usually) optional BOM (required for\n* multi-byte formats); first 32-bit charsets:\n*/\nif ((quad >> 8) == 0) { // 0x000000?? -> UTF32-BE\n_bigEndian = true;\n} else if ((quad & 0x00FFFFFF) == 0) { // 0x??000000 -> UTF32-LE\n_bigEndian = false;\n} else if ((quad & ~0x00FF0000) == 0) { // 0x00??0000 -> UTF32-in-order\nreportWeirdUCS4(\"3412\");\n} else if ((quad & ~0x0000FF00) == 0) { // 0x0000??00 -> UTF32-in-order\nreportWeirdUCS4(\"2143\");\n} else {\n// Can not be valid UTF-32 encoded JSON...\nreturn false;\n}\n// Not BOM (just regular content), nothing to skip past:\n//_inputPtr += 4;\n_bytesPerChar = 4;\nreturn true;\n}\n\nprivate boolean checkUTF16(int i16)\n{\nif ((i16 & 0xFF00) == 0) { // UTF-16BE\n_bigEndian = true;\n} else if ((i16 & 0x00FF) == 0) { // UTF-16LE\n_bigEndian = false;\n} else { // nope, not  UTF-16\nreturn false;\n}\n// Not BOM (just regular content), nothing to skip past:\n//_inputPtr += 2;\n_bytesPerChar = 2;\nreturn true;\n}\n\n/*\n/**********************************************************\n/* Internal methods, problem reporting\n/**********************************************************\n*/\n\nprivate void reportWeirdUCS4(String type) throws IOException {\nthrow new CharConversionException(\"Unsupported UCS-4 endianness (\"+type+\") detected\");\n}\n\n/*\n/**********************************************************\n/* Internal methods, raw input access\n/**********************************************************\n*/\n\nprotected boolean ensureLoaded(int minimum) throws IOException {\n/* Let's assume here buffer has enough room -- this will always\n* be true for the limited used this method gets\n*/\nint gotten = (_inputEnd - _inputPtr);\nwhile (gotten < minimum) {\nint count;\n\nif (_in == null) { // block source\ncount = -1;\n} else {\ncount = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n}\nif (count < 1) {\nreturn false;\n}\n_inputEnd += count;\ngotten += count;\n}\nreturn true;\n}\n}",
            "method_id": 41
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:<init>(IZIZ)V",
            "method_body": "private ByteQuadsCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n_parent = null;\n_seed = seed;\n_intern = intern;\n_failOnDoS = failOnDoS;\n// Sanity check: let's now allow hash sizes below certain minimum value\nif (sz < MIN_HASH_SIZE) {\nsz = MIN_HASH_SIZE;\n} else {\n// Also; size must be 2^N; otherwise hash algorithm won't\n// work... so let's just pad it up, if so\nif ((sz & (sz - 1)) != 0) { // only true if it's 2^N\nint curr = MIN_HASH_SIZE;\nwhile (curr < sz) {\ncurr += curr;\n}\nsz = curr;\n}\n}\n_tableInfo = new AtomicReference<TableInfo>(TableInfo.createInitial(sz));\n}",
            "method_id": 42
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
            "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}",
            "method_id": 43
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:<init>(Ljava/lang/String;IZ)V",
            "method_body": "private Feature(boolean defaultState) { _defaultState = defaultState; }\nprivate Feature(boolean defaultState) { _defaultState = defaultState; }",
            "method_id": 44
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:getMask()I",
            "method_body": "public int getMask() { return _mask; }\npublic int getMask() { return _mask; }",
            "method_id": 45
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_nextAfterName()Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "private final JsonToken _nextTokenNotInObject(int i) throws IOException\n{\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\nreturn (_currToken = JsonToken.VALUE_STRING);\n}\nswitch (i) {\ncase '[':\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_ARRAY);\ncase '{':\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_OBJECT);\ncase 't':\n_matchToken(\"true\", 1);\nreturn (_currToken = JsonToken.VALUE_TRUE);\ncase 'f':\n_matchToken(\"false\", 1);\nreturn (_currToken = JsonToken.VALUE_FALSE);\ncase 'n':\n_matchToken(\"null\", 1);\nreturn (_currToken = JsonToken.VALUE_NULL);\ncase '-':\nreturn (_currToken = _parseNegNumber());\n/* Should we have separate handling for plus? Although\n* it is not allowed per se, it may be erroneously used,\n* and could be indicated by a more specific error message.\n*/\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn (_currToken = _parsePosNumber(i));\n}\nreturn (_currToken = _handleUnexpectedValue(i));\n}\n\nprivate final JsonToken _nextAfterName()\n{\n_nameCopied = false; // need to invalidate if it was copied\nJsonToken t = _nextToken;\n_nextToken = null;\n// Also: may need to start new context?\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn (_currToken = t);\n}\n\n/*\n/**********************************************************\n/* Public API, traversal, nextXxxValue/nextFieldName\n/**********************************************************\n*/\n\n@Override\npublic boolean nextFieldName(SerializableString str) throws IOException\n{\n// // // Note: most of code below is copied from nextToken()\n\n_numTypesValid = NR_UNKNOWN;\nif (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n_nextAfterName();\nreturn false;\n}\nif (_tokenIncomplete) {\n_skipString();\n}\nint i = _skipWSOrEnd();\nif (i < 0) { // end-of-input\nclose();\n_currToken = null;\nreturn false;\n}\n_tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n_tokenInputRow = _currInputRow;\n_tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n// finally: clear any data retained so far\n_binaryValue = null;\n\n// Closing scope?\nif (i == INT_RBRACKET) {\nif (!_parsingContext.inArray()) {\n_reportMismatchedEndMarker(i, '}');\n}\n_parsingContext = _parsingContext.getParent();\n_currToken = JsonToken.END_ARRAY;\nreturn false;\n}\nif (i == INT_RCURLY) {\nif (!_parsingContext.inObject()) {\n_reportMismatchedEndMarker(i, ']');\n}\n_parsingContext = _parsingContext.getParent();\n_currToken = JsonToken.END_OBJECT;\nreturn false;\n}\n\n// Nope: do we then expect a comma?\nif (_parsingContext.expectComma()) {\nif (i != INT_COMMA) {\n_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n}\ni = _skipWS();\n}\n\nif (!_parsingContext.inObject()) {\n_nextTokenNotInObject(i);\nreturn false;\n}\n\n// // // This part differs, name parsing\nif (i == INT_QUOTE) {\n// when doing literal match, must consider escaping:\nbyte[] nameBytes = str.asQuotedUTF8();\nfinal int len = nameBytes.length;\n// 22-May-2014, tatu: Actually, let's require 4 more bytes for faster skipping\n//    of colon that follows name\nif ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n// first check length match by\nfinal int end = _inputPtr+len;\nif (_inputBuffer[end] == INT_QUOTE) {\nint offset = 0;\nint ptr = _inputPtr;\nwhile (true) {\nif (ptr == end) { // yes, match!\n_parsingContext.setCurrentName(str.getValue());\n_isNextTokenNameYes(_skipColonFast(ptr+1));\nreturn true;\n}\nif (nameBytes[offset] != _inputBuffer[ptr]) {\nbreak;\n}\n++offset;\n++ptr;\n}\n}\n}\n}\nreturn _isNextTokenNameMaybe(i, str);\n}",
            "method_id": 46
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer:createRoot()Lcom/fasterxml/jackson/core/sym/BytesToNameCanonicalizer;",
            "method_body": "public static BytesToNameCanonicalizer createRoot() {\n/* [Issue-21]: Need to use a variable seed, to thwart hash-collision\n* based attacks.\n*/\nlong now = System.currentTimeMillis();\n// ensure it's not 0; and might as well require to be odd so:\nint seed = (((int) now) + ((int) (now >>> 32))) | 1;\nreturn createRoot(seed);\n}",
            "method_id": 47
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:findName([IIII)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleUnexpectedValue(i);\n}\n\n\nprivate final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n{\n// // // and this is back to standard nextToken()\n\nString n = _parseName(i);\n_parsingContext.setCurrentName(n);\nfinal boolean match = n.equals(str.getValue());\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n\n// Ok: we must have a value... what is it? Strings are very common, check first:\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn match;\n}\nJsonToken t;\n\nswitch (i) {\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ncase 't':\n_matchToken(\"true\", 1);\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase 'f':\n_matchToken(\"false\", 1);\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchToken(\"null\", 1);\nt = JsonToken.VALUE_NULL;\nbreak;\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ndefault:\nt = _handleUnexpectedValue(i);\n}\n_nextToken = t;\nreturn match;\n}\n\n@Override\npublic String nextTextValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\nreturn _finishAndReturnString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n@Override\npublic int nextIntValue(int defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n@Override\npublic long nextLongValue(long defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n@Override\npublic Boolean nextBooleanValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n\nJsonToken t = nextToken();\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected JsonToken _parsePosNumber(int c) throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n// Ok: we can first just add digit we saw first:\noutBuf[0] = (char) c;\nint intLen = 1;\nint outPtr = 1;\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - 1; // 1 == outPtr\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) { // split across boundary, offline\nreturn _parseNumber2(outBuf, outPtr, false, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, false, intLen);\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n// And there we have it!\nreturn resetInt(false, intLen);\n}\n\nprotected JsonToken _parseNegNumber() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\noutBuf[outPtr++] = '-';\n// Must have something after sign too\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Note: must be followed by a digit\nif (c < INT_0 || c > INT_9) {\nreturn _handleInvalidNumberStart(c, true);\n}\n\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n\n// Ok: we can first just add digit we saw first:\noutBuf[outPtr++] = (char) c;\nint intLen = 1;\n\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - outPtr;\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) {\n// Long enough to be split across boundary, so:\nreturn _parseNumber2(outBuf, outPtr, true, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, true, intLen);\n}\n\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n\n// And there we have it!\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to handle parsing when input is split across buffer boundary\n* (or output is longer than segment used to store it)\n*/\nprivate final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\nint intPartLength) throws IOException\n{\n// Ok, parse the rest\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_textBuffer.setCurrentLength(outPtr);\nreturn resetInt(negative, intPartLength);\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c > INT_9 || c < INT_0) {\nif (c == INT_PERIOD || c == INT_e || c == INT_E) {\nreturn _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n}\nbreak;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n++intPartLength;\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n}\n\n// And there we have it!\nreturn resetInt(negative, intPartLength);\n\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final int _verifyNoLeadingZeroes() throws IOException\n{\n// Ok to have plain \"0\"\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn INT_0;\n}\nint ch = _inputBuffer[_inputPtr] & 0xFF;\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < INT_0 || ch > INT_9) {\nreturn INT_0;\n}\n// [JACKSON-358]: we may want to allow them, after all...\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\nreturn INT_0;\n}\n++_inputPtr; // skip previous zeroes\nif (ch != INT_0) { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\nboolean negative, int integerPartLength) throws IOException\n{\nint fractLen = 0;\nboolean eof = false;\n\n// And then see if we get other parts\nif (c == INT_PERIOD) { // yes, fraction\noutBuf[outPtr++] = (char) c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == INT_e || c == INT_E) { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Not optional, can require that we get one more char\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Likewise, non optional:\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n\n// And there we have it!\nreturn resetFloat(negative, integerPartLength, fractLen, expLen);\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\n// TODO? Handle UTF-8 char decoding for error reporting\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName(int i) throws IOException\n{\nif (i != INT_QUOTE) {\nreturn _handleOddName(i);\n}\n// First: can we optimize out bounds checks?\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\n}\n\n// If so, can also unroll loops nicely\n/* 25-Nov-2008, tatu: This may seem weird, but here we do\n*   NOT want to worry about UTF-8 decoding. Rather, we'll\n*   assume that part is ok (if not it will get caught\n*   later on), and just handle quotes and backslashes here.\n*/\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\nint q = input[_inputPtr++] & 0xFF;\n\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\n}\nif (i == INT_QUOTE) { // 4 byte/char case or broken\nreturn findName(q, 4);\n}\nreturn parseName(q, i, 4);\n}\nif (i == INT_QUOTE) { // 3 byte/char case or broken\nreturn findName(q, 3);\n}\nreturn parseName(q, i, 3);\n}\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\n}\nreturn parseName(q, i, 2);\n}\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\n}\nreturn parseName(q, i, 1);\n}\nif (q == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseName(0, q, 0); // quoting or invalid char\n}\n\nprotected final String parseMediumName(int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Ok, got 5 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 5 bytes\nreturn findName(_quad1, q2, 1);\n}\nreturn parseName(_quad1, q2, i, 1); // quoting or invalid char\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 6 bytes\nreturn findName(_quad1, q2, 2);\n}\nreturn parseName(_quad1, q2, i, 2);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 7 bytes\nreturn findName(_quad1, q2, 3);\n}\nreturn parseName(_quad1, q2, i, 3);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 8 bytes\nreturn findName(_quad1, q2, 4);\n}\nreturn parseName(_quad1, q2, i, 4);\n}\nreturn parseMediumName2(i, q2);\n}\n\n/**\n* @since 2.6\n*/\nprotected final String parseMediumName2(int q3, final int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Got 9 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 9 bytes\nreturn findName(_quad1, q2, q3, 1);\n}\nreturn parseName(_quad1, q2, q3, i, 1);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 10 bytes\nreturn findName(_quad1, q2, q3, 2);\n}\nreturn parseName(_quad1, q2, q3, i, 2);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 11 bytes\nreturn findName(_quad1, q2, q3, 3);\n}\nreturn parseName(_quad1, q2, q3, i, 3);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 12 bytes\nreturn findName(_quad1, q2, q3, 4);\n}\nreturn parseName(_quad1, q2, q3, i, 4);\n}\nreturn parseLongName(i, q2, q3);\n}\n\nprotected final String parseLongName(int q, final int q2, int q3) throws IOException\n{\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\n\n// As explained above, will ignore UTF-8 encoding at this point\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\n\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 1);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 2);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 2);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 3);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 3);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 4);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 4);\n}\n\n// Nope, no end in sight. Need to grow quad array etc\nif (qlen >= _quadBuffer.length) {\n_quadBuffer = growArrayBy(_quadBuffer, qlen);\n}\n_quadBuffer[qlen++] = q;\nq = i;\n}\n\n/* Let's offline if we hit buffer boundary (otherwise would\n* need to [try to] align input, which is bit complicated\n* and may not always be possible)\n*/\nreturn parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n}\n\n/**\n* Method called when not even first 8 bytes are guaranteed\n* to come consequtively. Happens rarely, so this is offlined;\n* plus we'll also do full checks for escaping etc.\n*/\nprotected String slowParseName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n}\n}\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\n}\n\nprivate final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\nreturn parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\nreturn parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n}\n\n/**\n* Slower parsing method which is generally branched to when\n* an escape sequence is detected (or alternatively for long\n* names, one crossing input buffer boundary).\n* Needs to be able to handle more exceptional cases, gets slower,\n* and hance is offlined to a separate method.\n*/\nprotected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\nint currQuadBytes) throws IOException\n{\n/* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n*   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n*   caught later on), and just handle quotes and backslashes here.\n*/\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\n}\n// Unquoted white space?\nif (ch != INT_BACKSLASH) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int ch) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\nchar c = (char) _decodeCharForError(ch);\n_reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n}\n/* Also: note that although we use a different table here,\n* it does NOT handle UTF-8 decoding. It'll just pass those\n* high-bit codes as acceptable for later decoding.\n*/\nfinal int[] codes = CharTypes.getInputCodeUtf8JsNames();\n// Also: must start with a valid character...\nif (codes[ch] != 0) {\n_reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\n\n/* Ok, now; instead of ultra-optimizing parsing here (as with\n* regular JSON names), let's just use the generic \"slow\"\n* variant. Can measure its impact later on if need be\n*/\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\nwhile (true) {\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (codes[ch] != 0) {\nbreak;\n}\n++_inputPtr;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n* main reason being to try to avoid slowing down fast path\n* for valid JSON -- more alternatives, more code, generally\n* bit slower execution.\n*/\nprotected String _parseAposName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\'' for name\");\n}\n}\nint ch = _inputBuffer[_inputPtr++] & 0xFF;\nif (ch == '\\'') { // special case, ''\nreturn \"\";\n}\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\n// Copied from parseEscapedFieldName, with minor mods:\n\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (ch == '\\'') {\nbreak;\n}\n// additional check to skip handling of double-quotes\nif (ch != '\"' && codes[ch] != 0) {\nif (ch != '\\\\') {\n// Unquoted white space?\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/*\n/**********************************************************\n/* Internal methods, symbol (name) handling\n/**********************************************************\n*/\n\nprivate final String findName(int q1, int lastQuadBytes) throws JsonParseException\n{\nq1 = pad(q1, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n{\nq2 = pad(q2, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1, q2);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn addName(_quadBuffer, 2, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n{\nq3 = pad(q3, lastQuadBytes);\nString name = _symbols.findName(q1, q2, q3);\nif (name != null) {\nreturn name;\n}\nint[] quads = _quadBuffer;\nquads[0] = q1;\nquads[1] = q2;\nquads[2] = pad(q3, lastQuadBytes);\nreturn addName(quads, 3, lastQuadBytes);\n}\n\nprivate final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n{\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\n}\nreturn name;\n}\n\n/**\n* This is the main workhorse method used when we take a symbol\n* table miss. It needs to demultiplex individual bytes, decode\n* multi-byte chars (if any), and then construct Name instance\n* and add it to the symbol table.\n*/\nprivate final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n{\n/* Ok: must decode UTF-8 chars. No other validation is\n* needed, since unescaping has been done earlier as necessary\n* (as well as error reporting for unescaped control chars)\n*/\n// 4 bytes per quad, except last one maybe less\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n/* And last one is not correctly aligned (leading zero bytes instead\n* need to shift a bit, instead of trailing). Only need to shift it\n* for UTF-8 decoding; need revert for storage (since key will not\n* be aligned, to optimize lookup speed)\n*/\nint lastQuad;\n\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\n// 8/16/24 bit left shift\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n} else {\nlastQuad = 0;\n}\n\n// Need some working space, TextBuffer works well:\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\n\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\n\nif (ch > 127) { // multi-byte\nint needed;\nif ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\nch &= 0x1F;\nneeded = 1;\n} else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\nch &= 0x0F;\nneeded = 2;\n} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\nch &= 0x07;\nneeded = 3;\n} else { // 5- and 6-byte chars not valid xml chars\n_reportInvalidInitial(ch);\nneeded = ch = 1; // never really gets this far\n}\nif ((ix + needed) > byteLen) {\n_reportInvalidEOF(\" in field name\");\n}\n\n// Ok, always need at least one more:\nint ch2 = quads[ix >> 2]; // current quad, need to shift+mask\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 1) {\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 2) { // 4 bytes? (need surrogates on output)\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2 & 0xFF);\n}\nch = (ch << 6) | (ch2 & 0x3F);\n}\n}\nif (needed > 2) { // surrogate pair? once again, let's output one here, one later on\nch -= 0x10000; // to normalize it starting with 0x0\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) (0xD800 + (ch >> 10));\nch = 0xDC00 | (ch & 0x03FF);\n}\n}\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) ch;\n}\n\n// Ok. Now we have the character array, and can construct the String\nString baseName = new String(cbuf, 0, cix);\n// And finally, un-align if necessary\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\n}\nreturn _symbols.addName(baseName, quads, qlen);\n}\n\n/*\n/**********************************************************\n/* Internal methods, String value parsing\n/**********************************************************\n*/\n\n@Override\nprotected void _finishString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\n_textBuffer.setCurrentLength(outPtr);\nreturn;\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\n}\n\n/**\n* @since 2.6\n*/\nprotected String _finishAndReturnString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\nreturn _textBuffer.setCurrentAndReturn(outPtr);\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\nreturn _textBuffer.contentsAsString();\n}\n\nprivate final void _finishString2(char[] outBuf, int outPtr)\nthrows IOException\n{\nint c;\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ASCII non-funny-char loop:\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nfinal int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nc = _decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\n// Need to be fully UTF-8 aware here:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\nint c;\n\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nint max = _inputEnd;\nif (ptr >= max) {\nloadMoreGuaranteed();\nptr = _inputPtr;\nmax = _inputEnd;\n}\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\n_decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\n_skipUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\n_skipUtf8_3(c);\nbreak;\ncase 4: // 4-byte UTF\n_skipUtf8_4(c);\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n}\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleUnexpectedValue(int c)\nthrows IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (c) {\ncase ']':\ncase '}':\n// Error: neither is valid at this point; valid closers have\n// been handled earlier\n_reportUnexpectedChar(c, \"expected a value\");\ncase '\\'':\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(c)) {\n_reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos()\nthrows IOException\n{\nint c = 0;\n// Otherwise almost verbatim copy of _finishString()\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ascii non-funny-char loop:\nascii_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nint max = _inputEnd;\n{\nint max2 = _inputPtr + (outBuf.length - outPtr);\nif (max2 < max) {\nmax = max2;\n}\n}\nwhile (_inputPtr < max) {\nc = (int) inputBuffer[_inputPtr++] & 0xFF;\nif (c == '\\'' || codes[c] != 0) {\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n}\n\n// Ok: end marker, escape or multi-byte?\nif (c == '\\'') {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nif (c != '\\'') { // marked as special, isn't here\nc = _decodeEscaped();\n}\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n_throwUnquotedSpace(c, \"string value\");\n}\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n\nreturn JsonToken.VALUE_STRING;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\nthrows IOException\n{\nwhile (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nch = _inputBuffer[_inputPtr++];\nString match;\nif (ch == 'N') {\nmatch = neg ? \"-INF\" :\"+INF\";\n} else if (ch == 'n') {\nmatch = neg ? \"-Infinity\" :\"+Infinity\";\n} else {\nbreak;\n}\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\nprotected final void _matchToken(String matchStr, int i) throws IOException\n{\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\n_matchToken2(matchStr, i);\nreturn;\n}\ndo {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n_reportInvalidToken(matchStr.substring(0, i));\n}\n++_inputPtr;\n} while (++i < len);\n\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n_checkMatchEnd(matchStr, i, ch);\n}\n}",
            "method_id": 48
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:<clinit>()V",
            "method_body": "public final static int HASH_MULT = 33;\n\n/**\n* Default initial table size. Shouldn't be miniscule (as there's\n* cost to both array realloc and rehashing), but let's keep\n* it reasonably small. For systems that properly\n* reuse factories it doesn't matter either way; but when\n* recreating factories often, initial overhead may dominate.\n*/\nprotected static final int DEFAULT_T_SIZE = 64;\n\n/**\n* Let's not expand symbol tables past some maximum size;\n* this should protected against OOMEs caused by large documents\n* with unique (~= random) names.\n*/\nprotected static final int MAX_T_SIZE = 0x10000; // 64k entries == 256k mem\n\n/**\n* Let's only share reasonably sized symbol tables. Max size set to 3/4 of 16k;\n* this corresponds to 64k main hash index. This should allow for enough distinct\n* names for almost any case.\n*/\nfinal static int MAX_ENTRIES_FOR_REUSE = 12000;\n\n/**\n* Also: to thwart attacks based on hash collisions (which may or may not\n* be cheap to calculate), we will need to detect \"too long\"\n* collision chains. Let's start with static value of 255 entries\n* for the longest legal chain.\n*<p>\n* Note: longest chain we have been able to produce without malicious\n* intent has been 38 (with \"com.fasterxml.jackson.core.main.TestWithTonsaSymbols\");\n* our setting should be reasonable here.\n*<p>\n* Also note that value was lowered from 255 (2.3 and earlier) to 100 for 2.4\n*\n* @since 2.1\n*/\nfinal static int MAX_COLL_CHAIN_LENGTH = 100;\n\nfinal static CharsToNameCanonicalizer sBootstrapSymbolTable = new CharsToNameCanonicalizer();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* Sharing of learnt symbols is done by optional linking of symbol\n* table instances with their parents. When parent linkage is\n* defined, and child instance is released (call to <code>release</code>),\n* parent's shared tables may be updated from the child instance.\n*/\nprotected CharsToNameCanonicalizer _parent;\n\n/**\n* Seed value we use as the base to make hash codes non-static between\n* different runs, but still stable for lifetime of a single symbol table\n* instance.\n* This is done for security reasons, to avoid potential DoS attack via\n* hash collisions.\n*\n* @since 2.1\n*/\nfinal private int _hashSeed;\n\nfinal protected int _flags;\n\n/**\n* Whether any canonicalization should be attempted (whether using\n* intern or not)\n*/\nprotected boolean _canonicalize;\n\n/*\n/**********************************************************\n/* Actual symbol table data\n/**********************************************************\n*/\n\n/**\n* Primary matching symbols; it's expected most match occur from\n* here.\n*/\nprotected String[] _symbols;\n\n/**\n* Overflow buckets; if primary doesn't match, lookup is done\n* from here.\n*<p>\n* Note: Number of buckets is half of number of symbol entries, on\n* assumption there's less need for buckets.\n*/\nprotected Bucket[] _buckets;\n\n/**\n* Current size (number of entries); needed to know if and when\n* rehash.\n*/\nprotected int _size;\n\n/**\n* Limit that indicates maximum size this instance can hold before\n* it needs to be expanded and rehashed. Calculated using fill\n* factor passed in to constructor.\n*/\nprotected int _sizeThreshold;\n\n/**\n* Mask used to get index from hash values; equal to\n* <code>_buckets.length - 1</code>, when _buckets.length is\n* a power of two.\n*/\nprotected int _indexMask;\n\n/**\n* We need to keep track of the longest collision list; this is needed\n* both to indicate problems with attacks and to allow flushing for\n* other cases.\n*\n* @since 2.1\n*/\nprotected int _longestCollisionList;\n\n/*\n/**********************************************************\n/* State regarding shared arrays\n/**********************************************************\n*/\n\n/**\n* Flag that indicates if any changes have been made to the data;\n* used to both determine if bucket array needs to be copied when\n* (first) change is made, and potentially if updated bucket list\n* is to be resync'ed back to master instance.\n*/\nprotected boolean _dirty;\n\n/*\n/**********************************************************\n/* Bit of DoS detection goodness\n/**********************************************************\n*/\n\n/**\n* Lazily constructed structure that is used to keep track of\n* collision buckets that have overflowed once: this is used\n* to detect likely attempts at denial-of-service attacks that\n* uses hash collisions.\n*\n* @since 2.4\n*/\nprotected BitSet _overflows;\n\n/*\n/**********************************************************\n/* Life-cycle\n/**********************************************************\n*/\n\n/**\n* Method called to create root canonicalizer for a {@link com.fasterxml.jackson.core.JsonFactory}",
            "method_id": 49
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:<clinit>()V",
            "method_body": "final static byte BYTE_LF = (byte) '\\n';\n\n// This is the main input-code lookup table, fetched eagerly\nprivate final static int[] _icUTF8 = CharTypes.getInputCodeUtf8();\n\n// Latin1 encoding is not supported, but we do use 8-bit subset for\n// pre-processing task, to simplify first pass, keep it fast.\nprotected final static int[] _icLatin1 = CharTypes.getInputCodeLatin1();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\n/**\n* Codec used for data binding when (if) requested; typically full\n* <code>ObjectMapper</code>, but that abstract is not part of core\n* package.\n*/\nprotected ObjectCodec _objectCodec;\n\n/**\n* Symbol table that contains field names encountered so far\n*/\nfinal protected ByteQuadsCanonicalizer _symbols;\n\n/*\n/**********************************************************\n/* Parsing state\n/**********************************************************\n*/\n\n/**\n* Temporary buffer used for name parsing.\n*/\nprotected int[] _quadBuffer = new int[16];\n\n/**\n* Flag that indicates that the current token has not yet\n* been fully processed, and needs to be finished for\n* some access (or skipped to obtain the next token)\n*/\nprotected boolean _tokenIncomplete = false;\n\n/**\n* Temporary storage for partially parsed name bytes.\n*/\nprivate int _quad1;\n\n/*\n/**********************************************************\n/* Input buffering (from former 'StreamBasedParserBase')\n/**********************************************************\n*/\n\nprotected InputStream _inputStream;\n\n/*\n/**********************************************************\n/* Current input data\n/**********************************************************\n*/\n\n/**\n* Current buffer from which data is read; generally data is read into\n* buffer from input source, but in some cases pre-loaded buffer\n* is handed to the parser.\n*/\nprotected byte[] _inputBuffer;\n\n/**\n* Flag that indicates whether the input buffer is recycable (and\n* needs to be returned to recycler once we are done) or not.\n*<p>\n* If it is not, it also means that parser can NOT modify underlying\n* buffer.\n*/\nprotected boolean _bufferRecyclable;\n\n/*\n/**********************************************************\n/* Life-cycle\n/**********************************************************\n*/\n\npublic UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\nObjectCodec codec, ByteQuadsCanonicalizer sym,\nbyte[] inputBuffer, int start, int end,\nboolean bufferRecyclable)\n{\nsuper(ctxt, features);\n_inputStream = in;\n_objectCodec = codec;\n_symbols = sym;\n_inputBuffer = inputBuffer;\n_inputPtr = start;\n_inputEnd = end;\n_currInputRowStart = start;\n// If we have offset, need to omit that from byte offset, so:\n_currInputProcessed = -start;\n_bufferRecyclable = bufferRecyclable;\n}",
            "method_id": 50
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper:<init>(Lcom/fasterxml/jackson/core/io/IOContext;[BII)V",
            "method_body": "public ByteSourceJsonBootstrapper(IOContext ctxt, byte[] inputBuffer, int inputStart, int inputLen) {\n_context = ctxt;\n_in = null;\n_inputBuffer = inputBuffer;\n_inputPtr = inputStart;\n_inputEnd = (inputStart + inputLen);\n// Need to offset this for correct location info\n_inputProcessed = -inputStart;\n_bufferRecyclable = false;\n}",
            "method_id": 51
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:parseMediumName2(II)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleUnexpectedValue(i);\n}\n\n\nprivate final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n{\n// // // and this is back to standard nextToken()\n\nString n = _parseName(i);\n_parsingContext.setCurrentName(n);\nfinal boolean match = n.equals(str.getValue());\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n\n// Ok: we must have a value... what is it? Strings are very common, check first:\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn match;\n}\nJsonToken t;\n\nswitch (i) {\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ncase 't':\n_matchToken(\"true\", 1);\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase 'f':\n_matchToken(\"false\", 1);\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchToken(\"null\", 1);\nt = JsonToken.VALUE_NULL;\nbreak;\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ndefault:\nt = _handleUnexpectedValue(i);\n}\n_nextToken = t;\nreturn match;\n}\n\n@Override\npublic String nextTextValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\nreturn _finishAndReturnString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n@Override\npublic int nextIntValue(int defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n@Override\npublic long nextLongValue(long defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n@Override\npublic Boolean nextBooleanValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n\nJsonToken t = nextToken();\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected JsonToken _parsePosNumber(int c) throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n// Ok: we can first just add digit we saw first:\noutBuf[0] = (char) c;\nint intLen = 1;\nint outPtr = 1;\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - 1; // 1 == outPtr\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) { // split across boundary, offline\nreturn _parseNumber2(outBuf, outPtr, false, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, false, intLen);\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n// And there we have it!\nreturn resetInt(false, intLen);\n}\n\nprotected JsonToken _parseNegNumber() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\noutBuf[outPtr++] = '-';\n// Must have something after sign too\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Note: must be followed by a digit\nif (c < INT_0 || c > INT_9) {\nreturn _handleInvalidNumberStart(c, true);\n}\n\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n\n// Ok: we can first just add digit we saw first:\noutBuf[outPtr++] = (char) c;\nint intLen = 1;\n\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - outPtr;\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) {\n// Long enough to be split across boundary, so:\nreturn _parseNumber2(outBuf, outPtr, true, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, true, intLen);\n}\n\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n\n// And there we have it!\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to handle parsing when input is split across buffer boundary\n* (or output is longer than segment used to store it)\n*/\nprivate final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\nint intPartLength) throws IOException\n{\n// Ok, parse the rest\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_textBuffer.setCurrentLength(outPtr);\nreturn resetInt(negative, intPartLength);\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c > INT_9 || c < INT_0) {\nif (c == INT_PERIOD || c == INT_e || c == INT_E) {\nreturn _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n}\nbreak;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n++intPartLength;\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n}\n\n// And there we have it!\nreturn resetInt(negative, intPartLength);\n\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final int _verifyNoLeadingZeroes() throws IOException\n{\n// Ok to have plain \"0\"\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn INT_0;\n}\nint ch = _inputBuffer[_inputPtr] & 0xFF;\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < INT_0 || ch > INT_9) {\nreturn INT_0;\n}\n// [JACKSON-358]: we may want to allow them, after all...\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\nreturn INT_0;\n}\n++_inputPtr; // skip previous zeroes\nif (ch != INT_0) { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\nboolean negative, int integerPartLength) throws IOException\n{\nint fractLen = 0;\nboolean eof = false;\n\n// And then see if we get other parts\nif (c == INT_PERIOD) { // yes, fraction\noutBuf[outPtr++] = (char) c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == INT_e || c == INT_E) { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Not optional, can require that we get one more char\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Likewise, non optional:\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n\n// And there we have it!\nreturn resetFloat(negative, integerPartLength, fractLen, expLen);\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\n// TODO? Handle UTF-8 char decoding for error reporting\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName(int i) throws IOException\n{\nif (i != INT_QUOTE) {\nreturn _handleOddName(i);\n}\n// First: can we optimize out bounds checks?\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\n}\n\n// If so, can also unroll loops nicely\n/* 25-Nov-2008, tatu: This may seem weird, but here we do\n*   NOT want to worry about UTF-8 decoding. Rather, we'll\n*   assume that part is ok (if not it will get caught\n*   later on), and just handle quotes and backslashes here.\n*/\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\nint q = input[_inputPtr++] & 0xFF;\n\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\n}\nif (i == INT_QUOTE) { // 4 byte/char case or broken\nreturn findName(q, 4);\n}\nreturn parseName(q, i, 4);\n}\nif (i == INT_QUOTE) { // 3 byte/char case or broken\nreturn findName(q, 3);\n}\nreturn parseName(q, i, 3);\n}\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\n}\nreturn parseName(q, i, 2);\n}\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\n}\nreturn parseName(q, i, 1);\n}\nif (q == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseName(0, q, 0); // quoting or invalid char\n}\n\nprotected final String parseMediumName(int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Ok, got 5 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 5 bytes\nreturn findName(_quad1, q2, 1);\n}\nreturn parseName(_quad1, q2, i, 1); // quoting or invalid char\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 6 bytes\nreturn findName(_quad1, q2, 2);\n}\nreturn parseName(_quad1, q2, i, 2);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 7 bytes\nreturn findName(_quad1, q2, 3);\n}\nreturn parseName(_quad1, q2, i, 3);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 8 bytes\nreturn findName(_quad1, q2, 4);\n}\nreturn parseName(_quad1, q2, i, 4);\n}\nreturn parseMediumName2(i, q2);\n}\n\n/**\n* @since 2.6\n*/\nprotected final String parseMediumName2(int q3, final int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Got 9 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 9 bytes\nreturn findName(_quad1, q2, q3, 1);\n}\nreturn parseName(_quad1, q2, q3, i, 1);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 10 bytes\nreturn findName(_quad1, q2, q3, 2);\n}\nreturn parseName(_quad1, q2, q3, i, 2);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 11 bytes\nreturn findName(_quad1, q2, q3, 3);\n}\nreturn parseName(_quad1, q2, q3, i, 3);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 12 bytes\nreturn findName(_quad1, q2, q3, 4);\n}\nreturn parseName(_quad1, q2, q3, i, 4);\n}\nreturn parseLongName(i, q2, q3);\n}\n\nprotected final String parseLongName(int q, final int q2, int q3) throws IOException\n{\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\n\n// As explained above, will ignore UTF-8 encoding at this point\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\n\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 1);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 2);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 2);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 3);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 3);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 4);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 4);\n}\n\n// Nope, no end in sight. Need to grow quad array etc\nif (qlen >= _quadBuffer.length) {\n_quadBuffer = growArrayBy(_quadBuffer, qlen);\n}\n_quadBuffer[qlen++] = q;\nq = i;\n}\n\n/* Let's offline if we hit buffer boundary (otherwise would\n* need to [try to] align input, which is bit complicated\n* and may not always be possible)\n*/\nreturn parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n}\n\n/**\n* Method called when not even first 8 bytes are guaranteed\n* to come consequtively. Happens rarely, so this is offlined;\n* plus we'll also do full checks for escaping etc.\n*/\nprotected String slowParseName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n}\n}\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\n}\n\nprivate final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\nreturn parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\nreturn parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n}\n\n/**\n* Slower parsing method which is generally branched to when\n* an escape sequence is detected (or alternatively for long\n* names, one crossing input buffer boundary).\n* Needs to be able to handle more exceptional cases, gets slower,\n* and hance is offlined to a separate method.\n*/\nprotected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\nint currQuadBytes) throws IOException\n{\n/* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n*   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n*   caught later on), and just handle quotes and backslashes here.\n*/\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\n}\n// Unquoted white space?\nif (ch != INT_BACKSLASH) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int ch) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\nchar c = (char) _decodeCharForError(ch);\n_reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n}\n/* Also: note that although we use a different table here,\n* it does NOT handle UTF-8 decoding. It'll just pass those\n* high-bit codes as acceptable for later decoding.\n*/\nfinal int[] codes = CharTypes.getInputCodeUtf8JsNames();\n// Also: must start with a valid character...\nif (codes[ch] != 0) {\n_reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\n\n/* Ok, now; instead of ultra-optimizing parsing here (as with\n* regular JSON names), let's just use the generic \"slow\"\n* variant. Can measure its impact later on if need be\n*/\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\nwhile (true) {\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (codes[ch] != 0) {\nbreak;\n}\n++_inputPtr;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n* main reason being to try to avoid slowing down fast path\n* for valid JSON -- more alternatives, more code, generally\n* bit slower execution.\n*/\nprotected String _parseAposName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\'' for name\");\n}\n}\nint ch = _inputBuffer[_inputPtr++] & 0xFF;\nif (ch == '\\'') { // special case, ''\nreturn \"\";\n}\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\n// Copied from parseEscapedFieldName, with minor mods:\n\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (ch == '\\'') {\nbreak;\n}\n// additional check to skip handling of double-quotes\nif (ch != '\"' && codes[ch] != 0) {\nif (ch != '\\\\') {\n// Unquoted white space?\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/*\n/**********************************************************\n/* Internal methods, symbol (name) handling\n/**********************************************************\n*/\n\nprivate final String findName(int q1, int lastQuadBytes) throws JsonParseException\n{\nq1 = pad(q1, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n{\nq2 = pad(q2, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1, q2);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn addName(_quadBuffer, 2, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n{\nq3 = pad(q3, lastQuadBytes);\nString name = _symbols.findName(q1, q2, q3);\nif (name != null) {\nreturn name;\n}\nint[] quads = _quadBuffer;\nquads[0] = q1;\nquads[1] = q2;\nquads[2] = pad(q3, lastQuadBytes);\nreturn addName(quads, 3, lastQuadBytes);\n}\n\nprivate final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n{\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\n}\nreturn name;\n}\n\n/**\n* This is the main workhorse method used when we take a symbol\n* table miss. It needs to demultiplex individual bytes, decode\n* multi-byte chars (if any), and then construct Name instance\n* and add it to the symbol table.\n*/\nprivate final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n{\n/* Ok: must decode UTF-8 chars. No other validation is\n* needed, since unescaping has been done earlier as necessary\n* (as well as error reporting for unescaped control chars)\n*/\n// 4 bytes per quad, except last one maybe less\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n/* And last one is not correctly aligned (leading zero bytes instead\n* need to shift a bit, instead of trailing). Only need to shift it\n* for UTF-8 decoding; need revert for storage (since key will not\n* be aligned, to optimize lookup speed)\n*/\nint lastQuad;\n\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\n// 8/16/24 bit left shift\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n} else {\nlastQuad = 0;\n}\n\n// Need some working space, TextBuffer works well:\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\n\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\n\nif (ch > 127) { // multi-byte\nint needed;\nif ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\nch &= 0x1F;\nneeded = 1;\n} else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\nch &= 0x0F;\nneeded = 2;\n} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\nch &= 0x07;\nneeded = 3;\n} else { // 5- and 6-byte chars not valid xml chars\n_reportInvalidInitial(ch);\nneeded = ch = 1; // never really gets this far\n}\nif ((ix + needed) > byteLen) {\n_reportInvalidEOF(\" in field name\");\n}\n\n// Ok, always need at least one more:\nint ch2 = quads[ix >> 2]; // current quad, need to shift+mask\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 1) {\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 2) { // 4 bytes? (need surrogates on output)\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2 & 0xFF);\n}\nch = (ch << 6) | (ch2 & 0x3F);\n}\n}\nif (needed > 2) { // surrogate pair? once again, let's output one here, one later on\nch -= 0x10000; // to normalize it starting with 0x0\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) (0xD800 + (ch >> 10));\nch = 0xDC00 | (ch & 0x03FF);\n}\n}\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) ch;\n}\n\n// Ok. Now we have the character array, and can construct the String\nString baseName = new String(cbuf, 0, cix);\n// And finally, un-align if necessary\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\n}\nreturn _symbols.addName(baseName, quads, qlen);\n}\n\n/*\n/**********************************************************\n/* Internal methods, String value parsing\n/**********************************************************\n*/\n\n@Override\nprotected void _finishString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\n_textBuffer.setCurrentLength(outPtr);\nreturn;\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\n}\n\n/**\n* @since 2.6\n*/\nprotected String _finishAndReturnString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\nreturn _textBuffer.setCurrentAndReturn(outPtr);\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\nreturn _textBuffer.contentsAsString();\n}\n\nprivate final void _finishString2(char[] outBuf, int outPtr)\nthrows IOException\n{\nint c;\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ASCII non-funny-char loop:\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nfinal int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nc = _decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\n// Need to be fully UTF-8 aware here:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\nint c;\n\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nint max = _inputEnd;\nif (ptr >= max) {\nloadMoreGuaranteed();\nptr = _inputPtr;\nmax = _inputEnd;\n}\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\n_decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\n_skipUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\n_skipUtf8_3(c);\nbreak;\ncase 4: // 4-byte UTF\n_skipUtf8_4(c);\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n}\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleUnexpectedValue(int c)\nthrows IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (c) {\ncase ']':\ncase '}':\n// Error: neither is valid at this point; valid closers have\n// been handled earlier\n_reportUnexpectedChar(c, \"expected a value\");\ncase '\\'':\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(c)) {\n_reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos()\nthrows IOException\n{\nint c = 0;\n// Otherwise almost verbatim copy of _finishString()\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ascii non-funny-char loop:\nascii_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nint max = _inputEnd;\n{\nint max2 = _inputPtr + (outBuf.length - outPtr);\nif (max2 < max) {\nmax = max2;\n}\n}\nwhile (_inputPtr < max) {\nc = (int) inputBuffer[_inputPtr++] & 0xFF;\nif (c == '\\'' || codes[c] != 0) {\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n}\n\n// Ok: end marker, escape or multi-byte?\nif (c == '\\'') {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nif (c != '\\'') { // marked as special, isn't here\nc = _decodeEscaped();\n}\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n_throwUnquotedSpace(c, \"string value\");\n}\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n\nreturn JsonToken.VALUE_STRING;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\nthrows IOException\n{\nwhile (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nch = _inputBuffer[_inputPtr++];\nString match;\nif (ch == 'N') {\nmatch = neg ? \"-INF\" :\"+INF\";\n} else if (ch == 'n') {\nmatch = neg ? \"-Infinity\" :\"+Infinity\";\n} else {\nbreak;\n}\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\nprotected final void _matchToken(String matchStr, int i) throws IOException\n{\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\n_matchToken2(matchStr, i);\nreturn;\n}\ndo {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n_reportInvalidToken(matchStr.substring(0, i));\n}\n++_inputPtr;\n} while (++i < len);\n\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n_checkMatchEnd(matchStr, i, ch);\n}\n}",
            "method_id": 52
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.IOContext:setEncoding(Lcom/fasterxml/jackson/core/JsonEncoding;)V",
            "method_body": "public void setEncoding(JsonEncoding enc) {\n_encoding = enc;\n}",
            "method_id": 53
        },
        {
            "method_signature": "com.fasterxml.jackson.core.base.ParserBase:<init>(Lcom/fasterxml/jackson/core/io/IOContext;I)V",
            "method_body": "protected ParserBase(IOContext ctxt, int features) {\nsuper(features);\n_ioContext = ctxt;\n_textBuffer = ctxt.constructTextBuffer();\nDupDetector dups = Feature.STRICT_DUPLICATE_DETECTION.enabledIn(features)\n? DupDetector.rootDetector(this) : null;\n_parsingContext = JsonReadContext.createRootContext(dups);\n}",
            "method_id": 54
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer$TableInfo:<init>(II[I[Lcom/fasterxml/jackson/core/sym/Name;[Lcom/fasterxml/jackson/core/sym/BytesToNameCanonicalizer$Bucket;III)V",
            "method_body": "public TableInfo(int count, int mainHashMask, int[] mainHash, Name[] mainNames,\nBucket[] collList, int collCount, int collEnd, int longestCollisionList)\n{\nthis.count = count;\nthis.mainHashMask = mainHashMask;\nthis.mainHash = mainHash;\nthis.mainNames = mainNames;\nthis.collList = collList;\nthis.collCount = collCount;\nthis.collEnd = collEnd;\nthis.longestCollisionList = longestCollisionList;\n}",
            "method_id": 55
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:parseMediumName(I)Ljava/lang/String;",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleUnexpectedValue(i);\n}\n\n\nprivate final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n{\n// // // and this is back to standard nextToken()\n\nString n = _parseName(i);\n_parsingContext.setCurrentName(n);\nfinal boolean match = n.equals(str.getValue());\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n\n// Ok: we must have a value... what is it? Strings are very common, check first:\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn match;\n}\nJsonToken t;\n\nswitch (i) {\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ncase 't':\n_matchToken(\"true\", 1);\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase 'f':\n_matchToken(\"false\", 1);\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchToken(\"null\", 1);\nt = JsonToken.VALUE_NULL;\nbreak;\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ndefault:\nt = _handleUnexpectedValue(i);\n}\n_nextToken = t;\nreturn match;\n}\n\n@Override\npublic String nextTextValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\nreturn _finishAndReturnString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n@Override\npublic int nextIntValue(int defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n@Override\npublic long nextLongValue(long defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n@Override\npublic Boolean nextBooleanValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n\nJsonToken t = nextToken();\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected JsonToken _parsePosNumber(int c) throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n// Ok: we can first just add digit we saw first:\noutBuf[0] = (char) c;\nint intLen = 1;\nint outPtr = 1;\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - 1; // 1 == outPtr\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) { // split across boundary, offline\nreturn _parseNumber2(outBuf, outPtr, false, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, false, intLen);\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n// And there we have it!\nreturn resetInt(false, intLen);\n}\n\nprotected JsonToken _parseNegNumber() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\noutBuf[outPtr++] = '-';\n// Must have something after sign too\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Note: must be followed by a digit\nif (c < INT_0 || c > INT_9) {\nreturn _handleInvalidNumberStart(c, true);\n}\n\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n\n// Ok: we can first just add digit we saw first:\noutBuf[outPtr++] = (char) c;\nint intLen = 1;\n\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - outPtr;\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) {\n// Long enough to be split across boundary, so:\nreturn _parseNumber2(outBuf, outPtr, true, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, true, intLen);\n}\n\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n\n// And there we have it!\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to handle parsing when input is split across buffer boundary\n* (or output is longer than segment used to store it)\n*/\nprivate final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\nint intPartLength) throws IOException\n{\n// Ok, parse the rest\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_textBuffer.setCurrentLength(outPtr);\nreturn resetInt(negative, intPartLength);\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c > INT_9 || c < INT_0) {\nif (c == INT_PERIOD || c == INT_e || c == INT_E) {\nreturn _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n}\nbreak;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n++intPartLength;\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n}\n\n// And there we have it!\nreturn resetInt(negative, intPartLength);\n\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final int _verifyNoLeadingZeroes() throws IOException\n{\n// Ok to have plain \"0\"\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn INT_0;\n}\nint ch = _inputBuffer[_inputPtr] & 0xFF;\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < INT_0 || ch > INT_9) {\nreturn INT_0;\n}\n// [JACKSON-358]: we may want to allow them, after all...\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\nreturn INT_0;\n}\n++_inputPtr; // skip previous zeroes\nif (ch != INT_0) { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\nboolean negative, int integerPartLength) throws IOException\n{\nint fractLen = 0;\nboolean eof = false;\n\n// And then see if we get other parts\nif (c == INT_PERIOD) { // yes, fraction\noutBuf[outPtr++] = (char) c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == INT_e || c == INT_E) { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Not optional, can require that we get one more char\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Likewise, non optional:\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n\n// And there we have it!\nreturn resetFloat(negative, integerPartLength, fractLen, expLen);\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\n// TODO? Handle UTF-8 char decoding for error reporting\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName(int i) throws IOException\n{\nif (i != INT_QUOTE) {\nreturn _handleOddName(i);\n}\n// First: can we optimize out bounds checks?\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\n}\n\n// If so, can also unroll loops nicely\n/* 25-Nov-2008, tatu: This may seem weird, but here we do\n*   NOT want to worry about UTF-8 decoding. Rather, we'll\n*   assume that part is ok (if not it will get caught\n*   later on), and just handle quotes and backslashes here.\n*/\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\nint q = input[_inputPtr++] & 0xFF;\n\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\n}\nif (i == INT_QUOTE) { // 4 byte/char case or broken\nreturn findName(q, 4);\n}\nreturn parseName(q, i, 4);\n}\nif (i == INT_QUOTE) { // 3 byte/char case or broken\nreturn findName(q, 3);\n}\nreturn parseName(q, i, 3);\n}\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\n}\nreturn parseName(q, i, 2);\n}\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\n}\nreturn parseName(q, i, 1);\n}\nif (q == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseName(0, q, 0); // quoting or invalid char\n}\n\nprotected final String parseMediumName(int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Ok, got 5 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 5 bytes\nreturn findName(_quad1, q2, 1);\n}\nreturn parseName(_quad1, q2, i, 1); // quoting or invalid char\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 6 bytes\nreturn findName(_quad1, q2, 2);\n}\nreturn parseName(_quad1, q2, i, 2);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 7 bytes\nreturn findName(_quad1, q2, 3);\n}\nreturn parseName(_quad1, q2, i, 3);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 8 bytes\nreturn findName(_quad1, q2, 4);\n}\nreturn parseName(_quad1, q2, i, 4);\n}\nreturn parseMediumName2(i, q2);\n}\n\n/**\n* @since 2.6\n*/\nprotected final String parseMediumName2(int q3, final int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Got 9 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 9 bytes\nreturn findName(_quad1, q2, q3, 1);\n}\nreturn parseName(_quad1, q2, q3, i, 1);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 10 bytes\nreturn findName(_quad1, q2, q3, 2);\n}\nreturn parseName(_quad1, q2, q3, i, 2);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 11 bytes\nreturn findName(_quad1, q2, q3, 3);\n}\nreturn parseName(_quad1, q2, q3, i, 3);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 12 bytes\nreturn findName(_quad1, q2, q3, 4);\n}\nreturn parseName(_quad1, q2, q3, i, 4);\n}\nreturn parseLongName(i, q2, q3);\n}\n\nprotected final String parseLongName(int q, final int q2, int q3) throws IOException\n{\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\n\n// As explained above, will ignore UTF-8 encoding at this point\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\n\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 1);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 2);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 2);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 3);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 3);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 4);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 4);\n}\n\n// Nope, no end in sight. Need to grow quad array etc\nif (qlen >= _quadBuffer.length) {\n_quadBuffer = growArrayBy(_quadBuffer, qlen);\n}\n_quadBuffer[qlen++] = q;\nq = i;\n}\n\n/* Let's offline if we hit buffer boundary (otherwise would\n* need to [try to] align input, which is bit complicated\n* and may not always be possible)\n*/\nreturn parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n}\n\n/**\n* Method called when not even first 8 bytes are guaranteed\n* to come consequtively. Happens rarely, so this is offlined;\n* plus we'll also do full checks for escaping etc.\n*/\nprotected String slowParseName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n}\n}\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\n}\n\nprivate final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\nreturn parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\nreturn parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n}\n\n/**\n* Slower parsing method which is generally branched to when\n* an escape sequence is detected (or alternatively for long\n* names, one crossing input buffer boundary).\n* Needs to be able to handle more exceptional cases, gets slower,\n* and hance is offlined to a separate method.\n*/\nprotected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\nint currQuadBytes) throws IOException\n{\n/* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n*   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n*   caught later on), and just handle quotes and backslashes here.\n*/\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\n}\n// Unquoted white space?\nif (ch != INT_BACKSLASH) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int ch) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\nchar c = (char) _decodeCharForError(ch);\n_reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n}\n/* Also: note that although we use a different table here,\n* it does NOT handle UTF-8 decoding. It'll just pass those\n* high-bit codes as acceptable for later decoding.\n*/\nfinal int[] codes = CharTypes.getInputCodeUtf8JsNames();\n// Also: must start with a valid character...\nif (codes[ch] != 0) {\n_reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\n\n/* Ok, now; instead of ultra-optimizing parsing here (as with\n* regular JSON names), let's just use the generic \"slow\"\n* variant. Can measure its impact later on if need be\n*/\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\nwhile (true) {\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (codes[ch] != 0) {\nbreak;\n}\n++_inputPtr;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n* main reason being to try to avoid slowing down fast path\n* for valid JSON -- more alternatives, more code, generally\n* bit slower execution.\n*/\nprotected String _parseAposName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\'' for name\");\n}\n}\nint ch = _inputBuffer[_inputPtr++] & 0xFF;\nif (ch == '\\'') { // special case, ''\nreturn \"\";\n}\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\n// Copied from parseEscapedFieldName, with minor mods:\n\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (ch == '\\'') {\nbreak;\n}\n// additional check to skip handling of double-quotes\nif (ch != '\"' && codes[ch] != 0) {\nif (ch != '\\\\') {\n// Unquoted white space?\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/*\n/**********************************************************\n/* Internal methods, symbol (name) handling\n/**********************************************************\n*/\n\nprivate final String findName(int q1, int lastQuadBytes) throws JsonParseException\n{\nq1 = pad(q1, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n{\nq2 = pad(q2, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1, q2);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn addName(_quadBuffer, 2, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n{\nq3 = pad(q3, lastQuadBytes);\nString name = _symbols.findName(q1, q2, q3);\nif (name != null) {\nreturn name;\n}\nint[] quads = _quadBuffer;\nquads[0] = q1;\nquads[1] = q2;\nquads[2] = pad(q3, lastQuadBytes);\nreturn addName(quads, 3, lastQuadBytes);\n}\n\nprivate final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n{\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\n}\nreturn name;\n}\n\n/**\n* This is the main workhorse method used when we take a symbol\n* table miss. It needs to demultiplex individual bytes, decode\n* multi-byte chars (if any), and then construct Name instance\n* and add it to the symbol table.\n*/\nprivate final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n{\n/* Ok: must decode UTF-8 chars. No other validation is\n* needed, since unescaping has been done earlier as necessary\n* (as well as error reporting for unescaped control chars)\n*/\n// 4 bytes per quad, except last one maybe less\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n/* And last one is not correctly aligned (leading zero bytes instead\n* need to shift a bit, instead of trailing). Only need to shift it\n* for UTF-8 decoding; need revert for storage (since key will not\n* be aligned, to optimize lookup speed)\n*/\nint lastQuad;\n\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\n// 8/16/24 bit left shift\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n} else {\nlastQuad = 0;\n}\n\n// Need some working space, TextBuffer works well:\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\n\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\n\nif (ch > 127) { // multi-byte\nint needed;\nif ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\nch &= 0x1F;\nneeded = 1;\n} else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\nch &= 0x0F;\nneeded = 2;\n} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\nch &= 0x07;\nneeded = 3;\n} else { // 5- and 6-byte chars not valid xml chars\n_reportInvalidInitial(ch);\nneeded = ch = 1; // never really gets this far\n}\nif ((ix + needed) > byteLen) {\n_reportInvalidEOF(\" in field name\");\n}\n\n// Ok, always need at least one more:\nint ch2 = quads[ix >> 2]; // current quad, need to shift+mask\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 1) {\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 2) { // 4 bytes? (need surrogates on output)\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2 & 0xFF);\n}\nch = (ch << 6) | (ch2 & 0x3F);\n}\n}\nif (needed > 2) { // surrogate pair? once again, let's output one here, one later on\nch -= 0x10000; // to normalize it starting with 0x0\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) (0xD800 + (ch >> 10));\nch = 0xDC00 | (ch & 0x03FF);\n}\n}\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) ch;\n}\n\n// Ok. Now we have the character array, and can construct the String\nString baseName = new String(cbuf, 0, cix);\n// And finally, un-align if necessary\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\n}\nreturn _symbols.addName(baseName, quads, qlen);\n}\n\n/*\n/**********************************************************\n/* Internal methods, String value parsing\n/**********************************************************\n*/\n\n@Override\nprotected void _finishString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\n_textBuffer.setCurrentLength(outPtr);\nreturn;\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\n}\n\n/**\n* @since 2.6\n*/\nprotected String _finishAndReturnString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\nreturn _textBuffer.setCurrentAndReturn(outPtr);\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\nreturn _textBuffer.contentsAsString();\n}\n\nprivate final void _finishString2(char[] outBuf, int outPtr)\nthrows IOException\n{\nint c;\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ASCII non-funny-char loop:\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nfinal int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nc = _decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\n// Need to be fully UTF-8 aware here:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\nint c;\n\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nint max = _inputEnd;\nif (ptr >= max) {\nloadMoreGuaranteed();\nptr = _inputPtr;\nmax = _inputEnd;\n}\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\n_decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\n_skipUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\n_skipUtf8_3(c);\nbreak;\ncase 4: // 4-byte UTF\n_skipUtf8_4(c);\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n}\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleUnexpectedValue(int c)\nthrows IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (c) {\ncase ']':\ncase '}':\n// Error: neither is valid at this point; valid closers have\n// been handled earlier\n_reportUnexpectedChar(c, \"expected a value\");\ncase '\\'':\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(c)) {\n_reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos()\nthrows IOException\n{\nint c = 0;\n// Otherwise almost verbatim copy of _finishString()\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ascii non-funny-char loop:\nascii_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nint max = _inputEnd;\n{\nint max2 = _inputPtr + (outBuf.length - outPtr);\nif (max2 < max) {\nmax = max2;\n}\n}\nwhile (_inputPtr < max) {\nc = (int) inputBuffer[_inputPtr++] & 0xFF;\nif (c == '\\'' || codes[c] != 0) {\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n}\n\n// Ok: end marker, escape or multi-byte?\nif (c == '\\'') {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nif (c != '\\'') { // marked as special, isn't here\nc = _decodeEscaped();\n}\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n_throwUnquotedSpace(c, \"string value\");\n}\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n\nreturn JsonToken.VALUE_STRING;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\nthrows IOException\n{\nwhile (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nch = _inputBuffer[_inputPtr++];\nString match;\nif (ch == 'N') {\nmatch = neg ? \"-INF\" :\"+INF\";\n} else if (ch == 'n') {\nmatch = neg ? \"-Infinity\" :\"+Infinity\";\n} else {\nbreak;\n}\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\nprotected final void _matchToken(String matchStr, int i) throws IOException\n{\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\n_matchToken2(matchStr, i);\nreturn;\n}\ndo {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n_reportInvalidToken(matchStr.substring(0, i));\n}\n++_inputPtr;\n} while (++i < len);\n\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n_checkMatchEnd(matchStr, i, ch);\n}\n}",
            "method_id": 56
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:_findOffsetForAdd(I)I",
            "method_body": "private int _findOffsetForAdd(int hash)\n{\n// first, check the primary:\nint offset = _calcOffset(hash);\nfinal int[] hashArea = _hashArea;\nif (hashArea[offset+3] == 0) {\n//System.err.printf(\" PRImary slot #%d, hash %X\\n\", (offset>>2), hash & 0x7F);\nreturn offset;\n}\n// then secondary\nint offset2 = _secondaryStart + ((offset >> 3) << 2);\nif (hashArea[offset2+3] == 0) {\n//System.err.printf(\" SECondary slot #%d (start x%X), hash %X\\n\",(offset >> 3), _secondaryStart, (hash & 0x7F));\nreturn offset2;\n}\n// if not, tertiary?\n\noffset2 = _tertiaryStart + ((offset >> (_tertiaryShift + 2)) << _tertiaryShift);\nfinal int bucketSize = (1 << _tertiaryShift);\nfor (int end = offset2 + bucketSize; offset2 < end; offset2 += 4) {\nif (hashArea[offset2+3] == 0) {\n//System.err.printf(\" TERtiary slot x%X (from x%X, start x%X), hash %X.\\n\", offset2, ((offset >> (_tertiaryShift + 2)) << _tertiaryShift), _tertiaryStart, (hash & 0x7F));\nreturn offset2;\n}\n}\n\n// and if even tertiary full, append at the end of spill area\noffset = _spilloverEnd;\n_spilloverEnd += 4;\n\n//System.err.printf(\" SPIll-over at x%X; start x%X; end x%X, hash %X\\n\", offset, _spilloverStart(), _hashArea.length, (hash & 0x7F));\n\n// one caveat: in the unlikely event if spill-over filling up,\n// check if that could be considered a DoS attack; handle appropriately\n// (NOTE: approximate for now; we could verify details if that becomes necessary)\n/* 31-Jul-2015, tatu: Note that spillover area does NOT end at end of array,\n*   since \"long names\" area follows. Instead, need to calculate from hash size.\n*/\nif (_spilloverEnd >= hashArea.length) {\nif (_failOnDoS) {\n_reportTooManyCollisions();\n}\n// and if we didn't fail, we'll simply force rehash for next add\n// (which, in turn, may double up or nuke contents, depending on size etc)\n_needRehash = true;\n}\nreturn offset;\n}",
            "method_id": 57
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer$TableInfo:createInitial(I)Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer$TableInfo;",
            "method_body": "public static TableInfo createInitial(int sz) {\nint hashAreaSize = sz << 3;\nint tertShift = _calcTertiaryShift(sz);\n\nreturn new TableInfo(sz, // hashSize\n0, // count\ntertShift,\nnew int[hashAreaSize], // mainHash, 2x slots, 4 ints per slot\nnew String[sz << 1], // names == 2x slots\nhashAreaSize - sz, // at 7/8 of the total area\nhashAreaSize // longNameOffset, immediately after main hashes\n);\n}",
            "method_id": 58
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:createRootContext(Lcom/fasterxml/jackson/core/json/DupDetector;)Lcom/fasterxml/jackson/core/json/JsonReadContext;",
            "method_body": "public static JsonReadContext createRootContext(DupDetector dups) {\nreturn new JsonReadContext(null, dups, TYPE_ROOT, 1, 0);\n}",
            "method_id": 59
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;)V",
            "method_body": "public JsonFactory(ObjectCodec oc) { _objectCodec = oc; }\npublic JsonFactory(ObjectCodec oc) { _objectCodec = oc; }",
            "method_id": 60
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:_createContext(Ljava/lang/Object;Z)Lcom/fasterxml/jackson/core/io/IOContext;",
            "method_body": "protected IOContext _createContext(Object srcRef, boolean resourceManaged) {\nreturn new IOContext(_getBufferRecycler(), srcRef, resourceManaged);\n}",
            "method_id": 61
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:emptyAndGetCurrentSegment()[C",
            "method_body": "public char[] emptyAndGetCurrentSegment()\n{\n// inlined 'resetWithEmpty()'\n_inputStart = -1; // indicates shared buffer not used\n_currentSize = 0;\n_inputLen = 0;\n\n_inputBuffer = null;\n_resultString = null;\n_resultArray = null;\n\n// And then reset internal input buffers, if necessary:\nif (_hasSegments) {\nclearSegments();\n}\nchar[] curr = _currentSegment;\nif (curr == null) {\n_currentSegment = curr = buf(0);\n}\nreturn curr;\n}",
            "method_id": 62
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:enabledIn(I)Z",
            "method_body": "public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\npublic boolean enabledIn(int flags) { return (flags & getMask()) != 0; }",
            "method_id": 63
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_nextTokenNotInObject(I)Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "private final JsonToken _nextTokenNotInObject(int i) throws IOException\n{\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\nreturn (_currToken = JsonToken.VALUE_STRING);\n}\nswitch (i) {\ncase '[':\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_ARRAY);\ncase '{':\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\nreturn (_currToken = JsonToken.START_OBJECT);\ncase 't':\n_matchToken(\"true\", 1);\nreturn (_currToken = JsonToken.VALUE_TRUE);\ncase 'f':\n_matchToken(\"false\", 1);\nreturn (_currToken = JsonToken.VALUE_FALSE);\ncase 'n':\n_matchToken(\"null\", 1);\nreturn (_currToken = JsonToken.VALUE_NULL);\ncase '-':\nreturn (_currToken = _parseNegNumber());\n/* Should we have separate handling for plus? Although\n* it is not allowed per se, it may be erroneously used,\n* and could be indicated by a more specific error message.\n*/\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nreturn (_currToken = _parsePosNumber(i));\n}\nreturn (_currToken = _handleUnexpectedValue(i));\n}\n\nprivate final JsonToken _nextAfterName()\n{\n_nameCopied = false; // need to invalidate if it was copied\nJsonToken t = _nextToken;\n_nextToken = null;\n// Also: may need to start new context?\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn (_currToken = t);\n}\n\n/*\n/**********************************************************\n/* Public API, traversal, nextXxxValue/nextFieldName\n/**********************************************************\n*/\n\n@Override\npublic boolean nextFieldName(SerializableString str) throws IOException\n{\n// // // Note: most of code below is copied from nextToken()\n\n_numTypesValid = NR_UNKNOWN;\nif (_currToken == JsonToken.FIELD_NAME) { // can't have name right after name\n_nextAfterName();\nreturn false;\n}\nif (_tokenIncomplete) {\n_skipString();\n}\nint i = _skipWSOrEnd();\nif (i < 0) { // end-of-input\nclose();\n_currToken = null;\nreturn false;\n}\n_tokenInputTotal = _currInputProcessed + _inputPtr - 1;\n_tokenInputRow = _currInputRow;\n_tokenInputCol = _inputPtr - _currInputRowStart - 1;\n\n// finally: clear any data retained so far\n_binaryValue = null;\n\n// Closing scope?\nif (i == INT_RBRACKET) {\nif (!_parsingContext.inArray()) {\n_reportMismatchedEndMarker(i, '}');\n}\n_parsingContext = _parsingContext.getParent();\n_currToken = JsonToken.END_ARRAY;\nreturn false;\n}\nif (i == INT_RCURLY) {\nif (!_parsingContext.inObject()) {\n_reportMismatchedEndMarker(i, ']');\n}\n_parsingContext = _parsingContext.getParent();\n_currToken = JsonToken.END_OBJECT;\nreturn false;\n}\n\n// Nope: do we then expect a comma?\nif (_parsingContext.expectComma()) {\nif (i != INT_COMMA) {\n_reportUnexpectedChar(i, \"was expecting comma to separate \"+_parsingContext.getTypeDesc()+\" entries\");\n}\ni = _skipWS();\n}\n\nif (!_parsingContext.inObject()) {\n_nextTokenNotInObject(i);\nreturn false;\n}\n\n// // // This part differs, name parsing\nif (i == INT_QUOTE) {\n// when doing literal match, must consider escaping:\nbyte[] nameBytes = str.asQuotedUTF8();\nfinal int len = nameBytes.length;\n// 22-May-2014, tatu: Actually, let's require 4 more bytes for faster skipping\n//    of colon that follows name\nif ((_inputPtr + len + 4) < _inputEnd) { // maybe...\n// first check length match by\nfinal int end = _inputPtr+len;\nif (_inputBuffer[end] == INT_QUOTE) {\nint offset = 0;\nint ptr = _inputPtr;\nwhile (true) {\nif (ptr == end) { // yes, match!\n_parsingContext.setCurrentName(str.getValue());\n_isNextTokenNameYes(_skipColonFast(ptr+1));\nreturn true;\n}\nif (nameBytes[offset] != _inputBuffer[ptr]) {\nbreak;\n}\n++offset;\n++ptr;\n}\n}\n}\n}\nreturn _isNextTokenNameMaybe(i, str);\n}",
            "method_id": 64
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:createRoot(I)Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer;",
            "method_body": "protected static ByteQuadsCanonicalizer createRoot(int seed) {\nreturn new ByteQuadsCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n}",
            "method_id": 65
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:_appendLongName([II)I",
            "method_body": "private int _appendLongName(int[] quads, int qlen)\n{\nint start = _longNameOffset;\n\n// note: at this point we must already be shared. But may not have enough space\nif ((start + qlen) > _hashArea.length) {\n// try to increment in reasonable chunks; at least space that we need\nint toAdd = (start + qlen) - _hashArea.length;\n// but at least 1/8 of regular hash area size or 16kB (whichever smaller)\nint minAdd = Math.min(4096, _hashSize);\n\nint newSize = _hashArea.length + Math.max(toAdd, minAdd);\n_hashArea = Arrays.copyOf(_hashArea, newSize);\n}\nSystem.arraycopy(quads, 0, _hashArea, start, qlen);\n_longNameOffset += qlen;\nreturn start;\n}",
            "method_id": 66
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonGenerator$Feature:getMask()I",
            "method_body": "public int getMask() { return _mask; }\npublic int getMask() { return _mask; }",
            "method_id": 67
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer:initTableInfo(I)Lcom/fasterxml/jackson/core/sym/BytesToNameCanonicalizer$TableInfo;",
            "method_body": "private TableInfo initTableInfo(int sz) {\nreturn new TableInfo(0, // count\nsz - 1, // mainHashMask\nnew int[sz], // mainHash\nnew Name[sz], // mainNames\nnull, // collList\n0, // collCount,\n0, // collEnd\n0 // longestCollisionList\n);\n}",
            "method_id": 68
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer:<init>(IZIZ)V",
            "method_body": "private BytesToNameCanonicalizer(int sz, boolean intern, int seed, boolean failOnDoS) {\n_parent = null;\n_seed = seed;\n_intern = intern;\n_failOnDoS = failOnDoS;\n// Sanity check: let's now allow hash sizes below certain minimum value\nif (sz < MIN_HASH_SIZE) {\nsz = MIN_HASH_SIZE;\n} else {\n/* Also; size must be 2^N; otherwise hash algorithm won't\n* work... so let's just pad it up, if so\n*/\nif ((sz & (sz - 1)) != 0) { // only true if it's 2^N\nint curr = MIN_HASH_SIZE;\nwhile (curr < sz) {\ncurr += curr;\n}\nsz = curr;\n}\n}\n_tableInfo = new AtomicReference<TableInfo>(initTableInfo(sz));\n}",
            "method_id": 69
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.CharTypes:getInputCodeLatin1()[I",
            "method_body": "public static int[] getInputCodeLatin1() { return sInputCodes; }\npublic static int[] getInputCodeLatin1() { return sInputCodes; }",
            "method_id": 70
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:<init>(Lcom/fasterxml/jackson/core/io/IOContext;ILjava/io/InputStream;Lcom/fasterxml/jackson/core/ObjectCodec;Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer;[BIIZ)V",
            "method_body": "public UTF8StreamJsonParser(IOContext ctxt, int features, InputStream in,\nObjectCodec codec, ByteQuadsCanonicalizer sym,\nbyte[] inputBuffer, int start, int end,\nboolean bufferRecyclable)\n{\nsuper(ctxt, features);\n_inputStream = in;\n_objectCodec = codec;\n_symbols = sym;\n_inputBuffer = inputBuffer;\n_inputPtr = start;\n_inputEnd = end;\n_currInputRowStart = start;\n// If we have offset, need to omit that from byte offset, so:\n_currInputProcessed = -start;\n_bufferRecyclable = bufferRecyclable;\n}",
            "method_id": 71
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:enabledIn(I)Z",
            "method_body": "public boolean enabledIn(int flags) { return (flags & _mask) != 0; }\npublic boolean enabledIn(int flags) { return (flags & _mask) != 0; }",
            "method_id": 72
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:<init>()V",
            "method_body": "public BufferRecycler() {\nthis(4, 4);\n}",
            "method_id": 73
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:_findSecondary(II)Ljava/lang/String;",
            "method_body": "private String _findSecondary(int origOffset, int q1)\n{\n// tertiary area division is dynamic. First; its size is N/4 compared to\n// primary hash size; and offsets are for 4 int slots. So to get to logical\n// index would shift by 4. But! Tertiary area is further split into buckets,\n// determined by shift value. And finally, from bucket back into physical offsets\nint offset = _tertiaryStart + ((origOffset >> (_tertiaryShift + 2)) << _tertiaryShift);\nfinal int[] hashArea = _hashArea;\nfinal int bucketSize = (1 << _tertiaryShift);\nfor (int end = offset + bucketSize; offset < end; offset += 4) {\nint len = hashArea[offset+3];\nif ((q1 == hashArea[offset]) && (1 == len)) {\nreturn _names[offset >> 2];\n}\nif (len == 0) {\nreturn null;\n}\n}\n// but if tertiary full, check out spill-over area as last resort\n// shared spillover starts at 7/8 of the main hash area\n// (which is sized at 2 * _hashSize), so:\nfor (offset = _spilloverStart(); offset < _spilloverEnd; offset += 4) {\nif ((q1 == hashArea[offset]) && (1 == hashArea[offset+3])) {\nreturn _names[offset >> 2];\n}\n}\nreturn null;\n}",
            "method_id": 74
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.JsonReadContext:<init>(Lcom/fasterxml/jackson/core/json/JsonReadContext;Lcom/fasterxml/jackson/core/json/DupDetector;III)V",
            "method_body": "public JsonReadContext(JsonReadContext parent, DupDetector dups, int type, int lineNr, int colNr) {\nsuper();\n_parent = parent;\n_dups = dups;\n_type = type;\n_lineNr = lineNr;\n_columnNr = colNr;\n_index = -1;\n}",
            "method_id": 75
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:isEnabled(Lcom/fasterxml/jackson/core/JsonFactory$Feature;)Z",
            "method_body": "public final boolean isEnabled(JsonFactory.Feature f) {\nreturn (_factoryFeatures & f.getMask()) != 0;\n}",
            "method_id": 76
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:<clinit>()V",
            "method_body": "final static char[] NO_CHARS = new char[0];\n\n/**\n* Let's start with sizable but not huge buffer, will grow as necessary\n*/\nfinal static int MIN_SEGMENT_LEN = 1000;\n\n/**\n* Let's limit maximum segment length to something sensible\n* like 256k\n*/\nfinal static int MAX_SEGMENT_LEN = 0x40000;\n\n/*\n/**********************************************************\n/* Configuration:\n/**********************************************************\n*/\n\nprivate final BufferRecycler _allocator;\n\n/*\n/**********************************************************\n/* Shared input buffers\n/**********************************************************\n*/\n\n/**\n* Shared input buffer; stored here in case some input can be returned\n* as is, without being copied to collector's own buffers. Note that\n* this is read-only for this Object.\n*/\nprivate char[] _inputBuffer;\n\n/**\n* Character offset of first char in input buffer; -1 to indicate\n* that input buffer currently does not contain any useful char data\n*/\nprivate int _inputStart;\n\nprivate int _inputLen;\n\n/*\n/**********************************************************\n/* Aggregation segments (when not using input buf)\n/**********************************************************\n*/\n\n/**\n* List of segments prior to currently active segment.\n*/\nprivate ArrayList<char[]> _segments;\n\n/**\n* Flag that indicates whether _seqments is non-empty\n*/\nprivate boolean _hasSegments = false;\n\n// // // Currently used segment; not (yet) contained in _seqments\n\n/**\n* Amount of characters in segments in {@link _segments}",
            "method_id": 77
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:<clinit>()V",
            "method_body": "public final static String FORMAT_NAME_JSON = \"JSON\";\n\n/**\n* Bitfield (set of flags) of all factory features that are enabled by default.\n*/\nprotected final static int DEFAULT_FACTORY_FEATURE_FLAGS = JsonFactory.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all parser features that are enabled\n* by default.\n*/\nprotected final static int DEFAULT_PARSER_FEATURE_FLAGS = JsonParser.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all generator features that are enabled\n* by default.\n*/\nprotected final static int DEFAULT_GENERATOR_FEATURE_FLAGS = JsonGenerator.Feature.collectDefaults();\n\nprivate final static SerializableString DEFAULT_ROOT_VALUE_SEPARATOR = DefaultPrettyPrinter.DEFAULT_ROOT_VALUE_SEPARATOR;\n\n/*\n/**********************************************************\n/* Buffer, symbol table management\n/**********************************************************\n*/\n\n/**\n* This <code>ThreadLocal</code> contains a {@link java.lang.ref.SoftReference}",
            "method_id": 78
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer$TableInfo:<init>(III[I[Ljava/lang/String;II)V",
            "method_body": "public TableInfo(int size, int count, int tertiaryShift,\nint[] mainHash, String[] names, int spilloverEnd, int longNameOffset)\n{\nthis.size = size;\nthis.count = count;\nthis.tertiaryShift = tertiaryShift;\nthis.mainHash = mainHash;\nthis.names = names;\nthis.spilloverEnd = spilloverEnd;\nthis.longNameOffset = longNameOffset;\n}",
            "method_id": 79
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults() {\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) { flags |= f.getMask(); }\n}\nreturn flags;\n}",
            "method_id": 80
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:initTables(I)V",
            "method_body": "private void initTables(int initialSize)\n{\n_symbols = new String[initialSize];\n_buckets = new Bucket[initialSize >> 1];\n// Mask is easy to calc for powers of two.\n_indexMask = initialSize - 1;\n_size = 0;\n_longestCollisionList = 0;\n// Hard-coded fill factor is 75%\n_sizeThreshold = _thresholdSize(initialSize);\n}",
            "method_id": 81
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_skipWS()I",
            "method_body": "private final int _skipWS() throws IOException\n{\nwhile (_inputPtr < _inputEnd) {\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWS2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipWS2();\n}",
            "method_id": 82
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:_getBufferRecycler()Lcom/fasterxml/jackson/core/util/BufferRecycler;",
            "method_body": "public BufferRecycler _getBufferRecycler()\n{\nBufferRecycler br;\n\n/* 23-Apr-2015, tatu: Let's allow disabling of buffer recycling\n*   scheme, for cases where it is considered harmful (possibly\n*   on Android, for example)\n*/\nif (isEnabled(Feature.USE_THREAD_LOCAL_FOR_BUFFER_RECYCLING)) {\nSoftReference<BufferRecycler> ref = _recyclerRef.get();\nbr = (ref == null) ? null : ref.get();\n\nif (br == null) {\nbr = new BufferRecycler();\n_recyclerRef.set(new SoftReference<BufferRecycler>(br));\n}\n} else {\nbr = new BufferRecycler();\n}\nreturn br;\n}",
            "method_id": 83
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:_createParser([BIILcom/fasterxml/jackson/core/io/IOContext;)Lcom/fasterxml/jackson/core/JsonParser;",
            "method_body": "protected JsonParser _createParser(byte[] data, int offset, int len, IOContext ctxt) throws IOException\n{\nreturn new ByteSourceJsonBootstrapper(ctxt, data, offset, len).constructParser(_parserFeatures,\n_objectCodec, _byteSymbolCanonicalizer, _rootCharSymbols, _factoryFeatures);\n}",
            "method_id": 84
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:<init>(II)V",
            "method_body": "protected BufferRecycler(int bbCount, int cbCount) {\n_byteBuffers = new byte[bbCount][];\n_charBuffers = new char[cbCount][];\n}",
            "method_id": 85
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.InternCache:<clinit>()V",
            "method_body": "private final static int MAX_ENTRIES = 180;\n\npublic final static InternCache instance = new InternCache();\n\n/**\n* As minor optimization let's try to avoid \"flush storms\",\n* cases where multiple threads might try to concurrently\n* flush the map.\n*/\nprivate final Object lock = new Object();\n\nprivate InternCache() { super(MAX_ENTRIES, 0.8f, 4); }",
            "method_id": 86
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:allocCharBuffer(II)[C",
            "method_body": "public char[] allocCharBuffer(int ix, int minSize) {\nfinal int DEF_SIZE = charBufferLength(ix);\nif (minSize < DEF_SIZE) {\nminSize = DEF_SIZE;\n}\nchar[] buffer = _charBuffers[ix];\nif (buffer == null || buffer.length < minSize) {\nbuffer = calloc(minSize);\n} else {\n_charBuffers[ix] = null;\n}\nreturn buffer;\n}",
            "method_id": 87
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:nukeSymbols(Z)V",
            "method_body": "private void nukeSymbols(boolean fill) {\n_count = 0;\n// reset spill-over to empty (starting at 7/8 of hash area)\n_spilloverEnd = _spilloverStart();\n// and long name area to empty, starting immediately after hash area\n_longNameOffset = _hashSize << 3;\nif (fill) {\nArrays.fill(_hashArea, 0);\nArrays.fill(_names, null);\n}\n}",
            "method_id": 88
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.InternCache:intern(Ljava/lang/String;)Ljava/lang/String;",
            "method_body": "public String intern(String input) {\nString result = get(input);\nif (result != null) { return result; }\n\n/* 18-Sep-2013, tatu: We used to use LinkedHashMap, which has simple LRU\n*   method. No such functionality exists with CHM; and let's use simplest\n*   possible limitation: just clear all contents. This because otherwise\n*   we are simply likely to keep on clearing same, commonly used entries.\n*/\nif (size() >= MAX_ENTRIES) {\n/* Not incorrect wrt well-known double-locking anti-pattern because underlying\n* storage gives close enough answer to real one here; and we are\n* more concerned with flooding than starvation.\n*/\nsynchronized (lock) {\nif (size() >= MAX_ENTRIES) {\nclear();\n}\n}\n}\nresult = input.intern();\nput(result, result);\nreturn result;\n}",
            "method_id": 89
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:_calcOffset(I)I",
            "method_body": "private final int _calcOffset(int hash)\n{\n// NOTE: simple for initial impl, but we may want to interleave it a bit\n// in near future\n// So: first, hash into primary hash index\nint ix = hash & (_hashSize-1);\n// keeping in mind we have 4 ints per entry\nreturn (ix << 2);\n}",
            "method_id": 90
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_skipWSOrEnd()I",
            "method_body": "private final int _skipWSOrEnd() throws IOException\n{\n// Let's handle first character separately since it is likely that\n// it is either non-whitespace; or we have longer run of white space\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\nreturn _eofAsNextChar();\n}\n}\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n\nwhile (_inputPtr < _inputEnd) {\ni = _inputBuffer[_inputPtr++] & 0xFF;\nif (i > INT_SPACE) {\nif (i == INT_SLASH || i == INT_HASH) {\n--_inputPtr;\nreturn _skipWSOrEnd2();\n}\nreturn i;\n}\nif (i != INT_SPACE) {\nif (i == INT_LF) {\n++_currInputRow;\n_currInputRowStart = _inputPtr;\n} else if (i == INT_CR) {\n_skipCR();\n} else if (i != INT_TAB) {\n_throwInvalidSpace(i);\n}\n}\n}\nreturn _skipWSOrEnd2();\n}",
            "method_id": 91
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.DefaultPrettyPrinter:<clinit>()V",
            "method_body": "private static final long serialVersionUID = 1;\n\n/**\n* Constant that specifies default \"root-level\" separator to use between\n* root values: a single space character.\n*\n* @since 2.1\n*/\npublic final static SerializedString DEFAULT_ROOT_VALUE_SEPARATOR = new SerializedString(\" \");\n\n/**\n* Interface that defines objects that can produce indentation used\n* to separate object entries and array values. Indentation in this\n* context just means insertion of white space, independent of whether\n* linefeeds are output.\n*/\npublic interface Indenter\n{\nvoid writeIndentation(JsonGenerator jg, int level) throws IOException;\n\n/**\n* @return True if indenter is considered inline (does not add linefeeds),\n*   false otherwise\n*/\nboolean isInline();\n}",
            "method_id": 92
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:rehash()V",
            "method_body": "private void rehash()\n{\n_needRehash = false;\n// Note: since we'll make copies, no need to unshare, can just mark as such:\n_hashShared = false;\n\n// And then we can first deal with the main hash area. Since we are expanding\n// linearly (double up), we know there'll be no collisions during this phase.\nfinal int[] oldHashArea = _hashArea;\nfinal String[] oldNames = _names;\nfinal int oldSize = _hashSize;\nfinal int oldCount = _count;\nfinal int newSize = oldSize + oldSize;\nfinal int oldEnd = _spilloverEnd;\n\n/* 13-Mar-2010, tatu: Let's guard against OOME that could be caused by\n*    large documents with unique (or mostly so) names\n*/\nif (newSize > MAX_T_SIZE) {\nnukeSymbols(true);\nreturn;\n}\n// double up main hash area, but do not expand long-name area:\n_hashArea = new int[oldHashArea.length + (oldSize<<3)];\n_hashSize = newSize;\n_secondaryStart = (newSize << 2); // 4 ints per entry\n_tertiaryStart = _secondaryStart + (_secondaryStart >> 1); // right after secondary\n_tertiaryShift = _calcTertiaryShift(newSize);\n\n// and simply double up name array\n_names = new String[oldNames.length << 1];\nnukeSymbols(false);\n\n// Plus we can scan only through the primary hash area, looking for non-empty\n// slots, without worrying about ordering. This should never reduce priority\n// of existing entries: primaries remain primaries; however, due to increased\n// space, secondaries may become primaries etc\n\nint copyCount = 0;\nint[] q = new int[16];\nfor (int offset = 0, end = oldEnd; offset < end; offset += 4) {\nint len = oldHashArea[offset+3];\nif (len == 0) { // empty slot, skip\ncontinue;\n}\n++copyCount;\nString name = oldNames[offset>>2];\nswitch (len) {\ncase 1:\nq[0] = oldHashArea[offset];\naddName(name, q, 1);\nbreak;\ncase 2:\nq[0] = oldHashArea[offset];\nq[1] = oldHashArea[offset+1];\naddName(name, q, 2);\nbreak;\ncase 3:\nq[0] = oldHashArea[offset];\nq[1] = oldHashArea[offset+1];\nq[2] = oldHashArea[offset+2];\naddName(name, q, 3);\nbreak;\ndefault:\nif (len > q.length) {\nq = new int[len];\n}\n// #0 is hash, #1 offset\nint qoff = oldHashArea[offset+1];\nSystem.arraycopy(oldHashArea, qoff, q, 0, len);\naddName(name, q, len);\nbreak;\n}\n}\n\n// Sanity checks: since corruption difficult to detect, assert explicitly\n// with production code\nif (copyCount != oldCount) {\nthrow new IllegalStateException(\"Failed rehash(): old count=\"+oldCount+\", copyCount=\"+copyCount);\n}\n}",
            "method_id": 93
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper:ensureLoaded(I)Z",
            "method_body": "public static MatchStrength hasJSONFormat(InputAccessor acc) throws IOException\n{\n// Ideally we should see \"[\" or \"{\"; but if not, we'll accept double-quote (String)\n// in future could also consider accepting non-standard matches?\n\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nbyte b = acc.nextByte();\n// Very first thing, a UTF-8 BOM?\nif (b == UTF8_BOM_1) { // yes, looks like UTF-8 BOM\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != UTF8_BOM_2) {\nreturn MatchStrength.NO_MATCH;\n}\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != UTF8_BOM_3) {\nreturn MatchStrength.NO_MATCH;\n}\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nb = acc.nextByte();\n}\n// Then possible leading space\nint ch = skipSpace(acc, b);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\n// First, let's see if it looks like a structured type:\nif (ch == '{') { // JSON object?\n// Ideally we need to find either double-quote or closing bracket\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (ch == '\"' || ch == '}') {\nreturn MatchStrength.SOLID_MATCH;\n}\n// ... should we allow non-standard? Let's not yet... can add if need be\nreturn MatchStrength.NO_MATCH;\n}\nMatchStrength strength;\n\nif (ch == '[') {\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\n// closing brackets is easy; but for now, let's also accept opening...\nif (ch == ']' || ch == '[') {\nreturn MatchStrength.SOLID_MATCH;\n}\nreturn MatchStrength.SOLID_MATCH;\n} else {\n// plain old value is not very convincing...\nstrength = MatchStrength.WEAK_MATCH;\n}\n\nif (ch == '\"') { // string value\nreturn strength;\n}\nif (ch <= '9' && ch >= '0') { // number\nreturn strength;\n}\nif (ch == '-') { // negative number\nch = skipSpace(acc);\nif (ch < 0) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nreturn (ch <= '9' && ch >= '0') ? strength : MatchStrength.NO_MATCH;\n}\n// or one of literals\nif (ch == 'n') { // null\nreturn tryMatch(acc, \"ull\", strength);\n}\nif (ch == 't') { // true\nreturn tryMatch(acc, \"rue\", strength);\n}\nif (ch == 'f') { // false\nreturn tryMatch(acc, \"alse\", strength);\n}\nreturn MatchStrength.NO_MATCH;\n}\n\nprivate static MatchStrength tryMatch(InputAccessor acc, String matchStr, MatchStrength fullMatchStrength)\nthrows IOException\n{\nfor (int i = 0, len = matchStr.length(); i < len; ++i) {\nif (!acc.hasMoreBytes()) {\nreturn MatchStrength.INCONCLUSIVE;\n}\nif (acc.nextByte() != matchStr.charAt(i)) {\nreturn MatchStrength.NO_MATCH;\n}\n}\nreturn fullMatchStrength;\n}\n\nprivate static int skipSpace(InputAccessor acc) throws IOException\n{\nif (!acc.hasMoreBytes()) {\nreturn -1;\n}\nreturn skipSpace(acc, acc.nextByte());\n}\n\nprivate static int skipSpace(InputAccessor acc, byte b) throws IOException\n{\nwhile (true) {\nint ch = (int) b & 0xFF;\nif (!(ch == ' ' || ch == '\\r' || ch == '\\n' || ch == '\\t')) {\nreturn ch;\n}\nif (!acc.hasMoreBytes()) {\nreturn -1;\n}\nb = acc.nextByte();\nch = (int) b & 0xFF;\n}\n}\n\n/*\n/**********************************************************\n/* Internal methods, parsing\n/**********************************************************\n*/\n\n/**\n* @return True if a BOM was succesfully found, and encoding\n*   thereby recognized.\n*/\nprivate boolean handleBOM(int quad) throws IOException\n{\n/* Handling of (usually) optional BOM (required for\n* multi-byte formats); first 32-bit charsets:\n*/\nswitch (quad) {\ncase 0x0000FEFF:\n_bigEndian = true;\n_inputPtr += 4;\n_bytesPerChar = 4;\nreturn true;\ncase 0xFFFE0000: // UCS-4, LE?\n_inputPtr += 4;\n_bytesPerChar = 4;\n_bigEndian = false;\nreturn true;\ncase 0x0000FFFE: // UCS-4, in-order...\nreportWeirdUCS4(\"2143\"); // throws exception\ncase 0xFEFF0000: // UCS-4, in-order...\nreportWeirdUCS4(\"3412\"); // throws exception\n}\n// Ok, if not, how about 16-bit encoding BOMs?\nint msw = quad >>> 16;\nif (msw == 0xFEFF) { // UTF-16, BE\n_inputPtr += 2;\n_bytesPerChar = 2;\n_bigEndian = true;\nreturn true;\n}\nif (msw == 0xFFFE) { // UTF-16, LE\n_inputPtr += 2;\n_bytesPerChar = 2;\n_bigEndian = false;\nreturn true;\n}\n// And if not, then UTF-8 BOM?\nif ((quad >>> 8) == 0xEFBBBF) { // UTF-8\n_inputPtr += 3;\n_bytesPerChar = 1;\n_bigEndian = true; // doesn't really matter\nreturn true;\n}\nreturn false;\n}\n\nprivate boolean checkUTF32(int quad) throws IOException\n{\n/* Handling of (usually) optional BOM (required for\n* multi-byte formats); first 32-bit charsets:\n*/\nif ((quad >> 8) == 0) { // 0x000000?? -> UTF32-BE\n_bigEndian = true;\n} else if ((quad & 0x00FFFFFF) == 0) { // 0x??000000 -> UTF32-LE\n_bigEndian = false;\n} else if ((quad & ~0x00FF0000) == 0) { // 0x00??0000 -> UTF32-in-order\nreportWeirdUCS4(\"3412\");\n} else if ((quad & ~0x0000FF00) == 0) { // 0x0000??00 -> UTF32-in-order\nreportWeirdUCS4(\"2143\");\n} else {\n// Can not be valid UTF-32 encoded JSON...\nreturn false;\n}\n// Not BOM (just regular content), nothing to skip past:\n//_inputPtr += 4;\n_bytesPerChar = 4;\nreturn true;\n}\n\nprivate boolean checkUTF16(int i16)\n{\nif ((i16 & 0xFF00) == 0) { // UTF-16BE\n_bigEndian = true;\n} else if ((i16 & 0x00FF) == 0) { // UTF-16LE\n_bigEndian = false;\n} else { // nope, not  UTF-16\nreturn false;\n}\n// Not BOM (just regular content), nothing to skip past:\n//_inputPtr += 2;\n_bytesPerChar = 2;\nreturn true;\n}\n\n/*\n/**********************************************************\n/* Internal methods, problem reporting\n/**********************************************************\n*/\n\nprivate void reportWeirdUCS4(String type) throws IOException {\nthrow new CharConversionException(\"Unsupported UCS-4 endianness (\"+type+\") detected\");\n}\n\n/*\n/**********************************************************\n/* Internal methods, raw input access\n/**********************************************************\n*/\n\nprotected boolean ensureLoaded(int minimum) throws IOException {\n/* Let's assume here buffer has enough room -- this will always\n* be true for the limited used this method gets\n*/\nint gotten = (_inputEnd - _inputPtr);\nwhile (gotten < minimum) {\nint count;\n\nif (_in == null) { // block source\ncount = -1;\n} else {\ncount = _in.read(_inputBuffer, _inputEnd, _inputBuffer.length - _inputEnd);\n}\nif (count < 1) {\nreturn false;\n}\n_inputEnd += count;\ngotten += count;\n}\nreturn true;\n}\n}",
            "method_id": 94
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser:<init>(I)V",
            "method_body": "protected JsonParser(int features) { _features = features; }\nprotected JsonParser(int features) { _features = features; }",
            "method_id": 95
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.BufferRecycler:calloc(I)[C",
            "method_body": "protected char[] calloc(int size) { return new char[size]; }\nprotected char[] calloc(int size) { return new char[size]; }",
            "method_id": 96
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonStreamContext:inObject()Z",
            "method_body": "public final boolean inObject() { return _type == TYPE_OBJECT; }\npublic final boolean inObject() { return _type == TYPE_OBJECT; }",
            "method_id": 97
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:_verifyNeedForRehash()V",
            "method_body": "private void _verifyNeedForRehash() {\n// Yes if above 80%, or above 50% AND have ~1% spill-overs\nif (_count > (_hashSize >> 1)) { // over 50%\nint spillCount = (_spilloverEnd - _spilloverStart()) >> 2;\nif ((spillCount > (1 + _count >> 7))\n|| (_count > (_hashSize * 0.80))) {\n_needRehash = true;\n}\n}\n}",
            "method_id": 98
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonParser$Feature:enabledByDefault()Z",
            "method_body": "public boolean enabledByDefault() { return _defaultState; }\npublic boolean enabledByDefault() { return _defaultState; }",
            "method_id": 99
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:createParser([B)Lcom/fasterxml/jackson/core/JsonParser;",
            "method_body": "public JsonParser createParser(byte[] data) throws IOException, JsonParseException {\nIOContext ctxt = _createContext(data, true);\nif (_inputDecorator != null) {\nInputStream in = _inputDecorator.decorate(ctxt, data, 0, data.length);\nif (in != null) {\nreturn _createParser(in, ctxt);\n}\n}\nreturn _createParser(data, 0, data.length, ctxt);\n}",
            "method_id": 100
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer:createRoot(I)Lcom/fasterxml/jackson/core/sym/BytesToNameCanonicalizer;",
            "method_body": "protected static BytesToNameCanonicalizer createRoot(int seed) {\nreturn new BytesToNameCanonicalizer(DEFAULT_T_SIZE, true, seed, true);\n}",
            "method_id": 101
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:_spilloverStart()I",
            "method_body": "private final int _spilloverStart() {\n// we'll need slot at 1.75x of hashSize, but with 4-ints per slot.\n// So basically multiply by 7\nint offset = _hashSize;\nreturn (offset << 3) - offset;\n}",
            "method_id": 102
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory:<init>(Lcom/fasterxml/jackson/core/JsonFactory;Lcom/fasterxml/jackson/core/ObjectCodec;)V",
            "method_body": "protected final transient com.fasterxml.jackson.core.sym.BytesToNameCanonicalizer _rootByteSymbols\nprotected int _factoryFeatures = DEFAULT_FACTORY_FEATURE_FLAGS;\nprotected int _parserFeatures = DEFAULT_PARSER_FEATURE_FLAGS;\nprotected int _generatorFeatures = DEFAULT_GENERATOR_FEATURE_FLAGS;\nprotected SerializableString _rootValueSeparator = DEFAULT_ROOT_VALUE_SEPARATOR;\npublic JsonFactory() { this(null); }",
            "method_id": 103
        },
        {
            "method_signature": "com.fasterxml.jackson.core.util.TextBuffer:buf(I)[C",
            "method_body": "private char[] buf(int needed)\n{\nif (_allocator != null) {\nreturn _allocator.allocCharBuffer(BufferRecycler.CHAR_TEXT_BUFFER, needed);\n}\nreturn new char[Math.max(needed, MIN_SEGMENT_LEN)];\n}",
            "method_id": 104
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:findName(I)Ljava/lang/String;",
            "method_body": "public String findName(int q1)\n{\nint offset = _calcOffset(calcHash(q1));\n// first: primary match?\nfinal int[] hashArea = _hashArea;\n\nint len = hashArea[offset+3];\n\nif (len == 1) {\nif (hashArea[offset] == q1) {\nreturn _names[offset >> 2];\n}\n} else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\nreturn null;\n}\n// secondary? single slot shared by N/2 primaries\nint offset2 = _secondaryStart + ((offset >> 3) << 2);\n\nlen = hashArea[offset2+3];\n\nif (len == 1) {\nif (hashArea[offset2] == q1) {\nreturn _names[offset2 >> 2];\n}\n} else if (len == 0) { // empty slot; unlikely but avoid further lookups if so\nreturn null;\n}\n\n// tertiary lookup & spillovers best to offline\nreturn _findSecondary(offset, q1);\n}",
            "method_id": 105
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.UTF8StreamJsonParser:_matchToken(Ljava/lang/String;I)V",
            "method_body": "private final void _isNextTokenNameYes(int i) throws IOException\n{\n_currToken = JsonToken.FIELD_NAME;\n\nswitch (i) {\ncase '\"':\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn;\ncase '[':\n_nextToken = JsonToken.START_ARRAY;\nreturn;\ncase '{':\n_nextToken = JsonToken.START_OBJECT;\nreturn;\ncase 't':\n_matchToken(\"true\", 1);\n_nextToken = JsonToken.VALUE_TRUE;\nreturn;\ncase 'f':\n_matchToken(\"false\", 1);\n_nextToken = JsonToken.VALUE_FALSE;\nreturn;\ncase 'n':\n_matchToken(\"null\", 1);\n_nextToken = JsonToken.VALUE_NULL;\nreturn;\ncase '-':\n_nextToken = _parseNegNumber();\nreturn;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\n_nextToken = _parsePosNumber(i);\nreturn;\n}\n_nextToken = _handleUnexpectedValue(i);\n}\n\n\nprivate final boolean _isNextTokenNameMaybe(int i, SerializableString str) throws IOException\n{\n// // // and this is back to standard nextToken()\n\nString n = _parseName(i);\n_parsingContext.setCurrentName(n);\nfinal boolean match = n.equals(str.getValue());\n_currToken = JsonToken.FIELD_NAME;\ni = _skipColon();\n\n// Ok: we must have a value... what is it? Strings are very common, check first:\nif (i == INT_QUOTE) {\n_tokenIncomplete = true;\n_nextToken = JsonToken.VALUE_STRING;\nreturn match;\n}\nJsonToken t;\n\nswitch (i) {\ncase '[':\nt = JsonToken.START_ARRAY;\nbreak;\ncase '{':\nt = JsonToken.START_OBJECT;\nbreak;\ncase 't':\n_matchToken(\"true\", 1);\nt = JsonToken.VALUE_TRUE;\nbreak;\ncase 'f':\n_matchToken(\"false\", 1);\nt = JsonToken.VALUE_FALSE;\nbreak;\ncase 'n':\n_matchToken(\"null\", 1);\nt = JsonToken.VALUE_NULL;\nbreak;\ncase '-':\nt = _parseNegNumber();\nbreak;\ncase '0':\ncase '1':\ncase '2':\ncase '3':\ncase '4':\ncase '5':\ncase '6':\ncase '7':\ncase '8':\ncase '9':\nt = _parsePosNumber(i);\nbreak;\ndefault:\nt = _handleUnexpectedValue(i);\n}\n_nextToken = t;\nreturn match;\n}\n\n@Override\npublic String nextTextValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_STRING) {\nif (_tokenIncomplete) {\n_tokenIncomplete = false;\nreturn _finishAndReturnString();\n}\nreturn _textBuffer.contentsAsString();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_STRING) ? getText() : null;\n}\n\n@Override\npublic int nextIntValue(int defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getIntValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getIntValue() : defaultValue;\n}\n\n@Override\npublic long nextLongValue(long defaultValue) throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_NUMBER_INT) {\nreturn getLongValue();\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn defaultValue;\n}\n// !!! TODO: optimize this case as well\nreturn (nextToken() == JsonToken.VALUE_NUMBER_INT) ? getLongValue() : defaultValue;\n}\n\n@Override\npublic Boolean nextBooleanValue() throws IOException\n{\n// two distinct cases; either got name and we know next type, or 'other'\nif (_currToken == JsonToken.FIELD_NAME) { // mostly copied from '_nextAfterName'\n_nameCopied = false;\nJsonToken t = _nextToken;\n_nextToken = null;\n_currToken = t;\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nif (t == JsonToken.START_ARRAY) {\n_parsingContext = _parsingContext.createChildArrayContext(_tokenInputRow, _tokenInputCol);\n} else if (t == JsonToken.START_OBJECT) {\n_parsingContext = _parsingContext.createChildObjectContext(_tokenInputRow, _tokenInputCol);\n}\nreturn null;\n}\n\nJsonToken t = nextToken();\nif (t == JsonToken.VALUE_TRUE) {\nreturn Boolean.TRUE;\n}\nif (t == JsonToken.VALUE_FALSE) {\nreturn Boolean.FALSE;\n}\nreturn null;\n}\n\n/*\n/**********************************************************\n/* Internal methods, number parsing\n/**********************************************************\n*/\n\n/**\n* Initial parsing method for number values. It needs to be able\n* to parse enough input to be able to determine whether the\n* value is to be considered a simple integer value, or a more\n* generic decimal value: latter of which needs to be expressed\n* as a floating point number. The basic rule is that if the number\n* has no fractional or exponential part, it is an integer; otherwise\n* a floating point number.\n*<p>\n* Because much of input has to be processed in any case, no partial\n* parsing is done: all input text will be stored for further\n* processing. However, actual numeric value conversion will be\n* deferred, since it is usually the most complicated and costliest\n* part of processing.\n*/\nprotected JsonToken _parsePosNumber(int c) throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n// Ok: we can first just add digit we saw first:\noutBuf[0] = (char) c;\nint intLen = 1;\nint outPtr = 1;\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - 1; // 1 == outPtr\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) { // split across boundary, offline\nreturn _parseNumber2(outBuf, outPtr, false, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, false, intLen);\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n// And there we have it!\nreturn resetInt(false, intLen);\n}\n\nprotected JsonToken _parseNegNumber() throws IOException\n{\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nint outPtr = 0;\n\n// Need to prepend sign?\noutBuf[outPtr++] = '-';\n// Must have something after sign too\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Note: must be followed by a digit\nif (c < INT_0 || c > INT_9) {\nreturn _handleInvalidNumberStart(c, true);\n}\n\n// One special case: if first char is 0, must not be followed by a digit\nif (c == INT_0) {\nc = _verifyNoLeadingZeroes();\n}\n\n// Ok: we can first just add digit we saw first:\noutBuf[outPtr++] = (char) c;\nint intLen = 1;\n\n// And then figure out how far we can read without further checks\n// for either input or output\nint end = _inputPtr + outBuf.length - outPtr;\nif (end > _inputEnd) {\nend = _inputEnd;\n}\n\n// With this, we have a nice and tight loop:\nwhile (true) {\nif (_inputPtr >= end) {\n// Long enough to be split across boundary, so:\nreturn _parseNumber2(outBuf, outPtr, true, intLen);\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak;\n}\n++intLen;\noutBuf[outPtr++] = (char) c;\n}\nif (c == '.' || c == 'e' || c == 'E') {\nreturn _parseFloat(outBuf, outPtr, c, true, intLen);\n}\n\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n\n// And there we have it!\nreturn resetInt(true, intLen);\n}\n\n/**\n* Method called to handle parsing when input is split across buffer boundary\n* (or output is longer than segment used to store it)\n*/\nprivate final JsonToken _parseNumber2(char[] outBuf, int outPtr, boolean negative,\nint intPartLength) throws IOException\n{\n// Ok, parse the rest\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\n_textBuffer.setCurrentLength(outPtr);\nreturn resetInt(negative, intPartLength);\n}\nint c = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c > INT_9 || c < INT_0) {\nif (c == INT_PERIOD || c == INT_e || c == INT_E) {\nreturn _parseFloat(outBuf, outPtr, c, negative, intPartLength);\n}\nbreak;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n++intPartLength;\n}\n--_inputPtr; // to push back trailing char (comma etc)\n_textBuffer.setCurrentLength(outPtr);\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(_inputBuffer[_inputPtr++] & 0xFF);\n}\n\n// And there we have it!\nreturn resetInt(negative, intPartLength);\n\n}\n\n/**\n* Method called when we have seen one zero, and want to ensure\n* it is not followed by another\n*/\nprivate final int _verifyNoLeadingZeroes() throws IOException\n{\n// Ok to have plain \"0\"\nif (_inputPtr >= _inputEnd && !loadMore()) {\nreturn INT_0;\n}\nint ch = _inputBuffer[_inputPtr] & 0xFF;\n// if not followed by a number (probably '.'); return zero as is, to be included\nif (ch < INT_0 || ch > INT_9) {\nreturn INT_0;\n}\n// [JACKSON-358]: we may want to allow them, after all...\nif (!isEnabled(Feature.ALLOW_NUMERIC_LEADING_ZEROS)) {\nreportInvalidNumber(\"Leading zeroes not allowed\");\n}\n// if so, just need to skip either all zeroes (if followed by number); or all but one (if non-number)\n++_inputPtr; // Leading zero to be skipped\nif (ch == INT_0) {\nwhile (_inputPtr < _inputEnd || loadMore()) {\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch < INT_0 || ch > INT_9) { // followed by non-number; retain one zero\nreturn INT_0;\n}\n++_inputPtr; // skip previous zeroes\nif (ch != INT_0) { // followed by other number; return\nbreak;\n}\n}\n}\nreturn ch;\n}\n\nprivate final JsonToken _parseFloat(char[] outBuf, int outPtr, int c,\nboolean negative, int integerPartLength) throws IOException\n{\nint fractLen = 0;\nboolean eof = false;\n\n// And then see if we get other parts\nif (c == INT_PERIOD) { // yes, fraction\noutBuf[outPtr++] = (char) c;\n\nfract_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak fract_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\nif (c < INT_0 || c > INT_9) {\nbreak fract_loop;\n}\n++fractLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n}\n// must be followed by sequence of ints, one minimum\nif (fractLen == 0) {\nreportUnexpectedNumberChar(c, \"Decimal point not followed by a digit\");\n}\n}\n\nint expLen = 0;\nif (c == INT_e || c == INT_E) { // exponent?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Not optional, can require that we get one more char\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n// Sign indicator?\nif (c == '-' || c == '+') {\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\n// Likewise, non optional:\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nexp_loop:\nwhile (c <= INT_9 && c >= INT_0) {\n++expLen;\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\noutBuf[outPtr++] = (char) c;\nif (_inputPtr >= _inputEnd && !loadMore()) {\neof = true;\nbreak exp_loop;\n}\nc = (int) _inputBuffer[_inputPtr++] & 0xFF;\n}\n// must be followed by sequence of ints, one minimum\nif (expLen == 0) {\nreportUnexpectedNumberChar(c, \"Exponent indicator not followed by a digit\");\n}\n}\n\n// Ok; unless we hit end-of-input, need to push last char read back\nif (!eof) {\n--_inputPtr;\n// As per #105, need separating space between root values; check here\nif (_parsingContext.inRoot()) {\n_verifyRootSpace(c);\n}\n}\n_textBuffer.setCurrentLength(outPtr);\n\n// And there we have it!\nreturn resetFloat(negative, integerPartLength, fractLen, expLen);\n}\n\n/**\n* Method called to ensure that a root-value is followed by a space\n* token.\n*<p>\n* NOTE: caller MUST ensure there is at least one character available;\n* and that input pointer is AT given char (not past)\n*/\nprivate final void _verifyRootSpace(int ch) throws IOException\n{\n// caller had pushed it back, before calling; reset\n++_inputPtr;\n// TODO? Handle UTF-8 char decoding for error reporting\nswitch (ch) {\ncase ' ':\ncase '\\t':\nreturn;\ncase '\\r':\n_skipCR();\nreturn;\ncase '\\n':\n++_currInputRow;\n_currInputRowStart = _inputPtr;\nreturn;\n}\n_reportMissingRootWS(ch);\n}\n\n/*\n/**********************************************************\n/* Internal methods, secondary parsing\n/**********************************************************\n*/\n\nprotected final String _parseName(int i) throws IOException\n{\nif (i != INT_QUOTE) {\nreturn _handleOddName(i);\n}\n// First: can we optimize out bounds checks?\nif ((_inputPtr + 13) > _inputEnd) { // Need up to 12 chars, plus one trailing (quote)\nreturn slowParseName();\n}\n\n// If so, can also unroll loops nicely\n/* 25-Nov-2008, tatu: This may seem weird, but here we do\n*   NOT want to worry about UTF-8 decoding. Rather, we'll\n*   assume that part is ok (if not it will get caught\n*   later on), and just handle quotes and backslashes here.\n*/\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\nint q = input[_inputPtr++] & 0xFF;\n\nif (codes[q] == 0) {\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] == 0) {\n_quad1 = q;\nreturn parseMediumName(i);\n}\nif (i == INT_QUOTE) { // 4 byte/char case or broken\nreturn findName(q, 4);\n}\nreturn parseName(q, i, 4);\n}\nif (i == INT_QUOTE) { // 3 byte/char case or broken\nreturn findName(q, 3);\n}\nreturn parseName(q, i, 3);\n}\nif (i == INT_QUOTE) { // 2 byte/char case or broken\nreturn findName(q, 2);\n}\nreturn parseName(q, i, 2);\n}\nif (i == INT_QUOTE) { // one byte/char case or broken\nreturn findName(q, 1);\n}\nreturn parseName(q, i, 1);\n}\nif (q == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseName(0, q, 0); // quoting or invalid char\n}\n\nprotected final String parseMediumName(int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Ok, got 5 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 5 bytes\nreturn findName(_quad1, q2, 1);\n}\nreturn parseName(_quad1, q2, i, 1); // quoting or invalid char\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 6 bytes\nreturn findName(_quad1, q2, 2);\n}\nreturn parseName(_quad1, q2, i, 2);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 7 bytes\nreturn findName(_quad1, q2, 3);\n}\nreturn parseName(_quad1, q2, i, 3);\n}\nq2 = (q2 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 8 bytes\nreturn findName(_quad1, q2, 4);\n}\nreturn parseName(_quad1, q2, i, 4);\n}\nreturn parseMediumName2(i, q2);\n}\n\n/**\n* @since 2.6\n*/\nprotected final String parseMediumName2(int q3, final int q2) throws IOException\n{\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\n\n// Got 9 name bytes so far\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 9 bytes\nreturn findName(_quad1, q2, q3, 1);\n}\nreturn parseName(_quad1, q2, q3, i, 1);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 10 bytes\nreturn findName(_quad1, q2, q3, 2);\n}\nreturn parseName(_quad1, q2, q3, i, 2);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 11 bytes\nreturn findName(_quad1, q2, q3, 3);\n}\nreturn parseName(_quad1, q2, q3, i, 3);\n}\nq3 = (q3 << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) { // 12 bytes\nreturn findName(_quad1, q2, q3, 4);\n}\nreturn parseName(_quad1, q2, q3, i, 4);\n}\nreturn parseLongName(i, q2, q3);\n}\n\nprotected final String parseLongName(int q, final int q2, int q3) throws IOException\n{\n_quadBuffer[0] = _quad1;\n_quadBuffer[1] = q2;\n_quadBuffer[2] = q3;\n\n// As explained above, will ignore UTF-8 encoding at this point\nfinal byte[] input = _inputBuffer;\nfinal int[] codes = _icLatin1;\nint qlen = 3;\n\nwhile ((_inputPtr + 4) <= _inputEnd) {\nint i = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 1);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 1);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 2);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 2);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 3);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 3);\n}\n\nq = (q << 8) | i;\ni = input[_inputPtr++] & 0xFF;\nif (codes[i] != 0) {\nif (i == INT_QUOTE) {\nreturn findName(_quadBuffer, qlen, q, 4);\n}\nreturn parseEscapedName(_quadBuffer, qlen, q, i, 4);\n}\n\n// Nope, no end in sight. Need to grow quad array etc\nif (qlen >= _quadBuffer.length) {\n_quadBuffer = growArrayBy(_quadBuffer, qlen);\n}\n_quadBuffer[qlen++] = q;\nq = i;\n}\n\n/* Let's offline if we hit buffer boundary (otherwise would\n* need to [try to] align input, which is bit complicated\n* and may not always be possible)\n*/\nreturn parseEscapedName(_quadBuffer, qlen, 0, q, 0);\n}\n\n/**\n* Method called when not even first 8 bytes are guaranteed\n* to come consequtively. Happens rarely, so this is offlined;\n* plus we'll also do full checks for escaping etc.\n*/\nprotected String slowParseName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\\"' for name\");\n}\n}\nint i = _inputBuffer[_inputPtr++] & 0xFF;\nif (i == INT_QUOTE) { // special case, \"\"\nreturn \"\";\n}\nreturn parseEscapedName(_quadBuffer, 0, 0, i, 0);\n}\n\nprivate final String parseName(int q1, int ch, int lastQuadBytes) throws IOException {\nreturn parseEscapedName(_quadBuffer, 0, q1, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\nreturn parseEscapedName(_quadBuffer, 1, q2, ch, lastQuadBytes);\n}\n\nprivate final String parseName(int q1, int q2, int q3, int ch, int lastQuadBytes) throws IOException {\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn parseEscapedName(_quadBuffer, 2, q3, ch, lastQuadBytes);\n}\n\n/**\n* Slower parsing method which is generally branched to when\n* an escape sequence is detected (or alternatively for long\n* names, one crossing input buffer boundary).\n* Needs to be able to handle more exceptional cases, gets slower,\n* and hance is offlined to a separate method.\n*/\nprotected final String parseEscapedName(int[] quads, int qlen, int currQuad, int ch,\nint currQuadBytes) throws IOException\n{\n/* 25-Nov-2008, tatu: This may seem weird, but here we do not want to worry about\n*   UTF-8 decoding yet. Rather, we'll assume that part is ok (if not it will get\n*   caught later on), and just handle quotes and backslashes here.\n*/\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (codes[ch] != 0) {\nif (ch == INT_QUOTE) { // we are done\nbreak;\n}\n// Unquoted white space?\nif (ch != INT_BACKSLASH) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/**\n* Method called when we see non-white space character other\n* than double quote, when expecting a field name.\n* In standard mode will just throw an expection; but\n* in non-standard modes may be able to parse name.\n*/\nprotected String _handleOddName(int ch) throws IOException\n{\n// [JACKSON-173]: allow single quotes\nif (ch == '\\'' && isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _parseAposName();\n}\n// [JACKSON-69]: allow unquoted names if feature enabled:\nif (!isEnabled(Feature.ALLOW_UNQUOTED_FIELD_NAMES)) {\nchar c = (char) _decodeCharForError(ch);\n_reportUnexpectedChar(c, \"was expecting double-quote to start field name\");\n}\n/* Also: note that although we use a different table here,\n* it does NOT handle UTF-8 decoding. It'll just pass those\n* high-bit codes as acceptable for later decoding.\n*/\nfinal int[] codes = CharTypes.getInputCodeUtf8JsNames();\n// Also: must start with a valid character...\nif (codes[ch] != 0) {\n_reportUnexpectedChar(ch, \"was expecting either valid name character (for unquoted name) or double-quote (for quoted) to start field name\");\n}\n\n/* Ok, now; instead of ultra-optimizing parsing here (as with\n* regular JSON names), let's just use the generic \"slow\"\n* variant. Can measure its impact later on if need be\n*/\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\nwhile (true) {\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr] & 0xFF;\nif (codes[ch] != 0) {\nbreak;\n}\n++_inputPtr;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/* Parsing to support [JACKSON-173]. Plenty of duplicated code;\n* main reason being to try to avoid slowing down fast path\n* for valid JSON -- more alternatives, more code, generally\n* bit slower execution.\n*/\nprotected String _parseAposName() throws IOException\n{\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\": was expecting closing '\\'' for name\");\n}\n}\nint ch = _inputBuffer[_inputPtr++] & 0xFF;\nif (ch == '\\'') { // special case, ''\nreturn \"\";\n}\nint[] quads = _quadBuffer;\nint qlen = 0;\nint currQuad = 0;\nint currQuadBytes = 0;\n\n// Copied from parseEscapedFieldName, with minor mods:\n\nfinal int[] codes = _icLatin1;\n\nwhile (true) {\nif (ch == '\\'') {\nbreak;\n}\n// additional check to skip handling of double-quotes\nif (ch != '\"' && codes[ch] != 0) {\nif (ch != '\\\\') {\n// Unquoted white space?\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(ch, \"name\");\n} else {\n// Nope, escape sequence\nch = _decodeEscaped();\n}\n/* Oh crap. May need to UTF-8 (re-)encode it, if it's\n* beyond 7-bit ascii. Gets pretty messy.\n* If this happens often, may want to use different name\n* canonicalization to avoid these hits.\n*/\nif (ch > 127) {\n// Ok, we'll need room for first byte right away\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\nif (ch < 0x800) { // 2-byte\ncurrQuad = (currQuad << 8) | (0xc0 | (ch >> 6));\n++currQuadBytes;\n// Second byte gets output below:\n} else { // 3 bytes; no need to worry about surrogates here\ncurrQuad = (currQuad << 8) | (0xe0 | (ch >> 12));\n++currQuadBytes;\n// need room for middle byte?\nif (currQuadBytes >= 4) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = 0;\ncurrQuadBytes = 0;\n}\ncurrQuad = (currQuad << 8) | (0x80 | ((ch >> 6) & 0x3f));\n++currQuadBytes;\n}\n// And same last byte in both cases, gets output below:\nch = 0x80 | (ch & 0x3f);\n}\n}\n// Ok, we have one more byte to add at any rate:\nif (currQuadBytes < 4) {\n++currQuadBytes;\ncurrQuad = (currQuad << 8) | ch;\n} else {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = currQuad;\ncurrQuad = ch;\ncurrQuadBytes = 1;\n}\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOF(\" in field name\");\n}\n}\nch = _inputBuffer[_inputPtr++] & 0xFF;\n}\n\nif (currQuadBytes > 0) {\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(currQuad, currQuadBytes);\n}\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nname = addName(quads, qlen, currQuadBytes);\n}\nreturn name;\n}\n\n/*\n/**********************************************************\n/* Internal methods, symbol (name) handling\n/**********************************************************\n*/\n\nprivate final String findName(int q1, int lastQuadBytes) throws JsonParseException\n{\nq1 = pad(q1, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\nreturn addName(_quadBuffer, 1, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int lastQuadBytes) throws JsonParseException\n{\nq2 = pad(q2, lastQuadBytes);\n// Usually we'll find it from the canonical symbol table already\nString name = _symbols.findName(q1, q2);\nif (name != null) {\nreturn name;\n}\n// If not, more work. We'll need add stuff to buffer\n_quadBuffer[0] = q1;\n_quadBuffer[1] = q2;\nreturn addName(_quadBuffer, 2, lastQuadBytes);\n}\n\nprivate final String findName(int q1, int q2, int q3, int lastQuadBytes) throws JsonParseException\n{\nq3 = pad(q3, lastQuadBytes);\nString name = _symbols.findName(q1, q2, q3);\nif (name != null) {\nreturn name;\n}\nint[] quads = _quadBuffer;\nquads[0] = q1;\nquads[1] = q2;\nquads[2] = pad(q3, lastQuadBytes);\nreturn addName(quads, 3, lastQuadBytes);\n}\n\nprivate final String findName(int[] quads, int qlen, int lastQuad, int lastQuadBytes) throws JsonParseException\n{\nif (qlen >= quads.length) {\n_quadBuffer = quads = growArrayBy(quads, quads.length);\n}\nquads[qlen++] = pad(lastQuad, lastQuadBytes);\nString name = _symbols.findName(quads, qlen);\nif (name == null) {\nreturn addName(quads, qlen, lastQuadBytes);\n}\nreturn name;\n}\n\n/**\n* This is the main workhorse method used when we take a symbol\n* table miss. It needs to demultiplex individual bytes, decode\n* multi-byte chars (if any), and then construct Name instance\n* and add it to the symbol table.\n*/\nprivate final String addName(int[] quads, int qlen, int lastQuadBytes) throws JsonParseException\n{\n/* Ok: must decode UTF-8 chars. No other validation is\n* needed, since unescaping has been done earlier as necessary\n* (as well as error reporting for unescaped control chars)\n*/\n// 4 bytes per quad, except last one maybe less\nint byteLen = (qlen << 2) - 4 + lastQuadBytes;\n\n/* And last one is not correctly aligned (leading zero bytes instead\n* need to shift a bit, instead of trailing). Only need to shift it\n* for UTF-8 decoding; need revert for storage (since key will not\n* be aligned, to optimize lookup speed)\n*/\nint lastQuad;\n\nif (lastQuadBytes < 4) {\nlastQuad = quads[qlen-1];\n// 8/16/24 bit left shift\nquads[qlen-1] = (lastQuad << ((4 - lastQuadBytes) << 3));\n} else {\nlastQuad = 0;\n}\n\n// Need some working space, TextBuffer works well:\nchar[] cbuf = _textBuffer.emptyAndGetCurrentSegment();\nint cix = 0;\n\nfor (int ix = 0; ix < byteLen; ) {\nint ch = quads[ix >> 2]; // current quad, need to shift+mask\nint byteIx = (ix & 3);\nch = (ch >> ((3 - byteIx) << 3)) & 0xFF;\n++ix;\n\nif (ch > 127) { // multi-byte\nint needed;\nif ((ch & 0xE0) == 0xC0) { // 2 bytes (0x0080 - 0x07FF)\nch &= 0x1F;\nneeded = 1;\n} else if ((ch & 0xF0) == 0xE0) { // 3 bytes (0x0800 - 0xFFFF)\nch &= 0x0F;\nneeded = 2;\n} else if ((ch & 0xF8) == 0xF0) { // 4 bytes; double-char with surrogates and all...\nch &= 0x07;\nneeded = 3;\n} else { // 5- and 6-byte chars not valid xml chars\n_reportInvalidInitial(ch);\nneeded = ch = 1; // never really gets this far\n}\nif ((ix + needed) > byteLen) {\n_reportInvalidEOF(\" in field name\");\n}\n\n// Ok, always need at least one more:\nint ch2 = quads[ix >> 2]; // current quad, need to shift+mask\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 1) {\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\n\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2);\n}\nch = (ch << 6) | (ch2 & 0x3F);\nif (needed > 2) { // 4 bytes? (need surrogates on output)\nch2 = quads[ix >> 2];\nbyteIx = (ix & 3);\nch2 = (ch2 >> ((3 - byteIx) << 3));\n++ix;\nif ((ch2 & 0xC0) != 0x080) {\n_reportInvalidOther(ch2 & 0xFF);\n}\nch = (ch << 6) | (ch2 & 0x3F);\n}\n}\nif (needed > 2) { // surrogate pair? once again, let's output one here, one later on\nch -= 0x10000; // to normalize it starting with 0x0\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) (0xD800 + (ch >> 10));\nch = 0xDC00 | (ch & 0x03FF);\n}\n}\nif (cix >= cbuf.length) {\ncbuf = _textBuffer.expandCurrentSegment();\n}\ncbuf[cix++] = (char) ch;\n}\n\n// Ok. Now we have the character array, and can construct the String\nString baseName = new String(cbuf, 0, cix);\n// And finally, un-align if necessary\nif (lastQuadBytes < 4) {\nquads[qlen-1] = lastQuad;\n}\nreturn _symbols.addName(baseName, quads, qlen);\n}\n\n/*\n/**********************************************************\n/* Internal methods, String value parsing\n/**********************************************************\n*/\n\n@Override\nprotected void _finishString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\n_textBuffer.setCurrentLength(outPtr);\nreturn;\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\n}\n\n/**\n* @since 2.6\n*/\nprotected String _finishAndReturnString() throws IOException\n{\n// First, single tight loop for ASCII content, not split across input buffer boundary:\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\nfinal int[] codes = _icUTF8;\n\nfinal int max = Math.min(_inputEnd, (ptr + outBuf.length));\nfinal byte[] inputBuffer = _inputBuffer;\nwhile (ptr < max) {\nint c = (int) inputBuffer[ptr] & 0xFF;\nif (codes[c] != 0) {\nif (c == INT_QUOTE) {\n_inputPtr = ptr+1;\nreturn _textBuffer.setCurrentAndReturn(outPtr);\n}\nbreak;\n}\n++ptr;\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n_finishString2(outBuf, outPtr);\nreturn _textBuffer.contentsAsString();\n}\n\nprivate final void _finishString2(char[] outBuf, int outPtr)\nthrows IOException\n{\nint c;\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ASCII non-funny-char loop:\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nif (ptr >= _inputEnd) {\nloadMoreGuaranteed();\nptr = _inputPtr;\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nfinal int max = Math.min(_inputEnd, (ptr + (outBuf.length - outPtr)));\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nc = _decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n}\n\n/**\n* Method called to skim through rest of unparsed String value,\n* if it is not needed. This can be done bit faster if contents\n* need not be stored for future access.\n*/\nprotected void _skipString() throws IOException\n{\n_tokenIncomplete = false;\n\n// Need to be fully UTF-8 aware here:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\nint c;\n\nascii_loop:\nwhile (true) {\nint ptr = _inputPtr;\nint max = _inputEnd;\nif (ptr >= max) {\nloadMoreGuaranteed();\nptr = _inputPtr;\nmax = _inputEnd;\n}\nwhile (ptr < max) {\nc = (int) inputBuffer[ptr++] & 0xFF;\nif (codes[c] != 0) {\n_inputPtr = ptr;\nbreak ascii_loop;\n}\n}\n_inputPtr = ptr;\n}\n// Ok: end marker, escape or multi-byte?\nif (c == INT_QUOTE) {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\n_decodeEscaped();\nbreak;\ncase 2: // 2-byte UTF\n_skipUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\n_skipUtf8_3(c);\nbreak;\ncase 4: // 4-byte UTF\n_skipUtf8_4(c);\nbreak;\ndefault:\nif (c < INT_SPACE) {\n// As per [JACKSON-208], call can now return:\n_throwUnquotedSpace(c, \"string value\");\n} else {\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n}\n}\n}\n\n/**\n* Method for handling cases where first non-space character\n* of an expected value token is not legal for standard JSON content.\n*/\nprotected JsonToken _handleUnexpectedValue(int c)\nthrows IOException\n{\n// Most likely an error, unless we are to allow single-quote-strings\nswitch (c) {\ncase ']':\ncase '}':\n// Error: neither is valid at this point; valid closers have\n// been handled earlier\n_reportUnexpectedChar(c, \"expected a value\");\ncase '\\'':\nif (isEnabled(Feature.ALLOW_SINGLE_QUOTES)) {\nreturn _handleApos();\n}\nbreak;\ncase 'N':\n_matchToken(\"NaN\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"NaN\", Double.NaN);\n}\n_reportError(\"Non-standard token 'NaN': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase 'I':\n_matchToken(\"Infinity\", 1);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(\"Infinity\", Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token 'Infinity': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\nbreak;\ncase '+': // note: '-' is taken as number\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nreturn _handleInvalidNumberStart(_inputBuffer[_inputPtr++] & 0xFF, false);\n}\n// [Issue#77] Try to decode most likely token\nif (Character.isJavaIdentifierStart(c)) {\n_reportInvalidToken(\"\"+((char) c), \"('true', 'false' or 'null')\");\n}\n// but if it doesn't look like a token:\n_reportUnexpectedChar(c, \"expected a valid value (number, String, array, object, 'true', 'false' or 'null')\");\nreturn null;\n}\n\nprotected JsonToken _handleApos()\nthrows IOException\n{\nint c = 0;\n// Otherwise almost verbatim copy of _finishString()\nint outPtr = 0;\nchar[] outBuf = _textBuffer.emptyAndGetCurrentSegment();\n\n// Here we do want to do full decoding, hence:\nfinal int[] codes = _icUTF8;\nfinal byte[] inputBuffer = _inputBuffer;\n\nmain_loop:\nwhile (true) {\n// Then the tight ascii non-funny-char loop:\nascii_loop:\nwhile (true) {\nif (_inputPtr >= _inputEnd) {\nloadMoreGuaranteed();\n}\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nint max = _inputEnd;\n{\nint max2 = _inputPtr + (outBuf.length - outPtr);\nif (max2 < max) {\nmax = max2;\n}\n}\nwhile (_inputPtr < max) {\nc = (int) inputBuffer[_inputPtr++] & 0xFF;\nif (c == '\\'' || codes[c] != 0) {\nbreak ascii_loop;\n}\noutBuf[outPtr++] = (char) c;\n}\n}\n\n// Ok: end marker, escape or multi-byte?\nif (c == '\\'') {\nbreak main_loop;\n}\n\nswitch (codes[c]) {\ncase 1: // backslash\nif (c != '\\'') { // marked as special, isn't here\nc = _decodeEscaped();\n}\nbreak;\ncase 2: // 2-byte UTF\nc = _decodeUtf8_2(c);\nbreak;\ncase 3: // 3-byte UTF\nif ((_inputEnd - _inputPtr) >= 2) {\nc = _decodeUtf8_3fast(c);\n} else {\nc = _decodeUtf8_3(c);\n}\nbreak;\ncase 4: // 4-byte UTF\nc = _decodeUtf8_4(c);\n// Let's add first part right away:\noutBuf[outPtr++] = (char) (0xD800 | (c >> 10));\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\nc = 0xDC00 | (c & 0x3FF);\n// And let the other char output down below\nbreak;\ndefault:\nif (c < INT_SPACE) {\n_throwUnquotedSpace(c, \"string value\");\n}\n// Is this good enough error message?\n_reportInvalidChar(c);\n}\n// Need more room?\nif (outPtr >= outBuf.length) {\noutBuf = _textBuffer.finishCurrentSegment();\noutPtr = 0;\n}\n// Ok, let's add char to output:\noutBuf[outPtr++] = (char) c;\n}\n_textBuffer.setCurrentLength(outPtr);\n\nreturn JsonToken.VALUE_STRING;\n}\n\n/**\n* Method called if expected numeric value (due to leading sign) does not\n* look like a number\n*/\nprotected JsonToken _handleInvalidNumberStart(int ch, boolean neg)\nthrows IOException\n{\nwhile (ch == 'I') {\nif (_inputPtr >= _inputEnd) {\nif (!loadMore()) {\n_reportInvalidEOFInValue();\n}\n}\nch = _inputBuffer[_inputPtr++];\nString match;\nif (ch == 'N') {\nmatch = neg ? \"-INF\" :\"+INF\";\n} else if (ch == 'n') {\nmatch = neg ? \"-Infinity\" :\"+Infinity\";\n} else {\nbreak;\n}\n_matchToken(match, 3);\nif (isEnabled(Feature.ALLOW_NON_NUMERIC_NUMBERS)) {\nreturn resetAsNaN(match, neg ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY);\n}\n_reportError(\"Non-standard token '\"+match+\"': enable JsonParser.Feature.ALLOW_NON_NUMERIC_NUMBERS to allow\");\n}\nreportUnexpectedNumberChar(ch, \"expected digit (0-9) to follow minus sign, for valid numeric value\");\nreturn null;\n}\n\nprotected final void _matchToken(String matchStr, int i) throws IOException\n{\nfinal int len = matchStr.length();\nif ((_inputPtr + len) >= _inputEnd) {\n_matchToken2(matchStr, i);\nreturn;\n}\ndo {\nif (_inputBuffer[_inputPtr] != matchStr.charAt(i)) {\n_reportInvalidToken(matchStr.substring(0, i));\n}\n++_inputPtr;\n} while (++i < len);\n\nint ch = _inputBuffer[_inputPtr] & 0xFF;\nif (ch >= '0' && ch != ']' && ch != '}') { // expected/allowed chars\n_checkMatchEnd(matchStr, i, ch);\n}\n}",
            "method_id": 106
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonFactory$Feature:enabledByDefault()Z",
            "method_body": "public boolean enabledByDefault() { return _defaultState; }\npublic boolean enabledByDefault() { return _defaultState; }",
            "method_id": 107
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:calcHash(I)I",
            "method_body": "public int calcHash(int q1)\n{\nint hash = q1 ^ _seed;\n/* 29-Mar-2015, tatu: Earlier used 15 + 9 right shifts, which worked ok\n*    except for one specific problem case: numbers. So needed to make sure\n*    that all 4 least-significant bits participate in hash. Couple of ways\n*    to work it out, but this is the simplest, fast and seems to do ok.\n*/\nhash += (hash >>> 16); // to xor hi- and low- 16-bits\nhash ^= (hash >>> 12);\nreturn hash;\n}",
            "method_id": 108
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:<init>(Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;I[Ljava/lang/String;[Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer$Bucket;III)V",
            "method_body": "private CharsToNameCanonicalizer(CharsToNameCanonicalizer parent, int flags,\nString[] symbols, Bucket[] buckets, int size, int hashSeed, int longestColl) {\n_parent = parent;\n\n_flags = flags;\n_canonicalize = JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(flags);\n\n_symbols = symbols;\n_buckets = buckets;\n_size = size;\n_hashSeed = hashSeed;\n// Hard-coded fill factor, 75%\nint arrayLen = (symbols.length);\n_sizeThreshold = _thresholdSize(arrayLen);\n_indexMask =  (arrayLen - 1);\n_longestCollisionList = longestColl;\n\n// Need to make copies of arrays, if/when adding new entries\n_dirty = false;\n}",
            "method_id": 109
        },
        {
            "method_signature": "com.fasterxml.jackson.core.io.CharTypes:getInputCodeUtf8()[I",
            "method_body": "public static int[] getInputCodeUtf8() { return sInputCodesUTF8; }\npublic static int[] getInputCodeUtf8() { return sInputCodesUTF8; }",
            "method_id": 110
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.ByteQuadsCanonicalizer:_verifySharing()V",
            "method_body": "private void _verifySharing()\n{\nif (_hashShared) {\n_hashArea = Arrays.copyOf(_hashArea, _hashArea.length);\n_names = Arrays.copyOf(_names, _names.length);\n_hashShared = false;\n}\nif (_needRehash) {\nrehash();\n}\n}",
            "method_id": 111
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:<init>()V",
            "method_body": "private CharsToNameCanonicalizer() {\n// these settings don't really matter for the bootstrap instance\n_canonicalize = true;\n_flags = -1;\n// And we'll also set flags so no copying of buckets is needed:\n_dirty = true;\n_hashSeed = 0;\n_longestCollisionList = 0;\ninitTables(DEFAULT_T_SIZE);\n}",
            "method_id": 112
        },
        {
            "method_signature": "com.fasterxml.jackson.core.json.ByteSourceJsonBootstrapper:constructParser(ILcom/fasterxml/jackson/core/ObjectCodec;Lcom/fasterxml/jackson/core/sym/ByteQuadsCanonicalizer;Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;I)Lcom/fasterxml/jackson/core/JsonParser;",
            "method_body": "public JsonParser constructParser(int parserFeatures, ObjectCodec codec,\nByteQuadsCanonicalizer rootByteSymbols, CharsToNameCanonicalizer rootCharSymbols,\nint factoryFeatures) throws IOException\n{\nJsonEncoding enc = detectEncoding();\n\nif (enc == JsonEncoding.UTF8) {\n/* and without canonicalization, byte-based approach is not performance; just use std UTF-8 reader\n* (which is ok for larger input; not so hot for smaller; but this is not a common case)\n*/\nif (JsonFactory.Feature.CANONICALIZE_FIELD_NAMES.enabledIn(factoryFeatures)) {\nByteQuadsCanonicalizer can = rootByteSymbols.makeChild(factoryFeatures);\nreturn new UTF8StreamJsonParser(_context, parserFeatures, _in, codec, can,\n_inputBuffer, _inputPtr, _inputEnd, _bufferRecyclable);\n}\n}\nreturn new ReaderBasedJsonParser(_context, parserFeatures, constructReader(), codec,\nrootCharSymbols.makeChild(factoryFeatures));\n}",
            "method_id": 113
        },
        {
            "method_signature": "com.fasterxml.jackson.core.sym.CharsToNameCanonicalizer:createRoot(I)Lcom/fasterxml/jackson/core/sym/CharsToNameCanonicalizer;",
            "method_body": "protected static CharsToNameCanonicalizer createRoot(int hashSeed) {\nreturn sBootstrapSymbolTable.makeOrphan(hashSeed);\n}",
            "method_id": 114
        },
        {
            "method_signature": "com.fasterxml.jackson.core.JsonToken:<init>(Ljava/lang/String;ILjava/lang/String;I)V",
            "method_body": "JsonToken(String token, int id)\n{\nif (token == null) {\n_serialized = null;\n_serializedChars = null;\n_serializedBytes = null;\n} else {\n_serialized = token;\n_serializedChars = token.toCharArray();\n// It's all in ascii, can just case...\nint len = _serializedChars.length;\n_serializedBytes = new byte[len];\nfor (int i = 0; i < len; ++i) {\n_serializedBytes[i] = (byte) _serializedChars[i];\n}\n}\n_id = id;\n\n_isBoolean = (id == JsonTokenId.ID_FALSE || id == JsonTokenId.ID_TRUE);\n_isNumber = (id == JsonTokenId.ID_NUMBER_INT || id == JsonTokenId.ID_NUMBER_FLOAT);\n\n_isStructStart = (id == JsonTokenId.ID_START_OBJECT || id == JsonTokenId.ID_START_ARRAY);\n_isStructEnd = (id == JsonTokenId.ID_END_OBJECT || id == JsonTokenId.ID_END_ARRAY);\n\n_isScalar = !_isStructStart && !_isStructEnd\n&& (id != JsonTokenId.ID_FIELD_NAME)\n&& (id != JsonTokenId.ID_NOT_AVAILABLE);\n}",
            "method_id": 115
        }
    ]
}