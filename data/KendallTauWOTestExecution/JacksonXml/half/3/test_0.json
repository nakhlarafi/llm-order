{
    "bug_id": 3,
    "test_id": 0,
    "test_name": "com.fasterxml.jackson.dataformat.xml.stream.XmlParserNextXxxTest.testXmlAttributesWithNextTextValue",
    "test_body": "public void testXmlAttributesWithNextTextValue() throws Exception\n{\nfinal String XML = \"<data max=\\\"7\\\" offset=\\\"9\\\"/>\";\nFromXmlParser xp = (FromXmlParser) _xmlFactory.createParser(new StringReader(XML));\n// First: verify handling without forcing array handling:\nassertToken(JsonToken.START_OBJECT, xp.nextToken()); // <data>\nassertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <max>\nassertEquals(\"max\", xp.getCurrentName());\nassertEquals(\"7\", xp.nextTextValue());\nassertToken(JsonToken.FIELD_NAME, xp.nextToken()); // <offset>\nassertEquals(\"offset\", xp.getCurrentName());\nassertEquals(\"offset\", xp.getText());\nassertEquals(\"9\", xp.nextTextValue());\nassertEquals(\"9\", xp.getText());\nassertToken(JsonToken.END_OBJECT, xp.nextToken()); // </data>\nxp.close();\n}\n",
    "stack_trace": "junit.framework.ComparisonFailure: expected:<7> but was:<null>\nat junit.framework.Assert.assertEquals(Assert.java:100)\nat junit.framework.Assert.assertEquals(Assert.java:107)\nat junit.framework.TestCase.assertEquals(TestCase.java:269)\nat com.fasterxml.jackson.dataformat.xml.stream.XmlParserNextXxxTest.testXmlAttributesWithNextTextValue(XmlParserNextXxxTest.java:41)",
    "covered_methods": [
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
            "method_body": "public XmlFactory(ObjectCodec oc, XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\nthis(oc, DEFAULT_XML_PARSER_FEATURE_FLAGS, DEFAULT_XML_GENERATOR_FEATURE_FLAGS,\nxmlIn, xmlOut, null);\n}",
            "method_id": 0
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:_next()I",
            "method_body": "private final int _next() throws XMLStreamException\n{\nswitch (_currentState) {\ncase XML_ATTRIBUTE_VALUE:\n++_nextAttributeIndex;\n// fall through\ncase XML_START_ELEMENT: // attributes to return?\nif (_nextAttributeIndex < _attributeCount) {\n_localName = _xmlReader.getAttributeLocalName(_nextAttributeIndex);\n_namespaceURI = _xmlReader.getAttributeNamespace(_nextAttributeIndex);\n_textValue = _xmlReader.getAttributeValue(_nextAttributeIndex);\nreturn (_currentState = XML_ATTRIBUTE_NAME);\n}\n// otherwise need to find START/END_ELEMENT or text\nString text = _collectUntilTag();\n// If it's START_ELEMENT, ignore any text\nif (_xmlReader.getEventType() == XMLStreamReader.START_ELEMENT) {\nreturn _initStartElement();\n}\n// For END_ELEMENT we will return text, if any\nif (text != null) {\n_textValue = text;\nreturn (_currentState = XML_TEXT);\n}\nreturn _handleEndElement();\ncase XML_ATTRIBUTE_NAME:\n// if we just returned name, will need to just send value next\nreturn (_currentState = XML_ATTRIBUTE_VALUE);\ncase XML_TEXT:\n// text is always followed by END_ELEMENT\nreturn _handleEndElement();\ncase XML_END:\nreturn XML_END;\n//            throw new IllegalStateException(\"No more XML tokens available (end of input)\");\n}\n\n// Ok: must be END_ELEMENT; see what tag we get (or end)\nswitch (_skipUntilTag()) {\ncase XMLStreamConstants.END_DOCUMENT:\nreturn (_currentState = XML_END);\ncase XMLStreamConstants.END_ELEMENT:\nreturn _handleEndElement();\n}\n// START_ELEMENT...\nreturn _initStartElement();\n}",
            "method_id": 1
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getLocalName()Ljava/lang/String;",
            "method_body": "public String getLocalName() { return _localName; }\npublic String getLocalName() { return _localName; }",
            "method_id": 2
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_createParser(Ljava/io/Reader;Lcom/fasterxml/jackson/core/io/IOContext;)Lcom/fasterxml/jackson/dataformat/xml/deser/FromXmlParser;",
            "method_body": "protected FromXmlParser _createParser(Reader r, IOContext ctxt) throws IOException\n{\nXMLStreamReader sr;\ntry {\nsr = _xmlInputFactory.createXMLStreamReader(r);\nsr = _initializeXmlReader(sr);\n} catch (XMLStreamException e) {\nreturn StaxUtil.throwXmlAsIOException(e);\n}\nFromXmlParser xp = new FromXmlParser(ctxt, _generatorFeatures, _xmlGeneratorFeatures,\n_objectCodec, sr);\nif (_cfgNameForTextElement != null) {\nxp.setXMLTextElementName(_cfgNameForTextElement);\n}\nreturn xp;\n}",
            "method_id": 3
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:<init>(Lcom/fasterxml/jackson/core/io/IOContext;IILcom/fasterxml/jackson/core/ObjectCodec;Ljavax/xml/stream/XMLStreamReader;)V",
            "method_body": "public FromXmlParser(IOContext ctxt, int genericParserFeatures, int xmlFeatures,\nObjectCodec codec, XMLStreamReader xmlReader)\n{\nsuper(genericParserFeatures);\n_formatFeatures = xmlFeatures;\n_ioContext = ctxt;\n_objectCodec = codec;\n_parsingContext = XmlReadContext.createRootContext(-1, -1);\n// and thereby start a scope\n_nextToken = JsonToken.START_OBJECT;\n_xmlTokens = new XmlTokenStream(xmlReader, ctxt.getSourceReference());\n}",
            "method_id": 4
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:nextTextValue()Ljava/lang/String;",
            "method_body": "public String nextTextValue() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\n\n// expected case; yes, got a String\nif (t == JsonToken.VALUE_STRING) {\nreturn _currText;\n}\n_updateState(t);\nreturn null;\n}\n\nint token = _xmlTokens.next();\n\n// mostly copied from 'nextToken()'\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\nif (_mayBeLeaf) {\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n_currToken = JsonToken.START_OBJECT;\nreturn null;\n}\nif (_parsingContext.inArray()) {\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n_mayBeLeaf = true;\n_currToken = JsonToken.FIELD_NAME;\nreturn null;\n}\n\n// Ok; beyond start element, what do we get?\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\nif (_mayBeLeaf) {\n// NOTE: this is different from nextToken() -- produce \"\", NOT null\n_mayBeLeaf = false;\n_currToken = JsonToken.VALUE_STRING;\nreturn (_currText = \"\");\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\n_currToken = JsonToken.START_OBJECT;\n} else {\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\n_currToken = JsonToken.FIELD_NAME;\n}\nbreak;\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\n_currToken = JsonToken.VALUE_STRING;\nbreak;\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\n\n// NOTE: this is different from nextToken() -- NO work-around\n// for otherwise empty List/array\n_currToken = JsonToken.VALUE_STRING;\nreturn _currText;\n}\n// If not a leaf, need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\n_currToken = JsonToken.FIELD_NAME;\nbreak;\ncase XmlTokenStream.XML_END:\n_currToken = null;\n}\nreturn null;\n}",
            "method_id": 5
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$1:<clinit>()V",
            "method_body": "public JsonToken nextToken() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\nswitch (t) {\ncase START_OBJECT:\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nbreak;\ncase START_ARRAY:\n_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\nbreak;\ncase END_OBJECT:\ncase END_ARRAY:\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase FIELD_NAME:\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nbreak;\ndefault: // VALUE_STRING, VALUE_NULL\n// should be fine as is?\n}\nreturn t;\n}\nint token = _xmlTokens.next();\n\n// Need to have a loop just because we may have to eat/convert\n// a start-element that indicates an array element.\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\n// If we thought we might get leaf, no such luck\nif (_mayBeLeaf) {\n// leave _mayBeLeaf set, as we start a new context\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nif (_parsingContext.inArray()) {\n// Yup: in array, so this element could be verified; but it won't be\n// reported anyway, and we need to process following event.\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\n\n// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n// Couple of ways to do it; but start by making _xmlTokens replay the thing...\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n\n_mayBeLeaf = true;\n// Ok: in array context we need to skip reporting field names.\n// But what's the best way to find next token?\nreturn (_currToken = JsonToken.FIELD_NAME);\n}\n\n// Ok; beyond start element, what do we get?\nwhile (true) {\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\n// Simple, except that if this is a leaf, need to suppress end:\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\nif (_parsingContext.inArray()) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nreturn (_currToken = JsonToken.VALUE_NULL);\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\nreturn (_currToken = JsonToken.VALUE_STRING);\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// One more refinement (pronunced like \"hack\") is that if\n// we had an empty String (or all white space), and we are\n// deserializing an array, we better hide the empty text.\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\nif (_parsingContext.inArray()) {\nif (_isEmpty(_currText)) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null (or, worse, as used to\n//    be done, by swallowing the token)\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n}\nreturn (_currToken = JsonToken.VALUE_STRING);\n} else {\n// [dataformat-xml#177]: empty text may also need to be skipped\n// but... [dataformat-xml#191]: looks like we can't short-cut, must\n// loop over again\nif (_parsingContext.inObject()) {\nif ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\ntoken = _xmlTokens.next();\ncontinue;\n}\n}\n}\n// If not a leaf (or otherwise ignorable), need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_END:\nreturn (_currToken = null);\n}\n}\n}",
            "method_id": 6
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:next()I",
            "method_body": "public int next() throws IOException\n{\nif (_repeatElement != 0) {\nreturn (_currentState = _handleRepeatElement());\n}\ntry {\nreturn _next();\n} catch (XMLStreamException e) {\nStaxUtil.throwXmlAsIOException(e);\nreturn -1;\n}\n}",
            "method_id": 7
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:<clinit>()V",
            "method_body": "public final static String DEFAULT_UNNAMED_TEXT_PROPERTY = \"\";\n\n/**\n* Enumeration that defines all togglable features for XML parsers.\n* None defined so far (2.6), so just a placeholder.\n*/\npublic enum Feature implements FormatFeature\n{\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}",
            "method_id": 8
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:getCurrentName()Ljava/lang/String;",
            "method_body": "public final String getCurrentName() { return _currentName; }\npublic final String getCurrentName() { return _currentName; }",
            "method_id": 9
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>()V",
            "method_body": "public XmlFactory() { this(null, null, null); }\npublic XmlFactory() { this(null, null, null); }",
            "method_id": 10
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:enabledByDefault()Z",
            "method_body": "@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public boolean enabledByDefault() { return _defaultState; }",
            "method_id": 11
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createRootContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
            "method_body": "public static XmlReadContext createRootContext(int lineNr, int colNr) {\nreturn new XmlReadContext(null, TYPE_ROOT, lineNr, colNr);\n}",
            "method_id": 12
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<init>(Lcom/fasterxml/jackson/core/ObjectCodec;IILjavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;Ljava/lang/String;)V",
            "method_body": "protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\nXMLInputFactory xmlIn, XMLOutputFactory xmlOut,\nString nameForTextElem)\n{\nsuper(oc);\n_xmlParserFeatures = xpFeatures;\n_xmlGeneratorFeatures = xgFeatures;\n_cfgNameForTextElement = nameForTextElem;\nif (xmlIn == null) {\nxmlIn = XMLInputFactory.newInstance();\n// as per [dataformat-xml#190], disable external entity expansion by default\nxmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n}\nif (xmlOut == null) {\nxmlOut = XMLOutputFactory.newInstance();\n}\n_initFactories(xmlIn, xmlOut);\n_xmlInputFactory = xmlIn;\n_xmlOutputFactory = xmlOut;\n}",
            "method_id": 13
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:createChildObjectContext(II)Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;",
            "method_body": "public final XmlReadContext createChildObjectContext(int lineNr, int colNr)\n{\nXmlReadContext ctxt = _child;\nif (ctxt == null) {\n_child = ctxt = new XmlReadContext(this, TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}\nctxt.reset(TYPE_OBJECT, lineNr, colNr);\nreturn ctxt;\n}",
            "method_id": 14
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initializeXmlReader(Ljavax/xml/stream/XMLStreamReader;)Ljavax/xml/stream/XMLStreamReader;",
            "method_body": "protected final XMLStreamReader _initializeXmlReader(XMLStreamReader sr) throws IOException, XMLStreamException\n{\n// for now, nothing to do... except let's find the root element\nwhile (sr.next() != XMLStreamConstants.START_ELEMENT) {\n;\n}\nreturn sr;\n}",
            "method_id": 15
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:getCurrentName()Ljava/lang/String;",
            "method_body": "public String getCurrentName() throws IOException\n{\n// start markers require information from parent\nString name;\nif (_currToken == JsonToken.START_OBJECT || _currToken == JsonToken.START_ARRAY) {\nXmlReadContext parent = _parsingContext.getParent();\nname = parent.getCurrentName();\n} else {\nname = _parsingContext.getCurrentName();\n}\n// sanity check\nif (name == null) {\nthrow new IllegalStateException(\"Missing name, in state: \"+_currToken);\n}\nreturn name;\n}",
            "method_id": 16
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}",
            "method_id": 17
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:<init>(Ljavax/xml/stream/XMLStreamReader;Ljava/lang/Object;)V",
            "method_body": "public XmlTokenStream(XMLStreamReader xmlReader, Object sourceRef)\n{\n_sourceReference = sourceRef;\n// Let's ensure we point to START_ELEMENT...\nif (xmlReader.getEventType() != XMLStreamConstants.START_ELEMENT) {\nthrow new IllegalArgumentException(\"Invalid XMLStreamReader passed: should be pointing to START_ELEMENT (\"\n+XMLStreamConstants.START_ELEMENT+\"), instead got \"+xmlReader.getEventType());\n}\n_xmlReader = Stax2ReaderAdapter.wrapIfNecessary(xmlReader);\n_currentState = XML_START_ELEMENT;\n_localName = _xmlReader.getLocalName();\n_namespaceURI = _xmlReader.getNamespaceURI();\n_attributeCount = _xmlReader.getAttributeCount();\n}",
            "method_id": 18
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:<init>(Lcom/fasterxml/jackson/dataformat/xml/deser/XmlReadContext;III)V",
            "method_body": "public XmlReadContext(XmlReadContext parent, int type, int lineNr, int colNr)\n{\nsuper();\n_type = type;\n_parent = parent;\n_lineNr = lineNr;\n_columnNr = colNr;\n_index = -1;\n}",
            "method_id": 19
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlTokenStream:getText()Ljava/lang/String;",
            "method_body": "public String getText() { return _textValue; }\npublic String getText() { return _textValue; }",
            "method_id": 20
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser$Feature:collectDefaults()I",
            "method_body": "public static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}",
            "method_id": 21
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<init>(Ljava/lang/String;IZ)V",
            "method_body": "private Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}",
            "method_id": 22
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.ser.ToXmlGenerator$Feature:<clinit>()V",
            "method_body": "protected final static String DEFAULT_UNKNOWN_ELEMENT = \"unknown\";\n\n/**\n* Enumeration that defines all togglable extra XML-specific features\n*/\npublic enum Feature implements FormatFeature\n{\n/**\n* Feature that controls whether XML declaration should be written before\n* when generator is initialized (true) or not (false)\n*/\nWRITE_XML_DECLARATION(false),\n\n/**\n* Feature that controls whether output should be done as XML 1.1; if so,\n* certain aspects may differ from default (1.0) processing: for example,\n* XML declaration will be automatically added (regardless of setting\n* <code>WRITE_XML_DECLARATION</code>) as this is required for reader to\n* know to use 1.1 compliant handling. XML 1.1 can be used to allow quoted\n* control characters (Ascii codes 0 through 31) as well as additional linefeeds\n* and name characters.\n*/\nWRITE_XML_1_1(false)\n;\n\nfinal boolean _defaultState;\nfinal int _mask;\n\n/**\n* Method that calculates bit set (flags) of all features that\n* are enabled by default.\n*/\npublic static int collectDefaults()\n{\nint flags = 0;\nfor (Feature f : values()) {\nif (f.enabledByDefault()) {\nflags |= f.getMask();\n}\n}\nreturn flags;\n}\n\nprivate Feature(boolean defaultState) {\n_defaultState = defaultState;\n_mask = (1 << ordinal());\n}\n\n@Override public boolean enabledByDefault() { return _defaultState; }\n@Override public int getMask() { return _mask; }\n@Override public boolean enabledIn(int flags) { return (flags & getMask()) != 0; }\n}",
            "method_id": 23
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.FromXmlParser:nextToken()Lcom/fasterxml/jackson/core/JsonToken;",
            "method_body": "public JsonToken nextToken() throws IOException\n{\n_binaryValue = null;\nif (_nextToken != null) {\nJsonToken t = _nextToken;\n_currToken = t;\n_nextToken = null;\nswitch (t) {\ncase START_OBJECT:\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nbreak;\ncase START_ARRAY:\n_parsingContext = _parsingContext.createChildArrayContext(-1, -1);\nbreak;\ncase END_OBJECT:\ncase END_ARRAY:\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nbreak;\ncase FIELD_NAME:\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nbreak;\ndefault: // VALUE_STRING, VALUE_NULL\n// should be fine as is?\n}\nreturn t;\n}\nint token = _xmlTokens.next();\n\n// Need to have a loop just because we may have to eat/convert\n// a start-element that indicates an array element.\nwhile (token == XmlTokenStream.XML_START_ELEMENT) {\n// If we thought we might get leaf, no such luck\nif (_mayBeLeaf) {\n// leave _mayBeLeaf set, as we start a new context\n_nextToken = JsonToken.FIELD_NAME;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nif (_parsingContext.inArray()) {\n// Yup: in array, so this element could be verified; but it won't be\n// reported anyway, and we need to process following event.\ntoken = _xmlTokens.next();\n_mayBeLeaf = true;\ncontinue;\n}\nString name = _xmlTokens.getLocalName();\n_parsingContext.setCurrentName(name);\n\n// Ok: virtual wrapping can be done by simply repeating current START_ELEMENT.\n// Couple of ways to do it; but start by making _xmlTokens replay the thing...\nif (_namesToWrap != null && _namesToWrap.contains(name)) {\n_xmlTokens.repeatStartElement();\n}\n\n_mayBeLeaf = true;\n// Ok: in array context we need to skip reporting field names.\n// But what's the best way to find next token?\nreturn (_currToken = JsonToken.FIELD_NAME);\n}\n\n// Ok; beyond start element, what do we get?\nwhile (true) {\nswitch (token) {\ncase XmlTokenStream.XML_END_ELEMENT:\n// Simple, except that if this is a leaf, need to suppress end:\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\nif (_parsingContext.inArray()) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\nreturn (_currToken = JsonToken.VALUE_NULL);\n}\n_currToken = _parsingContext.inArray() ? JsonToken.END_ARRAY : JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.getParent();\n_namesToWrap = _parsingContext.getNamesToWrap();\nreturn _currToken;\n\ncase XmlTokenStream.XML_ATTRIBUTE_NAME:\n// If there was a chance of leaf node, no more...\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n_nextToken = JsonToken.FIELD_NAME;\n_currText = _xmlTokens.getText();\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n_parsingContext.setCurrentName(_xmlTokens.getLocalName());\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_ATTRIBUTE_VALUE:\n_currText = _xmlTokens.getText();\nreturn (_currToken = JsonToken.VALUE_STRING);\ncase XmlTokenStream.XML_TEXT:\n_currText = _xmlTokens.getText();\nif (_mayBeLeaf) {\n_mayBeLeaf = false;\n// One more refinement (pronunced like \"hack\") is that if\n// we had an empty String (or all white space), and we are\n// deserializing an array, we better hide the empty text.\n// Also: must skip following END_ELEMENT\n_xmlTokens.skipEndElement();\nif (_parsingContext.inArray()) {\nif (_isEmpty(_currText)) {\n// 06-Jan-2015, tatu: as per [dataformat-xml#180], need to\n//    expose as empty Object, not null (or, worse, as used to\n//    be done, by swallowing the token)\n_nextToken = JsonToken.END_OBJECT;\n_parsingContext = _parsingContext.createChildObjectContext(-1, -1);\nreturn (_currToken = JsonToken.START_OBJECT);\n}\n}\nreturn (_currToken = JsonToken.VALUE_STRING);\n} else {\n// [dataformat-xml#177]: empty text may also need to be skipped\n// but... [dataformat-xml#191]: looks like we can't short-cut, must\n// loop over again\nif (_parsingContext.inObject()) {\nif ((_currToken != JsonToken.FIELD_NAME) && _isEmpty(_currText)) {\ntoken = _xmlTokens.next();\ncontinue;\n}\n}\n}\n// If not a leaf (or otherwise ignorable), need to transform into property...\n_parsingContext.setCurrentName(_cfgNameForTextElement);\n_nextToken = JsonToken.VALUE_STRING;\nreturn (_currToken = JsonToken.FIELD_NAME);\ncase XmlTokenStream.XML_END:\nreturn (_currToken = null);\n}\n}\n}",
            "method_id": 24
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:_initFactories(Ljavax/xml/stream/XMLInputFactory;Ljavax/xml/stream/XMLOutputFactory;)V",
            "method_body": "protected void _initFactories(XMLInputFactory xmlIn, XMLOutputFactory xmlOut)\n{\n// Better ensure namespaces get built properly, so:\nxmlOut.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.TRUE);\n// and for parser, force coalescing as well (much simpler to use)\nxmlIn.setProperty(XMLInputFactory.IS_COALESCING, Boolean.TRUE);\n}",
            "method_id": 25
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.XmlFactory:<clinit>()V",
            "method_body": "public final static String FORMAT_NAME_XML = \"XML\";\n\n/**\n* Bitfield (set of flags) of all parser features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_PARSER_FEATURE_FLAGS = FromXmlParser.Feature.collectDefaults();\n\n/**\n* Bitfield (set of flags) of all generator features that are enabled\n* by default.\n*/\nfinal static int DEFAULT_XML_GENERATOR_FEATURE_FLAGS = ToXmlGenerator.Feature.collectDefaults();\n\n/*\n/**********************************************************\n/* Configuration\n/**********************************************************\n*/\n\nprotected int _xmlParserFeatures;\n\nprotected int _xmlGeneratorFeatures;\n\n// non-final for setters (why are they needed again?)\nprotected transient XMLInputFactory _xmlInputFactory;\n\nprotected transient XMLOutputFactory _xmlOutputFactory;\n\nprotected String _cfgNameForTextElement;\n\n/*\n/**********************************************************\n/* Factory construction, configuration\n/**********************************************************\n*/\n\n/**\n* Default constructor used to create factory instances.\n* Creation of a factory instance is a light-weight operation,\n* but it is still a good idea to reuse limited number of\n* factory instances (and quite often just a single instance):\n* factories are used as context for storing some reused\n* processing objects (such as symbol tables parsers use)\n* and this reuse only works within context of a single\n* factory instance.\n*/\npublic XmlFactory() { this(null, null, null); }",
            "method_id": 26
        },
        {
            "method_signature": "com.fasterxml.jackson.dataformat.xml.deser.XmlReadContext:setCurrentName(Ljava/lang/String;)V",
            "method_body": "public void setCurrentName(String name) {\n_currentName = name;\n}",
            "method_id": 27
        }
    ]
}